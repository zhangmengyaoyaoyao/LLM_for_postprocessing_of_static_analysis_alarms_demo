## Bug Report
```json
{
  "category": "DODGY_CODE",
  "vtype": "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",
  "priority": "3",
  "rank": "20",
  "project": "bcel",
  "warning_line": "wide = false; \n",
  "warning_method": "private String codeToHTML(final ByteSequence bytes, final int method_number) throws IOException {\nfinal short opcode = (short) bytes.readUnsignedByte();\nString name;\nString signature;\nint default_offset = 0;\nint low;\nint high;\nint index;\nint class_index;\nint vindex;\nint constant;\nint[] jump_table;\nint no_pad_bytes = 0;\nint offset;\nfinal StringBuilder buf = new StringBuilder(256);\nbuf.append(\"<TT>\").append(Const.getOpcodeName(opcode)).append(\"</TT></TD><TD>\");\nif ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\nfinal int remainder = bytes.getIndex() % 4;\nno_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\nfor (int i = 0; i < no_pad_bytes; i++) {\nbytes.readByte();\n}\ndefault_offset = bytes.readInt();\n}\nswitch(opcode) {\ncase Const.TABLESWITCH:\nlow = bytes.readInt();\nhigh = bytes.readInt();\noffset = bytes.getIndex() - 12 - no_pad_bytes - 1;\ndefault_offset += offset;\nbuf.append(\"<TABLE BORDER=1><TR>\");\njump_table = new int[high - low + 1];\nfor (int i = 0; i < jump_table.length; i++) {\njump_table[i] = offset + bytes.readInt();\nbuf.append(\"<TH>\").append(low + i).append(\"</TH>\");\n}\nbuf.append(\"<TH>default</TH></TR>\\n<TR>\");\nfor (final int element : jump_table) {\nbuf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(element).append(\"\\\">\").append(element).append(\"</A></TD>\");\n}\nbuf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(default_offset).append(\"\\\">\").append(default_offset).append(\"</A></TD></TR>\\n</TABLE>\\n\");\nbreak;\ncase Const.LOOKUPSWITCH:\nfinal int npairs = bytes.readInt();\noffset = bytes.getIndex() - 8 - no_pad_bytes - 1;\njump_table = new int[npairs];\ndefault_offset += offset;\nbuf.append(\"<TABLE BORDER=1><TR>\");\nfor (int i = 0; i < npairs; i++) {\nfinal int match = bytes.readInt();\njump_table[i] = offset + bytes.readInt();\nbuf.append(\"<TH>\").append(match).append(\"</TH>\");\n}\nbuf.append(\"<TH>default</TH></TR>\\n<TR>\");\nfor (int i = 0; i < npairs; i++) {\nbuf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(jump_table[i]).append(\"\\\">\").append(jump_table[i]).append(\"</A></TD>\");\n}\nbuf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(default_offset).append(\"\\\">\").append(default_offset).append(\"</A></TD></TR>\\n</TABLE>\\n\");\nbreak;\ncase Const.GOTO:\ncase Const.IFEQ:\ncase Const.IFGE:\ncase Const.IFGT:\ncase Const.IFLE:\ncase Const.IFLT:\ncase Const.IFNE:\ncase Const.IFNONNULL:\ncase Const.IFNULL:\ncase Const.IF_ACMPEQ:\ncase Const.IF_ACMPNE:\ncase Const.IF_ICMPEQ:\ncase Const.IF_ICMPGE:\ncase Const.IF_ICMPGT:\ncase Const.IF_ICMPLE:\ncase Const.IF_ICMPLT:\ncase Const.IF_ICMPNE:\ncase Const.JSR:\nindex = bytes.getIndex() + bytes.readShort() - 1;\nbuf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(index).append(\"\\\">\").append(index).append(\"</A>\");\nbreak;\ncase Const.GOTO_W:\ncase Const.JSR_W:\nfinal int windex = bytes.getIndex() + bytes.readInt() - 1;\nbuf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(windex).append(\"\\\">\").append(windex).append(\"</A>\");\nbreak;\ncase Const.ALOAD:\ncase Const.ASTORE:\ncase Const.DLOAD:\ncase Const.DSTORE:\ncase Const.FLOAD:\ncase Const.FSTORE:\ncase Const.ILOAD:\ncase Const.ISTORE:\ncase Const.LLOAD:\ncase Const.LSTORE:\ncase Const.RET:\nif (wide) {\nvindex = bytes.readShort();\nwide = false;\n} else {\nvindex = bytes.readUnsignedByte();\n}\nbuf.append(\"%\").append(vindex);\nbreak;\ncase Const.WIDE:\nwide = true;\nbuf.append(\"(wide)\");\nbreak;\ncase Const.NEWARRAY:\nbuf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\"</FONT>\");\nbreak;\ncase Const.GETFIELD:\ncase Const.GETSTATIC:\ncase Const.PUTFIELD:\ncase Const.PUTSTATIC:\nindex = bytes.readShort();\nfinal ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index, Const.CONSTANT_Fieldref);\nclass_index = c1.getClassIndex();\nname = constantPool.getConstantString(class_index, Const.CONSTANT_Class);\nname = Utility.compactClassName(name, false);\nindex = c1.getNameAndTypeIndex();\nfinal String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\nif (name.equals(className)) {\nbuf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\").append(field_name).append(\"\\\" TARGET=Methods>\").append(field_name).append(\"</A>\\n\");\n} else {\nbuf.append(constantHtml.referenceConstant(class_index)).append(\".\").append(field_name);\n}\nbreak;\ncase Const.CHECKCAST:\ncase Const.INSTANCEOF:\ncase Const.NEW:\nindex = bytes.readShort();\nbuf.append(constantHtml.referenceConstant(index));\nbreak;\ncase Const.INVOKESPECIAL:\ncase Const.INVOKESTATIC:\ncase Const.INVOKEVIRTUAL:\ncase Const.INVOKEINTERFACE:\ncase Const.INVOKEDYNAMIC:\nfinal int m_index = bytes.readShort();\nString str;\nif (opcode == Const.INVOKEINTERFACE) {\nbytes.readUnsignedByte();\nbytes.readUnsignedByte();\nfinal ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool.getConstant(m_index, Const.CONSTANT_InterfaceMethodref);\nclass_index = c.getClassIndex();\nindex = c.getNameAndTypeIndex();\nname = Class2HTML.referenceClass(class_index);\n} else if (opcode == Const.INVOKEDYNAMIC) {\nbytes.readUnsignedByte();\nbytes.readUnsignedByte();\nfinal ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool.getConstant(m_index, Const.CONSTANT_InvokeDynamic);\nindex = c.getNameAndTypeIndex();\nname = \"#\" + c.getBootstrapMethodAttrIndex();\n} else {\n// UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\nfinal ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index, Const.CONSTANT_Methodref);\nclass_index = c.getClassIndex();\nindex = c.getNameAndTypeIndex();\nname = Class2HTML.referenceClass(class_index);\n}\nstr = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));\nfinal ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index, Const.CONSTANT_NameAndType);\nsignature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\nfinal String[] args = Utility.methodSignatureArgumentTypes(signature, false);\nfinal String type = Utility.methodSignatureReturnType(signature, false);\nbuf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(m_index).append(\"\\\" TARGET=ConstantPool>\").append(str).append(\"</A>\").append(\"(\");\nfor (int i = 0; i < args.length; i++) {\nbuf.append(Class2HTML.referenceType(args[i]));\nif (i < args.length - 1) {\nbuf.append(\", \");\n}\n}\nbuf.append(\"):\").append(Class2HTML.referenceType(type));\nbreak;\ncase Const.LDC_W:\ncase Const.LDC2_W:\nindex = bytes.readShort();\nbuf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"</a>\");\nbreak;\ncase Const.LDC:\nindex = bytes.readUnsignedByte();\nbuf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"</a>\");\nbreak;\ncase Const.ANEWARRAY:\nindex = bytes.readShort();\nbuf.append(constantHtml.referenceConstant(index));\nbreak;\ncase Const.MULTIANEWARRAY:\nindex = bytes.readShort();\nfinal int dimensions = bytes.readByte();\nbuf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions).append(\"-dimensional\");\nbreak;\ncase Const.IINC:\nif (wide) {\nvindex = bytes.readShort();\nconstant = bytes.readShort();\nwide = false;\n} else {\nvindex = bytes.readUnsignedByte();\nconstant = bytes.readByte();\n}\nbuf.append(\"%\").append(vindex).append(\" \").append(constant);\nbreak;\ndefault:\nif (Const.getNoOfOperands(opcode) > 0) {\nfor (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\nswitch(Const.getOperandType(opcode, i)) {\ncase Const.T_BYTE:\nbuf.append(bytes.readUnsignedByte());\nbreak;\ncase // Either branch or index\nConst.T_SHORT:\nbuf.append(bytes.readShort());\nbreak;\ncase Const.T_INT:\nbuf.append(bytes.readInt());\nbreak;\ndefault:\n// Never reached\nthrow new IllegalStateException(\"Unreachable default case reached! \" + Const.getOperandType(opcode, i));\n}\nbuf.append(\"&nbsp;\");\n}\n}\n}\nbuf.append(\"</TD>\");\nreturn buf.toString();\n}"
}
```

## Your Answer
//your reason
The warning indicates that there is a write to a static variable from an instance method, which is generally considered bad practice as it can lead to unexpected behavior and bugs. This is because static variables are shared across all instances of a class, and modifying them from an instance method can lead to inconsistencies. The code snippet provided does not show the actual write operation, but the warning suggests that such an operation is present. Therefore, the warning is actionable and should be investigated to ensure that the code is correct and behaves as intended.

@@ actionable @@