## Bug Report
```json
{
    "category": "BAD_PRACTICE",
    "vtype": "DM_EXIT",
    "priority": "3",
    "rank": "19",
    "project": "bcel",
    "warning_line": "System.exit(-1);\n",
    "warning_method": "public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool, final boolean verbose) throws IOException {\nshort opcode = (short) bytes.readUnsignedByte();\nint default_offset = 0;\nint low;\nint high;\nint npairs;\nint index;\nint vindex;\nint constant;\nint[] match;\nint[] jump_table;\nint no_pad_bytes = 0;\nint offset;\nStringBuilder buf = new StringBuilder(Const.getOpcodeName(opcode));\nif ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\nint remainder = bytes.getIndex() % 4;\nno_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\nfor (int i = 0; i < no_pad_bytes; i++) {\nbyte b;\nif ((b = bytes.readByte()) != 0) {\nSystem.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName(opcode) + \":\" + b);\n}\n}\ndefault_offset = bytes.readInt();\n}\nswitch(opcode) {\ncase Const.TABLESWITCH:\nlow = bytes.readInt();\nhigh = bytes.readInt();\noffset = bytes.getIndex() - 12 - no_pad_bytes - 1;\ndefault_offset += offset;\nbuf.append(\"\\tdefault = \").append(default_offset).append(\", low = \").append(low).append(\", high = \").append(high).append(\"(\");\njump_table = new int[high - low + 1];\nfor (int i = 0; i < jump_table.length; i++) {\njump_table[i] = offset + bytes.readInt();\nbuf.append(jump_table[i]);\nif (i < jump_table.length - 1) {\nbuf.append(\", \");\n}\n}\nbuf.append(\")\");\nbreak;\ncase Const.LOOKUPSWITCH:\n{\nnpairs = bytes.readInt();\noffset = bytes.getIndex() - 8 - no_pad_bytes - 1;\nmatch = new int[npairs];\njump_table = new int[npairs];\ndefault_offset += offset;\nbuf.append(\"\\tdefault = \").append(default_offset).append(\", npairs = \").append(npairs).append(\" (\");\nfor (int i = 0; i < npairs; i++) {\nmatch[i] = bytes.readInt();\njump_table[i] = offset + bytes.readInt();\nbuf.append(\"(\").append(match[i]).append(\", \").append(jump_table[i]).append(\")\");\nif (i < npairs - 1) {\nbuf.append(\", \");\n}\n}\nbuf.append(\")\");\n}\nbreak;\ncase Const.GOTO:\ncase Const.IFEQ:\ncase Const.IFGE:\ncase Const.IFGT:\ncase Const.IFLE:\ncase Const.IFLT:\ncase Const.JSR:\ncase Const.IFNE:\ncase Const.IFNONNULL:\ncase Const.IFNULL:\ncase Const.IF_ACMPEQ:\ncase Const.IF_ACMPNE:\ncase Const.IF_ICMPEQ:\ncase Const.IF_ICMPGE:\ncase Const.IF_ICMPGT:\ncase Const.IF_ICMPLE:\ncase Const.IF_ICMPLT:\ncase Const.IF_ICMPNE:\nbuf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readShort());\nbreak;\ncase Const.GOTO_W:\ncase Const.JSR_W:\nbuf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readInt());\nbreak;\ncase Const.ALOAD:\ncase Const.ASTORE:\ncase Const.DLOAD:\ncase Const.DSTORE:\ncase Const.FLOAD:\ncase Const.FSTORE:\ncase Const.ILOAD:\ncase Const.ISTORE:\ncase Const.LLOAD:\ncase Const.LSTORE:\ncase Const.RET:\nif (wide) {\nvindex = bytes.readUnsignedShort();\nwide = false;\n} else {\nvindex = bytes.readUnsignedByte();\n}\nbuf.append(\"\\t\\t%\").append(vindex);\nbreak;\ncase Const.WIDE:\nwide = true;\nbuf.append(\"\\t(wide)\");\nbreak;\ncase Const.NEWARRAY:\nbuf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\nbreak;\ncase Const.GETFIELD:\ncase Const.GETSTATIC:\ncase Const.PUTFIELD:\ncase Const.PUTSTATIC:\nindex = bytes.readUnsignedShort();\nbuf.append(\"\\t\\t\").append(constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.NEW:\ncase Const.CHECKCAST:\nbuf.append(\"\\t\");\ncase Const.INSTANCEOF:\nindex = bytes.readUnsignedShort();\nbuf.append(\"\\t<\").append(constant_pool.constantToString(index, Const.CONSTANT_Class)).append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.INVOKESPECIAL:\ncase Const.INVOKESTATIC:\nindex = bytes.readUnsignedShort();\nConstant c = constant_pool.getConstant(index);\nbuf.append(\"\\t\").append(constant_pool.constantToString(index, c.getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.INVOKEVIRTUAL:\nindex = bytes.readUnsignedShort();\nbuf.append(\"\\t\").append(constant_pool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.INVOKEINTERFACE:\nindex = bytes.readUnsignedShort();\nint nargs = bytes.readUnsignedByte();\nbuf.append(\"\\t\").append(constant_pool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? \" (\" + index + \")\\t\" : \"\").append(nargs).append(\"\\t\").append(bytes.readUnsignedByte());\nbreak;\ncase Const.INVOKEDYNAMIC:\nindex = bytes.readUnsignedShort();\nbuf.append(\"\\t\").append(constant_pool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? \" (\" + index + \")\\t\" : \"\").append(bytes.readUnsignedByte()).append(bytes.readUnsignedByte());\nbreak;\ncase Const.LDC_W:\ncase Const.LDC2_W:\nindex = bytes.readUnsignedShort();\nbuf.append(\"\\t\\t\").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.LDC:\nindex = bytes.readUnsignedByte();\nbuf.append(\"\\t\\t\").append(constant_pool.constantToString(index, constant_pool.getConstant(index).getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.ANEWARRAY:\nindex = bytes.readUnsignedShort();\nbuf.append(\"\\t\\t<\").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\nbreak;\ncase Const.MULTIANEWARRAY:\n{\nindex = bytes.readUnsignedShort();\nint dimensions = bytes.readUnsignedByte();\nbuf.append(\"\\t<\").append(compactClassName(constant_pool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions).append(verbose ? \" (\" + index + \")\" : \"\");\n}\nbreak;\ncase Const.IINC:\nif (wide) {\nvindex = bytes.readUnsignedShort();\nconstant = bytes.readShort();\nwide = false;\n} else {\nvindex = bytes.readUnsignedByte();\nconstant = bytes.readByte();\n}\nbuf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\nbreak;\ndefault:\nif (Const.getNoOfOperands(opcode) > 0) {\nfor (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\nbuf.append(\"\\t\\t\");\nswitch(Const.getOperandType(opcode, i)) {\ncase Const.T_BYTE:\nbuf.append(bytes.readByte());\nbreak;\ncase Const.T_SHORT:\nbuf.append(bytes.readShort());\nbreak;\ncase Const.T_INT:\nbuf.append(bytes.readInt());\nbreak;\ndefault:\n// Never reached\nSystem.err.println(\"Unreachable default case reached!\");\nSystem.exit(-1);\n}\n}\n}\n}\nreturn buf.toString();\n}"
}
```

## Your Answer
The warning is about using `System.exit(-1)` which can terminate the JVM abruptly and is generally considered a bad practice. It is actionable as it should be replaced with a proper error handling mechanism. 
@@ actionable @@