{
    "project": "bash",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "subst.c",
    "message": "pointer `temp` last assigned on line 808 could be null and is dereferenced at line 893, column 4.",
    "warning_function_name": "string_extract_double_quoted",
    "warning_line": "temp[j++] = '$';",
    "warning_context": "      /* Process a character that was quoted by a backslash. */\n      if (pass_next)\n\t{\n\t  /* XXX - take another look at this in light of Interp 221 */\n\t  /* Posix.2 sez:\n\n\t     ``The backslash shall retain its special meaning as an escape\n\t     character only when followed by one of the characters:\n\t\t$\t`\t\"\t\\\t<newline>''.\n\n\t     If STRIPDQ is zero, we handle the double quotes here and let\n\t     expand_word_internal handle the rest.  If STRIPDQ is non-zero,\n\t     we have already been through one round of backslash stripping,\n\t     and want to strip these backslashes only if DQUOTE is non-zero,\n\t     indicating that we are inside an embedded double-quoted string. */\n\n\t     /* If we are in an embedded quoted string, then don't strip\n\t\tbackslashes before characters for which the backslash\n\t\tretains its special meaning, but remove backslashes in\n\t\tfront of other characters.  If we are not in an\n\t\tembedded quoted string, don't strip backslashes at all.\n\t\tThis mess is necessary because the string was already\n\t\tsurrounded by double quotes (and sh has some really weird\n\t\tquoting rules).\n\t\tThe returned string will be run through expansion as if\n\t\tit were double-quoted. */\n\t  if ((stripdq == 0 && c != '\"') ||\n\t      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))\n\t    temp[j++] = '\\\\';\n\t  pass_next = 0;\n\nadd_one_character:\n\t  COPY_CHAR_I (temp, j, string, send, i);\n\t  continue;\n\t}\n\n      /* A backslash protects the next character.  The code just above\n\t handles preserving the backslash in front of any character but\n\t a double quote. */\n      if (c == '\\\\')\n\t{\n\t  pass_next++;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Inside backquotes, ``the portion of the quoted string from the\n\t initial backquote and the characters up to the next backquote\n\t that is not preceded by a backslash, having escape characters\n\t removed, defines that command''. */\n      if (backquote)\n\t{\n\t  if (c == '`')\n\t    backquote = 0;\n\t  temp[j++] = c;\n\t  i++;\n\t  continue;\n\t}\n\n      if (c == '`')\n\t{\n\t  temp[j++] = c;\n\t  backquote++;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Pass everything between `$(' and the matching `)' or a quoted\n\t ${ ... } pair through according to the Posix.2 specification. */\n      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))\n\t{\n\t  int free_ret = 1;\n\n\t  si = i + 2;\n\t  if (string[i + 1] == LPAREN)\n\t    ret = extract_command_subst (string, &si, 0);\n\t  else\n\t    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);\n\n\t  temp[j++] = '$';\n\t  temp[j++] = string[i + 1];\n\n\t  /* Just paranoia; ret will not be 0 unless no_longjmp_on_fatal_error\n\t     is set. */\n\t  if (ret == 0 && no_longjmp_on_fatal_error)\n\t    {\n\t      free_ret = 0;\n\t      ret = string + i + 2;\n\t    }\n\n\t  for (t = 0; ret[t]; t++, j++)\n\t    temp[j] = ret[t];\n\t  temp[j] = string[si];\n\n\t  if (string[si])\n\t    {\n\t      j++;\n\t      i = si + 1;\n\t    }\n\t  else\n\t    i = si;\n"
}