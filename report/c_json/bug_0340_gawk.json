{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Message": "Access to field 'ranges' results in a dereference of a null pointer (loaded from variable 'work_mbc')",
    "Code_line": "                        = maybe_realloc (work_mbc->ranges,",
    "Code_function": "parse_bracket_exp (void)\n{\n  bool invert;\n  int c, c1, c2;\n  charclass ccl;\n\n  /* This is a bracket expression that dfaexec is known to\n     process correctly.  */\n  bool known_bracket_exp = true;\n\n  /* Used to warn about [:space:].\n     Bit 0 = first character is a colon.\n     Bit 1 = last character is a colon.\n     Bit 2 = includes any other character but a colon.\n     Bit 3 = includes ranges, char/equiv classes or collation elements.  */\n  int colon_warning_state;\n\n  wint_t wc;\n  wint_t wc2;\n  wint_t wc1 = 0;\n\n  /* Work area to build a mb_char_classes.  */\n  struct mb_char_classes *work_mbc;\n  size_t chars_al, ranges_al, ch_classes_al, equivs_al, coll_elems_al;\n\n  chars_al = ranges_al = ch_classes_al = equivs_al = coll_elems_al = 0;\n  if (dfa->multibyte)\n    {\n      dfa->mbcsets = maybe_realloc (dfa->mbcsets, dfa->nmbcsets,\n                                    &dfa->mbcsets_alloc,\n                                    sizeof *dfa->mbcsets);\n\n      /* dfa->multibyte_prop[] hold the index of dfa->mbcsets.\n         We will update dfa->multibyte_prop[] in addtok, because we can't\n         decide the index in dfa->tokens[].  */\n\n      /* Initialize work area.  */\n      work_mbc = &(dfa->mbcsets[dfa->nmbcsets++]);\n      memset (work_mbc, 0, sizeof *work_mbc);\n    }\n  else\n    work_mbc = NULL;\n\n  memset (ccl, 0, sizeof ccl);\n  FETCH_WC (c, wc, _(\"unbalanced [\"));\n  if (c == '^')\n    {\n      FETCH_WC (c, wc, _(\"unbalanced [\"));\n      invert = true;\n      known_bracket_exp = using_simple_locale ();\n    }\n  else\n    invert = false;\n\n  colon_warning_state = (c == ':');\n  do\n    {\n      c1 = NOTCHAR;\t/* Mark c1 as not initialized.  */\n      colon_warning_state &= ~2;\n\n      /* Note that if we're looking at some other [:...:] construct,\n         we just treat it as a bunch of ordinary characters.  We can do\n         this because we assume regex has checked for syntax errors before\n         dfa is ever called.  */\n      if (c == '[')\n        {\n          FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n\n          if ((c1 == ':' && (syntax_bits & RE_CHAR_CLASSES))\n              || c1 == '.' || c1 == '=')\n            {\n              enum { MAX_BRACKET_STRING_LEN = 32 };\n              char str[MAX_BRACKET_STRING_LEN + 1];\n              size_t len = 0;\n              for (;;)\n                {\n                  FETCH_WC (c, wc, _(\"unbalanced [\"));\n                  if ((c == c1 && *lexptr == ']') || lexleft == 0)\n                    break;\n                  if (len < MAX_BRACKET_STRING_LEN)\n                    str[len++] = c;\n                  else\n                    /* This is in any case an invalid class name.  */\n                    str[0] = '\\0';\n                }\n              str[len] = '\\0';\n\n              /* Fetch bracket.  */\n              FETCH_WC (c, wc, _(\"unbalanced [\"));\n              if (c1 == ':')\n                /* Build character class.  POSIX allows character\n                   classes to match multicharacter collating elements,\n                   but the regex code does not support that, so do not\n                   worry about that possibility.  */\n                {\n                  char const *class\n                    = (case_fold && (STREQ (str, \"upper\")\n                                     || STREQ (str, \"lower\")) ? \"alpha\" : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n                    dfaerror (_(\"invalid character class\"));\n\n                  if (dfa->multibyte && !pred->single_byte_only)\n                    {\n                      /* Store the character class as wctype_t.  */\n                      wctype_t wt = (wctype_t) wctype (class);\n\n                      work_mbc->ch_classes\n                        = maybe_realloc (work_mbc->ch_classes,\n                                         work_mbc->nch_classes, &ch_classes_al,\n                                         sizeof *work_mbc->ch_classes);\n                      work_mbc->ch_classes[work_mbc->nch_classes++] = wt;\n                    }\n\n                  for (c2 = 0; c2 < NOTCHAR; ++c2)\n                    if (pred->func (c2))\n                      setbit (c2, ccl);\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n\n              /* Fetch new lookahead character.  */\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* We treat '[' as a normal character here.  c/c1/wc/wc1\n             are already set up.  */\n        }\n\n      if (c == '\\\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n        FETCH_WC (c, wc, _(\"unbalanced [\"));\n\n      if (c1 == NOTCHAR)\n        FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n\n      if (c1 == '-')\n        /* build range characters.  */\n        {\n          FETCH_WC (c2, wc2, _(\"unbalanced [\"));\n\n          /* A bracket expression like [a-[.aa.]] matches an unknown set.\n             Treat it like [-a[.aa.]] while parsing it, and\n             remember that the set is unknown.  */\n          if (c2 == '[' && *lexptr == '.')\n            {\n              known_bracket_exp = false;\n              c2 = ']';\n            }\n\n          if (c2 != ']')\n            {\n              if (c2 == '\\\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n                FETCH_WC (c2, wc2, _(\"unbalanced [\"));\n\n              if (dfa->multibyte)\n                {\n                  /* When case folding map a range, say [m-z] (or even [M-z])\n                     to the pair of ranges, [m-z] [M-Z].  Although this code\n                     is wrong in multiple ways, it's never used in practice.\n                     FIXME: Remove this (and related) unused code.  */\n                  if (wc != WEOF && wc2 != WEOF)\n                    {\n                      work_mbc->ranges\n                        = maybe_realloc (work_mbc->ranges,\n                                         work_mbc->nranges + 2,\n                                         &ranges_al, sizeof *work_mbc->ranges);\n                      work_mbc->ranges[work_mbc->nranges].beg\n                        = case_fold ? towlower (wc) : wc;\n                      work_mbc->ranges[work_mbc->nranges++].end\n                        = case_fold ? towlower (wc2) : wc2;\n\n                      if (case_fold && (iswalpha (wc) || iswalpha (wc2)))\n                        {\n                          work_mbc->ranges[work_mbc->nranges].beg\n                            = towupper (wc);\n                          work_mbc->ranges[work_mbc->nranges++].end\n                            = towupper (wc2);\n                        }\n                    }\n                }\n              else if (using_simple_locale ())\n                {\n                  for (c1 = c; c1 <= c2; c1++)\n                    setbit (c1, ccl);\n                  if (case_fold)\n                    {\n                      int uc = toupper (c);\n                      int uc2 = toupper (c2);\n                      for (c1 = 0; c1 < NOTCHAR; c1++)\n                        {\n                          int uc1 = toupper (c1);\n                          if (uc <= uc1 && uc1 <= uc2)\n                            setbit (c1, ccl);\n                        }\n                    }\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* In the case [x-], the - is an ordinary hyphen,\n             which is left in c1, the lookahead character.  */\n          lexptr -= cur_mb_len;\n          lexleft += cur_mb_len;\n        }\n\n      colon_warning_state |= (c == ':') ? 2 : 4;\n\n      if (!dfa->multibyte)\n        {\n          if (case_fold)\n            setbit_case_fold_c (c, ccl);\n          else\n            setbit (c, ccl);\n          continue;\n        }\n\n      if (wc == WEOF)\n        known_bracket_exp = false;\n      else\n        {\n          wchar_t folded[CASE_FOLDED_BUFSIZE + 1];\n          int i;\n          int n = (case_fold ? case_folded_counterparts (wc, folded + 1) + 1\n                   : 1);\n          folded[0] = wc;\n          for (i = 0; i < n; i++)\n            if (!setbit_wc (folded[i], ccl))\n              {\n                work_mbc->chars\n                  = maybe_realloc (work_mbc->chars, work_mbc->nchars,\n                                   &chars_al, sizeof *work_mbc->chars);\n                work_mbc->chars[work_mbc->nchars++] = folded[i];\n              }\n        }\n    }\n  while ((wc = wc1, (c = c1) != ']'));\n\n  if (colon_warning_state == 7)\n    dfawarn (_(\"character class syntax is [[:space:]], not [:space:]\"));\n\n  if (! known_bracket_exp)\n    return BACKREF;\n\n  if (dfa->multibyte)\n    {\n      static charclass zeroclass;\n      work_mbc->invert = invert;\n      work_mbc->cset = equal (ccl, zeroclass) ? -1 : charclass_index (ccl);\n      return MBCSET;\n    }\n\n  if (invert)\n    {\n      assert (!dfa->multibyte);\n      notset (ccl);\n      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)\n        clrbit (eolbyte, ccl);\n    }\n\n  return CSET + charclass_index (ccl);\n}"
}