{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      if (convfn != dentry)",
    "Code_function": "rl_filename_completion_function (text, state)\n     const char *text;\n     int state;\n{\n  static DIR *directory = (DIR *)NULL;\n  static char *filename = (char *)NULL;\n  static char *dirname = (char *)NULL;\n  static char *users_dirname = (char *)NULL;\n  static int filename_len;\n  char *temp, *dentry, *convfn;\n  int dirlen, dentlen, convlen;\n  struct dirent *entry;\n\n  /* If we don't have any state, then do some initialization. */\n  if (state == 0)\n    {\n      /* If we were interrupted before closing the directory or reading\n\t all of its contents, close it. */\n      if (directory)\n\t{\n\t  closedir (directory);\n\t  directory = (DIR *)NULL;\n\t}\n      FREE (dirname);\n      FREE (filename);\n      FREE (users_dirname);\n\n      filename = savestring (text);\n      if (*text == 0)\n\ttext = \".\";\n      dirname = savestring (text);\n\n      temp = strrchr (dirname, '/');\n\n#if defined (__MSDOS__)\n      /* special hack for //X/... */\n      if (dirname[0] == '/' && dirname[1] == '/' && ISALPHA ((unsigned char)dirname[2]) && dirname[3] == '/')\n        temp = strrchr (dirname + 3, '/');\n#endif\n\n      if (temp)\n\t{\n\t  strcpy (filename, ++temp);\n\t  *temp = '\\0';\n\t}\n#if defined (__MSDOS__)\n      /* searches from current directory on the drive */\n      else if (ISALPHA ((unsigned char)dirname[0]) && dirname[1] == ':')\n        {\n          strcpy (filename, dirname + 2);\n          dirname[2] = '\\0';\n        }\n#endif\n      else\n\t{\n\t  dirname[0] = '.';\n\t  dirname[1] = '\\0';\n\t}\n\n      /* We aren't done yet.  We also support the \"~user\" syntax. */\n\n      /* Save the version of the directory that the user typed, dequoting\n\t it if necessary. */\n      if (rl_completion_found_quote && rl_filename_dequoting_function)\n\tusers_dirname = (*rl_filename_dequoting_function) (dirname, rl_completion_quote_character);\n      else\n\tusers_dirname = savestring (dirname);\n\n      if (*dirname == '~')\n\t{\n\t  temp = tilde_expand (dirname);\n\t  xfree (dirname);\n\t  dirname = temp;\n\t}\n\n      /* We have saved the possibly-dequoted version of the directory name\n\t the user typed.  Now transform the directory name we're going to\n\t pass to opendir(2).  The directory rewrite hook modifies only the\n\t directory name; the directory completion hook modifies both the\n\t directory name passed to opendir(2) and the version the user\n\t typed.  Both the directory completion and rewrite hooks should perform\n\t any necessary dequoting.  The hook functions return 1 if they modify\n\t the directory name argument.  If either hook returns 0, it should\n\t not modify the directory name pointer passed as an argument. */\n      if (rl_directory_rewrite_hook)\n\t(*rl_directory_rewrite_hook) (&dirname);\n      else if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))\n\t{\n\t  xfree (users_dirname);\n\t  users_dirname = savestring (dirname);\n\t}\n      else if (rl_completion_found_quote && rl_filename_dequoting_function)\n\t{\n\t  /* delete single and double quotes */\n\t  xfree (dirname);\n\t  dirname = savestring (users_dirname);\n\t}\n      directory = opendir (dirname);\n\n      /* Now dequote a non-null filename.  FILENAME will not be NULL, but may\n\t be empty. */\n      if (*filename && rl_completion_found_quote && rl_filename_dequoting_function)\n\t{\n\t  /* delete single and double quotes */\n\t  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);\n\t  xfree (filename);\n\t  filename = temp;\n\t}\n      filename_len = strlen (filename);\n\n      rl_filename_completion_desired = 1;\n    }\n\n  /* At this point we should entertain the possibility of hacking wildcarded\n     filenames, like /usr/man/man<WILD>/te<TAB>.  If the directory name\n     contains globbing characters, then build an array of directories, and\n     then map over that list while completing. */\n  /* *** UNIMPLEMENTED *** */\n\n  /* Now that we have some state, we can read the directory. */\n\n  entry = (struct dirent *)NULL;\n  while (directory && (entry = readdir (directory)))\n    {\n      convfn = dentry = entry->d_name;\n      convlen = dentlen = D_NAMLEN (entry);\n\n      if (rl_filename_rewrite_hook)\n\t{\n\t  convfn = (*rl_filename_rewrite_hook) (dentry, dentlen);\n\t  convlen = (convfn == dentry) ? dentlen : strlen (convfn);\n\t}\n\n      /* Special case for no filename.  If the user has disabled the\n         `match-hidden-files' variable, skip filenames beginning with `.'.\n\t All other entries except \".\" and \"..\" match. */\n      if (filename_len == 0)\n\t{\n\t  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))\n\t    continue;\n\n\t  if (convfn[0] != '.' ||\n\t       (convfn[1] && (convfn[1] != '.' || convfn[2])))\n\t    break;\n\t}\n      else\n\t{\n\t  if (complete_fncmp (convfn, convlen, filename, filename_len))\n\t    break;\n\t}\n    }\n\n  if (entry == 0)\n    {\n      if (directory)\n\t{\n\t  closedir (directory);\n\t  directory = (DIR *)NULL;\n\t}\n      if (dirname)\n\t{\n\t  xfree (dirname);\n\t  dirname = (char *)NULL;\n\t}\n      if (filename)\n\t{\n\t  xfree (filename);\n\t  filename = (char *)NULL;\n\t}\n      if (users_dirname)\n\t{\n\t  xfree (users_dirname);\n\t  users_dirname = (char *)NULL;\n\t}\n\n      return (char *)NULL;\n    }\n  else\n    {\n      /* dirname && (strcmp (dirname, \".\") != 0) */\n      if (dirname && (dirname[0] != '.' || dirname[1]))\n\t{\n\t  if (rl_complete_with_tilde_expansion && *users_dirname == '~')\n\t    {\n\t      dirlen = strlen (dirname);\n\t      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));\n\t      strcpy (temp, dirname);\n\t      /* Canonicalization cuts off any final slash present.  We\n\t\t may need to add it back. */\n\t      if (dirname[dirlen - 1] != '/')\n\t        {\n\t          temp[dirlen++] = '/';\n\t          temp[dirlen] = '\\0';\n\t        }\n\t    }\n\t  else\n\t    {\n\t      dirlen = strlen (users_dirname);\n\t      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));\n\t      strcpy (temp, users_dirname);\n\t      /* Make sure that temp has a trailing slash here. */\n\t      if (users_dirname[dirlen - 1] != '/')\n\t\ttemp[dirlen++] = '/';\n\t    }\n\n\t  strcpy (temp + dirlen, convfn);\n\t}\n      else\n\ttemp = savestring (convfn);\n\n      if (convfn != dentry)\n\txfree (convfn);\n\n      return (temp);\n    }\n}"
}