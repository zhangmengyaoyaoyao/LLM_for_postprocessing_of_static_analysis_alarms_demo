{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: [8, 9] (⇐ [7, 8] + 1) Size: 2 by call to `exp_nameop`.",
    "Code_line": "\t\t\t\t       exp_nameop (NAME, \".\"),",
    "Code_function": "ldctor_build_sets (void)\n{\n  static bfd_boolean called;\n  bfd_boolean header_printed;\n  struct set_info *p;\n\n  /* The emulation code may call us directly, but we only want to do\n     this once.  */\n  if (called)\n    return;\n  called = TRUE;\n\n  if (constructors_sorted)\n    {\n      for (p = sets; p != NULL; p = p->next)\n\t{\n\t  int c, i;\n\t  struct set_element *e;\n\t  struct set_element **array;\n\n\t  if (p->elements == NULL)\n\t    continue;\n\n\t  c = 0;\n\t  for (e = p->elements; e != NULL; e = e->next)\n\t    ++c;\n\n\t  array = (struct set_element **) xmalloc (c * sizeof *array);\n\n\t  i = 0;\n\t  for (e = p->elements; e != NULL; e = e->next)\n\t    {\n\t      array[i] = e;\n\t      ++i;\n\t    }\n\n\t  qsort (array, c, sizeof *array, ctor_cmp);\n\n\t  e = array[0];\n\t  p->elements = e;\n\t  for (i = 0; i < c - 1; i++)\n\t    array[i]->next = array[i + 1];\n\t  array[i]->next = NULL;\n\n\t  free (array);\n\t}\n    }\n\n  lang_list_init (&constructor_list);\n  push_stat_ptr (&constructor_list);\n\n  header_printed = FALSE;\n  for (p = sets; p != NULL; p = p->next)\n    {\n      struct set_element *e;\n      reloc_howto_type *howto;\n      int reloc_size, size;\n\n      /* If the symbol is defined, we may have been invoked from\n\t collect, and the sets may already have been built, so we do\n\t not do anything.  */\n      if (p->h->type == bfd_link_hash_defined\n\t  || p->h->type == bfd_link_hash_defweak)\n\tcontinue;\n\n      /* For each set we build:\n\t   set:\n\t     .long number_of_elements\n\t     .long element0\n\t     ...\n\t     .long elementN\n\t     .long 0\n\t except that we use the right size instead of .long.  When\n\t generating relocatable output, we generate relocs instead of\n\t addresses.  */\n      howto = bfd_reloc_type_lookup (link_info.output_bfd, p->reloc);\n      if (howto == NULL)\n\t{\n\t  if (link_info.relocatable)\n\t    {\n\t      einfo (_(\"%P%X: %s does not support reloc %s for set %s\\n\"),\n\t\t     bfd_get_target (link_info.output_bfd),\n\t\t     bfd_get_reloc_code_name (p->reloc),\n\t\t     p->h->root.string);\n\t      continue;\n\t    }\n\n\t  /* If this is not a relocatable link, all we need is the\n\t     size, which we can get from the input BFD.  */\n\t  if (p->elements->section->owner != NULL)\n\t    howto = bfd_reloc_type_lookup (p->elements->section->owner,\n\t\t\t\t\t   p->reloc);\n\t  if (howto == NULL)\n\t    {\n\t      einfo (_(\"%P%X: %s does not support reloc %s for set %s\\n\"),\n\t\t     bfd_get_target (p->elements->section->owner),\n\t\t     bfd_get_reloc_code_name (p->reloc),\n\t\t     p->h->root.string);\n\t      continue;\n\t    }\n\t}\n\n      reloc_size = bfd_get_reloc_size (howto);\n      switch (reloc_size)\n\t{\n\tcase 1: size = BYTE; break;\n\tcase 2: size = SHORT; break;\n\tcase 4: size = LONG; break;\n\tcase 8:\n\t  if (howto->complain_on_overflow == complain_overflow_signed)\n\t    size = SQUAD;\n\t  else\n\t    size = QUAD;\n\t  break;\n\tdefault:\n\t  einfo (_(\"%P%X: Unsupported size %d for set %s\\n\"),\n\t\t bfd_get_reloc_size (howto), p->h->root.string);\n\t  size = LONG;\n\t  break;\n\t}\n\n      lang_add_assignment (exp_assign (\".\",\n\t\t\t\t       exp_unop (ALIGN_K,\n\t\t\t\t\t\t exp_intop (reloc_size)),\n\t\t\t\t       FALSE));\n      lang_add_assignment (exp_assign (p->h->root.string,\n\t\t\t\t       exp_nameop (NAME, \".\"),\n\t\t\t\t       FALSE));\n      lang_add_data (size, exp_intop (p->count));\n\n      for (e = p->elements; e != NULL; e = e->next)\n\t{\n\t  if (config.map_file != NULL)\n\t    {\n\t      int len;\n\n\t      if (! header_printed)\n\t\t{\n\t\t  minfo (_(\"\\nSet                 Symbol\\n\\n\"));\n\t\t  header_printed = TRUE;\n\t\t}\n\n\t      minfo (\"%s\", p->h->root.string);\n\t      len = strlen (p->h->root.string);\n\n\t      if (len >= 19)\n\t\t{\n\t\t  print_nl ();\n\t\t  len = 0;\n\t\t}\n\t      while (len < 20)\n\t\t{\n\t\t  print_space ();\n\t\t  ++len;\n\t\t}\n\n\t      if (e->name != NULL)\n\t\tminfo (\"%T\\n\", e->name);\n\t      else\n\t\tminfo (\"%G\\n\", e->section->owner, e->section, e->value);\n\t    }\n\n\t  /* Need SEC_KEEP for --gc-sections.  */\n\t  if (! bfd_is_abs_section (e->section))\n\t    e->section->flags |= SEC_KEEP;\n\n\t  if (link_info.relocatable)\n\t    lang_add_reloc (p->reloc, howto, e->section, e->name,\n\t\t\t    exp_intop (e->value));\n\t  else\n\t    lang_add_data (size, exp_relop (e->section, e->value));\n\t}\n\n      lang_add_data (size, exp_intop (0));\n    }\n\n  pop_stat_ptr ();\n}"
}