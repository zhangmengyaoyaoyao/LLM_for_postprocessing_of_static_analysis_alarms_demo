{
    "Project": "binutils",
    "Tool": "Cppcheck",
    "category": "uninitvar",
    "file": "bfd/elf64-alpha.c",
    "message": "Uninitialized variable: *pbe",
    "warning_function_name": "elf64_alpha_merge_gots",
    "warning_line": "struct alpha_elf_got_entry *ae, *be, **pbe, **start;",
    "warning_context": "static void\nelf64_alpha_merge_gots (bfd *a, bfd *b)\n{\n  int total = alpha_elf_tdata (a)->total_got_size;\n  bfd *bsub;\n\n  /* Remember local expansion.  */\n  {\n    int e = alpha_elf_tdata (b)->local_got_size;\n    total += e;\n    alpha_elf_tdata (a)->local_got_size += e;\n  }\n\n  for (bsub = b; bsub ; bsub = alpha_elf_tdata (bsub)->in_got_link_next)\n    {\n      struct alpha_elf_got_entry **local_got_entries;\n      struct alpha_elf_link_hash_entry **hashes;\n      Elf_Internal_Shdr *symtab_hdr;\n      int i, n;\n\n      /* Let the local .got entries know they are part of a new subsegment.  */\n      local_got_entries = alpha_elf_tdata (bsub)->local_got_entries;\n      if (local_got_entries)\n        {\n\t  n = elf_tdata (bsub)->symtab_hdr.sh_info;\n\t  for (i = 0; i < n; ++i)\n\t    {\n\t      struct alpha_elf_got_entry *ent;\n\t      for (ent = local_got_entries[i]; ent; ent = ent->next)\n\t        ent->gotobj = a;\n\t    }\n        }\n\n      /* Merge the global .got entries.  */\n      hashes = alpha_elf_sym_hashes (bsub);\n      symtab_hdr = &elf_tdata (bsub)->symtab_hdr;\n\n      n = NUM_SHDR_ENTRIES (symtab_hdr) - symtab_hdr->sh_info;\n      for (i = 0; i < n; ++i)\n        {\n\t  struct alpha_elf_got_entry *ae, *be, **pbe, **start;\n\t  struct alpha_elf_link_hash_entry *h;\n\n\t  h = hashes[i];\n\t  while (h->root.root.type == bfd_link_hash_indirect\n\t         || h->root.root.type == bfd_link_hash_warning)\n\t    h = (struct alpha_elf_link_hash_entry *)h->root.root.u.i.link;\n\n\t  pbe = start = &h->got_entries;\n\t  while ((be = *pbe) != NULL)\n\t    {\n\t      if (be->use_count == 0)\n\t        {\n\t\t  *pbe = be->next;\n\t\t  memset (be, 0xa5, sizeof (*be));\n\t\t  goto kill;\n\t        }\n\t      if (be->gotobj != b)\n\t        goto next;\n\n\t      for (ae = *start; ae ; ae = ae->next)\n\t        if (ae->gotobj == a\n\t\t    && ae->reloc_type == be->reloc_type\n\t\t    && ae->addend == be->addend)\n\t\t  {\n\t\t    ae->flags |= be->flags;\n\t\t    ae->use_count += be->use_count;\n\t\t    *pbe = be->next;\n\t\t    memset (be, 0xa5, sizeof (*be));\n\t\t    goto kill;\n\t\t  }\n\t      be->gotobj = a;\n\t      total += alpha_got_entry_size (be->reloc_type);\n\n\t    next:;\n\t      pbe = &be->next;\n\t    kill:;\n\t    }\n        }\n\n      alpha_elf_tdata (bsub)->gotobj = a;\n    }\n  alpha_elf_tdata (a)->total_got_size = total;\n\n  /* Merge the two in_got chains.  */\n  {\n    bfd *next;\n\n    bsub = a;\n    while ((next = alpha_elf_tdata (bsub)->in_got_link_next) != NULL)\n      bsub = next;\n\n    alpha_elf_tdata (bsub)->in_got_link_next = b;\n  }\n}\n"
}