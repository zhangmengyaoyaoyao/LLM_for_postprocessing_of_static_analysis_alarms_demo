{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "param_expand",
    "warning_line": "SADD_MBQCHAR_BODY(temp, string, sindex, string_size);",
    "warning_context": "  char *istring;\n\n  /* The current size of the above object. */\n  int istring_size;\n\n  /* Index into ISTRING. */\n  int istring_index;\n\n  /* Temporary string storage. */\n  char *temp, *temp1;\n\n  /* The text of WORD. */\n  register char *string;\n\n  /* The size of STRING. */\n  size_t string_size;\n\n  /* The index into STRING. */\n  int sindex;\n\n  /* This gets 1 if we see a $@ while quoted. */\n  int quoted_dollar_at;\n\n  /* One of UNQUOTED, PARTIALLY_QUOTED, or WHOLLY_QUOTED, depending on\n     whether WORD contains no quoting characters, a partially quoted\n     string (e.g., \"xx\"ab), or is fully quoted (e.g., \"xxab\"). */\n  int quoted_state;\n\n  /* State flags */\n  int had_quoted_null;\n  int has_dollar_at, temp_has_dollar_at;\n  int split_on_spaces;\n  int tflag;\n  int pflags;\t\t\t/* flags passed to param_expand */\n\n  int assignoff;\t\t/* If assignment, offset of `=' */\n\n  register unsigned char c;\t/* Current character. */\n  int t_index;\t\t\t/* For calls to string_extract_xxx. */\n\n  char twochars[2];\n\n  DECLARE_MBSTATE;\n\n  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);\n  istring[istring_index = 0] = '\\0';\n  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;\n  split_on_spaces = 0;\n  quoted_state = UNQUOTED;\n\n  string = word->word;\n  if (string == 0)\n    goto finished_with_string;\n  /* Don't need the string length for the SADD... and COPY_ macros unless\n     multibyte characters are possible. */\n  string_size = (MB_CUR_MAX > 1) ? strlen (string) : 1;\n\n  if (contains_dollar_at)\n    *contains_dollar_at = 0;\n\n  assignoff = -1;\n\n  /* Begin the expansion. */\n\n  for (sindex = 0; ;)\n    {\n      c = string[sindex];\n\n      /* Case on top-level character. */\n      switch (c)\n\t{\n\tcase '\\0':\n\t  goto finished_with_string;\n\n\tcase CTLESC:\n\t  sindex++;\n#if HANDLE_MULTIBYTE\n\t  if (MB_CUR_MAX > 1 && string[sindex])\n\t    {\n\t      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);\n\t    }\n\t  else\n#endif\n\t    {\n\t      temp = (char *)xmalloc (3);\n\t      temp[0] = CTLESC;\n\t      temp[1] = c = string[sindex];\n\t      temp[2] = '\\0';\n\t    }\n\ndollar_add_string:\n\t  if (string[sindex])\n\t    sindex++;\n\nadd_string:\n\t  if (temp)\n\t    {\n\t      istring = sub_append_string (temp, istring, &istring_index, &istring_size);\n\t      temp = (char *)0;\n\t    }\n\n"
}