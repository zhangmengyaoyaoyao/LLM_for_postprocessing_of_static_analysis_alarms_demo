{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "libiberty/cp-demangle.c",
    "message": "The value read from saved_templates was never initialized.",
    "warning_function_name": "d_print_comp_inner",
    "warning_line": "dpi->templates = saved_templates;",
    "warning_context": "\tstruct d_print_mod *pdpm;\n\n\t/* When printing arrays, it's possible to have cases where the\n\t   same CV-qualifier gets pushed on the stack multiple times.\n\t   We only need to print it once.  */\n\n\tfor (pdpm = dpi->modifiers; pdpm != NULL; pdpm = pdpm->next)\n\t  {\n\t    if (! pdpm->printed)\n\t      {\n\t\tif (pdpm->mod->type != DEMANGLE_COMPONENT_RESTRICT\n\t\t    && pdpm->mod->type != DEMANGLE_COMPONENT_VOLATILE\n\t\t    && pdpm->mod->type != DEMANGLE_COMPONENT_CONST)\n\t\t  break;\n\t\tif (pdpm->mod->type == dc->type)\n\t\t  {\n\t\t    d_print_comp (dpi, options, d_left (dc));\n\t\t    return;\n\t\t  }\n\t      }\n\t  }\n      }\n      goto modifier;\n\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      {\n\t/* Handle reference smashing: & + && = &.  */\n\tconst struct demangle_component *sub = d_left (dc);\n\tif (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n\t  {\n\t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n\t    struct demangle_component *a;\n\n\t    if (scope == NULL)\n\t      {\n\t\t/* This is the first time SUB has been traversed.\n\t\t   We need to capture the current templates so\n\t\t   they can be restored if SUB is reentered as a\n\t\t   substitution.  */\n\t\td_save_scope (dpi, sub);\n\t\tif (d_print_saw_error (dpi))\n\t\t  return;\n\t      }\n\t    else\n\t      {\n\t\tconst struct d_component_stack *dcse;\n\t\tint found_self_or_parent = 0;\n\n\t\t/* This traversal is reentering SUB as a substition.\n\t\t   If we are not beneath SUB or DC in the tree then we\n\t\t   need to restore SUB's template stack temporarily.  */\n\t\tfor (dcse = dpi->component_stack; dcse != NULL;\n\t\t     dcse = dcse->parent)\n\t\t  {\n\t\t    if (dcse->dc == sub\n\t\t\t|| (dcse->dc == dc\n\t\t\t    && dcse != dpi->component_stack))\n\t\t      {\n\t\t\tfound_self_or_parent = 1;\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\n\t\tif (!found_self_or_parent)\n\t\t  {\n\t\t    saved_templates = dpi->templates;\n\t\t    dpi->templates = scope->templates;\n\t\t    need_template_restore = 1;\n\t\t  }\n\t      }\n\n\t    a = d_lookup_template_argument (dpi, sub);\n\t    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t      a = d_index_template_argument (a, dpi->pack_index);\n\n\t    if (a == NULL)\n\t      {\n\t\tif (need_template_restore)\n\t\t  dpi->templates = saved_templates;\n\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    sub = a;\n\t  }\n\n\tif (sub->type == DEMANGLE_COMPONENT_REFERENCE\n\t    || sub->type == dc->type)\n\t  dc = sub;\n\telse if (sub->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE)\n\t  mod_inner = d_left (sub);\n      }\n      /* Fall through.  */\n\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n"
}