{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "\treturn (unary_test (op, \"1\"));",
    "Code_function": "unary_operator ()\n{\n  char *op;\n  intmax_t r;\n\n  op = argv[pos];\n  if (test_unop (op) == 0)\n    return (FALSE);\n\n  /* the only tricky case is `-t', which may or may not take an argument. */\n  if (op[1] == 't')\n    {\n      advance (0);\n      if (pos < argc)\n\t{\n\t  if (legal_number (argv[pos], &r))\n\t    {\n\t      advance (0);\n\t      return (unary_test (op, argv[pos - 1]));\n\t    }\n\t  else\n\t    return (FALSE);\n\t}\n      else\n\treturn (unary_test (op, \"1\"));\n    }\n\n  /* All of the unary operators take an argument, so we first call\n     unary_advance (), which checks to make sure that there is an\n     argument, and then advances pos right past it.  This means that\n     pos - 1 is the location of the argument. */\n  unary_advance ();\n  return (unary_test (op, argv[pos - 1]));\n}"
}