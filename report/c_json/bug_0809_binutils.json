{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "bfd/elf.c",
    "message": "Offset: [max(0, `abfd->tdata.elf_obj_data->o->strtab_ptr->size`), 2+max(0, `abfd->tdata.elf_obj_data->o->strtab_ptr->size`)] Size: [0, +oo] by call to `_bfd_elf_init_reloc_shdr`.",
    "warning_function_name": "elf_fake_sections",
    "warning_line": "&& !_bfd_elf_init_reloc_shdr (abfd, &esd->rela, asect, TRUE))",
    "warning_context": "\t\t    || this_hdr->sh_info == elf_tdata (abfd)->cverdefs);\n      break;\n\n    case SHT_GNU_verneed:\n      this_hdr->sh_entsize = 0;\n      /* objcopy or strip will copy over sh_info, but may not set\n\t cverrefs.  The linker will set cverrefs, but sh_info will be\n\t zero.  */\n      if (this_hdr->sh_info == 0)\n\tthis_hdr->sh_info = elf_tdata (abfd)->cverrefs;\n      else\n\tBFD_ASSERT (elf_tdata (abfd)->cverrefs == 0\n\t\t    || this_hdr->sh_info == elf_tdata (abfd)->cverrefs);\n      break;\n\n    case SHT_GROUP:\n      this_hdr->sh_entsize = GRP_ENTRY_SIZE;\n      break;\n\n    case SHT_GNU_HASH:\n      this_hdr->sh_entsize = bed->s->arch_size == 64 ? 0 : 4;\n      break;\n    }\n\n  if ((asect->flags & SEC_ALLOC) != 0)\n    this_hdr->sh_flags |= SHF_ALLOC;\n  if ((asect->flags & SEC_READONLY) == 0)\n    this_hdr->sh_flags |= SHF_WRITE;\n  if ((asect->flags & SEC_CODE) != 0)\n    this_hdr->sh_flags |= SHF_EXECINSTR;\n  if ((asect->flags & SEC_MERGE) != 0)\n    {\n      this_hdr->sh_flags |= SHF_MERGE;\n      this_hdr->sh_entsize = asect->entsize;\n      if ((asect->flags & SEC_STRINGS) != 0)\n\tthis_hdr->sh_flags |= SHF_STRINGS;\n    }\n  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)\n    this_hdr->sh_flags |= SHF_GROUP;\n  if ((asect->flags & SEC_THREAD_LOCAL) != 0)\n    {\n      this_hdr->sh_flags |= SHF_TLS;\n      if (asect->size == 0\n\t  && (asect->flags & SEC_HAS_CONTENTS) == 0)\n\t{\n\t  struct bfd_link_order *o = asect->map_tail.link_order;\n\n\t  this_hdr->sh_size = 0;\n\t  if (o != NULL)\n\t    {\n\t      this_hdr->sh_size = o->offset + o->size;\n\t      if (this_hdr->sh_size != 0)\n\t\tthis_hdr->sh_type = SHT_NOBITS;\n\t    }\n\t}\n    }\n  if ((asect->flags & (SEC_GROUP | SEC_EXCLUDE)) == SEC_EXCLUDE)\n    this_hdr->sh_flags |= SHF_EXCLUDE;\n\n  /* If the section has relocs, set up a section header for the\n     SHT_REL[A] section.  If two relocation sections are required for\n     this section, it is up to the processor-specific back-end to\n     create the other.  */\n  if ((asect->flags & SEC_RELOC) != 0)\n    {\n      /* When doing a relocatable link, create both REL and RELA sections if\n\t needed.  */\n      if (arg->link_info\n\t  /* Do the normal setup if we wouldn't create any sections here.  */\n\t  && esd->rel.count + esd->rela.count > 0\n\t  && (arg->link_info->relocatable || arg->link_info->emitrelocations))\n\t{\n\t  if (esd->rel.count && esd->rel.hdr == NULL\n\t      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rel, asect, FALSE))\n\t    {\n\t      arg->failed = TRUE;\n\t      return;\n\t    }\n\t  if (esd->rela.count && esd->rela.hdr == NULL\n\t      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rela, asect, TRUE))\n\t    {\n\t      arg->failed = TRUE;\n\t      return;\n\t    }\n\t}\n      else if (!_bfd_elf_init_reloc_shdr (abfd,\n\t\t\t\t\t  (asect->use_rela_p\n\t\t\t\t\t   ? &esd->rela : &esd->rel),\n\t\t\t\t\t  asect,\n\t\t\t\t\t  asect->use_rela_p))\n\t  arg->failed = TRUE;\n    }\n\n  /* Check for processor-specific section types.  */\n  sh_type = this_hdr->sh_type;\n  if (bed->elf_backend_fake_sections\n      && !(*bed->elf_backend_fake_sections) (abfd, this_hdr, asect))\n    arg->failed = TRUE;\n\n  if (sh_type == SHT_NOBITS && asect->size != 0)\n    {\n"
}