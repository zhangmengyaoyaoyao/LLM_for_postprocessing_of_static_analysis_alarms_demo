{
    "project": "combine",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/field.c",
    "message": "The value read from field_list_length was never initialized.",
    "warning_function_name": "find_input_ranges",
    "warning_line": "for (i = 0; i < field_list_length; i++)",
    "warning_context": "    STRINGTYPE *temp_string;\n    STRINGTYPE *other_string;\n\n    if (out_string->length > 0 && output_delimiter != NULL)\n      dstrcat (out_string, output_delimiter);\n    if (input_delimiter != NULL) {\n      if (ranges[i].lower_bound < 0 || ranges[i].lower_bound > field_list_length)\n\tFATAL_ERROR2 (_\n\t\t      (\"bad field substring -- wanted field %ld from %d fields\"),\n\t\t      ranges[i].lower_bound, field_list_length);\n      temp_string = field_list[ranges[i].lower_bound - 1];\n      }\n    else {\n      temp_string\n\t= dstrsubstr (input_record, ranges[i].lower_bound,\n\t\t      ranges[i].upper_bound, 0, DStr_not_own);\n      if (temp_string == NULL) {\n\tif (ranges[i].lower_bound > 0\n\t    || ranges[i].lower_bound > ranges[i].upper_bound\n\t    || ranges[i].upper_bound > input_record->length)\n\t  FATAL_ERROR3 (_\n\t\t\t(\"bad field substring -- wanted bytes %ld-%ld in %ld-byte string\"),\n\t\t\tranges[i].lower_bound, ranges[i].upper_bound,\n\t\t\tinput_record->length);\n\telse\n\t  FATAL_ERROR (_(\"unable to allocate memory\"));\n\t}\n      }\n#ifdef HAVE_LIBGUILE\n    if (ranges[i].format != NULL) {\t/* We have some processing to do. */\n      SCM return_value;\n      STRINGTYPE *result_string;\n      size_t return_length;\n      /* Assuming scheme for now */\n      /* Assemble scheme code */\n      create_scheme_string_variable (&df_name_input_field, 0, temp_string);\n\n      /* Call Guile */\n      result_string = eval_scheme_string_function (ranges[i].format);\n      if (input_delimiter == NULL)\n\tdstrfree (temp_string);\n      temp_string = result_string;\n      }\n#  endif /* HAVE_LIBGUILE */\n    other_string = dstrcat (out_string, temp_string);\n    if (other_string == NULL)\n      FATAL_ERROR (_(\"unable to allocate memory\"));\n    if (input_delimiter == NULL || ranges[i].format != NULL)\n      dstrfree (temp_string);\n    }\n\n  /* Note: we have not given the possibility of changing a record-ending\n   *  key string with scheme extensibility.\n   */\n  if (end_range_start != 0) {\n    STRINGTYPE *temp_string;\n    STRINGTYPE *other_string;\n    if (out_string->length > 0 && output_delimiter != NULL)\n      dstrcat (out_string, output_delimiter);\n    temp_string\n      = dstrsubstr (input_record, end_range_start, input_record->length, 0,\n\t\t    DStr_not_own);\n    if (temp_string == NULL) {\n      if (end_range_start > input_record->length || end_range_start < 0)\n\tFATAL_ERROR3 (_\n\t\t      (\"bad field substring -- wanted bytes %ld-%ld in %ld-byte string\"),\n\t\t      end_range_start, input_record->length,\n\t\t      input_record->length);\n      else\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      }\n    other_string = dstrcat (out_string, temp_string);\n    if (other_string == NULL)\n      FATAL_ERROR (_(\"unable to allocate memory\"));\n    dstrfree (temp_string);\n    }\n\n  if (input_delimiter != NULL) {\n    int i;\n    for (i = 0; i < field_list_length; i++)\n      dstrfree (field_list[i]);\n    free (field_list);\n    }\n\n  return EXIT_SUCCESS;\n  }\n\n/********\n * Create an arrax of field strings from a set of ranges and an\n * optional delimiter.  Generally the same as find_input_ranges above,\n * with a different target.  The additional parameter MAKE_COPY is\n * non-zero to indicate that we need to use the results after\n * INPUT_RECORD has been over-written.  The processing assumes that in\n * delimited files, each field will be referred to only once.  The\n * problem here is that we are handing the pointer off to the array,\n * so we can't just free it in the future.  Perhaps we need to give up\n * that efficiency for flexibility, or mark when the field is used and\n * then copy it in the future.  \n */\nint\na_find_input_ranges (out_ranges, input_record, ranges, range_count,\n"
}