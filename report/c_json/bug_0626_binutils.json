{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "      h = _bfd_elf_define_linkage_sym (abfd, info, s,",
    "Code_function": "_bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n{\n  flagword flags, pltflags;\n  struct elf_link_hash_entry *h;\n  asection *s;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  struct elf_link_hash_table *htab = elf_hash_table (info);\n\n  /* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and\n     .rel[a].bss sections.  */\n  flags = bed->dynamic_sec_flags;\n\n  pltflags = flags;\n  if (bed->plt_not_loaded)\n    /* We do not clear SEC_ALLOC here because we still want the OS to\n       allocate space for the section; it's just that there's nothing\n       to read in from the object file.  */\n    pltflags &= ~ (SEC_CODE | SEC_LOAD | SEC_HAS_CONTENTS);\n  else\n    pltflags |= SEC_ALLOC | SEC_CODE | SEC_LOAD;\n  if (bed->plt_readonly)\n    pltflags |= SEC_READONLY;\n\n  s = bfd_make_section_anyway_with_flags (abfd, \".plt\", pltflags);\n  if (s == NULL\n      || ! bfd_set_section_alignment (abfd, s, bed->plt_alignment))\n    return FALSE;\n  htab->splt = s;\n\n  /* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the\n     .plt section.  */\n  if (bed->want_plt_sym)\n    {\n      h = _bfd_elf_define_linkage_sym (abfd, info, s,\n\t\t\t\t       \"_PROCEDURE_LINKAGE_TABLE_\");\n      elf_hash_table (info)->hplt = h;\n      if (h == NULL)\n\treturn FALSE;\n    }\n\n  s = bfd_make_section_anyway_with_flags (abfd,\n\t\t\t\t\t  (bed->rela_plts_and_copies_p\n\t\t\t\t\t   ? \".rela.plt\" : \".rel.plt\"),\n\t\t\t\t\t  flags | SEC_READONLY);\n  if (s == NULL\n      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n    return FALSE;\n  htab->srelplt = s;\n\n  if (! _bfd_elf_create_got_section (abfd, info))\n    return FALSE;\n\n  if (bed->want_dynbss)\n    {\n      /* The .dynbss section is a place to put symbols which are defined\n\t by dynamic objects, are referenced by regular objects, and are\n\t not functions.  We must allocate space for them in the process\n\t image and use a R_*_COPY reloc to tell the dynamic linker to\n\t initialize them at run time.  The linker script puts the .dynbss\n\t section into the .bss section of the final image.  */\n      s = bfd_make_section_anyway_with_flags (abfd, \".dynbss\",\n\t\t\t\t\t      (SEC_ALLOC | SEC_LINKER_CREATED));\n      if (s == NULL)\n\treturn FALSE;\n\n      /* The .rel[a].bss section holds copy relocs.  This section is not\n\t normally needed.  We need to create it here, though, so that the\n\t linker will map it to an output section.  We can't just create it\n\t only if we need it, because we will not know whether we need it\n\t until we have seen all the input files, and the first time the\n\t main linker code calls BFD after examining all the input files\n\t (size_dynamic_sections) the input sections have already been\n\t mapped to the output sections.  If the section turns out not to\n\t be needed, we can discard it later.  We will never need this\n\t section when generating a shared object, since they do not use\n\t copy relocs.  */\n      if (! info->shared)\n\t{\n\t  s = bfd_make_section_anyway_with_flags (abfd,\n\t\t\t\t\t\t  (bed->rela_plts_and_copies_p\n\t\t\t\t\t\t   ? \".rela.bss\" : \".rel.bss\"),\n\t\t\t\t\t\t  flags | SEC_READONLY);\n\t  if (s == NULL\n\t      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))\n\t    return FALSE;\n\t}\n    }\n\n  return TRUE;\n}"
}