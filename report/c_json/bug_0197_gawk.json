{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset: [-oo, 9998] Size: 200.",
    "Code_line": "  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;",
    "Code_function": "yyparse (void)\n{\n    int yystate;\n    /* Number of tokens to shift before error messages enabled.  */\n    int yyerrstatus;\n\n    /* The stacks and their tools:\n       'yyss': related to states.\n       'yyvs': related to semantic values.\n\n       Refer to the stacks through separate pointers, to allow yyoverflow\n       to reallocate them elsewhere.  */\n\n    /* The state stack.  */\n    yytype_int16 yyssa[YYINITDEPTH];\n    yytype_int16 *yyss;\n    yytype_int16 *yyssp;\n\n    /* The semantic value stack.  */\n    YYSTYPE yyvsa[YYINITDEPTH];\n    YYSTYPE *yyvs;\n    YYSTYPE *yyvsp;\n\n    YYSIZE_T yystacksize;\n\n  int yyn;\n  int yyresult;\n  /* Lookahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  yyssp = yyss = yyssa;\n  yyvsp = yyvs = yyvsa;\n  yystacksize = YYINITDEPTH;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY; /* Cause a token to be read.  */\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n        /* Give user a chance to reallocate the stack.  Use copies of\n           these so that the &'s don't force the real ones into\n           memory.  */\n        YYSTYPE *yyvs1 = yyvs;\n        yytype_int16 *yyss1 = yyss;\n\n        /* Each stack pointer address is followed by the size of the\n           data in use in that stack, in bytes.  This used to be a\n           conditional around just the two extra args, but that might\n           be undefined if yyoverflow is a macro.  */\n        yyoverflow (YY_(\"memory exhausted\"),\n                    &yyss1, yysize * sizeof (*yyssp),\n                    &yyvs1, yysize * sizeof (*yyvsp),\n                    &yystacksize);\n\n        yyss = yyss1;\n        yyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n        goto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n        yystacksize = YYMAXDEPTH;\n\n      {\n        yytype_int16 *yyss1 = yyss;\n        union yyalloc *yyptr =\n          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n        if (! yyptr)\n          goto yyexhaustedlab;\n        YYSTACK_RELOCATE (yyss_alloc, yyss);\n        YYSTACK_RELOCATE (yyvs_alloc, yyvs);\n#  undef YYSTACK_RELOCATE\n        if (yyss1 != yyssa)\n          YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n                  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n        YYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  if (yystate == YYFINAL)\n    YYACCEPT;\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     lookahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to lookahead token.  */\n  yyn = yypact[yystate];\n  if (yypact_value_is_default (yyn))\n    goto yydefault;\n\n  /* Not known => get a lookahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = yylex ();\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yytable_value_is_error (yyn))\n        goto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the lookahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token.  */\n  yychar = YYEMPTY;\n\n  yystate = yyn;\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  *++yyvsp = yylval;\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     '$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 3:\n#line 197 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\trule = 0;\n\t\tyyerrok;\n\t  }\n#line 1847 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 5:\n#line 203 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tnext_sourcefile();\n\t  }\n#line 1855 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 6:\n#line 207 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\trule = 0;\n\t\t/*\n\t\t * If errors, give up, don't produce an infinite\n\t\t * stream of syntax error messages.\n\t\t */\n  \t\t/* yyerrok; */\n\t  }\n#line 1868 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 7:\n#line 219 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(void) append_rule((yyvsp[-1]), (yyvsp[0]));\n\t  }\n#line 1876 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 8:\n#line 223 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (rule != Rule) {\n\t\t\tmsg(_(\"%s blocks must have an action part\"), ruletab[rule]);\n\t\t\terrcount++;\n\t\t} else if ((yyvsp[-1]) == NULL) {\n\t\t\tmsg(_(\"each rule must have a pattern or an action part\"));\n\t\t\terrcount++;\n\t\t} else\t\t/* pattern rule with non-empty pattern */\n\t\t\t(void) append_rule((yyvsp[-1]), NULL);\n\t  }\n#line 1891 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 9:\n#line 234 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tin_function = NULL;\n\t\t(void) mk_function((yyvsp[-1]), (yyvsp[0]));\n\t\tyyerrok;\n\t  }\n#line 1901 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 10:\n#line 240 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\twant_source = false;\n\t\tat_seen = false;\n\t\tyyerrok;\n\t  }\n#line 1911 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 11:\n#line 246 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\twant_source = false;\n\t\tat_seen = false;\n\t\tyyerrok;\n\t  }\n#line 1921 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 12:\n#line 255 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (include_source((yyvsp[0])) < 0)\n\t\t\tYYABORT;\n\t\tefree((yyvsp[0])->lextok);\n\t\tbcfree((yyvsp[0]));\n\t\t(yyval) = NULL;\n\t  }\n#line 1933 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 13:\n#line 263 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1939 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 14:\n#line 265 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1945 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 15:\n#line 270 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (load_library((yyvsp[0])) < 0)\n\t\t\tYYABORT;\n\t\tefree((yyvsp[0])->lextok);\n\t\tbcfree((yyvsp[0]));\n\t\t(yyval) = NULL;\n\t  }\n#line 1957 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 16:\n#line 278 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1963 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 17:\n#line 280 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 1969 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 18:\n#line 285 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = NULL; rule = Rule; }\n#line 1975 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 19:\n#line 287 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = (yyvsp[0]); rule = Rule; }\n#line 1981 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 20:\n#line 289 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *tp;\n\n\t\tadd_lint((yyvsp[-3]), LINT_assign_in_cond);\n\t\tadd_lint((yyvsp[0]), LINT_assign_in_cond);\n\n\t\ttp = instruction(Op_no_op);\n\t\tlist_prepend((yyvsp[-3]), bcalloc(Op_line_range, !!do_pretty_print + 1, 0));\n\t\t(yyvsp[-3])->nexti->triggered = false;\n\t\t(yyvsp[-3])->nexti->target_jmp = (yyvsp[0])->nexti;\n\n\t\tlist_append((yyvsp[-3]), instruction(Op_cond_pair));\n\t\t(yyvsp[-3])->lasti->line_range = (yyvsp[-3])->nexti;\n\t\t(yyvsp[-3])->lasti->target_jmp = tp;\n\n\t\tlist_append((yyvsp[0]), instruction(Op_cond_pair));\n\t\t(yyvsp[0])->lasti->line_range = (yyvsp[-3])->nexti;\n\t\t(yyvsp[0])->lasti->target_jmp = tp;\n\t\tif (do_pretty_print) {\n\t\t\t((yyvsp[-3])->nexti + 1)->condpair_left = (yyvsp[-3])->lasti;\n\t\t\t((yyvsp[-3])->nexti + 1)->condpair_right = (yyvsp[0])->lasti;\n\t\t}\n\t\t(yyval) = list_append(list_merge((yyvsp[-3]), (yyvsp[0])), tp);\n\t\trule = Rule;\n\t  }\n#line 2011 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 21:\n#line 315 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic int begin_seen = 0;\n\t\tif (do_lint_old && ++begin_seen == 2)\n\t\t\twarning_ln((yyvsp[0])->source_line,\n\t\t\t\t_(\"old awk does not support multiple `BEGIN' or `END' rules\"));\n\n\t\t(yyvsp[0])->in_rule = rule = BEGIN;\n\t\t(yyvsp[0])->source_file = source;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2026 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 22:\n#line 326 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic int end_seen = 0;\n\t\tif (do_lint_old && ++end_seen == 2)\n\t\t\twarning_ln((yyvsp[0])->source_line,\n\t\t\t\t_(\"old awk does not support multiple `BEGIN' or `END' rules\"));\n\n\t\t(yyvsp[0])->in_rule = rule = END;\n\t\t(yyvsp[0])->source_file = source;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2041 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 23:\n#line 337 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->in_rule = rule = BEGINFILE;\n\t\t(yyvsp[0])->source_file = source;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2051 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 24:\n#line 343 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->in_rule = rule = ENDFILE;\n\t\t(yyvsp[0])->source_file = source;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2061 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 25:\n#line 352 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-3]) == NULL)\n\t\t\t(yyval) = list_create(instruction(Op_no_op));\n\t\telse\n\t\t\t(yyval) = (yyvsp[-3]);\n\t  }\n#line 2072 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 26:\n#line 362 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2078 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 27:\n#line 364 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2084 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 28:\n#line 366 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tyyerror(_(\"`%s' is a built-in function, it cannot be redefined\"),\n\t\t\t\t\ttokstart);\n\t\tYYABORT;\n\t  }\n#line 2094 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 29:\n#line 372 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = (yyvsp[0]);\n\t\tat_seen = false;\n\t  }\n#line 2103 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 32:\n#line 385 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[-5])->source_file = source;\n\t\tif (install_function((yyvsp[-4])->lextok, (yyvsp[-5]), (yyvsp[-2])) < 0)\n\t\t\tYYABORT;\n\t\tin_function = (yyvsp[-4])->lextok;\n\t\t(yyvsp[-4])->lextok = NULL;\n\t\tbcfree((yyvsp[-4]));\n\t\t/* $4 already free'd in install_function */\n\t\t(yyval) = (yyvsp[-5]);\n\t  }\n#line 2118 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 33:\n#line 403 \"awkgram.y\" /* yacc.c:1646  */\n    { want_regexp = true; }\n#line 2124 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 34:\n#line 405 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t  NODE *n, *exp;\n\t\t  char *re;\n\t\t  size_t len;\n\n\t\t  re = (yyvsp[0])->lextok;\n\t\t  (yyvsp[0])->lextok = NULL;\n\t\t  len = strlen(re);\n\t\t  if (do_lint) {\n\t\t\tif (len == 0)\n\t\t\t\tlintwarn_ln((yyvsp[0])->source_line,\n\t\t\t\t\t_(\"regexp constant `//' looks like a C++ comment, but is not\"));\n\t\t\telse if (re[0] == '*' && re[len-1] == '*')\n\t\t\t\t/* possible C comment */\n\t\t\t\tlintwarn_ln((yyvsp[0])->source_line,\n\t\t\t\t\t_(\"regexp constant `/%s/' looks like a C comment, but is not\"), re);\n\t\t  }\n\n\t\t  exp = make_str_node(re, len, ALREADY_MALLOCED);\n\t\t  n = make_regnode(Node_regex, exp);\n\t\t  if (n == NULL) {\n\t\t\tunref(exp);\n\t\t\tYYABORT;\n\t\t  }\n\t\t  (yyval) = (yyvsp[0]);\n\t\t  (yyval)->opcode = Op_match_rec;\n\t\t  (yyval)->memory = n;\n\t\t}\n#line 2157 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 35:\n#line 437 \"awkgram.y\" /* yacc.c:1646  */\n    { bcfree((yyvsp[0])); }\n#line 2163 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 37:\n#line 443 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = NULL; }\n#line 2169 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 38:\n#line 445 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0]) == NULL)\n\t\t\t(yyval) = (yyvsp[-1]);\n\t\telse {\n\t\t\tadd_lint((yyvsp[0]), LINT_no_effect);\n\t\t\tif ((yyvsp[-1]) == NULL)\n\t\t\t\t(yyval) = (yyvsp[0]);\n\t\t\telse\n\t\t\t\t(yyval) = list_merge((yyvsp[-1]), (yyvsp[0]));\n\t\t}\n\t    yyerrok;\n\t  }\n#line 2186 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 39:\n#line 458 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = NULL; }\n#line 2192 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 42:\n#line 468 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2198 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 43:\n#line 470 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[-1]); }\n#line 2204 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 44:\n#line 472 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_pretty_print)\n\t\t\t(yyval) = list_prepend((yyvsp[0]), instruction(Op_exec_count));\n\t\telse\n\t\t\t(yyval) = (yyvsp[0]);\n \t  }\n#line 2215 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 45:\n#line 479 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *dflt, *curr = NULL, *cexp, *cstmt;\n\t\tINSTRUCTION *ip, *nextc, *tbreak;\n\t\tconst char **case_values = NULL;\n\t\tint maxcount = 128;\n\t\tint case_count = 0;\n\t\tint i;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\tcstmt = list_create(tbreak);\n\t\tcexp = list_create(instruction(Op_pop));\n\t\tdflt = instruction(Op_jmp);\n\t\tdflt->target_jmp = tbreak;\t/* if no case match and no explicit default */\n\n\t\tif ((yyvsp[-2]) != NULL) {\n\t\t\tcurr = (yyvsp[-2])->nexti;\n\t\t\tbcfree((yyvsp[-2]));\t/* Op_list */\n\t\t} /*  else\n\t\t\t\tcurr = NULL; */\n\n\t\tfor(; curr != NULL; curr = nextc) {\n\t\t\tINSTRUCTION *caseexp = curr->case_exp;\n\t\t\tINSTRUCTION *casestmt = curr->case_stmt;\n\n\t\t\tnextc = curr->nexti;\n\t\t\tif (curr->opcode == Op_K_case) {\n\t\t\t\tif (caseexp->opcode == Op_push_i) {\n\t\t\t\t\t/* a constant scalar */\n\t\t\t\t\tchar *caseval;\n\t\t\t\t\tcaseval = force_string(caseexp->memory)->stptr;\n\t\t\t\t\tfor (i = 0; i < case_count; i++) {\n\t\t\t\t\t\tif (strcmp(caseval, case_values[i]) == 0)\n\t\t\t\t\t\t\terror_ln(curr->source_line,\n\t\t\t\t\t\t\t\t_(\"duplicate case values in switch body: %s\"), caseval);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (case_values == NULL)\n\t\t\t\t\t\temalloc(case_values, const char **, sizeof(char *) * maxcount, \"statement\");\n\t\t\t\t\telse if (case_count >= maxcount) {\n\t\t\t\t\t\tmaxcount += 128;\n\t\t\t\t\t\terealloc(case_values, const char **, sizeof(char*) * maxcount, \"statement\");\n\t\t\t\t\t}\n\t\t\t\t\tcase_values[case_count++] = caseval;\n\t\t\t\t} else {\n\t\t\t\t\t/* match a constant regex against switch expression. */\n\t\t\t\t\t(curr + 1)->match_exp = true;\n\t\t\t\t}\n\t\t\t\tcurr->stmt_start = casestmt->nexti;\n\t\t\t\tcurr->stmt_end\t= casestmt->lasti;\n\t\t\t\t(void) list_prepend(cexp, curr);\n\t\t\t\t(void) list_prepend(cexp, caseexp);\n\t\t\t} else {\n\t\t\t\tif (dflt->target_jmp != tbreak)\n\t\t\t\t\terror_ln(curr->source_line,\n\t\t\t\t\t\t_(\"duplicate `default' detected in switch body\"));\n\t\t\t\telse\n\t\t\t\t\tdflt->target_jmp = casestmt->nexti;\n\n\t\t\t\tif (do_pretty_print) {\n\t\t\t\t\tcurr->stmt_start = casestmt->nexti;\n\t\t\t\t\tcurr->stmt_end = casestmt->lasti;\n\t\t\t\t\t(void) list_prepend(cexp, curr);\n\t\t\t\t} else\n\t\t\t\t\tbcfree(curr);\n\t\t\t}\n\n\t\t\tcstmt = list_merge(casestmt, cstmt);\n\t\t}\n\n\t\tif (case_values != NULL)\n\t\t\tefree(case_values);\n\n\t\tip = (yyvsp[-6]);\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_prepend(ip, (yyvsp[-8]));\n\t\t\t(void) list_prepend(ip, instruction(Op_exec_count));\n\t\t\t(yyvsp[-8])->target_break = tbreak;\n\t\t\t((yyvsp[-8]) + 1)->switch_start = cexp->nexti;\n\t\t\t((yyvsp[-8]) + 1)->switch_end = cexp->lasti;\n\t\t}/* else\n\t\t\t\t$1 is NULL */\n\n\t\t(void) list_append(cexp, dflt);\n\t\t(void) list_merge(ip, cexp);\n\t\t(yyval) = list_merge(ip, cstmt);\n\n\t\tbreak_allowed--;\n\t\tfix_break_continue(ip, tbreak, NULL);\n\t  }\n#line 2309 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 46:\n#line 569 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t *    -----------------\n\t\t * tc:\n\t\t *         cond\n\t\t *    -----------------\n\t\t *    [Op_jmp_false tb   ]\n\t\t *    -----------------\n\t\t *         body\n\t\t *    -----------------\n\t\t *    [Op_jmp      tc    ]\n\t\t * tb:[Op_no_op          ]\n\t\t */\n\n\t\tINSTRUCTION *ip, *tbreak, *tcont;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\tadd_lint((yyvsp[-3]), LINT_assign_in_cond);\n\t\ttcont = (yyvsp[-3])->nexti;\n\t\tip = list_append((yyvsp[-3]), instruction(Op_jmp_false));\n\t\tip->lasti->target_jmp = tbreak;\n\n\t\tif (do_pretty_print) {\n\t\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t\t(yyvsp[-5])->target_break = tbreak;\n\t\t\t(yyvsp[-5])->target_continue = tcont;\n\t\t\t((yyvsp[-5]) + 1)->while_body = ip->lasti;\n\t\t\t(void) list_prepend(ip, (yyvsp[-5]));\n\t\t}/* else\n\t\t\t\t$1 is NULL */\n\n\t\tif ((yyvsp[0]) != NULL)\n\t\t\t(void) list_merge(ip, (yyvsp[0]));\n\t\t(void) list_append(ip, instruction(Op_jmp));\n\t\tip->lasti->target_jmp = tcont;\n\t\t(yyval) = list_append(ip, tbreak);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t\tfix_break_continue(ip, tbreak, tcont);\n\t  }\n#line 2355 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 47:\n#line 611 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t *    -----------------\n\t\t * z:\n\t\t *         body\n\t\t *    -----------------\n\t\t * tc:\n\t\t *         cond\n\t\t *    -----------------\n\t\t *    [Op_jmp_true | z  ]\n\t\t * tb:[Op_no_op         ]\n\t\t */\n\n\t\tINSTRUCTION *ip, *tbreak, *tcont;\n\n\t\ttbreak = instruction(Op_no_op);\n\t\ttcont = (yyvsp[-2])->nexti;\n\t\tadd_lint((yyvsp[-2]), LINT_assign_in_cond);\n\t\tif ((yyvsp[-5]) != NULL)\n\t\t\tip = list_merge((yyvsp[-5]), (yyvsp[-2]));\n\t\telse\n\t\t\tip = list_prepend((yyvsp[-2]), instruction(Op_no_op));\n\t\tif (do_pretty_print)\n\t\t\t(void) list_prepend(ip, instruction(Op_exec_count));\n\t\t(void) list_append(ip, instruction(Op_jmp_true));\n\t\tip->lasti->target_jmp = ip->nexti;\n\t\t(yyval) = list_append(ip, tbreak);\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t\tfix_break_continue(ip, tbreak, tcont);\n\n\t\tif (do_pretty_print) {\n\t\t\t(yyvsp[-7])->target_break = tbreak;\n\t\t\t(yyvsp[-7])->target_continue = tcont;\n\t\t\t((yyvsp[-7]) + 1)->doloop_cond = tcont;\n\t\t\t(yyval) = list_prepend(ip, (yyvsp[-7]));\n\t\t\tbcfree((yyvsp[-4]));\n\t\t} /* else\n\t\t\t$1 and $4 are NULLs */\n\t  }\n#line 2401 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 48:\n#line 653 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tINSTRUCTION *ip;\n\t\tchar *var_name = (yyvsp[-5])->lextok;\n\n\t\tif ((yyvsp[0]) != NULL\n\t\t\t\t&& (yyvsp[0])->lasti->opcode == Op_K_delete\n\t\t\t\t&& (yyvsp[0])->lasti->expr_count == 1\n\t\t\t\t&& (yyvsp[0])->nexti->opcode == Op_push\n\t\t\t\t&& ((yyvsp[0])->nexti->memory->type != Node_var || !((yyvsp[0])->nexti->memory->var_update))\n\t\t\t\t&& strcmp((yyvsp[0])->nexti->memory->vname, var_name) == 0\n\t\t) {\n\n\t\t/* Efficiency hack.  Recognize the special case of\n\t\t *\n\t\t * \tfor (iggy in foo)\n\t\t * \t\tdelete foo[iggy]\n\t\t *\n\t\t * and treat it as if it were\n\t\t *\n\t\t * \tdelete foo\n\t\t *\n\t\t * Check that the body is a `delete a[i]' statement,\n\t\t * and that both the loop var and array names match.\n\t\t */\n\t\t\tNODE *arr = NULL;\n\n\t\t\tip = (yyvsp[0])->nexti->nexti;\n\t\t\tif ((yyvsp[-3])->nexti->opcode == Op_push && (yyvsp[-3])->lasti == (yyvsp[-3])->nexti)\n\t\t\t\tarr = (yyvsp[-3])->nexti->memory;\n\t\t\tif (arr != NULL\n\t\t\t\t\t&& ip->opcode == Op_no_op\n\t\t\t\t\t&& ip->nexti->opcode == Op_push_array\n\t\t\t\t\t&& strcmp(ip->nexti->memory->vname, arr->vname) == 0\n\t\t\t\t\t&& ip->nexti->nexti == (yyvsp[0])->lasti\n\t\t\t) {\n\t\t\t\t(void) make_assignable((yyvsp[0])->nexti);\n\t\t\t\t(yyvsp[0])->lasti->opcode = Op_K_delete_loop;\n\t\t\t\t(yyvsp[0])->lasti->expr_count = 0;\n\t\t\t\tif ((yyvsp[-7]) != NULL)\n\t\t\t\t\tbcfree((yyvsp[-7]));\n\t\t\t\tefree(var_name);\n\t\t\t\tbcfree((yyvsp[-5]));\n\t\t\t\tbcfree((yyvsp[-4]));\n\t\t\t\tbcfree((yyvsp[-3]));\n\t\t\t\t(yyval) = (yyvsp[0]);\n\t\t\t} else\n\t\t\t\tgoto regular_loop;\n\t\t} else {\n\t\t\tINSTRUCTION *tbreak, *tcont;\n\n\t\t\t/*    [ Op_push_array a       ]\n\t\t\t *    [ Op_arrayfor_init | ib ]\n\t\t\t * ic:[ Op_arrayfor_incr | ib ]\n\t\t\t *    [ Op_var_assign if any  ]\n\t\t\t *\n\t\t\t *              body\n\t\t\t *\n\t\t\t *    [Op_jmp | ic            ]\n\t\t\t * ib:[Op_arrayfor_final      ]\n\t\t\t */\nregular_loop:\n\t\t\tip = (yyvsp[-3]);\n\t\t\tip->nexti->opcode = Op_push_array;\n\n\t\t\ttbreak = instruction(Op_arrayfor_final);\n\t\t\t(yyvsp[-4])->opcode = Op_arrayfor_incr;\n\t\t\t(yyvsp[-4])->array_var = variable((yyvsp[-5])->source_line, var_name, Node_var);\n\t\t\t(yyvsp[-4])->target_jmp = tbreak;\n\t\t\ttcont = (yyvsp[-4]);\n\t\t\t(yyvsp[-5])->opcode = Op_arrayfor_init;\n\t\t\t(yyvsp[-5])->target_jmp = tbreak;\n\t\t\t(void) list_append(ip, (yyvsp[-5]));\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(yyvsp[-7])->opcode = Op_K_arrayfor;\n\t\t\t\t(yyvsp[-7])->target_continue = tcont;\n\t\t\t\t(yyvsp[-7])->target_break = tbreak;\n\t\t\t\t(void) list_append(ip, (yyvsp[-7]));\n\t\t\t} /* else\n\t\t\t\t\t$1 is NULL */\n\n\t\t\t/* add update_FOO instruction if necessary */\n\t\t\tif ((yyvsp[-4])->array_var->type == Node_var && (yyvsp[-4])->array_var->var_update) {\n\t\t\t\t(void) list_append(ip, instruction(Op_var_update));\n\t\t\t\tip->lasti->update_var = (yyvsp[-4])->array_var->var_update;\n\t\t\t}\n\t\t\t(void) list_append(ip, (yyvsp[-4]));\n\n\t\t\t/* add set_FOO instruction if necessary */\n\t\t\tif ((yyvsp[-4])->array_var->type == Node_var && (yyvsp[-4])->array_var->var_assign) {\n\t\t\t\t(void) list_append(ip, instruction(Op_var_assign));\n\t\t\t\tip->lasti->assign_var = (yyvsp[-4])->array_var->var_assign;\n\t\t\t}\n\n\t\t\tif (do_pretty_print) {\n\t\t\t\t(void) list_append(ip, instruction(Op_exec_count));\n\t\t\t\t((yyvsp[-7]) + 1)->forloop_cond = (yyvsp[-4]);\n\t\t\t\t((yyvsp[-7]) + 1)->forloop_body = ip->lasti;\n\t\t\t}\n\n\t\t\tif ((yyvsp[0]) != NULL)\n\t\t\t\t(void) list_merge(ip, (yyvsp[0]));\n\n\t\t\t(void) list_append(ip, instruction(Op_jmp));\n\t\t\tip->lasti->target_jmp = (yyvsp[-4]);\n\t\t\t(yyval) = list_append(ip, tbreak);\n\t\t\tfix_break_continue(ip, tbreak, tcont);\n\t\t}\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }\n#line 2518 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 49:\n#line 766 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_for_loop((yyvsp[-11]), (yyvsp[-9]), (yyvsp[-6]), (yyvsp[-3]), (yyvsp[0]));\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }\n#line 2529 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 50:\n#line 773 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t(yyval) = mk_for_loop((yyvsp[-10]), (yyvsp[-8]), (INSTRUCTION *) NULL, (yyvsp[-3]), (yyvsp[0]));\n\n\t\tbreak_allowed--;\n\t\tcontinue_allowed--;\n\t  }\n#line 2540 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 51:\n#line 780 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (do_pretty_print)\n\t\t\t(yyval) = list_prepend((yyvsp[0]), instruction(Op_exec_count));\n\t\telse\n\t\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2551 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 52:\n#line 790 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (! break_allowed)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`break' is not allowed outside a loop or switch\"));\n\t\t(yyvsp[-1])->target_jmp = NULL;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\n\t  }\n#line 2564 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 53:\n#line 799 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (! continue_allowed)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`continue' is not allowed outside a loop\"));\n\t\t(yyvsp[-1])->target_jmp = NULL;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\n\t  }\n#line 2577 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 54:\n#line 808 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* if inside function (rule = 0), resolve context at run-time */\n\t\tif (rule && rule != Rule)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`next' used in %s action\"), ruletab[rule]);\n\t\t(yyvsp[-1])->target_jmp = ip_rec;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\t  }\n#line 2590 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 55:\n#line 817 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* if inside function (rule = 0), resolve context at run-time */\n\t\tif (rule == BEGIN || rule == END || rule == ENDFILE)\n\t\t\terror_ln((yyvsp[-1])->source_line,\n\t\t\t\t_(\"`nextfile' used in %s action\"), ruletab[rule]);\n\n\t\t(yyvsp[-1])->target_newfile = ip_newfile;\n\t\t(yyvsp[-1])->target_endfile = ip_endfile;\n\t\t(yyval) = list_create((yyvsp[-1]));\n\t  }\n#line 2605 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 56:\n#line 828 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/* Initialize the two possible jump targets, the actual target\n\t\t * is resolved at run-time.\n\t\t */\n\t\t(yyvsp[-2])->target_end = ip_end;\t/* first instruction in end_block */\n\t\t(yyvsp[-2])->target_atexit = ip_atexit;\t/* cleanup and go home */\n\n\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t(yyval) = list_create((yyvsp[-2]));\n\t\t\t(void) list_prepend((yyval), instruction(Op_push_i));\n\t\t\t(yyval)->nexti->memory = dupnode(Nnull_string);\n\t\t} else\n\t\t\t(yyval) = list_append((yyvsp[-1]), (yyvsp[-2]));\n\t  }\n#line 2624 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 57:\n#line 843 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif (! in_function)\n\t\t\tyyerror(_(\"`return' used outside function context\"));\n\t  }\n#line 2633 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 58:\n#line 846 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t\t(void) list_prepend((yyval), instruction(Op_push_i));\n\t\t\t(yyval)->nexti->memory = dupnode(Nnull_string);\n\t\t} else {\n\t\t\tif (do_optimize\n\t\t\t\t&& (yyvsp[-1])->lasti->opcode == Op_func_call\n\t\t\t\t&& strcmp((yyvsp[-1])->lasti->func_name, in_function) == 0\n\t\t\t) {\n\t\t\t\t/* Do tail recursion optimization. Tail\n\t\t\t\t * call without a return value is recognized\n\t\t\t\t * in mk_function().\n\t\t\t\t */\n\t\t\t\t((yyvsp[-1])->lasti + 1)->tail_call = true;\n\t\t\t}\n\n\t\t\t(yyval) = list_append((yyvsp[-1]), (yyvsp[-3]));\n\t\t}\n\t  }\n#line 2658 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 60:\n#line 878 \"awkgram.y\" /* yacc.c:1646  */\n    { in_print = true; in_parens = 0; }\n#line 2664 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 61:\n#line 879 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\t/*\n\t\t * Optimization: plain `print' has no expression list, so $3 is null.\n\t\t * If $3 is NULL or is a bytecode list for $0 use Op_K_print_rec,\n\t\t * which is faster for these two cases.\n\t\t */\n\n\t\tif ((yyvsp[-3])->opcode == Op_K_print &&\n\t\t\t((yyvsp[-1]) == NULL\n\t\t\t\t|| ((yyvsp[-1])->lasti->opcode == Op_field_spec\n\t\t\t\t\t&& (yyvsp[-1])->nexti->nexti->nexti == (yyvsp[-1])->lasti\n\t\t\t\t\t&& (yyvsp[-1])->nexti->nexti->opcode == Op_push_i\n\t\t\t\t\t&& (yyvsp[-1])->nexti->nexti->memory->type == Node_val)\n\t\t\t)\n\t\t) {\n\t\t\tstatic bool warned = false;\n\t\t\t/*   -----------------\n\t\t\t *      output_redir\n\t\t\t *    [ redirect exp ]\n\t\t\t *   -----------------\n\t\t\t *     expression_list\n\t\t\t *   ------------------\n\t\t\t *    [Op_K_print_rec | NULL | redir_type | expr_count]\n\t\t\t */\n\n\t\t\tif ((yyvsp[-1]) != NULL) {\n\t\t\t\tNODE *n = (yyvsp[-1])->nexti->nexti->memory;\n\n\t\t\t\tif (! iszero(n))\n\t\t\t\t\tgoto regular_print;\n\n\t\t\t\tbcfree((yyvsp[-1])->lasti);\t\t\t/* Op_field_spec */\n\t\t\t\tunref(n);\t\t\t\t/* Node_val */\n\t\t\t\tbcfree((yyvsp[-1])->nexti->nexti);\t\t/* Op_push_i */\n\t\t\t\tbcfree((yyvsp[-1])->nexti);\t\t\t/* Op_list */\n\t\t\t\tbcfree((yyvsp[-1]));\t\t\t\t/* Op_list */\n\t\t\t} else {\n\t\t\t\tif (do_lint && (rule == BEGIN || rule == END) && ! warned) {\n\t\t\t\t\twarned = true;\n\t\t\t\t\tlintwarn_ln((yyvsp[-3])->source_line,\n\t\t_(\"plain `print' in BEGIN or END rule should probably be `print \\\"\\\"'\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t(yyvsp[-3])->opcode = Op_K_print_rec;\n\t\t\tif ((yyvsp[0]) == NULL) {    /* no redircetion */\n\t\t\t\t(yyvsp[-3])->redir_type = redirect_none;\n\t\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t\t} else {\n\t\t\t\tINSTRUCTION *ip;\n\t\t\t\tip = (yyvsp[0])->nexti;\n\t\t\t\t(yyvsp[-3])->redir_type = ip->redir_type;\n\t\t\t\t(yyvsp[0])->nexti = ip->nexti;\n\t\t\t\tbcfree(ip);\n\t\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-3]));\n\t\t\t}\n\t\t} else {\n\t\t\t/*   -----------------\n\t\t\t *    [ output_redir    ]\n\t\t\t *    [ redirect exp    ]\n\t\t\t *   -----------------\n\t\t\t *    [ expression_list ]\n\t\t\t *   ------------------\n\t\t\t *    [$1 | NULL | redir_type | expr_count]\n\t\t\t *\n\t\t\t */\nregular_print:\n\t\t\tif ((yyvsp[0]) == NULL) {\t\t/* no redirection */\n\t\t\t\tif ((yyvsp[-1]) == NULL)\t{\t/* printf without arg */\n\t\t\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t\t\t(yyvsp[-3])->redir_type = redirect_none;\n\t\t\t\t\t(yyval) = list_create((yyvsp[-3]));\n\t\t\t\t} else {\n\t\t\t\t\tINSTRUCTION *t = (yyvsp[-1]);\n\t\t\t\t\t(yyvsp[-3])->expr_count = count_expressions(&t, false);\n\t\t\t\t\t(yyvsp[-3])->redir_type = redirect_none;\n\t\t\t\t\t(yyval) = list_append(t, (yyvsp[-3]));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tINSTRUCTION *ip;\n\t\t\t\tip = (yyvsp[0])->nexti;\n\t\t\t\t(yyvsp[-3])->redir_type = ip->redir_type;\n\t\t\t\t(yyvsp[0])->nexti = ip->nexti;\n\t\t\t\tbcfree(ip);\n\t\t\t\tif ((yyvsp[-1]) == NULL) {\n\t\t\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t\t\t(yyval) = list_append((yyvsp[0]), (yyvsp[-3]));\n\t\t\t\t} else {\n\t\t\t\t\tINSTRUCTION *t = (yyvsp[-1]);\n\t\t\t\t\t(yyvsp[-3])->expr_count = count_expressions(&t, false);\n\t\t\t\t\t(yyval) = list_append(list_merge((yyvsp[0]), t), (yyvsp[-3]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t  }\n#line 2765 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 62:\n#line 976 \"awkgram.y\" /* yacc.c:1646  */\n    { sub_counter = 0; }\n#line 2771 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 63:\n#line 977 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tchar *arr = (yyvsp[-2])->lextok;\n\n\t\t(yyvsp[-2])->opcode = Op_push_array;\n\t\t(yyvsp[-2])->memory = variable((yyvsp[-2])->source_line, arr, Node_var_new);\n\n\t\tif (! do_posix && ! do_traditional) {\n\t\t\tif ((yyvsp[-2])->memory == symbol_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with SYMTAB\"));\n\t\t\telse if ((yyvsp[-2])->memory == func_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with FUNCTAB\"));\n\t\t}\n\n\t\tif ((yyvsp[0]) == NULL) {\n\t\t\t/*\n\t\t\t * As of September 2012, POSIX has added support\n\t\t\t * for `delete array'. See:\n\t\t\t * http://austingroupbugs.net/view.php?id=544\n\t\t\t *\n\t\t\t * Thanks to Nathan Weeks for the initiative.\n\t\t\t *\n\t\t\t * Thus we no longer warn or check do_posix.\n\t\t\t * Also, since BWK awk supports it, we don't have to\n\t\t\t * check do_traditional either.\n\t\t\t */\n\t\t\t(yyvsp[-3])->expr_count = 0;\n\t\t\t(yyval) = list_append(list_create((yyvsp[-2])), (yyvsp[-3]));\n\t\t} else {\n\t\t\t(yyvsp[-3])->expr_count = sub_counter;\n\t\t\t(yyval) = list_append(list_append((yyvsp[0]), (yyvsp[-2])), (yyvsp[-3]));\n\t\t}\n\t  }\n#line 2808 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 64:\n#line 1014 \"awkgram.y\" /* yacc.c:1646  */\n    {\n\t\tstatic bool warned = false;\n\t\tchar *arr = (yyvsp[-1])->lextok;\n\n\t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn_ln((yyvsp[-3])->source_line,\n\t\t\t\t_(\"`delete(array)' is a non-portable tawk extension\"));\n\t\t}\n\t\tif (do_traditional) {\n\t\t\terror_ln((yyvsp[-3])->source_line,\n\t\t\t\t_(\"`delete(array)' is a non-portable tawk extension\"));\n\t\t}\n\t\t(yyvsp[-1])->memory = variable((yyvsp[-1])->source_line, arr, Node_var_new);\n\t\t(yyvsp[-1])->opcode = Op_push_array;\n\t\t(yyvsp[-3])->expr_count = 0;\n\t\t(yyval) = list_append(list_create((yyvsp[-1])), (yyvsp[-3]));\n\n\t\tif (! do_posix && ! do_traditional) {\n\t\t\tif ((yyvsp[-1])->memory == symbol_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with SYMTAB\"));\n\t\t\telse if ((yyvsp[-1])->memory == func_table)\n\t\t\t\tfatal(_(\"`delete' is not allowed with FUNCTAB\"));\n\t\t}\n\t  }\n#line 2838 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 65:\n#line 1040 \"awkgram.y\" /* yacc.c:1646  */\n    {\t(yyval) = optimize_assignment((yyvsp[0])); }\n#line 2844 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 66:\n#line 1045 \"awkgram.y\" /* yacc.c:1646  */\n    { (yyval) = NULL; }\n#line 2850 \"awkgram.c\" /* yacc.c:1646  */\n    break;\n\n  case 67:\n#line 1047 \"awkgram."
}