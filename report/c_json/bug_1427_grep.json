{
    "Project": "grep",
    "Tool": "Cppcheck",
    "category": "uninitvar",
    "file": "src/dfa.c",
    "message": "Uninitialized variable: c",
    "warning_function_name": "parse_bracket_exp",
    "warning_line": "if (c == '^')",
    "warning_context": "static token\nparse_bracket_exp (void)\n{\n  bool invert;\n  int c, c1, c2;\n  charclass ccl;\n\n  /* This is a bracket expression that dfaexec is known to\n     process correctly.  */\n  bool known_bracket_exp = true;\n\n  /* Used to warn about [:space:].\n     Bit 0 = first character is a colon.\n     Bit 1 = last character is a colon.\n     Bit 2 = includes any other character but a colon.\n     Bit 3 = includes ranges, char/equiv classes or collation elements.  */\n  int colon_warning_state;\n\n  wint_t wc;\n  wint_t wc2;\n  wint_t wc1 = 0;\n\n  /* Work area to build a mb_char_classes.  */\n  struct mb_char_classes *work_mbc;\n  size_t chars_al, ranges_al, ch_classes_al, equivs_al, coll_elems_al;\n\n  chars_al = ranges_al = ch_classes_al = equivs_al = coll_elems_al = 0;\n  if (dfa->multibyte)\n    {\n      dfa->mbcsets = maybe_realloc (dfa->mbcsets, dfa->nmbcsets,\n                                    &dfa->mbcsets_alloc,\n                                    sizeof *dfa->mbcsets);\n\n      /* dfa->multibyte_prop[] hold the index of dfa->mbcsets.\n         We will update dfa->multibyte_prop[] in addtok, because we can't\n         decide the index in dfa->tokens[].  */\n\n      /* Initialize work area.  */\n      work_mbc = &(dfa->mbcsets[dfa->nmbcsets++]);\n      memset (work_mbc, 0, sizeof *work_mbc);\n    }\n  else\n    work_mbc = NULL;\n\n  memset (ccl, 0, sizeof ccl);\n  FETCH_WC (c, wc, _(\"unbalanced [\"));\n  if (c == '^')\n    {\n      FETCH_WC (c, wc, _(\"unbalanced [\"));\n      invert = true;\n      known_bracket_exp = using_simple_locale ();\n    }\n  else\n    invert = false;\n\n  colon_warning_state = (c == ':');\n  do\n    {\n      c1 = NOTCHAR;\t/* Mark c1 as not initialized.  */\n      colon_warning_state &= ~2;\n\n      /* Note that if we're looking at some other [:...:] construct,\n         we just treat it as a bunch of ordinary characters.  We can do\n         this because we assume regex has checked for syntax errors before\n         dfa is ever called.  */\n      if (c == '[')\n        {\n          FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n\n          if ((c1 == ':' && (syntax_bits & RE_CHAR_CLASSES))\n              || c1 == '.' || c1 == '=')\n            {\n              enum { MAX_BRACKET_STRING_LEN = 32 };\n              char str[MAX_BRACKET_STRING_LEN + 1];\n              size_t len = 0;\n              for (;;)\n                {\n                  FETCH_WC (c, wc, _(\"unbalanced [\"));\n                  if ((c == c1 && *lexptr == ']') || lexleft == 0)\n                    break;\n                  if (len < MAX_BRACKET_STRING_LEN)\n                    str[len++] = c;\n                  else\n                    /* This is in any case an invalid class name.  */\n                    str[0] = '\\0';\n                }\n              str[len] = '\\0';\n\n              /* Fetch bracket.  */\n              FETCH_WC (c, wc, _(\"unbalanced [\"));\n              if (c1 == ':')\n                /* Build character class.  POSIX allows character\n                   classes to match multicharacter collating elements,\n                   but the regex code does not support that, so do not\n                   worry about that possibility.  */\n                {\n                  char const *class\n                    = (case_fold && (STREQ (str, \"upper\")\n                                     || STREQ (str, \"lower\")) ? \"alpha\" : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n"
}