{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t    \t\t\tset_element(nf, start, 0L, sep_arr);",
    "Code_function": "fpat_parse_field(long up_to,\t/* parse only up to this field number */\n\tchar **buf,\t/* on input: string to parse; on output: point to start next */\n\tint len,\n\tNODE *fs ATTRIBUTE_UNUSED,\n\tRegexp *rp,\n\tSetfunc set,\t/* routine to set the value of the parsed field */\n\tNODE *n,\n\tNODE *sep_arr,  /* array of field separators (may be NULL) */\n\tbool in_middle)\n{\n\tchar *scan = *buf;\n\tlong nf = parse_high_water;\n\tchar *start;\n\tchar *end = scan + len;\n\tint regex_flags = RE_NEED_START;\n\tbool need_to_set_sep;\n\tbool non_empty;\n\tbool eosflag;\n\tmbstate_t mbs;\n\n\tmemset(&mbs, 0, sizeof(mbstate_t));\n\n\tif (up_to == UNLIMITED)\n\t\tnf = 0;\n\n\tif (len == 0)\n\t\treturn nf;\n\n\tif (rp == NULL) /* use FPAT */\n\t\trp = FPAT_regexp;\n\n\tif (in_middle) {\n\t\tregex_flags |= RE_NO_BOL;\n\t\tnon_empty = rp->non_empty;\n\t} else\n\t\tnon_empty = false;\n\n\teosflag = false;\n\tneed_to_set_sep = true;\n\tstart = scan;\n\twhile (research(rp, scan, 0, (end - scan), regex_flags) != -1\n\t       && nf < up_to) {\n\n\t\tif (REEND(rp, scan) > RESTART(rp, scan)) { /* if (RLENGTH > 0) */\n\t\t\tnon_empty = true;\n\t\t\tif (sep_arr != NULL && need_to_set_sep) {\n\t\t\t\tif (RESTART(rp, scan) == 0) /* match at front */\n\t\t    \t\t\tset_element(nf, start, 0L, sep_arr);\n\t\t\t\telse\n\t\t    \t\t\tset_element(nf,\n\t\t\t\t\t\tstart,\n\t\t\t\t\t\t(long) RESTART(rp, scan),\n\t\t\t\t\t\tsep_arr);\n\t\t\t}\n\t\t\t/* field is text that matched */\n\t\t\t(*set)(++nf,\n\t\t\t\tscan + RESTART(rp, scan),\n\t\t\t\t(long)(REEND(rp, scan) - RESTART(rp, scan)),\n\t\t\t\tn);\n\n\t\t\tscan += REEND(rp, scan);\n\t\t\tif (scan >= end)\n\t\t\t\tbreak;\n\t\t\tneed_to_set_sep = true;\n\t\t} else if (non_empty) { /* else if non_empty */\n\t\t\t/*\n\t\t\t * last match was non-empty, and at the\n\t\t\t * current character we get a zero length match,\n\t\t\t * which we don't want, so skip over it\n\t\t\t */\n\t\t\tnon_empty = false;\n\t\t\tif (sep_arr != NULL) {\n\t\t\t\tneed_to_set_sep = false;\n\t\t    \t\tset_element(nf, start, 1L, sep_arr);\n\t\t\t}\n\t\t\tincrement_scan(& scan, end - scan);\n\t\t} else {\n\t\t\t/* 0 length match */\n\t\t\tif (sep_arr != NULL && need_to_set_sep) {\n\t\t\t\tif (RESTART(rp, scan) == 0) /* RSTART == 1 */\n\t\t    \t\t\tset_element(nf, start, 0L, sep_arr);\n\t\t\t\telse\n\t\t    \t\t\tset_element(nf, start,\n\t\t\t\t\t\t\t(long) RESTART(rp, scan),\n\t\t\t\t\t\t\tsep_arr);\n\t\t\t}\n\t\t\tneed_to_set_sep = true;\n\t\t\t(*set)(++nf, scan, 0L, n);\n\t\t\tif (! non_empty && ! eosflag) { /* prev was empty */\n\t\t\t\tif (sep_arr != NULL) {\n\t\t    \t\t\tset_element(nf, start, 1L, sep_arr);\n\t\t\t\t\tneed_to_set_sep = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (RESTART(rp, scan) == 0)\n\t\t\t\tincrement_scan(& scan, end - scan);\n\t\t\telse {\n\t\t\t\tscan += RESTART(rp, scan);\n\t\t\t}\n\t\t\tnon_empty = false;\n\t\t}\n\t\tif (scan >= end) { /* length(string) == 0 */\n\t\t\tif (eosflag)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\teosflag = true;\n\t\t}\n\n\t\tstart = scan;\n\t}\n\tif (scan < end) {\n\t\tif (sep_arr != NULL)\n    \t\t\tset_element(nf, scan, (long) (end - scan), sep_arr);\n\t}\n\n\t*buf = scan;\n\trp->non_empty = non_empty;\n\treturn nf;\n}"
}