{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/app.c",
    "message": "The value read from fromlen was never initialized.",
    "warning_function_name": "process_escape",
    "warning_line": "ch = GET ();",
    "warning_context": "\t\t    ch = GET ();\n\t\t  state = 0;\n\t\t  PUT (ch);\n\t\t}\n\t    }\n\t  continue;\n\n\tcase 5:\n\t  /* We are going to copy everything up to a quote character,\n\t     with special handling for a backslash.  We try to\n\t     optimize the copying in the simple case without using the\n\t     GET and PUT macros.  */\n\t  {\n\t    char *s;\n\t    ptrdiff_t len;\n\n\t    for (s = from; s < fromend; s++)\n\t      {\n\t\tch = *s;\n\t\tif (ch == '\\\\'\n\t\t    || ch == quotechar\n\t\t    || ch == '\\n')\n\t\t  break;\n\t      }\n\t    len = s - from;\n\t    if (len > toend - to)\n\t      len = toend - to;\n\t    if (len > 0)\n\t      {\n\t\tmemcpy (to, from, len);\n\t\tto += len;\n\t\tfrom += len;\n\t\tif (to >= toend)\n\t\t  goto tofull;\n\t      }\n\t  }\n\n\t  ch = GET ();\n\t  if (ch == EOF)\n\t    {\n\t      /* This buffer is here specifically so\n\t\t that the UNGET below will work.  */\n\t      static char one_char_buf[1];\n\n\t      as_warn (_(\"end of file in string; '%c' inserted\"), quotechar);\n\t      state = old_state;\n\t      from = fromend = one_char_buf + 1;\n\t      fromlen = 1;\n\t      UNGET ('\\n');\n\t      PUT (quotechar);\n\t    }\n\t  else if (ch == quotechar)\n\t    {\n\t      state = old_state;\n\t      PUT (ch);\n\t    }\n#ifndef NO_STRING_ESCAPES\n\t  else if (ch == '\\\\')\n\t    {\n\t      state = 6;\n\t      PUT (ch);\n\t    }\n#endif\n\t  else if (scrub_m68k_mri && ch == '\\n')\n\t    {\n\t      /* Just quietly terminate the string.  This permits lines like\n\t\t   bne\tlabel\tloop if we haven't reach end yet.  */\n\t      state = old_state;\n\t      UNGET (ch);\n\t      PUT ('\\'');\n\t    }\n\t  else\n\t    {\n\t      PUT (ch);\n\t    }\n\t  continue;\n\n\tcase 6:\n\t  state = 5;\n\t  ch = GET ();\n\t  switch (ch)\n\t    {\n\t      /* Handle strings broken across lines, by turning '\\n' into\n\t\t '\\\\' and 'n'.  */\n\t    case '\\n':\n\t      UNGET ('n');\n\t      add_newlines++;\n\t      PUT ('\\\\');\n\t      continue;\n\n\t    case EOF:\n\t      as_warn (_(\"end of file in string; '%c' inserted\"), quotechar);\n\t      PUT (quotechar);\n\t      continue;\n\n\t    case '\"':\n\t    case '\\\\':\n\t    case 'b':\n\t    case 'f':\n\t    case 'n':\n\t    case 'r':\n"
}