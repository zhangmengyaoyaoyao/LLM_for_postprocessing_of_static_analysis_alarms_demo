{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "binutils/ieee.c",
    "message": "Offset added: [`info->types.alloc` + 32, +oo] (⇐ `info->types.alloc` + [32, +oo]) Size: [1, +oo] by call to `ieee_alloc_type`.",
    "warning_function_name": "parse_ieee_ty",
    "warning_line": "if (! ieee_alloc_type (info, typeindx, FALSE))",
    "warning_context": "static bfd_boolean\nparse_ieee_ty (struct ieee_info *info, const bfd_byte **pp)\n{\n  const bfd_byte *ty_start, *ty_var_start, *ty_code_start;\n  bfd_vma typeindx, varindx, tc;\n  void *dhandle;\n  bfd_boolean tag, typdef;\n  debug_type *arg_slots;\n  unsigned long type_bitsize;\n  debug_type type;\n\n  ty_start = *pp;\n\n  if (! ieee_read_number (info, pp, &typeindx))\n    return FALSE;\n\n  if (typeindx < 256)\n    {\n      ieee_error (info, ty_start, _(\"illegal type index\"));\n      return FALSE;\n    }\n\n  typeindx -= 256;\n  if (! ieee_alloc_type (info, typeindx, FALSE))\n    return FALSE;\n\n  if (**pp != 0xce)\n    {\n      ieee_error (info, *pp, _(\"unknown TY code\"));\n      return FALSE;\n    }\n  ++*pp;\n\n  ty_var_start = *pp;\n\n  if (! ieee_read_number (info, pp, &varindx))\n    return FALSE;\n\n  if (varindx < 32)\n    {\n      ieee_error (info, ty_var_start, _(\"illegal variable index\"));\n      return FALSE;\n    }\n  varindx -= 32;\n\n  if (varindx >= info->vars.alloc || info->vars.vars[varindx].name == NULL)\n    {\n      ieee_error (info, ty_var_start, _(\"undefined variable in TY\"));\n      return FALSE;\n    }\n\n  ty_code_start = *pp;\n\n  if (! ieee_read_number (info, pp, &tc))\n    return FALSE;\n\n  dhandle = info->dhandle;\n\n  tag = FALSE;\n  typdef = FALSE;\n  arg_slots = NULL;\n  type_bitsize = 0;\n  switch (tc)\n    {\n    default:\n      ieee_error (info, ty_code_start, _(\"unknown TY code\"));\n      return FALSE;\n\n    case '!':\n      /* Unknown type, with size.  We treat it as int.  FIXME.  */\n      {\n\tbfd_vma size;\n\n\tif (! ieee_read_number (info, pp, &size))\n\t  return FALSE;\n\ttype = debug_make_int_type (dhandle, size, FALSE);\n      }\n      break;\n\n    case 'A': /* Array.  */\n    case 'a': /* FORTRAN array in column/row order.  FIXME: Not\n\t\t distinguished from normal array.  */\n      {\n\tdebug_type ele_type;\n\tbfd_vma lower, upper;\n\n\tif (! ieee_read_type_index (info, pp, &ele_type)\n\t    || ! ieee_read_number (info, pp, &lower)\n\t    || ! ieee_read_number (info, pp, &upper))\n\t  return FALSE;\n\ttype = debug_make_array_type (dhandle, ele_type,\n\t\t\t\t      ieee_builtin_type (info, ty_code_start,\n\t\t\t\t\t\t\t ((unsigned int)\n\t\t\t\t\t\t\t  builtin_int)),\n\t\t\t\t      (bfd_signed_vma) lower,\n\t\t\t\t      (bfd_signed_vma) upper,\n\t\t\t\t      FALSE);\n      }\n      break;\n\n    case 'E':\n"
}