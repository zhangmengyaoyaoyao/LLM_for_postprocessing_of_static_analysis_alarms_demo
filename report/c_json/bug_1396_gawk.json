{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "dfa.c",
    "message": "Access to field 'in' results in a dereference of a null pointer (loaded from variable 'mp')",
    "warning_function_name": "dfamust",
    "warning_line": "for (i = 0; mp->in[i] != NULL; ++i)",
    "warning_context": "        {\n        case BEGLINE:\n          mp = allocmust (mp);\n          mp->begline = true;\n          break;\n        case ENDLINE:\n          mp = allocmust (mp);\n          mp->endline = true;\n          break;\n        case LPAREN:\n        case RPAREN:\n          assert (!\"neither LPAREN nor RPAREN may appear here\");\n\n        case EMPTY:\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n        case BACKREF:\n        case ANYCHAR:\n        case MBCSET:\n          mp = allocmust (mp);\n          break;\n\n        case STAR:\n        case QMARK:\n          resetmust (mp);\n          break;\n\n        case OR:\n          {\n            char **new;\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n            size_t j, ln, rn, n;\n\n            /* Guaranteed to be.  Unlikely, but ...  */\n            if (STREQ (lmp->is, rmp->is))\n              {\n                lmp->begline &= rmp->begline;\n                lmp->endline &= rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            /* Left side--easy */\n            i = 0;\n            while (lmp->left[i] != '\\0' && lmp->left[i] == rmp->left[i])\n              ++i;\n            lmp->left[i] = '\\0';\n            /* Right side */\n            ln = strlen (lmp->right);\n            rn = strlen (rmp->right);\n            n = ln;\n            if (n > rn)\n              n = rn;\n            for (i = 0; i < n; ++i)\n              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])\n                break;\n            for (j = 0; j < i; ++j)\n              lmp->right[j] = lmp->right[(ln - i) + j];\n            lmp->right[j] = '\\0';\n            new = inboth (lmp->in, rmp->in);\n            freelist (lmp->in);\n            free (lmp->in);\n            lmp->in = new;\n            freemust (rmp);\n          }\n          break;\n\n        case PLUS:\n          mp->is[0] = '\\0';\n          break;\n\n        case END:\n          assert (!mp->prev);\n          for (i = 0; mp->in[i] != NULL; ++i)\n            if (strlen (mp->in[i]) > strlen (result))\n              result = mp->in[i];\n          if (STREQ (result, mp->is))\n            {\n              exact = true;\n              begline = mp->begline;\n              endline = mp->endline;\n            }\n          goto done;\n\n        case CAT:\n          {\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n\n            /* In.  Everything in left, plus everything in\n               right, plus concatenation of\n               left's right and right's left.  */\n            lmp->in = addlists (lmp->in, rmp->in);\n            if (lmp->right[0] != '\\0' && rmp->left[0] != '\\0')\n              {\n"
}