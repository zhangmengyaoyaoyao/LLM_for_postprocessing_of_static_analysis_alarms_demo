{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/sh/casemod.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "sh_modcase",
    "warning_line": "ADVANCE_CHAR (ret, end, start);",
    "warning_context": "\t{\n\t  if (usewords)\n\t    nop = inword ? CASE_UPPER : CASE_LOWER;\n\t  else\n\t    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;\n\t  inword = 1;\n\t}\n      else if (flags == CASE_UPFIRST)\n \t{\n \t  if (usewords)\n\t    nop = inword ? CASE_NOOP : CASE_UPPER;\n\t  else\n\t    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;\n \t  inword = 1;\n \t}\n      else if (flags == CASE_LOWFIRST)\n \t{\n \t  if (usewords)\n\t    nop = inword ? CASE_NOOP : CASE_LOWER;\n\t  else\n\t    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;\n \t  inword = 1;\n \t}\n      else if (flags == CASE_TOGGLE)\n\t{\n\t  nop = inword ? CASE_NOOP : CASE_TOGGLE;\n\t  inword = 1;\n\t}\n      else\n\tnop = flags;\n\n      /* Need to check UCHAR_MAX since wc may have already been converted to a\n\t wide character by cval() */\n      if (MB_CUR_MAX == 1 || (wc <= UCHAR_MAX && is_basic ((int)wc)))\n\t{\nsinglebyte:\n\t  switch (nop)\n\t  {\n\t  default:\n\t  case CASE_NOOP:  nc = wc; break;\n\t  case CASE_UPPER:  nc = TOUPPER (wc); break;\n\t  case CASE_LOWER:  nc = TOLOWER (wc); break;\n\t  case CASE_TOGGLEALL:\n\t  case CASE_TOGGLE: nc = TOGGLE (wc); break;\n\t  }\n\t  ret[start] = nc;\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      else\n\t{\n\t  m = mbrtowc (&wc, string + start, end - start, &state);\n\t  if (MB_INVALIDCH (m))\n\t    {\n\t      wc = (unsigned char)string[start];\n\t      goto singlebyte;\n\t    }\n\t  else if (MB_NULLWCH (m))\n\t    wc = L'\\0';\n\t  switch (nop)\n\t  {\n\t  default:\n\t  case CASE_NOOP:  nwc = wc; break;\n\t  case CASE_UPPER:  nwc = _to_wupper (wc); break;\n\t  case CASE_LOWER:  nwc = _to_wlower (wc); break;\n\t  case CASE_TOGGLEALL:\n\t  case CASE_TOGGLE: nwc = TOGGLE (wc); break;\n\t  }\n\t  if  (nwc != wc)\t/*  just skip unchanged characters */\n\t    {\n\t      mlen = wcrtomb (mb, nwc, &state);\n\t      if (mlen > 0)\n\t\tmb[mlen] = '\\0';\n\t      /* Assume the same width */\n\t      strncpy (ret + start, mb, mlen);\n\t    }\n\t}\n#endif\n\n      /*  This assumes that the upper and lower case versions are the same width. */\n      ADVANCE_CHAR (ret, end, start);\n    }\n\n  return ret;\n}\n"
}