{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t\tps_back = ps1;",
    "Code_function": "compute_lcd_of_matches (match_list, matches, text)\n     char **match_list;\n     int matches;\n     const char *text;\n{\n  register int i, c1, c2, si;\n  int low;\t\t/* Count of max-matched characters. */\n  int lx;\n  char *dtext;\t\t/* dequoted TEXT, if needed */\n#if defined (HANDLE_MULTIBYTE)\n  int v;\n  size_t v1, v2;\n  mbstate_t ps1, ps2;\n  wchar_t wc1, wc2;\n#endif\n\n  /* If only one match, just use that.  Otherwise, compare each\n     member of the list with the next, finding out where they\n     stop matching. */\n  if (matches == 1)\n    {\n      match_list[0] = match_list[1];\n      match_list[1] = (char *)NULL;\n      return 1;\n    }\n\n  for (i = 1, low = 100000; i < matches; i++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  memset (&ps1, 0, sizeof (mbstate_t));\n\t  memset (&ps2, 0, sizeof (mbstate_t));\n\t}\n#endif\n      if (_rl_completion_case_fold)\n\t{\n\t  for (si = 0;\n\t       (c1 = _rl_to_lower(match_list[i][si])) &&\n\t       (c2 = _rl_to_lower(match_list[i + 1][si]));\n\t       si++)\n#if defined (HANDLE_MULTIBYTE)\n\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t      {\n\t\tv1 = mbrtowc(&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);\n\t\tv2 = mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);\n\t\tif (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n\t\t  {\n\t\t    if (c1 != c2)\t/* do byte comparison */\n\t\t      break;\n\t\t    continue;\n\t\t  }\n\t\twc1 = towlower (wc1);\n\t\twc2 = towlower (wc2);\n\t\tif (wc1 != wc2)\n\t\t  break;\n\t\telse if (v1 > 1)\n\t\t  si += v1 - 1;\n\t      }\n\t    else\n#endif\n\t    if (c1 != c2)\n\t      break;\n\t}\n      else\n\t{\n\t  for (si = 0;\n\t       (c1 = match_list[i][si]) &&\n\t       (c2 = match_list[i + 1][si]);\n\t       si++)\n#if defined (HANDLE_MULTIBYTE)\n\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t      {\n\t\tmbstate_t ps_back;\n\t\tps_back = ps1;\n\t\tif (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))\n\t\t  break;\n\t\telse if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)\n\t\t  si += v - 1;\n\t      }\n\t    else\n#endif\n\t    if (c1 != c2)\n\t      break;\n\t}\n\n      if (low > si)\n\tlow = si;\n    }\n\n  /* If there were multiple matches, but none matched up to even the\n     first character, and the user typed something, use that as the\n     value of matches[0]. */\n  if (low == 0 && text && *text)\n    {\n      match_list[0] = (char *)xmalloc (strlen (text) + 1);\n      strcpy (match_list[0], text);\n    }\n  else\n    {\n      match_list[0] = (char *)xmalloc (low + 1);\n\n      /* XXX - this might need changes in the presence of multibyte chars */\n\n      /* If we are ignoring case, try to preserve the case of the string\n\t the user typed in the face of multiple matches differing in case. */\n      if (_rl_completion_case_fold)\n\t{\n\t  /* We're making an assumption here:\n\t\tIF we're completing filenames AND\n\t\t   the application has defined a filename dequoting function AND\n\t\t   we found a quote character AND\n\t\t   the application has requested filename quoting\n\t\tTHEN\n\t\t   we assume that TEXT was dequoted before checking against\n\t\t   the file system and needs to be dequoted here before we\n\t\t   check against the list of matches\n\t\tFI */\n\t  dtext = (char *)NULL;\n\t  if (rl_filename_completion_desired &&\n\t      rl_filename_dequoting_function &&\n\t      rl_completion_found_quote &&\n\t      rl_filename_quoting_desired)\n\t    {\n\t      dtext = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);\n\t      text = dtext;\n\t    }\n\n\t  /* sort the list to get consistent answers. */\n\t  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);\n\n\t  si = strlen (text);\n\t  lx = (si <= low) ? si : low;\t/* check shorter of text and matches */\n\t  /* Try to preserve the case of what the user typed in the presence of\n\t     multiple matches: check each match for something that matches\n\t     what the user typed taking case into account; use it up to common\n\t     length of matches if one is found.  If not, just use first match. */\n\t  for (i = 1; i <= matches; i++)\n\t    if (strncmp (match_list[i], text, lx) == 0)\n\t      {\n\t\tstrncpy (match_list[0], match_list[i], low);\n\t\tbreak;\n\t      }\n\t  /* no casematch, use first entry */\n\t  if (i > matches)\n\t    strncpy (match_list[0], match_list[1], low);\n\n\t  FREE (dtext);\n\t}\n      else\n        strncpy (match_list[0], match_list[1], low);\n\n      match_list[0][low] = '\\0';\n    }\n\n  return matches;\n}"
}