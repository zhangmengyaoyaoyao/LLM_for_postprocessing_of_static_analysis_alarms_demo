{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t      incl_type = incl_sym[TYPEOFF];",
    "Code_function": "_bfd_link_section_stabs (bfd *abfd,\n\t\t\t struct stab_info *sinfo,\n\t\t\t asection *stabsec,\n\t\t\t asection *stabstrsec,\n\t\t\t void * *psecinfo,\n\t\t\t bfd_size_type *pstring_offset)\n{\n  bfd_boolean first;\n  bfd_size_type count, amt;\n  struct stab_section_info *secinfo;\n  bfd_byte *stabbuf = NULL;\n  bfd_byte *stabstrbuf = NULL;\n  bfd_byte *sym, *symend;\n  bfd_size_type stroff, next_stroff, skip;\n  bfd_size_type *pstridx;\n\n  if (stabsec->size == 0\n      || stabstrsec->size == 0)\n    /* This file does not contain stabs debugging information.  */\n    return TRUE;\n\n  if (stabsec->size % STABSIZE != 0)\n    /* Something is wrong with the format of these stab symbols.\n       Don't try to optimize them.  */\n    return TRUE;\n\n  if ((stabstrsec->flags & SEC_RELOC) != 0)\n    /* We shouldn't see relocations in the strings, and we aren't\n       prepared to handle them.  */\n    return TRUE;\n\n  if (bfd_is_abs_section (stabsec->output_section)\n      || bfd_is_abs_section (stabstrsec->output_section))\n    /* At least one of the sections is being discarded from the\n       link, so we should just ignore them.  */\n    return TRUE;\n\n  first = FALSE;\n\n  if (sinfo->stabstr == NULL)\n    {\n      flagword flags;\n\n      /* Initialize the stabs information we need to keep track of.  */\n      first = TRUE;\n      sinfo->strings = _bfd_stringtab_init ();\n      if (sinfo->strings == NULL)\n\tgoto error_return;\n      /* Make sure the first byte is zero.  */\n      (void) _bfd_stringtab_add (sinfo->strings, \"\", TRUE, TRUE);\n      if (! bfd_hash_table_init (&sinfo->includes,\n\t\t\t\t stab_link_includes_newfunc,\n\t\t\t\t sizeof (struct stab_link_includes_entry)))\n\tgoto error_return;\n      flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING\n\t       | SEC_LINKER_CREATED);\n      sinfo->stabstr = bfd_make_section_anyway_with_flags (abfd, \".stabstr\",\n\t\t\t\t\t\t\t   flags);\n      if (sinfo->stabstr == NULL)\n\tgoto error_return;\n    }\n\n  /* Initialize the information we are going to store for this .stab\n     section.  */\n  count = stabsec->size / STABSIZE;\n\n  amt = sizeof (struct stab_section_info);\n  amt += (count - 1) * sizeof (bfd_size_type);\n  *psecinfo = bfd_alloc (abfd, amt);\n  if (*psecinfo == NULL)\n    goto error_return;\n\n  secinfo = (struct stab_section_info *) *psecinfo;\n  secinfo->excls = NULL;\n  stabsec->rawsize = stabsec->size;\n  secinfo->cumulative_skips = NULL;\n  memset (secinfo->stridxs, 0, (size_t) count * sizeof (bfd_size_type));\n\n  /* Read the stabs information from abfd.  */\n  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf)\n      || !bfd_malloc_and_get_section (abfd, stabstrsec, &stabstrbuf))\n    goto error_return;\n\n  /* Look through the stabs symbols, work out the new string indices,\n     and identify N_BINCL symbols which can be eliminated.  */\n  stroff = 0;\n  /* The stabs sections can be split when\n     -split-by-reloc/-split-by-file is used.  We must keep track of\n     each stab section's place in the single concatenated string\n     table.  */\n  next_stroff = pstring_offset ? *pstring_offset : 0;\n  skip = 0;\n\n  symend = stabbuf + stabsec->size;\n  for (sym = stabbuf, pstridx = secinfo->stridxs;\n       sym < symend;\n       sym += STABSIZE, ++pstridx)\n    {\n      bfd_size_type symstroff;\n      int type;\n      const char *string;\n\n      if (*pstridx != 0)\n\t/* This symbol has already been handled by an N_BINCL pass.  */\n\tcontinue;\n\n      type = sym[TYPEOFF];\n\n      if (type == 0)\n\t{\n\t  /* Special type 0 stabs indicate the offset to the next\n\t     string table.  We only copy the very first one.  */\n\t  stroff = next_stroff;\n\t  next_stroff += bfd_get_32 (abfd, sym + 8);\n\t  if (pstring_offset)\n\t    *pstring_offset = next_stroff;\n\t  if (! first)\n\t    {\n\t      *pstridx = (bfd_size_type) -1;\n\t      ++skip;\n\t      continue;\n\t    }\n\t  first = FALSE;\n\t}\n\n      /* Store the string in the hash table, and record the index.  */\n      symstroff = stroff + bfd_get_32 (abfd, sym + STRDXOFF);\n      if (symstroff >= stabstrsec->size)\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"%B(%A+0x%lx): Stabs entry has invalid string index.\"),\n\t     abfd, stabsec, (long) (sym - stabbuf));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto error_return;\n\t}\n      string = (char *) stabstrbuf + symstroff;\n      *pstridx = _bfd_stringtab_add (sinfo->strings, string, TRUE, TRUE);\n\n      /* An N_BINCL symbol indicates the start of the stabs entries\n\t for a header file.  We need to scan ahead to the next N_EINCL\n\t symbol, ignoring nesting, adding up all the characters in the\n\t symbol names, not including the file numbers in types (the\n\t first number after an open parenthesis).  */\n      if (type == (int) N_BINCL)\n\t{\n\t  bfd_vma sum_chars;\n\t  bfd_vma num_chars;\n\t  bfd_vma buf_len = 0;\n\t  char * symb;\n\t  char * symb_rover;\n\t  int nest;\n\t  bfd_byte * incl_sym;\n\t  struct stab_link_includes_entry * incl_entry;\n\t  struct stab_link_includes_totals * t;\n\t  struct stab_excl_list * ne;\n\n\t  symb = symb_rover = NULL;\n\t  sum_chars = num_chars = 0;\n\t  nest = 0;\n\n\t  for (incl_sym = sym + STABSIZE;\n\t       incl_sym < symend;\n\t       incl_sym += STABSIZE)\n\t    {\n\t      int incl_type;\n\n\t      incl_type = incl_sym[TYPEOFF];\n\t      if (incl_type == 0)\n\t\tbreak;\n\t      else if (incl_type == (int) N_EXCL)\n\t\tcontinue;\n\t      else if (incl_type == (int) N_EINCL)\n\t\t{\n\t\t  if (nest == 0)\n\t\t    break;\n\t\t  --nest;\n\t\t}\n\t      else if (incl_type == (int) N_BINCL)\n\t\t++nest;\n\t      else if (nest == 0)\n\t\t{\n\t\t  const char *str;\n\n\t\t  str = ((char *) stabstrbuf\n\t\t\t + stroff\n\t\t\t + bfd_get_32 (abfd, incl_sym + STRDXOFF));\n\t\t  for (; *str != '\\0'; str++)\n\t\t    {\n\t\t      if (num_chars >= buf_len)\n\t\t\t{\n\t\t\t  buf_len += 32 * 1024;\n\t\t\t  symb = (char *) bfd_realloc_or_free (symb, buf_len);\n\t\t\t  if (symb == NULL)\n\t\t\t    goto error_return;\n\t\t\t  symb_rover = symb + num_chars;\n\t\t\t}\n\t\t      * symb_rover ++ = * str;\n\t\t      sum_chars += *str;\n\t\t      num_chars ++;\n\t\t      if (*str == '(')\n\t\t\t{\n\t\t\t  /* Skip the file number.  */\n\t\t\t  ++str;\n\t\t\t  while (ISDIGIT (*str))\n\t\t\t    ++str;\n\t\t\t  --str;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t  BFD_ASSERT (num_chars == (bfd_vma) (symb_rover - symb));\n\n\t  /* If we have already included a header file with the same\n\t     value, then replaced this one with an N_EXCL symbol.  */\n\t  incl_entry = (struct stab_link_includes_entry * )\n\t    bfd_hash_lookup (&sinfo->includes, string, TRUE, TRUE);\n\t  if (incl_entry == NULL)\n\t    goto error_return;\n\n\t  for (t = incl_entry->totals; t != NULL; t = t->next)\n\t    if (t->sum_chars == sum_chars\n\t\t&& t->num_chars == num_chars\n\t\t&& memcmp (t->symb, symb, num_chars) == 0)\n\t      break;\n\n\t  /* Record this symbol, so that we can set the value\n\t     correctly.  */\n\t  amt = sizeof *ne;\n\t  ne = (struct stab_excl_list *) bfd_alloc (abfd, amt);\n\t  if (ne == NULL)\n\t    goto error_return;\n\t  ne->offset = sym - stabbuf;\n\t  ne->val = sum_chars;\n\t  ne->type = (int) N_BINCL;\n\t  ne->next = secinfo->excls;\n\t  secinfo->excls = ne;\n\n\t  if (t == NULL)\n\t    {\n\t      /* This is the first time we have seen this header file\n\t\t with this set of stabs strings.  */\n\t      t = (struct stab_link_includes_totals *)\n                  bfd_hash_allocate (&sinfo->includes, sizeof *t);\n\t      if (t == NULL)\n\t\tgoto error_return;\n\t      t->sum_chars = sum_chars;\n\t      t->num_chars = num_chars;\n              /* Trim data down.  */\n\t      t->symb = symb = (char *) bfd_realloc_or_free (symb, num_chars);\n\t      t->next = incl_entry->totals;\n\t      incl_entry->totals = t;\n\t    }\n\t  else\n\t    {\n\t      bfd_size_type *incl_pstridx;\n\n\t      /* We have seen this header file before.  Tell the final\n\t\t pass to change the type to N_EXCL.  */\n\t      ne->type = (int) N_EXCL;\n\n\t      /* Free off superfluous symbols.  */\n\t      free (symb);\n\n\t      /* Mark the skipped symbols.  */\n\n\t      nest = 0;\n\t      for (incl_sym = sym + STABSIZE, incl_pstridx = pstridx + 1;\n\t\t   incl_sym < symend;\n\t\t   incl_sym += STABSIZE, ++incl_pstridx)\n\t\t{\n\t\t  int incl_type;\n\n\t\t  incl_type = incl_sym[TYPEOFF];\n\n\t\t  if (incl_type == (int) N_EINCL)\n\t\t    {\n\t\t      if (nest == 0)\n\t\t\t{\n\t\t\t  *incl_pstridx = (bfd_size_type) -1;\n\t\t\t  ++skip;\n\t\t\t  break;\n\t\t\t}\n\t\t      --nest;\n\t\t    }\n\t\t  else if (incl_type == (int) N_BINCL)\n\t\t    ++nest;\n\t\t  else if (incl_type == (int) N_EXCL)\n\t\t    /* Keep existing exclusion marks.  */\n\t\t    continue;\n\t\t  else if (nest == 0)\n\t\t    {\n\t\t      *incl_pstridx = (bfd_size_type) -1;\n\t\t      ++skip;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  free (stabbuf);\n  stabbuf = NULL;\n  free (stabstrbuf);\n  stabstrbuf = NULL;\n\n  /* We need to set the section sizes such that the linker will\n     compute the output section sizes correctly.  We set the .stab\n     size to not include the entries we don't want.  We set\n     SEC_EXCLUDE for the .stabstr section, so that it will be dropped\n     from the link.  We record the size of the strtab in the first\n     .stabstr section we saw, and make sure we don't set SEC_EXCLUDE\n     for that section.  */\n  stabsec->size = (count - skip) * STABSIZE;\n  if (stabsec->size == 0)\n    stabsec->flags |= SEC_EXCLUDE | SEC_KEEP;\n  stabstrsec->flags |= SEC_EXCLUDE | SEC_KEEP;\n  sinfo->stabstr->size = _bfd_stringtab_size (sinfo->strings);\n\n  /* Calculate the `cumulative_skips' array now that stabs have been\n     deleted for this section.  */\n\n  if (skip != 0)\n    {\n      bfd_size_type i, offset;\n      bfd_size_type *pskips;\n\n      amt = count * sizeof (bfd_size_type);\n      secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);\n      if (secinfo->cumulative_skips == NULL)\n\tgoto error_return;\n\n      pskips = secinfo->cumulative_skips;\n      pstridx = secinfo->stridxs;\n      offset = 0;\n\n      for (i = 0; i < count; i++, pskips++, pstridx++)\n\t{\n\t  *pskips = offset;\n\t  if (*pstridx == (bfd_size_type) -1)\n\t    offset += STABSIZE;\n\t}\n\n      BFD_ASSERT (offset != 0);\n    }\n\n  return TRUE;\n\n error_return:\n  if (stabbuf != NULL)\n    free (stabbuf);\n  if (stabstrbuf != NULL)\n    free (stabstrbuf);\n  return FALSE;\n}"
}