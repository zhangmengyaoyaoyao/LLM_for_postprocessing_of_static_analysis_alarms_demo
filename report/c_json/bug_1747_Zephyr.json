{
    "Project": "Zephyr",
    "Tool": "Infer",
    "Bug Type": "Uninitialized Value",
    "Message": "The value read from buffer[_] was never initialized.",
    "Code_line": "\t\t*out++ = buffer[m++] ^ *p++;",
    "Code_function": "int tc_cbc_mode_decrypt(uint8_t *out, unsigned int outlen, const uint8_t *in,\n\t\t\t    unsigned int inlen, const uint8_t *iv,\n\t\t\t    const TCAesKeySched_t sched)\n{\n\n\tuint8_t buffer[TC_AES_BLOCK_SIZE];\n\tconst uint8_t *p;\n\tunsigned int n, m;\n\n\t/* sanity check the inputs */\n\tif (out == (uint8_t *) 0 ||\n\t    in == (const uint8_t *) 0 ||\n\t    sched == (TCAesKeySched_t) 0 ||\n\t    inlen == 0 ||\n\t    outlen == 0 ||\n\t    (inlen % TC_AES_BLOCK_SIZE) != 0 ||\n\t    (outlen % TC_AES_BLOCK_SIZE) != 0 ||\n\t    outlen != inlen) {\n\t\treturn TC_CRYPTO_FAIL;\n\t}\n\n\t/*\n\t * Note that in == iv + ciphertext, i.e. the iv and the ciphertext are\n\t * contiguous. This allows for a very efficient decryption algorithm\n\t * that would not otherwise be possible.\n\t */\n\tp = iv;\n\tfor (n = m = 0; n < outlen; ++n) {\n\t\tif ((n % TC_AES_BLOCK_SIZE) == 0) {\n\t\t\t(void)tc_aes_decrypt(buffer, in, sched);\n\t\t\tin += TC_AES_BLOCK_SIZE;\n\t\t\tm = 0;\n\t\t}\n\t\t*out++ = buffer[m++] ^ *p++;\n\t}\n\n\treturn TC_CRYPTO_SUCCESS;\n}"
}