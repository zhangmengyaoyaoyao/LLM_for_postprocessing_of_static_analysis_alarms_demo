{
    "project": "combine",
    "tool": "Cppcheck",
    "category": "memleakOnRealloc",
    "file": "src/df_options.c",
    "message": "Common realloc mistake: 'replace_ranges' nulled but not freed upon failure",
    "warning_function_name": "expand_delimited_ranges",
    "warning_line": "replace_ranges",
    "warning_context": "void\nexpand_delimited_ranges (out_ranges, range_count)\n     field_range **out_ranges;\n     int *range_count;\n{\n  int i;\n  field_range *replace_ranges;\n  int replace_count;\n\n  replace_ranges = NULL;\n  replace_count = 0;\n\n  for (i = 0; i < *range_count; i++) {\n    if ((*out_ranges)[i].upper_bound != 0\n\t&& (*out_ranges)[i].upper_bound != (*out_ranges)[i].lower_bound) {\n      int j;\n      /* Expand the ranges in the replacement */\n      if (replace_ranges == NULL) {\n\treplace_ranges\n\t  =\n\t  malloc ((i + (*out_ranges)[i].upper_bound\n\t\t   - (*out_ranges)[i].lower_bound + 1) * sizeof (field_range));\n\tif (replace_ranges == NULL) {\n\t  *out_ranges = NULL;\n\t  *range_count = 0;\n\t  return;\n\t  }\n\tif (i > 0)\n\t  memmove (replace_ranges, *out_ranges, i * sizeof (field_range));\n\treplace_count = i;\n\t}\n      else {\n\treplace_ranges\n\t  = realloc (replace_ranges,\n\t\t     (replace_count + (*out_ranges)[i].upper_bound\n\t\t      - (*out_ranges)[i].lower_bound\n\t\t      + 1) * sizeof (field_range));\n\tif (replace_ranges == NULL) {\n\t  *out_ranges = NULL;\n\t  *range_count = 0;\n\t  return;\n\t  }\n\t}\n      for (j = (*out_ranges)[i].lower_bound; j <= (*out_ranges)[i].upper_bound;\n\t   j++) {\n\treplace_count++;\n\treplace_ranges[replace_count - 1].lower_bound = j;\n\treplace_ranges[replace_count - 1].upper_bound = j;\n\treplace_ranges[replace_count - 1].precision\n\t  = (*out_ranges)[i].precision;\n\treplace_ranges[replace_count - 1].format = (*out_ranges)[i].format;\n\t}\n\n      }\n    else if (replace_ranges != NULL) {\n      /* Copy the range to the replacement */\n      replace_ranges\n\t= realloc (replace_ranges, (replace_count + 1) * sizeof (field_range));\n      if (replace_ranges == NULL) {\n\t*out_ranges = NULL;\n\t*range_count = 0;\n\treturn;\n\t}\n      replace_count++;\n      replace_ranges[replace_count - 1].upper_bound\n\t= (*out_ranges)[i].upper_bound;\n      replace_ranges[replace_count - 1].lower_bound\n\t= (*out_ranges)[i].lower_bound;\n      replace_ranges[replace_count - 1].precision = (*out_ranges)[i].precision;\n      replace_ranges[replace_count - 1].format = (*out_ranges)[i].format;\n      }\n    }\n\n  if (replace_ranges != NULL) {\n    *out_ranges = replace_ranges;\n    *range_count = replace_count;\n    }\n\n  return;\n  }\n"
}