{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/archive.c",
    "message": "Offset: [-28, 51] Size: 4064.",
    "warning_function_name": "_bfd_compute_and_write_armap",
    "warning_line": "*(map[orl_count].name) = (char *) bfd_alloc (arch,",
    "warning_context": "     them when done.  */\n  first_name = (char *) bfd_alloc (arch, 1);\n  if (first_name == NULL)\n    goto error_return;\n\n  /* Drop all the files called __.SYMDEF, we're going to make our own.  */\n  while (arch->archive_head\n\t && strcmp (arch->archive_head->filename, \"__.SYMDEF\") == 0)\n    arch->archive_head = arch->archive_head->archive_next;\n\n  /* Map over each element.  */\n  for (current = arch->archive_head;\n       current != NULL;\n       current = current->archive_next, elt_no++)\n    {\n      if (bfd_check_format (current, bfd_object)\n\t  && (bfd_get_file_flags (current) & HAS_SYMS) != 0)\n\t{\n\t  long storage;\n\t  long symcount;\n\t  long src_count;\n\n\t  storage = bfd_get_symtab_upper_bound (current);\n\t  if (storage < 0)\n\t    goto error_return;\n\n\t  if (storage != 0)\n\t    {\n\t      if (storage > syms_max)\n\t\t{\n\t\t  if (syms_max > 0)\n\t\t    free (syms);\n\t\t  syms_max = storage;\n\t\t  syms = (asymbol **) bfd_malloc (syms_max);\n\t\t  if (syms == NULL)\n\t\t    goto error_return;\n\t\t}\n\t      symcount = bfd_canonicalize_symtab (current, syms);\n\t      if (symcount < 0)\n\t\tgoto error_return;\n\n\t      /* Now map over all the symbols, picking out the ones we\n\t\t want.  */\n\t      for (src_count = 0; src_count < symcount; src_count++)\n\t\t{\n\t\t  flagword flags = (syms[src_count])->flags;\n\t\t  asection *sec = syms[src_count]->section;\n\n\t\t  if (((flags & (BSF_GLOBAL\n\t\t\t\t | BSF_WEAK\n\t\t\t\t | BSF_INDIRECT\n\t\t\t\t | BSF_GNU_UNIQUE)) != 0\n\t\t       || bfd_is_com_section (sec))\n\t\t      && ! bfd_is_und_section (sec))\n\t\t    {\n\t\t      bfd_size_type namelen;\n\t\t      struct orl *new_map;\n\n\t\t      /* This symbol will go into the archive header.  */\n\t\t      if (orl_count == orl_max)\n\t\t\t{\n\t\t\t  orl_max *= 2;\n\t\t\t  amt = orl_max * sizeof (struct orl);\n\t\t\t  new_map = (struct orl *) bfd_realloc (map, amt);\n\t\t\t  if (new_map == NULL)\n\t\t\t    goto error_return;\n\n\t\t\t  map = new_map;\n\t\t\t}\n\n\t\t      if (strcmp (syms[src_count]->name, \"__gnu_lto_slim\") == 0)\n\t\t\t(*_bfd_error_handler)\n\t\t\t  (_(\"%s: plugin needed to handle lto object\"),\n\t\t\t   bfd_get_filename (current));\n\t\t      namelen = strlen (syms[src_count]->name);\n\t\t      amt = sizeof (char *);\n\t\t      map[orl_count].name = (char **) bfd_alloc (arch, amt);\n\t\t      if (map[orl_count].name == NULL)\n\t\t\tgoto error_return;\n\t\t      *(map[orl_count].name) = (char *) bfd_alloc (arch,\n\t\t\t\t\t\t\t\t   namelen + 1);\n\t\t      if (*(map[orl_count].name) == NULL)\n\t\t\tgoto error_return;\n\t\t      strcpy (*(map[orl_count].name), syms[src_count]->name);\n\t\t      map[orl_count].u.abfd = current;\n\t\t      map[orl_count].namidx = stridx;\n\n\t\t      stridx += namelen + 1;\n\t\t      ++orl_count;\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* Now ask the BFD to free up any cached information, so we\n\t     don't fill all of memory with symbol tables.  */\n\t  if (! bfd_free_cached_info (current))\n\t    goto error_return;\n\t}\n    }\n\n  /* OK, now we have collected all the data, let's write them out.  */\n"
}