{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "extension/gawkfts.c",
    "message": "Offset: 2 Size: 1 by call to `fts_stat`.",
    "warning_function_name": "fts_read",
    "warning_line": "p->fts_info = fts_stat(sp, p, 1);",
    "warning_context": "\n\t/* Directory in pre-order. */\n\tif (p->fts_info == FTS_D) {\n\t\t/* If skipped or crossed mount point, do post-order visit. */\n\t\tif (instr == FTS_SKIP ||\n\t\t    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {\n\t\t\tif (p->fts_flags & FTS_SYMFOLLOW)\n\t\t\t\t(void)close(p->fts_symfd);\n\t\t\tif (sp->fts_child) {\n\t\t\t\tfts_lfree(sp->fts_child);\n\t\t\t\tsp->fts_child = NULL;\n\t\t\t}\n\t\t\tp->fts_info = FTS_DP;\n\t\t\treturn (p);\n\t\t}\n\n\t\t/* Rebuild if only read the names and now traversing. */\n\t\tif (sp->fts_child && ISSET(FTS_NAMEONLY)) {\n\t\t\tCLR(FTS_NAMEONLY);\n\t\t\tfts_lfree(sp->fts_child);\n\t\t\tsp->fts_child = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */\n\t\tif (sp->fts_child) {\n\t\t\tif (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_flags |= FTS_DONTCHDIR;\n\t\t\t\tfor (p = sp->fts_child; p; p = p->fts_link)\n\t\t\t\t\tp->fts_accpath =\n\t\t\t\t\t    p->fts_parent->fts_accpath;\n\t\t\t}\n\t\t} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n\t\t\tif (ISSET(FTS_STOP))\n\t\t\t\treturn (NULL);\n\t\t\treturn (p);\n\t\t}\n\t\tp = sp->fts_child;\n\t\tsp->fts_child = NULL;\n\t\tgoto name;\n\t}\n\n\t/* Move to the next node on this level. */\nnext:\ttmp = p;\n\tif ((p = p->fts_link) != NULL) {\n\t\tfts_free(tmp);\n\n\t\t/*\n\t\t * If reached the top, return to the original directory, and\n\t\t * load the paths for the next root.\n\t\t */\n\t\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\t\tSET(FTS_STOP);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfts_load(sp, p);\n\t\t\treturn (sp->fts_cur = p);\n\t\t}\n\n\t\t/*\n\t\t * User may have called fts_set on the node.  If skipped,\n\t\t * ignore.  If followed, get a file descriptor so we can\n\t\t * get back if necessary.\n\t\t */\n\t\tif (p->fts_instr == FTS_SKIP)\n\t\t\tgoto next;\n\t\tif (p->fts_instr == FTS_FOLLOW) {\n\t\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\t\tif ((p->fts_symfd =\n\t\t\t\t    open(\".\", O_RDONLY | O_CLOEXEC, 0)) == -1) {\n\t\t\t\t\tp->fts_errno = errno;\n\t\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t\t} else\n\t\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t\t}\n\t\t\tp->fts_instr = FTS_NOINSTR;\n\t\t}\n\nname:\t\tt = sp->fts_path + NAPPEND(p->fts_parent);\n\t\t*t++ = '/';\n\t\tmemmove(t, p->fts_name, (size_t)(p->fts_namelen + 1));\n\t\treturn (sp->fts_cur = p);\n\t}\n\n\t/* Move up to the parent node. */\n\tp = tmp->fts_parent;\n\tfts_free(tmp);\n\n"
}