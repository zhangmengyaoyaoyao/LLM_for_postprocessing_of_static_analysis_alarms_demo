{
    "project": "bash",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "lib/readline/bind.c",
    "message": "Offset: [2, +oo] Size: 2 by call to `rl_macro_bind`.",
    "warning_function_name": NaN,
    "warning_line": "rl_macro_bind (useq, &funname[1], _rl_keymap);",
    "warning_context": "  /* Handle equivalency bindings here.  Make the left-hand side be exactly\n     whatever the right-hand evaluates to, including keymaps. */\n  if (equivalency)\n    {\n      return 0;\n    }\n\n  /* If this is a new-style key-binding, then do the binding with\n     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */\n  if (*string == '\"')\n    {\n      char *seq;\n      register int j, k, passc;\n\n      seq = (char *)xmalloc (1 + strlen (string));\n      for (j = 1, k = passc = 0; string[j]; j++)\n\t{\n\t  /* Allow backslash to quote characters, but leave them in place.\n\t     This allows a string to end with a backslash quoting another\n\t     backslash, or with a backslash quoting a double quote.  The\n\t     backslashes are left in place for rl_translate_keyseq (). */\n\t  if (passc || (string[j] == '\\\\'))\n\t    {\n\t      seq[k++] = string[j];\n\t      passc = !passc;\n\t      continue;\n\t    }\n\n\t  if (string[j] == '\"')\n\t    break;\n\n\t  seq[k++] = string[j];\n\t}\n      seq[k] = '\\0';\n\n      /* Binding macro? */\n      if (*funname == '\\'' || *funname == '\"')\n\t{\n\t  j = strlen (funname);\n\n\t  /* Remove the delimiting quotes from each end of FUNNAME. */\n\t  if (j && funname[j - 1] == *funname)\n\t    funname[j - 1] = '\\0';\n\n\t  rl_macro_bind (seq, &funname[1], _rl_keymap);\n\t}\n      else\n\trl_bind_keyseq (seq, rl_named_function (funname));\n\n      xfree (seq);\n      return 0;\n    }\n\n  /* Get the actual character we want to deal with. */\n  kname = strrchr (string, '-');\n  if (kname == 0)\n    kname = string;\n  else\n    kname++;\n\n  key = glean_key_from_name (kname);\n\n  /* Add in control and meta bits. */\n  if (substring_member_of_array (string, _rl_possible_control_prefixes))\n    key = CTRL (_rl_to_upper (key));\n\n  if (substring_member_of_array (string, _rl_possible_meta_prefixes))\n    key = META (key);\n\n  /* Temporary.  Handle old-style keyname with macro-binding. */\n  if (*funname == '\\'' || *funname == '\"')\n    {\n      char useq[2];\n      int fl = strlen (funname);\n\n      useq[0] = key; useq[1] = '\\0';\n      if (fl && funname[fl - 1] == *funname)\n\tfunname[fl - 1] = '\\0';\n\n      rl_macro_bind (useq, &funname[1], _rl_keymap);\n    }\n#if defined (PREFIX_META_HACK)\n  /* Ugly, but working hack to keep prefix-meta around. */\n  else if (_rl_stricmp (funname, \"prefix-meta\") == 0)\n    {\n      char seq[2];\n\n      seq[0] = key;\n      seq[1] = '\\0';\n      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);\n    }\n#endif /* PREFIX_META_HACK */\n  else\n    rl_bind_key (key, rl_named_function (funname));\n  return 0;\n}\n\n/* Simple structure for boolean readline variables (i.e., those that can\n   have one of two values; either \"On\" or 1 for truth, or \"Off\" or 0 for\n   false. */\n\n"
}