{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/stabs.c",
    "message": "Offset added: [-20, 45] (⇐ [-21, 44] + 1) Size: 4064 by call to `_bfd_stringtab_add`.",
    "warning_function_name": "_bfd_link_section_stabs",
    "warning_line": "(void) _bfd_stringtab_add (sinfo->strings, \"\", TRUE, TRUE);",
    "warning_context": "bfd_boolean\n_bfd_link_section_stabs (bfd *abfd,\n\t\t\t struct stab_info *sinfo,\n\t\t\t asection *stabsec,\n\t\t\t asection *stabstrsec,\n\t\t\t void * *psecinfo,\n\t\t\t bfd_size_type *pstring_offset)\n{\n  bfd_boolean first;\n  bfd_size_type count, amt;\n  struct stab_section_info *secinfo;\n  bfd_byte *stabbuf = NULL;\n  bfd_byte *stabstrbuf = NULL;\n  bfd_byte *sym, *symend;\n  bfd_size_type stroff, next_stroff, skip;\n  bfd_size_type *pstridx;\n\n  if (stabsec->size == 0\n      || stabstrsec->size == 0)\n    /* This file does not contain stabs debugging information.  */\n    return TRUE;\n\n  if (stabsec->size % STABSIZE != 0)\n    /* Something is wrong with the format of these stab symbols.\n       Don't try to optimize them.  */\n    return TRUE;\n\n  if ((stabstrsec->flags & SEC_RELOC) != 0)\n    /* We shouldn't see relocations in the strings, and we aren't\n       prepared to handle them.  */\n    return TRUE;\n\n  if (bfd_is_abs_section (stabsec->output_section)\n      || bfd_is_abs_section (stabstrsec->output_section))\n    /* At least one of the sections is being discarded from the\n       link, so we should just ignore them.  */\n    return TRUE;\n\n  first = FALSE;\n\n  if (sinfo->stabstr == NULL)\n    {\n      flagword flags;\n\n      /* Initialize the stabs information we need to keep track of.  */\n      first = TRUE;\n      sinfo->strings = _bfd_stringtab_init ();\n      if (sinfo->strings == NULL)\n\tgoto error_return;\n      /* Make sure the first byte is zero.  */\n      (void) _bfd_stringtab_add (sinfo->strings, \"\", TRUE, TRUE);\n      if (! bfd_hash_table_init (&sinfo->includes,\n\t\t\t\t stab_link_includes_newfunc,\n\t\t\t\t sizeof (struct stab_link_includes_entry)))\n\tgoto error_return;\n      flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING\n\t       | SEC_LINKER_CREATED);\n      sinfo->stabstr = bfd_make_section_anyway_with_flags (abfd, \".stabstr\",\n\t\t\t\t\t\t\t   flags);\n      if (sinfo->stabstr == NULL)\n\tgoto error_return;\n    }\n\n  /* Initialize the information we are going to store for this .stab\n     section.  */\n  count = stabsec->size / STABSIZE;\n\n  amt = sizeof (struct stab_section_info);\n  amt += (count - 1) * sizeof (bfd_size_type);\n  *psecinfo = bfd_alloc (abfd, amt);\n  if (*psecinfo == NULL)\n    goto error_return;\n\n  secinfo = (struct stab_section_info *) *psecinfo;\n  secinfo->excls = NULL;\n  stabsec->rawsize = stabsec->size;\n  secinfo->cumulative_skips = NULL;\n  memset (secinfo->stridxs, 0, (size_t) count * sizeof (bfd_size_type));\n\n  /* Read the stabs information from abfd.  */\n  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf)\n      || !bfd_malloc_and_get_section (abfd, stabstrsec, &stabstrbuf))\n    goto error_return;\n\n  /* Look through the stabs symbols, work out the new string indices,\n     and identify N_BINCL symbols which can be eliminated.  */\n  stroff = 0;\n  /* The stabs sections can be split when\n     -split-by-reloc/-split-by-file is used.  We must keep track of\n     each stab section's place in the single concatenated string\n     table.  */\n  next_stroff = pstring_offset ? *pstring_offset : 0;\n  skip = 0;\n\n  symend = stabbuf + stabsec->size;\n  for (sym = stabbuf, pstridx = secinfo->stridxs;\n       sym < symend;\n       sym += STABSIZE, ++pstridx)\n    {\n      bfd_size_type symstroff;\n      int type;\n"
}