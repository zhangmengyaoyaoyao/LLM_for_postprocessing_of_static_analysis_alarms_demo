{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "\t\t\tfd = devopen(fname, binmode(\"r\"));",
    "Code_function": "nextfile(IOBUF **curfile, bool skipping)\n{\n\tstatic long i = 1;\n\tstatic bool files = false;\n\tNODE *arg, *tmp;\n\tconst char *fname;\n\tint fd = INVALID_HANDLE;\n\tint errcode = 0;\n\tIOBUF *iop = *curfile;\n\tlong argc;\n\n\tif (skipping) {\t\t\t/* for 'nextfile' call */\n\t\terrcode = 0;\n\t\tif (iop != NULL) {\n\t\t\terrcode = iop->errcode;\n\t\t\t(void) iop_close(iop);\n\t\t}\n\t\t*curfile = NULL;\n\t\treturn (errcode == 0);\n\t}\n\n\tif (iop != NULL) {\n\t\tif (at_eof(iop)) {\n\t\t\tassert(iop->public.fd != INVALID_HANDLE);\n\t\t\t(void) iop_close(iop);\n\t\t\t*curfile = NULL;\n\t\t\treturn 1;\t/* run endfile block */\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\targc = get_number_si(ARGC_node->var_value);\n\n\tfor (; i < argc; i++) {\n\t\ttmp = make_number((AWKNUM) i);\n\t\t(void) force_string(tmp);\n\t\targ = in_array(ARGV_node, tmp);\n\t\tunref(tmp);\n\t\tif (arg == NULL || arg->stlen == 0)\n\t\t\tcontinue;\n\t\targ = force_string(arg);\n\t\targ->stptr[arg->stlen] = '\\0';\n\t\tif (! do_traditional) {\n\t\t\tunref(ARGIND_node->var_value);\n\t\t\tARGIND_node->var_value = make_number((AWKNUM) i);\n\t\t}\n\n\t\tif (! arg_assign(arg->stptr, false)) {\n\t\t\tfiles = true;\n\t\t\tfname = arg->stptr;\n\n\t\t\t/* manage the awk variables: */\n\t\t\tunref(FILENAME_node->var_value);\n\t\t\tFILENAME_node->var_value = dupnode(arg);\n#ifdef HAVE_MPFR\n\t\t\tif (is_mpg_number(FNR_node->var_value))\n\t\t\t\tmpz_set_ui(MFNR, 0);\n#endif\n\t\t\tFNR = 0;\n\n\t\t\t/* IOBUF management: */\n\t\t\terrno = 0;\n\t\t\tfd = devopen(fname, binmode(\"r\"));\n\t\t\tif (fd == INVALID_HANDLE && errno == EMFILE) {\n\t\t\t\tclose_one();\n\t\t\t\tclose_one();\n\t\t\t\tfd = devopen(fname, binmode(\"r\"));\n\t\t\t}\n\t\t\terrcode = errno;\n\t\t\tif (! do_traditional)\n\t\t\t\tupdate_ERRNO_int(errno);\n\t\t\tiop = iop_alloc(fd, fname, errcode);\n\t\t\t*curfile = iop_finish(iop);\n\t\t\tif (iop->public.fd == INVALID_HANDLE)\n\t\t\t\tiop->errcode = errcode;\n\t\t\telse if (iop->valid)\n\t\t\t\tiop->errcode = 0;\n\n\t\t\tif (! do_traditional && iop->errcode != 0)\n\t\t\t\tupdate_ERRNO_int(iop->errcode);\n\n\t\t\treturn ++i;\t/* run beginfile block */\n\t\t}\n\t}\n\n\tif (files == false) {\n\t\tfiles = true;\n\t\t/* no args. -- use stdin */\n\t\t/* FNR is init'ed to 0 */\n\t\terrno = 0;\n\t\tif (! do_traditional)\n\t\t\tupdate_ERRNO_int(errno);\n\n\t\tunref(FILENAME_node->var_value);\n\t\tFILENAME_node->var_value = make_string(\"-\", 1);\n\t\tFILENAME_node->var_value->flags |= MAYBE_NUM; /* be pedantic */\n\t\tfname = \"-\";\n\t\tiop = iop_alloc(fileno(stdin), fname, 0);\n\t\t*curfile = iop_finish(iop);\n\n\t\tif (iop->public.fd == INVALID_HANDLE) {\n\t\t\terrcode = errno;\n\t\t\terrno = 0;\n\t\t\tupdate_ERRNO_int(errno);\n\t\t\t(void) iop_close(iop);\n\t\t\t*curfile = NULL;\n\t\t\tfatal(_(\"cannot open file `%s' for reading (%s)\"),\n\t\t\t\t\tfname, strerror(errcode));\n\t\t}\n\t\treturn ++i;\t/* run beginfile block */\n\t}\n\n\treturn -1;\t/* end of input, run end block or Op_atexit */\n}"
}