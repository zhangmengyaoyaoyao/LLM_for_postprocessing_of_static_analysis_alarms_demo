{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "      rl_macro_bind (useq, &funname[1], _rl_keymap);",
    "Code_function": "rl_parse_and_bind (string)\n     char *string;\n{\n  char *funname, *kname;\n  register int c, i;\n  int key, equivalency;\n\n  while (string && whitespace (*string))\n    string++;\n\n  if (string == 0 || *string == 0 || *string == '#')\n    return 0;\n\n  /* If this is a parser directive, act on it. */\n  if (*string == '$')\n    {\n      handle_parser_directive (&string[1]);\n      return 0;\n    }\n\n  /* If we aren't supposed to be parsing right now, then we're done. */\n  if (_rl_parsing_conditionalized_out)\n    return 0;\n\n  i = 0;\n  /* If this keyname is a complex key expression surrounded by quotes,\n     advance to after the matching close quote.  This code allows the\n     backslash to quote characters in the key expression. */\n  if (*string == '\"')\n    {\n      i = _rl_skip_to_delim (string, 1, '\"');\n\n      /* If we didn't find a closing quote, abort the line. */\n      if (string[i] == '\\0')\n        {\n          _rl_init_file_error (\"no closing `\\\"' in key binding\");\n          return 1;\n        }\n      else\n        i++;\t/* skip past closing double quote */\n    }\n\n  /* Advance to the colon (:) or whitespace which separates the two objects. */\n  for (; (c = string[i]) && c != ':' && c != ' ' && c != '\\t'; i++ );\n\n  equivalency = (c == ':' && string[i + 1] == '=');\n\n  /* Mark the end of the command (or keyname). */\n  if (string[i])\n    string[i++] = '\\0';\n\n  /* If doing assignment, skip the '=' sign as well. */\n  if (equivalency)\n    string[i++] = '\\0';\n\n  /* If this is a command to set a variable, then do that. */\n  if (_rl_stricmp (string, \"set\") == 0)\n    {\n      char *var, *value, *e;\n      int s;\n\n      var = string + i;\n      /* Make VAR point to start of variable name. */\n      while (*var && whitespace (*var)) var++;\n\n      /* Make VALUE point to start of value string. */\n      value = var;\n      while (*value && whitespace (*value) == 0) value++;\n      if (*value)\n\t*value++ = '\\0';\n      while (*value && whitespace (*value)) value++;\n\n      /* Strip trailing whitespace from values of boolean variables. */\n      if (find_boolean_var (var) >= 0)\n\t{\n\t  /* remove trailing whitespace */\nremove_trailing:\n\t  e = value + strlen (value) - 1;\n\t  while (e >= value && whitespace (*e))\n\t    e--;\n\t  e++;\t\t/* skip back to whitespace or EOS */\n\n\t  if (*e && e >= value)\n\t    *e = '\\0';\n\t}\n      else if ((i = find_string_var (var)) >= 0)\n\t{\n\t  /* Allow quoted strings in variable values */\n\t  if (*value == '\"')\n\t    {\n\t      i = _rl_skip_to_delim (value, 1, *value);\n\t      value[i] = '\\0';\n\t      value++;\t/* skip past the quote */\n\t    }\n\t  else\n\t    goto remove_trailing;\n\t}\n\n      rl_variable_bind (var, value);\n      return 0;\n    }\n\n  /* Skip any whitespace between keyname and funname. */\n  for (; string[i] && whitespace (string[i]); i++);\n  funname = &string[i];\n\n  /* Now isolate funname.\n     For straight function names just look for whitespace, since\n     that will signify the end of the string.  But this could be a\n     macro definition.  In that case, the string is quoted, so skip\n     to the matching delimiter.  We allow the backslash to quote the\n     delimiter characters in the macro body. */\n  /* This code exists to allow whitespace in macro expansions, which\n     would otherwise be gobbled up by the next `for' loop.*/\n  /* XXX - it may be desirable to allow backslash quoting only if \" is\n     the quoted string delimiter, like the shell. */\n  if (*funname == '\\'' || *funname == '\"')\n    {\n      i = _rl_skip_to_delim (string, i+1, *funname);\n      if (string[i])\n\ti++;\n    }\n\n  /* Advance to the end of the string.  */\n  for (; string[i] && whitespace (string[i]) == 0; i++);\n\n  /* No extra whitespace at the end of the string. */\n  string[i] = '\\0';\n\n  /* Handle equivalency bindings here.  Make the left-hand side be exactly\n     whatever the right-hand evaluates to, including keymaps. */\n  if (equivalency)\n    {\n      return 0;\n    }\n\n  /* If this is a new-style key-binding, then do the binding with\n     rl_bind_keyseq ().  Otherwise, let the older code deal with it. */\n  if (*string == '\"')\n    {\n      char *seq;\n      register int j, k, passc;\n\n      seq = (char *)xmalloc (1 + strlen (string));\n      for (j = 1, k = passc = 0; string[j]; j++)\n\t{\n\t  /* Allow backslash to quote characters, but leave them in place.\n\t     This allows a string to end with a backslash quoting another\n\t     backslash, or with a backslash quoting a double quote.  The\n\t     backslashes are left in place for rl_translate_keyseq (). */\n\t  if (passc || (string[j] == '\\\\'))\n\t    {\n\t      seq[k++] = string[j];\n\t      passc = !passc;\n\t      continue;\n\t    }\n\n\t  if (string[j] == '\"')\n\t    break;\n\n\t  seq[k++] = string[j];\n\t}\n      seq[k] = '\\0';\n\n      /* Binding macro? */\n      if (*funname == '\\'' || *funname == '\"')\n\t{\n\t  j = strlen (funname);\n\n\t  /* Remove the delimiting quotes from each end of FUNNAME. */\n\t  if (j && funname[j - 1] == *funname)\n\t    funname[j - 1] = '\\0';\n\n\t  rl_macro_bind (seq, &funname[1], _rl_keymap);\n\t}\n      else\n\trl_bind_keyseq (seq, rl_named_function (funname));\n\n      xfree (seq);\n      return 0;\n    }\n\n  /* Get the actual character we want to deal with. */\n  kname = strrchr (string, '-');\n  if (kname == 0)\n    kname = string;\n  else\n    kname++;\n\n  key = glean_key_from_name (kname);\n\n  /* Add in control and meta bits. */\n  if (substring_member_of_array (string, _rl_possible_control_prefixes))\n    key = CTRL (_rl_to_upper (key));\n\n  if (substring_member_of_array (string, _rl_possible_meta_prefixes))\n    key = META (key);\n\n  /* Temporary.  Handle old-style keyname with macro-binding. */\n  if (*funname == '\\'' || *funname == '\"')\n    {\n      char useq[2];\n      int fl = strlen (funname);\n\n      useq[0] = key; useq[1] = '\\0';\n      if (fl && funname[fl - 1] == *funname)\n\tfunname[fl - 1] = '\\0';\n\n      rl_macro_bind (useq, &funname[1], _rl_keymap);\n    }\n#if defined (PREFIX_META_HACK)\n  /* Ugly, but working hack to keep prefix-meta around. */\n  else if (_rl_stricmp (funname, \"prefix-meta\") == 0)\n    {\n      char seq[2];\n\n      seq[0] = key;\n      seq[1] = '\\0';\n      rl_generic_bind (ISKMAP, seq, (char *)emacs_meta_keymap, _rl_keymap);\n    }\n#endif /* PREFIX_META_HACK */\n  else\n    rl_bind_key (key, rl_named_function (funname));\n  return 0;\n}"
}