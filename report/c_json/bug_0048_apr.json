{
    "Project": "apr",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "tables/apr_hash.c",
    "message": "Dereference of null pointer",
    "warning_function_name": "apr_hash_merge",
    "warning_line": "new_vals[j].klen = iter->klen;",
    "warning_context": "APR_DECLARE(apr_hash_t *) apr_hash_merge(apr_pool_t *p,\n                                         const apr_hash_t *overlay,\n                                         const apr_hash_t *base,\n                                         void * (*merger)(apr_pool_t *p,\n                                                     const void *key,\n                                                     apr_ssize_t klen,\n                                                     const void *h1_val,\n                                                     const void *h2_val,\n                                                     const void *data),\n                                         const void *data)\n{\n    apr_hash_t *res;\n    apr_hash_entry_t *new_vals = NULL;\n    apr_hash_entry_t *iter;\n    apr_hash_entry_t *ent;\n    unsigned int i, j, k, hash;\n\n#if APR_POOL_DEBUG\n    /* we don't copy keys and values, so it's necessary that\n     * overlay->a.pool and base->a.pool have a life span at least\n     * as long as p\n     */\n    if (!apr_pool_is_ancestor(overlay->pool, p)) {\n        fprintf(stderr,\n                \"apr_hash_merge: overlay's pool is not an ancestor of p\\n\");\n        abort();\n    }\n    if (!apr_pool_is_ancestor(base->pool, p)) {\n        fprintf(stderr,\n                \"apr_hash_merge: base's pool is not an ancestor of p\\n\");\n        abort();\n    }\n#endif\n\n    res = apr_palloc(p, sizeof(apr_hash_t));\n    res->pool = p;\n    res->free = NULL;\n    res->hash_func = base->hash_func;\n    res->count = base->count;\n    res->max = (overlay->max > base->max) ? overlay->max : base->max;\n    if (base->count + overlay->count > res->max) {\n        res->max = res->max * 2 + 1;\n    }\n    res->seed = base->seed;\n    res->array = alloc_array(res, res->max);\n    if (base->count + overlay->count) {\n        new_vals = apr_palloc(p, sizeof(apr_hash_entry_t) *\n                              (base->count + overlay->count));\n    }\n    j = 0;\n    for (k = 0; k <= base->max; k++) {\n        for (iter = base->array[k]; iter; iter = iter->next) {\n            i = iter->hash & res->max;\n            new_vals[j].klen = iter->klen;\n            new_vals[j].key = iter->key;\n            new_vals[j].val = iter->val;\n            new_vals[j].hash = iter->hash;\n            new_vals[j].next = res->array[i];\n            res->array[i] = &new_vals[j];\n            j++;\n        }\n    }\n\n    for (k = 0; k <= overlay->max; k++) {\n        for (iter = overlay->array[k]; iter; iter = iter->next) {\n            if (res->hash_func)\n                hash = res->hash_func(iter->key, &iter->klen);\n            else\n                hash = hashfunc_default(iter->key, &iter->klen, res->seed);\n            i = hash & res->max;\n            for (ent = res->array[i]; ent; ent = ent->next) {\n                if ((ent->klen == iter->klen) &&\n                    (memcmp(ent->key, iter->key, iter->klen) == 0)) {\n                    if (merger) {\n                        ent->val = (*merger)(p, iter->key, iter->klen,\n                                             iter->val, ent->val, data);\n                    }\n                    else {\n                        ent->val = iter->val;\n                    }\n                    break;\n                }\n            }\n            if (!ent) {\n                new_vals[j].klen = iter->klen;\n                new_vals[j].key = iter->key;\n                new_vals[j].val = iter->val;\n                new_vals[j].hash = hash;\n                new_vals[j].next = res->array[i];\n                res->array[i] = &new_vals[j];\n                res->count++;\n                j++;\n            }\n        }\n    }\n    return res;\n}\n"
}