{
    "project": "gawk",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "re.c",
    "message": "Dereference of null pointer",
    "warning_function_name": "make_regexp",
    "warning_line": "*dest++ = c;",
    "warning_context": "\n\tif (first) {\n\t\tfirst = false;\n\t\t/* for debugging and testing */\n\t\tno_dfa = (getenv(\"GAWK_NO_DFA\") != NULL);\n\t}\n\n\t/* always check */\n\tcheck_bracket_exp((char *) s, len);\n\n\t/* Handle escaped characters first. */\n\n\t/*\n\t * Build a copy of the string (in buf) with the\n\t * escaped characters translated, and generate the regex\n\t * from that. \n\t */\n\tif (buf == NULL) {\n\t\temalloc(buf, char *, len + 2, \"make_regexp\");\n\t\tbuflen = len;\n\t} else if (len > buflen) {\n\t\terealloc(buf, char *, len + 2, \"make_regexp\");\n\t\tbuflen = len;\n\t}\n\tdest = buf;\n\n\twhile (src < end) {\n\t\tif (gawk_mb_cur_max > 1 && ! is_multibyte) {\n\t\t\t/* The previous byte is a singlebyte character, or last byte\n\t\t\t   of a multibyte character.  We check the next character.  */\n\t\t\tis_multibyte = mbrlen(src, end - src, &mbs);\n\t\t\tif (   is_multibyte == 1\n\t\t\t    || is_multibyte == (size_t) -1\n\t\t\t    || is_multibyte == (size_t) -2\n\t\t\t    || is_multibyte == 0) {\n\t\t\t\t/* We treat it as a single-byte character.  */\n\t\t\t\tis_multibyte = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* We skip multibyte character, since it must not be a special\n\t\t   character.  */\n\t\tif ((gawk_mb_cur_max == 1 || ! is_multibyte) &&\n\t\t    (*src == '\\\\')) {\n\t\t\tc = *++src;\n\t\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\tcase 'b':\n\t\t\tcase 'f':\n\t\t\tcase 'n':\n\t\t\tcase 'r':\n\t\t\tcase 't':\n\t\t\tcase 'v':\n\t\t\tcase 'x':\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tc2 = parse_escape(&src);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tcant_happen();\n\t\t\t\t/*\n\t\t\t\t * Unix awk treats octal (and hex?) chars\n\t\t\t\t * literally in re's, so escape regexp\n\t\t\t\t * metacharacters.\n\t\t\t\t */\n\t\t\t\tif (do_traditional\n\t\t\t\t    && ! do_posix\n\t\t\t\t    && (isdigit(c) || c == 'x')\n\t\t\t\t    && strchr(\"()|*+?.^$\\\\[]\", c2) != NULL)\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c2;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\tcase '9':\t/* a\\9b not valid */\n\t\t\t\t*dest++ = c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\tcase 'y':\t/* normally \\b */\n\t\t\t\t/* gnu regex op */\n\t\t\t\tif (! do_traditional) {\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t\t*dest++ = 'b';\n\t\t\t\t\tsrc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else, fall through */\n\t\t\tdefault:\n\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\t} /* switch */\n\t\t} else {\n\t\t\tc = *src;\n\t\t\tif (c == '^' || c == '$')\n\t\t\t\thas_anchor = true;\n"
}