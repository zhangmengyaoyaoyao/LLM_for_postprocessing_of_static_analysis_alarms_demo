{
    "project": "diffutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/analyze.c",
    "message": "The value read from changes was never initialized.",
    "warning_function_name": "diff_2_files",
    "warning_line": "changes = briefly_report (changes, cmp->file);",
    "warning_context": "int\ndiff_2_files (struct comparison *cmp)\n{\n  int f;\n  struct change *e, *p;\n  struct change *script;\n  int changes;\n\n\n  /* If we have detected that either file is binary,\n     compare the two files as binary.  This can happen\n     only when the first chunk is read.\n     Also, --brief without any --ignore-* options means\n     we can speed things up by treating the files as binary.  */\n\n  if (read_files (cmp->file, files_can_be_treated_as_binary))\n    {\n      /* Files with different lengths must be different.  */\n      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size\n\t  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))\n\t  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))\n\tchanges = 1;\n\n      /* Standard input equals itself.  */\n      else if (cmp->file[0].desc == cmp->file[1].desc)\n\tchanges = 0;\n\n      else\n\t/* Scan both files, a buffer at a time, looking for a difference.  */\n\t{\n\t  /* Allocate same-sized buffers for both files.  */\n\t  size_t lcm_max = PTRDIFF_MAX - 1;\n\t  size_t buffer_size =\n\t    buffer_lcm (sizeof (word),\n\t\t\tbuffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),\n\t\t\t\t    STAT_BLOCKSIZE (cmp->file[1].stat),\n\t\t\t\t    lcm_max),\n\t\t\tlcm_max);\n\t  for (f = 0; f < 2; f++)\n\t    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);\n\n\t  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)\n\t    {\n\t      /* Read a buffer's worth from both files.  */\n\t      for (f = 0; f < 2; f++)\n\t\tif (0 <= cmp->file[f].desc)\n\t\t  file_block_read (&cmp->file[f],\n\t\t\t\t   buffer_size - cmp->file[f].buffered);\n\n\t      /* If the buffers differ, the files differ.  */\n\t      if (cmp->file[0].buffered != cmp->file[1].buffered\n\t\t  || memcmp (cmp->file[0].buffer,\n\t\t\t     cmp->file[1].buffer,\n\t\t\t     cmp->file[0].buffered))\n\t\t{\n\t\t  changes = 1;\n\t\t  break;\n\t\t}\n\n\t      /* If we reach end of file, the files are the same.  */\n\t      if (cmp->file[0].buffered != buffer_size)\n\t\t{\n\t\t  changes = 0;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      changes = briefly_report (changes, cmp->file);\n    }\n  else\n    {\n      struct context ctxt;\n      lin diags;\n      lin too_expensive;\n\n      /* Allocate vectors for the results of comparison:\n\t a flag for each line of each file, saying whether that line\n\t is an insertion or deletion.\n\t Allocate an extra element, always 0, at each end of each vector.  */\n\n      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;\n      char *flag_space = zalloc (s);\n      cmp->file[0].changed = flag_space + 1;\n      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;\n\n      /* Some lines are obviously insertions or deletions\n\t because they don't match anything.  Detect them now, and\n\t avoid even thinking about them in the main comparison algorithm.  */\n\n      discard_confusing_lines (cmp->file);\n\n      /* Now do the main comparison algorithm, considering just the\n\t undiscarded lines.  */\n\n      ctxt.xvec = cmp->file[0].undiscarded;\n      ctxt.yvec = cmp->file[1].undiscarded;\n      diags = (cmp->file[0].nondiscarded_lines\n\t       + cmp->file[1].nondiscarded_lines + 3);\n      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));\n      ctxt.bdiag = ctxt.fdiag + diags;\n"
}