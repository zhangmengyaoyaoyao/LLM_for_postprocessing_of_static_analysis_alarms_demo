{
    "project": "binutils",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "ld/ldwrite.c",
    "message": "pointer `link_order` last assigned on line 58 could be null and is dereferenced at line 62, column 2.",
    "warning_function_name": "build_link_order",
    "warning_line": "link_order->type = bfd_data_link_order;",
    "warning_context": "static void\nbuild_link_order (lang_statement_union_type *statement)\n{\n  switch (statement->header.type)\n    {\n    case lang_data_statement_enum:\n      {\n\tasection *output_section;\n\tstruct bfd_link_order *link_order;\n\tbfd_vma value;\n\tbfd_boolean big_endian = FALSE;\n\n\toutput_section = statement->data_statement.output_section;\n\tASSERT (output_section->owner == link_info.output_bfd);\n\n\tif (!((output_section->flags & SEC_HAS_CONTENTS) != 0\n\t      || ((output_section->flags & SEC_LOAD) != 0\n\t\t  && (output_section->flags & SEC_THREAD_LOCAL))))\n\t  break;\n\n\tlink_order = bfd_new_link_order (link_info.output_bfd, output_section);\n\tif (link_order == NULL)\n\t  einfo (_(\"%P%F: bfd_new_link_order failed\\n\"));\n\n\tlink_order->type = bfd_data_link_order;\n\tlink_order->offset = statement->data_statement.output_offset;\n\tlink_order->u.data.contents = (bfd_byte *) xmalloc (QUAD_SIZE);\n\n\tvalue = statement->data_statement.value;\n\n\t/* If the endianness of the output BFD is not known, then we\n\t   base the endianness of the data on the first input file.\n\t   By convention, the bfd_put routines for an unknown\n\t   endianness are big endian, so we must swap here if the\n\t   input file is little endian.  */\n\tif (bfd_big_endian (link_info.output_bfd))\n\t  big_endian = TRUE;\n\telse if (bfd_little_endian (link_info.output_bfd))\n\t  big_endian = FALSE;\n\telse\n\t  {\n\t    bfd_boolean swap;\n\n\t    swap = FALSE;\n\t    if (command_line.endian == ENDIAN_BIG)\n\t      big_endian = TRUE;\n\t    else if (command_line.endian == ENDIAN_LITTLE)\n\t      {\n\t\tbig_endian = FALSE;\n\t\tswap = TRUE;\n\t      }\n\t    else if (command_line.endian == ENDIAN_UNSET)\n\t      {\n\t\tbig_endian = TRUE;\n\t\t{\n\t\t  LANG_FOR_EACH_INPUT_STATEMENT (s)\n\t\t    {\n\t\t      if (s->the_bfd != NULL)\n\t\t\t{\n\t\t\t  if (bfd_little_endian (s->the_bfd))\n\t\t\t    {\n\t\t\t      big_endian = FALSE;\n\t\t\t      swap = TRUE;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      }\n\n\t    if (swap)\n\t      {\n\t\tbfd_byte buffer[8];\n\n\t\tswitch (statement->data_statement.type)\n\t\t  {\n\t\t  case QUAD:\n\t\t  case SQUAD:\n\t\t    if (sizeof (bfd_vma) >= QUAD_SIZE)\n\t\t      {\n\t\t\tbfd_putl64 (value, buffer);\n\t\t\tvalue = bfd_getb64 (buffer);\n\t\t\tbreak;\n\t\t      }\n\t\t    /* Fall through.  */\n\t\t  case LONG:\n\t\t    bfd_putl32 (value, buffer);\n\t\t    value = bfd_getb32 (buffer);\n\t\t    break;\n\t\t  case SHORT:\n\t\t    bfd_putl16 (value, buffer);\n\t\t    value = bfd_getb16 (buffer);\n\t\t    break;\n\t\t  case BYTE:\n\t\t    break;\n\t\t  default:\n\t\t    abort ();\n\t\t  }\n\t      }\n\t  }\n\n"
}