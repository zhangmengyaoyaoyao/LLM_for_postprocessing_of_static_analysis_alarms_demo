{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "main.c",
    "message": "Array access (from variable 'optarg') results in a null pointer dereference",
    "warning_function_name": "parse_args",
    "warning_line": "if (optarg[0] == '\\0')",
    "warning_context": "\t/*\n\t * The + on the front tells GNU getopt not to rearrange argv.\n\t */\n\tconst char *optlist = \"+F:f:v:W;bcCd::D::e:E:ghi:l:L:nNo::Op::MPrStVYZ:\";\n\tint old_optind;\n\tint c;\n\tchar *scan;\n\tchar *src;\n\n\t/* we do error messages ourselves on invalid options */\n\topterr = false;\n\n\t/* copy argv before getopt gets to it; used to restart the debugger */  \n\tsave_argv(argc, argv);\n\n\t/* option processing. ready, set, go! */\n\tfor (optopt = 0, old_optind = 1;\n\t     (c = getopt_long(argc, argv, optlist, optab, NULL)) != EOF;\n\t     optopt = 0, old_optind = optind) {\n\t\tif (do_posix)\n\t\t\topterr = true;\n\n\t\tswitch (c) {\n\t\tcase 'F':\n\t\t\tadd_preassign(PRE_ASSIGN_FS, optarg);\n\t\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tdisallow_var_assigns = true;\n\t\t\t/* fall through */\n\t\tcase 'f':\n\t\t\t/*\n\t\t\t * Allow multiple -f options.\n\t\t\t * This makes function libraries real easy.\n\t\t\t * Most of the magic is in the scanner.\n\t\t\t *\n\t\t\t * The following is to allow for whitespace at the end\n\t\t\t * of a #! /bin/gawk line in an executable file\n\t\t\t */\n\t\t\tscan = optarg;\n\t\t\tif (argv[optind-1] != optarg)\n\t\t\t\twhile (isspace((unsigned char) *scan))\n\t\t\t\t\tscan++;\n\t\t\tsrc = (*scan == '\\0' ? argv[optind++] : optarg);\n\t\t\t(void) add_srcfile((src && src[0] == '-' && src[1] == '\\0') ?\n\t\t\t\t\tSRC_STDIN : SRC_FILE,\n\t\t\t\t\tsrc, srcfiles, NULL, NULL);\n\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tadd_preassign(PRE_ASSIGN, optarg);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tdo_binary = true;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tdo_flags |= DO_TRADITIONAL;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tcopyleft();\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdo_flags |= DO_DUMP_VARS;\n\t\t\tif (optarg != NULL && optarg[0] != '\\0')\n\t\t\t\tvarfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tdo_flags |= DO_DEBUG;\n\t\t\tif (optarg != NULL && optarg[0] != '\\0')\n\t\t\t\tcommand_file = optarg;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tif (optarg[0] == '\\0')\n\t\t\t\twarning(_(\"empty argument to `-e/--source' ignored\"));\n\t\t\telse\n\t\t\t\t(void) add_srcfile(SRC_CMDLINE, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\tdo_flags |= DO_INTL;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t/* write usage to stdout, per GNU coding stds */\n\t\t\tusage(EXIT_SUCCESS, stdout);\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\t(void) add_srcfile(SRC_INC, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\t(void) add_srcfile(SRC_EXTLIB, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n"
}