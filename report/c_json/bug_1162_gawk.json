{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "io.c",
    "message": "Offset: [1, 2] Size: [2, 3] by call to `devopen`.",
    "warning_function_name": "redirect",
    "warning_line": "fd = devopen(str, mode);",
    "warning_context": "\n\twhile (rp->output.fp == NULL && rp->iop == NULL) {\n\t\tif (! new_rp && (rp->flag & RED_EOF) != 0) {\n\t\t\t/*\n\t\t\t * Encountered EOF on file or pipe -- must be cleared\n\t\t\t * by explicit close() before reading more\n\t\t\t */\n\t\t\tsave_rp = NULL;\n\t\t\treturn rp;\n\t\t}\n\t\tmode = NULL;\n\t\terrno = 0;\n\t\tswitch (redirtype) {\n\t\tcase redirect_output:\n\t\t\tmode = binmode(\"w\");\n\t\t\tif ((rp->flag & RED_USED) != 0)\n\t\t\t\tmode = (rp->mode[1] == 'b') ? \"ab\" : \"a\";\n\t\t\tbreak;\n\t\tcase redirect_append:\n\t\t\tmode = binmode(\"a\");\n\t\t\tbreak;\n\t\tcase redirect_pipe:\n\t\t\t/* synchronize output before new pipe */\n\t\t\t(void) flush_io();\n\n\t\t\tos_restore_mode(fileno(stdin));\n\t\t\tif ((rp->output.fp = popen(str, binmode(\"w\"))) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for output (%s)\"),\n\t\t\t\t\t\tstr, strerror(errno));\n\n\t\t\t/* set close-on-exec */\n\t\t\tos_close_on_exec(fileno(rp->output.fp), str, \"pipe\", \"to\");\n\t\t\trp->flag |= RED_NOBUF;\n\t\t\tbreak;\n\t\tcase redirect_pipein:\n\t\t\tdirection = \"from\";\n\t\t\tif (gawk_popen(str, rp) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for input (%s)\"),\n\t\t\t\t\tstr, strerror(errno));\n\t\t\tbreak;\n\t\tcase redirect_input:\n\t\t\tdirection = \"from\";\n\t\t\tfd = devopen(str, binmode(\"r\"));\n\t\t\tif (fd == INVALID_HANDLE && errno == EISDIR) {\n\t\t\t\t*errflg = EISDIR;\n\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trp->iop = iop_alloc(fd, str, errno);\n\t\t\tfind_input_parser(rp->iop);\n\t\t\tiop_finish(rp->iop);\n\t\t\tif (! rp->iop->valid) {\n\t\t\t\tif (! do_traditional && rp->iop->errcode != 0)\n\t\t\t\t\tupdate_ERRNO_int(rp->iop->errcode);\n\t\t\t\tiop_close(rp->iop);\n\t\t\t\trp->iop = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase redirect_twoway:\n\t\t\tdirection = \"to/from\";\n\t\t\tif (! two_way_open(str, rp)) {\n#ifdef HAVE_SOCKETS\n\t\t\t\tif (inetfile(str, NULL)) {\n\t\t\t\t\t*errflg = errno;\n\t\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\t\treturn NULL;\n\t\t\t\t} else\n#endif\n\t\t\t\t\tfatal(_(\"can't open two way pipe `%s' for input/output (%s)\"),\n\t\t\t\t\t\t\tstr, strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\n\t\tif (mode != NULL) {\n\t\t\terrno = 0;\n\t\t\trp->output.mode = mode;\n\t\t\tfd = devopen(str, mode);\n\n\t\t\tif (fd > INVALID_HANDLE) {\n\t\t\t\tif (fd == fileno(stdin))\n\t\t\t\t\trp->output.fp = stdin;\n\t\t\t\telse if (fd == fileno(stdout))\n\t\t\t\t\trp->output.fp = stdout;\n\t\t\t\telse if (fd == fileno(stderr))\n\t\t\t\t\trp->output.fp = stderr;\n\t\t\t\telse {\n\t\t\t\t\tconst char *omode = mode;\n#if defined(F_GETFL) && defined(O_APPEND)\n\t\t\t\t\tint fd_flags;\n\n\t\t\t\t\tfd_flags = fcntl(fd, F_GETFL);\n\t\t\t\t\tif (fd_flags != -1 && (fd_flags & O_APPEND) == O_APPEND)\n\t\t\t\t\t\tomode = binmode(\"a\");\n#endif\n\t\t\t\t\tos_close_on_exec(fd, str, \"file\", \"\");\n\t\t\t\t\trp->output.fp = fdopen(fd, (const char *) omode);\n\t\t\t\t\trp->mode = (const char *) mode;\n\t\t\t\t\t/* don't leak file descriptors */\n"
}