{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from fillsize was never initialized.",
    "Code_line": "  fillsize = undossify_input (readbuf, fillsize);",
    "Code_function": "fillbuf (size_t save, struct stat const *st)\n{\n  size_t fillsize;\n  bool cc = true;\n  char *readbuf;\n  size_t readsize;\n\n  /* Offset from start of buffer to start of old stuff\n     that we want to save.  */\n  size_t saved_offset = buflim - save - buffer;\n\n  if (pagesize <= buffer + bufalloc - sizeof (uword) - buflim)\n    {\n      readbuf = buflim;\n      bufbeg = buflim - save;\n    }\n  else\n    {\n      size_t minsize = save + pagesize;\n      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - sizeof (uword);\n           newsize < minsize;\n           newsize *= 2)\n        if ((SIZE_MAX - pagesize - sizeof (uword)) / 2 < newsize)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (usable_st_size (st))\n        {\n          off_t to_be_read = st->st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft, and so that a uword can\n         be read aft.  */\n      newalloc = newsize + pagesize + sizeof (uword);\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - sizeof (uword) - readbuf;\n  readsize -= readsize % pagesize;\n\n  while (true)\n    {\n      fillsize = safe_read (bufdesc, readbuf, readsize);\n      if (fillsize == SAFE_READ_ERROR)\n        {\n          fillsize = 0;\n          cc = false;\n        }\n      bufoffset += fillsize;\n\n      if (fillsize == 0 || !skip_nuls || !all_zeros (readbuf, fillsize))\n        break;\n      totalnl = add_count (totalnl, fillsize);\n\n      if (SEEK_DATA != SEEK_SET && !seek_data_failed)\n        {\n          /* Solaris SEEK_DATA fails with errno == ENXIO in a hole at EOF.  */\n          off_t data_start = lseek (bufdesc, bufoffset, SEEK_DATA);\n          if (data_start < 0 && errno == ENXIO\n              && usable_st_size (st) && bufoffset < st->st_size)\n            data_start = lseek (bufdesc, 0, SEEK_END);\n\n          if (data_start < 0)\n            seek_data_failed = true;\n          else\n            {\n              totalnl = add_count (totalnl, data_start - bufoffset);\n              bufoffset = data_start;\n            }\n        }\n    }\n\n  fillsize = undossify_input (readbuf, fillsize);\n  buflim = readbuf + fillsize;\n  return cc;\n}"
}