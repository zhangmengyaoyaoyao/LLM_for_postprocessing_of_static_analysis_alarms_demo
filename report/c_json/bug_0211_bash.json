{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/display.c",
    "message": "The value read from n0 was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "lpos -= _rl_col_width (local_prompt, n0, num, 1);",
    "warning_context": "      } while (0)\n#else\n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#endif\n\n  /* inv_lbreaks[i] is where line i starts in the buffer. */\n  inv_lbreaks[newlines = 0] = 0;\n  lpos = prompt_physical_chars + modmark;\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (line_state_invisible->wrapped_line, 0, line_state_invisible->wbsize * sizeof (int));\n  num = 0;\n#endif\n\n  /* prompt_invis_chars_first_line is the number of invisible characters in\n     the first physical line of the prompt.\n     wrap_offset - prompt_invis_chars_first_line is the number of invis\n     chars on the second (or, more generally, last) line. */\n\n  /* This is zero-based, used to set the newlines */\n  prompt_lines_estimate = lpos / _rl_screenwidth;\n\n  /* what if lpos is already >= _rl_screenwidth before we start drawing the\n     contents of the command line? */\n  while (lpos >= _rl_screenwidth)\n    {\n      int z;\n      /* fix from Darin Johnson <darin@acuson.com> for prompt string with\n         invisible characters that is longer than the screen width.  The\n         prompt_invis_chars_first_line variable could be made into an array\n         saying how many invisible characters there are per line, but that's\n         probably too much work for the benefit gained.  How many people have\n         prompts that exceed two physical lines?\n         Additional logic fix from Edward Catmur <ed@catmur.co.uk> */\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\t{\n\t  n0 = num;\n          temp = local_prompt_len;\n          while (num < temp)\n\t    {\n\t      z = _rl_col_width  (local_prompt, n0, num, 1);\n\t      if (z > _rl_screenwidth)\n\t\t{\n\t          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n\t          break;\n\t\t}\n\t      else if (z == _rl_screenwidth)\n\t        break;\n\t      num++;\n\t    }\n          temp = num;\n\t}\n      else\n#endif /* !HANDLE_MULTIBYTE */\n\ttemp = ((newlines + 1) * _rl_screenwidth);\n\n      /* Now account for invisible characters in the current line. */\n      /* XXX - this assumes that the invisible characters may be split, but only\n\t between the first and the last lines. */\n      temp += (newlines == 0) ? prompt_invis_chars_first_line\n\t\t\t      : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line);\n\n      inv_lbreaks[++newlines] = temp;\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\tlpos -= _rl_col_width (local_prompt, n0, num, 1);\n      else\n#endif\n\tlpos -= _rl_screenwidth;\n    }\n\n  prompt_last_screen_line = newlines;\n\n  /* Draw the rest of the line (after the prompt) into invisible_line, keeping\n     track of where the cursor is (cpos_buffer_position), the number of the line containing\n     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).\n     It maintains an array of line breaks for display (inv_lbreaks).\n     This handles expanding tabs for display and displaying meta characters. */\n  lb_linenum = 0;\n#if defined (HANDLE_MULTIBYTE)\n  in = 0;\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    {\n      memset (&ps, 0, sizeof (mbstate_t));\n      /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);\n    }\n"
}