{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "awkgram.y",
    "message": "The value read from tmp_state.__count was never initialized.",
    "warning_function_name": "nextc",
    "warning_line": "cur_mbstate = tmp_state;",
    "warning_context": "static int\nnextc(bool check_for_bad)\n{\n\tif (gawk_mb_cur_max > 1) {\nagain:\n\t\tif (lexeof)\n\t\t\treturn END_FILE;\n\t\tif (lexptr == NULL || lexptr >= lexend) {\n\t\t\tif (get_src_buf())\n\t\t\t\tgoto again;\n\t\t\treturn END_SRC;\n\t\t}\n\n\t\t/* Update the buffer index.  */\n\t\tcur_ring_idx = (cur_ring_idx == RING_BUFFER_SIZE - 1)? 0 :\n\t\t\tcur_ring_idx + 1;\n\n\t\t/* Did we already check the current character?  */\n\t\tif (cur_char_ring[cur_ring_idx] == 0) {\n\t\t\t/* No, we need to check the next character on the buffer.  */\n\t\t\tint idx, work_ring_idx = cur_ring_idx;\n\t\t\tmbstate_t tmp_state;\n\t\t\tsize_t mbclen;\n\t\n\t\t\tfor (idx = 0 ; lexptr + idx < lexend ; idx++) {\n\t\t\t\ttmp_state = cur_mbstate;\n\t\t\t\tmbclen = mbrlen(lexptr, idx + 1, &tmp_state);\n\n\t\t\t\tif (mbclen == 1 || mbclen == (size_t)-1 || mbclen == 0) {\n\t\t\t\t\t/* It is a singlebyte character, non-complete multibyte\n\t\t\t\t\t   character or EOF.  We treat it as a singlebyte\n\t\t\t\t\t   character.  */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (mbclen == (size_t)-2) {\n\t\t\t\t\t/* It is not a complete multibyte character.  */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = idx + 1;\n\t\t\t\t} else {\n\t\t\t\t\t/* mbclen > 1 */\n\t\t\t\t\tcur_char_ring[work_ring_idx] = mbclen;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twork_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?\n\t\t\t\t\t0 : work_ring_idx + 1;\n\t\t\t}\n\t\t\tcur_mbstate = tmp_state;\n\n\t\t\t/* Put a mark on the position on which we write next character.  */\n\t\t\twork_ring_idx = (work_ring_idx == RING_BUFFER_SIZE - 1)?\n\t\t\t\t0 : work_ring_idx + 1;\n\t\t\tcur_char_ring[work_ring_idx] = 0;\n\t\t}\n\t\tif (check_for_bad)\n\t\t\tcheck_bad_char(*lexptr);\n\n\t\treturn (int) (unsigned char) *lexptr++;\n\t} else {\n\t\tdo {\n\t\t\tif (lexeof)\n\t\t\t\treturn END_FILE;\n\t\t\tif (lexptr && lexptr < lexend) {\n\t\t\t\tif (check_for_bad)\n\t\t\t\t\tcheck_bad_char(*lexptr);\n\t\t\t\treturn ((int) (unsigned char) *lexptr++);\n\t\t\t}\n\t\t} while (get_src_buf());\n\t\treturn END_SRC;\n\t}\n}\n"
}