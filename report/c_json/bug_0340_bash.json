{
    "Project": "bash",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bashline.c",
    "message": "Offset: [3, +oo] Size: [1, +oo].",
    "warning_function_name": "bash_directory_completion_hook",
    "warning_line": "temp2[len2] = '/';",
    "warning_context": "\t      rl_filename_quote_characters = custom_filename_quote_characters;\n\t      set_filename_bstab (rl_filename_quote_characters);\n\t    }\n\t}\n      else\n\t{\n\t  free (new_dirname);\n\t  free (local_dirname);\n\t  *dirname = (char *)xmalloc (1);\n\t  **dirname = '\\0';\n\t  return 1;\n\t}\n    }\n  else \n    {\n      /* Dequote the filename even if we don't expand it. */\n      new_dirname = bash_dequote_filename (local_dirname, rl_completion_quote_character);\n      return_value = STREQ (local_dirname, new_dirname) == 0;\n      free (local_dirname);\n      local_dirname = *dirname = new_dirname;\n    }\n\n  /* no_symbolic_links == 0 -> use (default) logical view of the file system.\n     local_dirname[0] == '.' && local_dirname[1] == '/' means files in the\n     current directory (./).\n     local_dirname[0] == '.' && local_dirname[1] == 0 means relative pathnames\n     in the current directory (e.g., lib/sh).\n     XXX - should we do spelling correction on these? */\n\n  /* This is test as it was in bash-4.2: skip relative pathnames in current\n     directory.  Change test to\n      (local_dirname[0] != '.' || (local_dirname[1] && local_dirname[1] != '/'))\n     if we want to skip paths beginning with ./ also. */\n  if (no_symbolic_links == 0 && (local_dirname[0] != '.' || local_dirname[1]))\n    {\n      char *temp1, *temp2;\n      int len1, len2;\n\n      /* If we have a relative path\n      \t\t(local_dirname[0] != '/' && local_dirname[0] != '.')\n\t that is canonical after appending it to the current directory, then\n\t \ttemp1 = temp2+'/'\n\t That is,\n\t \tstrcmp (temp1, temp2) == 0\n\t after adding a slash to temp2 below.  It should be safe to not\n\t change those.\n      */\n      t = get_working_directory (\"symlink-hook\");\n      temp1 = make_absolute (local_dirname, t);\n      free (t);\n      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\n      /* Try spelling correction if initial canonicalization fails.  Make\n\t sure we are set to replace the directory name with the results so\n\t subsequent directory checks don't fail. */\n      if (temp2 == 0 && dircomplete_spelling && dircomplete_expand)\n\t{\n\t  temp2 = dirspell (temp1);\n\t  if (temp2)\n\t    {\n\t      free (temp1);\n\t      temp1 = temp2;\n\t      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\t      return_value |= temp2 != 0;\n\t    }\n\t}\n      /* If we can't canonicalize, bail. */\n      if (temp2 == 0)\n\t{\n\t  free (temp1);\n\t  return return_value;\n\t}\n      len1 = strlen (temp1);\n      if (temp1[len1 - 1] == '/')\n\t{\n\t  len2 = strlen (temp2);\n\t  if (len2 > 2)\t\t/* don't append `/' to `/' or `//' */\n\t    {\n\t      temp2 = (char *)xrealloc (temp2, len2 + 2);\n\t      temp2[len2] = '/';\n\t      temp2[len2 + 1] = '\\0';\n\t    }\n\t}\n\n      /* dircomplete_expand_relpath == 0 means we want to leave relative\n\t pathnames that are unchanged by canonicalization alone.\n\t *local_dirname != '/' && *local_dirname != '.' == relative pathname\n\t (consistent with general.c:absolute_pathname())\n\t temp1 == temp2 (after appending a slash to temp2) means the pathname\n\t is not changed by canonicalization as described above. */\n      if (dircomplete_expand_relpath || ((local_dirname[0] != '/' && local_dirname[0] != '.') && STREQ (temp1, temp2) == 0))\n\treturn_value |= STREQ (local_dirname, temp2) == 0;\n      free (local_dirname);\n      *dirname = temp2;\n      free (temp1);\n    }\n\n  return (return_value);\n}\n\nstatic char **history_completion_array = (char **)NULL;\n"
}