{
    "Project": "combine",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "src/process_files.c",
    "message": "pointer `tmp_str` last assigned on line 351 could be null and is dereferenced by call to `strcpy()` at line 351, column 5.",
    "warning_function_name": "process_data_file",
    "warning_line": "FATAL_PERROR (input_filename);",
    "warning_context": "int\nprocess_data_file (input_filename)\n     char *input_filename;\n{\n  STRINGTYPE *value;\n  int write_record;\n  STRINGTYPE *new_value;\n  STRINGTYPE *key_value;\n  STRINGTYPE *tmp_buf_ptr;\n  STRINGTYPE *input_record_desc;\n\n  STRINGTYPE **output_fields;\n  int i;\n  int return_code;\n\n\n  value = NULL;\n  new_value = NULL;\n  key_value = NULL;\n  tmp_buf_ptr = NULL;\n\n\n  /* This is a new file.  Reset the file counters. */\n  gi_file_records_read = 0;\n  gi_file_records_dropped_filter = 0;\n  gi_file_records_matched = 0;\n  gi_file_output_records_written = 0;\n\n  if (strcmp (input_filename, \"-\"))\n    input_file = fopen (input_filename, \"r\");\n  else\n    input_file = stdin;\n\n  if (input_file == NULL)\n    FATAL_PERROR (input_filename);\n\n  input_record_desc\n    = df_get_next_record (input_file, &(gs_data_input_buffer),\n\t\t\t  &(gi_data_input_buffer_pos),\n\t\t\t  &(gi_data_input_buffer_size),\n\t\t\t  gs_data_input_record_delimiter,\n\t\t\t  gi_data_input_record_length);\n\n  while (input_record_desc != NULL) {\n    int keep_record;\n    /* For each record, assemble an output buffer from the output fields for\n     * the data file and any matching reference records from the reference \n     * files.  Update the counters in the hash tables for any required\n     * information.  If there is no match to a required reference record,\n     * then drop the record from output processing.  It will still be counted\n     * as a match to any reference table that is matched.\n     */\n    gi_data_records_read++;\n    gi_file_records_read++;\n    keep_record = 1;\n    write_record = 1;\n\n    if (gi_verbose_ind != 0 && (gi_file_records_read % 1000) == 0)\n      fprintf (stderr, _(\"\\rReading from data file %s: %12d records\"),\n\t       (input_file == stdin ? \"stdin\" : input_filename),\n\t       gi_file_records_read);\n\n    /* If we need to do anything to the entire record, do it */\n#ifdef HAVE_LIBGUILE\n    if (gs_data_ext_record_read_command != NULL) {\n      char *command_string;\n      STRINGTYPE *result_string;\n      SCM return_val;\n      size_t return_length;\n\n      command_string\n\t= malloc (gs_data_ext_record_read_command->length\n\t\t  + input_record_desc->length + 1);\n      if (command_string == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      sprintf (command_string, gs_data_ext_record_read_command->string,\n\t       input_record_desc->length, input_record_desc->string);\n      result_string = eval_scheme_string_function (command_string);\n      if (input_record_desc->own_string == DStr_own)\n\tfree (input_record_desc->string);\n      input_record_desc->string = result_string->string;\n      input_record_desc->length = result_string->length;\n      input_record_desc->own_string = DStr_not_own;\n      result_string->own_string = DStr_not_own;\n      dstrfree (result_string);\n      free (command_string);\n      }\n#  endif /* HAVE_LIBGUILE */\n\n\n    /* Assemble data file output fields. */\n    return_code\n      = a_find_input_ranges (&output_fields, input_record_desc,\n\t\t\t     gra_data_out_ranges, gi_data_out_range_count,\n\t\t\t     gi_data_out_end_start,\n\t\t\t     gs_data_input_field_delimiter,\n\t\t\t     gi_data_input_field_delimiter_repeat, DStr_not_own,\n\t\t\t     gs_output_field_delimiter, gs_data_empty_string);\n    if (return_code != EXIT_SUCCESS)\n      FATAL_ERROR (_(\"unable to allocate memory\"));\n    if (gs_data_empty_string != NULL) {\n"
}