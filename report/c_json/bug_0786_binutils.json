{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "libiberty/cp-demangle.c",
    "message": "pointer `ret` last assigned on line 2313 could be null and is dereferenced at line 2315, column 24.",
    "warning_function_name": "cplus_demangle_type",
    "warning_line": "di->expansion += ret->u.s_builtin.type->len;",
    "warning_context": "struct demangle_component *\ncplus_demangle_type (struct d_info *di)\n{\n  char peek;\n  struct demangle_component *ret;\n  int can_subst;\n\n  /* The ABI specifies that when CV-qualifiers are used, the base type\n     is substitutable, and the fully qualified type is substitutable,\n     but the base type with a strict subset of the CV-qualifiers is\n     not substitutable.  The natural recursive implementation of the\n     CV-qualifiers would cause subsets to be substitutable, so instead\n     we pull them all off now.\n\n     FIXME: The ABI says that order-insensitive vendor qualifiers\n     should be handled in the same way, but we have no way to tell\n     which vendor qualifiers are order-insensitive and which are\n     order-sensitive.  So we just assume that they are all\n     order-sensitive.  g++ 3.4 supports only one vendor qualifier,\n     __vector, and it treats it as order-sensitive when mangling\n     names.  */\n\n  peek = d_peek_char (di);\n  if (peek == 'r' || peek == 'V' || peek == 'K')\n    {\n      struct demangle_component **pret;\n\n      pret = d_cv_qualifiers (di, &ret, 0);\n      if (pret == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'F')\n\t{\n\t  /* cv-qualifiers before a function type apply to 'this',\n\t     so avoid adding the unqualified function type to\n\t     the substitution list.  */\n\t  *pret = d_function_type (di);\n\t}\n      else\n\t*pret = cplus_demangle_type (di);\n      if (!*pret)\n\treturn NULL;\n      if ((*pret)->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t  || (*pret)->type == DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t{\n\t  /* Move the ref-qualifier outside the cv-qualifiers so that\n\t     they are printed in the right order.  */\n\t  struct demangle_component *fn = d_left (*pret);\n\t  d_left (*pret) = ret;\n\t  ret = *pret;\n\t  *pret = fn;\n\t}\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n      return ret;\n    }\n\n  can_subst = 1;\n\n  switch (peek)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':\n    case 'o':                               case 's': case 't':\n    case 'v': case 'w': case 'x': case 'y': case 'z':\n      ret = d_make_builtin_type (di,\n\t\t\t\t &cplus_demangle_builtin_types[peek - 'a']);\n      di->expansion += ret->u.s_builtin.type->len;\n      can_subst = 0;\n      d_advance (di, 1);\n      break;\n\n    case 'u':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,\n\t\t\t d_source_name (di), NULL);\n      break;\n\n    case 'F':\n      ret = d_function_type (di);\n      break;\n\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case 'N':\n    case 'Z':\n      ret = d_class_enum_type (di);\n      break;\n\n    case 'A':\n      ret = d_array_type (di);\n      break;\n\n    case 'M':\n      ret = d_pointer_to_member_type (di);\n      break;\n\n    case 'T':\n      ret = d_template_param (di);\n      if (d_peek_char (di) == 'I')\n\t{\n\t  /* This may be <template-template-param> <template-args>.\n"
}