{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset: [0, 255] Size: 8 by call to `setbit`.",
    "Code_line": "        setbit (d->tokens[pos.index], matches);",
    "Code_function": "dfastate (state_num s, struct dfa *d, state_num trans[])\n{\n  leaf_set grps[NOTCHAR];       /* As many as will ever be needed.  */\n  charclass labels[NOTCHAR];    /* Labels corresponding to the groups.  */\n  size_t ngrps = 0;             /* Number of groups actually used.  */\n  position pos;                 /* Current position being considered.  */\n  charclass matches;            /* Set of matching characters.  */\n  charclass_word matchesf;\t/* Nonzero if matches is nonempty.  */\n  charclass intersect;          /* Intersection with some label set.  */\n  charclass_word intersectf;\t/* Nonzero if intersect is nonempty.  */\n  charclass leftovers;          /* Stuff in the label that didn't match.  */\n  charclass_word leftoversf;\t/* Nonzero if leftovers is nonempty.  */\n  position_set follows;         /* Union of the follows of some group.  */\n  position_set tmp;             /* Temporary space for merging sets.  */\n  int possible_contexts;        /* Contexts that this group can match.  */\n  int separate_contexts;        /* Context that new state wants to know.  */\n  state_num state;              /* New state.  */\n  state_num state_newline;      /* New state on a newline transition.  */\n  state_num state_letter;       /* New state on a letter transition.  */\n  bool next_isnt_1st_byte = false; /* We can't add state0.  */\n  size_t i, j, k;\n\n  zeroset (matches);\n\n  for (i = 0; i < d->states[s].elems.nelem; ++i)\n    {\n      pos = d->states[s].elems.elems[i];\n      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)\n        setbit (d->tokens[pos.index], matches);\n      else if (d->tokens[pos.index] >= CSET)\n        copyset (d->charclasses[d->tokens[pos.index] - CSET], matches);\n      else\n        {\n          if (d->tokens[pos.index] == MBCSET\n              || d->tokens[pos.index] == ANYCHAR)\n            {\n              /* MB_CUR_MAX > 1 */\n              if (d->tokens[pos.index] == MBCSET)\n                d->states[s].has_mbcset = true;\n              /* ANYCHAR and MBCSET must match with a single character, so we\n                 must put it to d->states[s].mbps, which contains the positions\n                 which can match with a single character not a byte.  */\n              if (d->states[s].mbps.nelem == 0)\n                alloc_position_set (&d->states[s].mbps, 1);\n              insert (pos, &(d->states[s].mbps));\n            }\n          continue;\n        }\n\n      /* Some characters may need to be eliminated from matches because\n         they fail in the current context.  */\n      if (pos.constraint != NO_CONSTRAINT)\n        {\n          if (!SUCCEEDS_IN_CONTEXT (pos.constraint,\n                                    d->states[s].context, CTX_NEWLINE))\n            for (j = 0; j < CHARCLASS_WORDS; ++j)\n              matches[j] &= ~newline[j];\n          if (!SUCCEEDS_IN_CONTEXT (pos.constraint,\n                                    d->states[s].context, CTX_LETTER))\n            for (j = 0; j < CHARCLASS_WORDS; ++j)\n              matches[j] &= ~letters[j];\n          if (!SUCCEEDS_IN_CONTEXT (pos.constraint,\n                                    d->states[s].context, CTX_NONE))\n            for (j = 0; j < CHARCLASS_WORDS; ++j)\n              matches[j] &= letters[j] | newline[j];\n\n          /* If there are no characters left, there's no point in going on.  */\n          for (j = 0; j < CHARCLASS_WORDS && !matches[j]; ++j)\n            continue;\n          if (j == CHARCLASS_WORDS)\n            continue;\n        }\n\n      for (j = 0; j < ngrps; ++j)\n        {\n          /* If matches contains a single character only, and the current\n             group's label doesn't contain that character, go on to the\n             next group.  */\n          if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR\n              && !tstbit (d->tokens[pos.index], labels[j]))\n            continue;\n\n          /* Check if this group's label has a nonempty intersection with\n             matches.  */\n          intersectf = 0;\n          for (k = 0; k < CHARCLASS_WORDS; ++k)\n            intersectf |= intersect[k] = matches[k] & labels[j][k];\n          if (!intersectf)\n            continue;\n\n          /* It does; now find the set differences both ways.  */\n          leftoversf = matchesf = 0;\n          for (k = 0; k < CHARCLASS_WORDS; ++k)\n            {\n              /* Even an optimizing compiler can't know this for sure.  */\n              charclass_word match = matches[k], label = labels[j][k];\n\n              leftoversf |= leftovers[k] = ~match & label;\n              matchesf |= matches[k] = match & ~label;\n            }\n\n          /* If there were leftovers, create a new group labeled with them.  */\n          if (leftoversf)\n            {\n              copyset (leftovers, labels[ngrps]);\n              copyset (intersect, labels[j]);\n              grps[ngrps].elems = xnmalloc (d->nleaves,\n                                            sizeof *grps[ngrps].elems);\n              memcpy (grps[ngrps].elems, grps[j].elems,\n                      sizeof (grps[j].elems[0]) * grps[j].nelem);\n              grps[ngrps].nelem = grps[j].nelem;\n              ++ngrps;\n            }\n\n          /* Put the position in the current group.  The constraint is\n             irrelevant here.  */\n          grps[j].elems[grps[j].nelem++] = pos.index;\n\n          /* If every character matching the current position has been\n             accounted for, we're done.  */\n          if (!matchesf)\n            break;\n        }\n\n      /* If we've passed the last group, and there are still characters\n         unaccounted for, then we'll have to create a new group.  */\n      if (j == ngrps)\n        {\n          copyset (matches, labels[ngrps]);\n          zeroset (matches);\n          grps[ngrps].elems = xnmalloc (d->nleaves, sizeof *grps[ngrps].elems);\n          grps[ngrps].nelem = 1;\n          grps[ngrps].elems[0] = pos.index;\n          ++ngrps;\n        }\n    }\n\n  alloc_position_set (&follows, d->nleaves);\n  alloc_position_set (&tmp, d->nleaves);\n\n  /* If we are a searching matcher, the default transition is to a state\n     containing the positions of state 0, otherwise the default transition\n     is to fail miserably.  */\n  if (d->searchflag)\n    {\n      /* Find the state(s) corresponding to the positions of state 0.  */\n      copy (&d->states[0].elems, &follows);\n      separate_contexts = state_separate_contexts (&follows);\n      state = state_index (d, &follows, separate_contexts ^ CTX_ANY);\n      if (separate_contexts & CTX_NEWLINE)\n        state_newline = state_index (d, &follows, CTX_NEWLINE);\n      else\n        state_newline = state;\n      if (separate_contexts & CTX_LETTER)\n        state_letter = state_index (d, &follows, CTX_LETTER);\n      else\n        state_letter = state;\n\n      for (i = 0; i < NOTCHAR; ++i)\n        trans[i] = (IS_WORD_CONSTITUENT (i)) ? state_letter : state;\n      trans[eolbyte] = state_newline;\n    }\n  else\n    for (i = 0; i < NOTCHAR; ++i)\n      trans[i] = -1;\n\n  for (i = 0; i < ngrps; ++i)\n    {\n      follows.nelem = 0;\n\n      /* Find the union of the follows of the positions of the group.\n         This is a hideously inefficient loop.  Fix it someday.  */\n      for (j = 0; j < grps[i].nelem; ++j)\n        for (k = 0; k < d->follows[grps[i].elems[j]].nelem; ++k)\n          insert (d->follows[grps[i].elems[j]].elems[k], &follows);\n\n      if (d->multibyte)\n        {\n          /* If a token in follows.elems is not 1st byte of a multibyte\n             character, or the states of follows must accept the bytes\n             which are not 1st byte of the multibyte character.\n             Then, if a state of follows encounter a byte, it must not be\n             a 1st byte of a multibyte character nor single byte character.\n             We cansel to add state[0].follows to next state, because\n             state[0] must accept 1st-byte\n\n             For example, we assume <sb a> is a certain single byte\n             character, <mb A> is a certain multibyte character, and the\n             codepoint of <sb a> equals the 2nd byte of the codepoint of\n             <mb A>.\n             When state[0] accepts <sb a>, state[i] transit to state[i+1]\n             by accepting accepts 1st byte of <mb A>, and state[i+1]\n             accepts 2nd byte of <mb A>, if state[i+1] encounter the\n             codepoint of <sb a>, it must not be <sb a> but 2nd byte of\n             <mb A>, so we cannot add state[0].  */\n\n          next_isnt_1st_byte = false;\n          for (j = 0; j < follows.nelem; ++j)\n            {\n              if (!(d->multibyte_prop[follows.elems[j].index] & 1))\n                {\n                  next_isnt_1st_byte = true;\n                  break;\n                }\n            }\n        }\n\n      /* If we are building a searching matcher, throw in the positions\n         of state 0 as well.  */\n      if (d->searchflag && (!d->multibyte || !next_isnt_1st_byte))\n        {\n          merge (&d->states[0].elems, &follows, &tmp);\n          copy (&tmp, &follows);\n        }\n\n      /* Find out if the new state will want any context information.  */\n      possible_contexts = charclass_context (labels[i]);\n      separate_contexts = state_separate_contexts (&follows);\n\n      /* Find the state(s) corresponding to the union of the follows.  */\n      if ((separate_contexts & possible_contexts) != possible_contexts)\n        state = state_index (d, &follows, separate_contexts ^ CTX_ANY);\n      else\n        state = -1;\n      if (separate_contexts & possible_contexts & CTX_NEWLINE)\n        state_newline = state_index (d, &follows, CTX_NEWLINE);\n      else\n        state_newline = state;\n      if (separate_contexts & possible_contexts & CTX_LETTER)\n        state_letter = state_index (d, &follows, CTX_LETTER);\n      else\n        state_letter = state;\n\n      /* Set the transitions for each character in the current label.  */\n      for (j = 0; j < CHARCLASS_WORDS; ++j)\n        for (k = 0; k < CHARCLASS_WORD_BITS; ++k)\n          if (labels[i][j] >> k & 1)\n            {\n              int c = j * CHARCLASS_WORD_BITS + k;\n\n              if (c == eolbyte)\n                trans[c] = state_newline;\n              else if (IS_WORD_CONSTITUENT (c))\n                trans[c] = state_letter;\n              else if (c < NOTCHAR)\n                trans[c] = state;\n            }\n    }\n\n  for (i = 0; i < ngrps; ++i)\n    free (grps[i].elems);\n  free (follows.elems);\n  free (tmp.elems);\n}"
}