{
    "Project": "diffutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t\t\t  printf (\"%*s %3o %-4s %3o %s\\n\",",
    "Code_function": "cmp (void)\n{\n  off_t line_number = 1;\t/* Line number (1...) of difference. */\n  off_t byte_number = 1;\t/* Byte number (1...) of difference. */\n  uintmax_t remaining = bytes;\t/* Remaining number of bytes to compare.  */\n  size_t read0, read1;\t\t/* Number of bytes read from each file. */\n  size_t first_diff;\t\t/* Offset (0...) in buffers of 1st diff. */\n  size_t smaller;\t\t/* The lesser of 'read0' and 'read1'. */\n  word *buffer0 = buffer[0];\n  word *buffer1 = buffer[1];\n  char *buf0 = (char *) buffer0;\n  char *buf1 = (char *) buffer1;\n  int differing = 0;\n  int f;\n  int offset_width IF_LINT (= 0);\n\n  if (comparison_type == type_all_diffs)\n    {\n      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));\n\n      for (f = 0; f < 2; f++)\n\tif (S_ISREG (stat_buf[f].st_mode))\n\t  {\n\t    off_t file_bytes = stat_buf[f].st_size - file_position (f);\n\t    if (file_bytes < byte_number_max)\n\t      byte_number_max = file_bytes;\n\t  }\n\n      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)\n\tcontinue;\n    }\n\n  for (f = 0; f < 2; f++)\n    {\n      off_t ig = ignore_initial[f];\n      if (ig && file_position (f) == -1)\n\t{\n\t  /* lseek failed; read and discard the ignored initial prefix.  */\n\t  do\n\t    {\n\t      size_t bytes_to_read = MIN (ig, buf_size);\n\t      size_t r = block_read (file_desc[f], buf0, bytes_to_read);\n\t      if (r != bytes_to_read)\n\t\t{\n\t\t  if (r == SIZE_MAX)\n\t\t    error (EXIT_TROUBLE, errno, \"%s\", file[f]);\n\t\t  break;\n\t\t}\n\t      ig -= r;\n\t    }\n\t  while (ig);\n\t}\n    }\n\n  do\n    {\n      size_t bytes_to_read = buf_size;\n\n      if (remaining != UINTMAX_MAX)\n\t{\n\t  if (remaining < bytes_to_read)\n\t    bytes_to_read = remaining;\n\t  remaining -= bytes_to_read;\n\t}\n\n      read0 = block_read (file_desc[0], buf0, bytes_to_read);\n      if (read0 == SIZE_MAX)\n\terror (EXIT_TROUBLE, errno, \"%s\", file[0]);\n      read1 = block_read (file_desc[1], buf1, bytes_to_read);\n      if (read1 == SIZE_MAX)\n\terror (EXIT_TROUBLE, errno, \"%s\", file[1]);\n\n      /* Insert sentinels for the block compare.  */\n\n      buf0[read0] = ~buf1[read0];\n      buf1[read1] = ~buf0[read1];\n\n      /* If the line number should be written for differing files,\n\t compare the blocks and count the number of newlines\n\t simultaneously.  */\n      first_diff = (comparison_type == type_first_diff\n\t\t    ? block_compare_and_count (buffer0, buffer1, &line_number)\n\t\t    : block_compare (buffer0, buffer1));\n\n      byte_number += first_diff;\n      smaller = MIN (read0, read1);\n\n      if (first_diff < smaller)\n\t{\n\t  switch (comparison_type)\n\t    {\n\t    case type_first_diff:\n\t      {\n\t\tchar byte_buf[INT_BUFSIZE_BOUND (off_t)];\n\t\tchar line_buf[INT_BUFSIZE_BOUND (off_t)];\n\t\tchar const *byte_num = offtostr (byte_number, byte_buf);\n\t\tchar const *line_num = offtostr (line_number, line_buf);\n\t\tif (!opt_print_bytes)\n\t\t  {\n\t\t    /* See POSIX 1003.1-2001 for this format.  This\n\t\t       message is used only in the POSIX locale, so it\n\t\t       need not be translated.  */\n\t\t    static char const char_message[] =\n\t\t      \"%s %s differ: char %s, line %s\\n\";\n\n\t\t    /* The POSIX rationale recommends using the word\n\t\t       \"byte\" outside the POSIX locale.  Some gettext\n\t\t       implementations translate even in the POSIX\n\t\t       locale if certain other environment variables\n\t\t       are set, so use \"byte\" if a translation is\n\t\t       available, or if outside the POSIX locale.  */\n\t\t    static char const byte_msgid[] =\n\t\t      N_(\"%s %s differ: byte %s, line %s\\n\");\n\t\t    char const *byte_message = _(byte_msgid);\n\t\t    bool use_byte_message = (byte_message != byte_msgid\n\t\t\t\t\t     || hard_locale_LC_MESSAGES);\n\n\t\t    printf (use_byte_message ? byte_message : char_message,\n\t\t\t    file[0], file[1], byte_num, line_num);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    unsigned char c0 = buf0[first_diff];\n\t\t    unsigned char c1 = buf1[first_diff];\n\t\t    char s0[5];\n\t\t    char s1[5];\n\t\t    sprintc (s0, c0);\n\t\t    sprintc (s1, c1);\n\t\t    printf (_(\"%s %s differ: byte %s, line %s is %3o %s %3o %s\\n\"),\n\t\t\t    file[0], file[1], byte_num, line_num,\n\t\t\t    c0, s0, c1, s1);\n\t\t}\n\t      }\n\t      /* Fall through.  */\n\t    case type_status:\n\t      return EXIT_FAILURE;\n\n\t    case type_all_diffs:\n\t      do\n\t\t{\n\t\t  unsigned char c0 = buf0[first_diff];\n\t\t  unsigned char c1 = buf1[first_diff];\n\t\t  if (c0 != c1)\n\t\t    {\n\t\t      char byte_buf[INT_BUFSIZE_BOUND (off_t)];\n\t\t      char const *byte_num = offtostr (byte_number, byte_buf);\n\t\t      if (!opt_print_bytes)\n\t\t\t{\n\t\t\t  /* See POSIX 1003.1-2001 for this format.  */\n\t\t\t  printf (\"%*s %3o %3o\\n\",\n\t\t\t\t  offset_width, byte_num, c0, c1);\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  char s0[5];\n\t\t\t  char s1[5];\n\t\t\t  sprintc (s0, c0);\n\t\t\t  sprintc (s1, c1);\n\t\t\t  printf (\"%*s %3o %-4s %3o %s\\n\",\n\t\t\t\t  offset_width, byte_num, c0, s0, c1, s1);\n\t\t\t}\n\t\t    }\n\t\t  byte_number++;\n\t\t  first_diff++;\n\t\t}\n\t      while (first_diff < smaller);\n\t      differing = -1;\n\t      break;\n\n\t    case type_no_stdout:\n\t      differing = 1;\n\t      break;\n\t    }\n\t}\n\n      if (read0 != read1)\n\t{\n\t  if (differing <= 0 && comparison_type != type_status)\n\t    {\n\t      /* See POSIX 1003.1-2001 for this format.  */\n\t      fprintf (stderr, _(\"cmp: EOF on %s\\n\"), file[read1 < read0]);\n\t    }\n\n\t  return EXIT_FAILURE;\n\t}\n    }\n  while (differing <= 0 && read0 == buf_size);\n\n  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;\n}"
}