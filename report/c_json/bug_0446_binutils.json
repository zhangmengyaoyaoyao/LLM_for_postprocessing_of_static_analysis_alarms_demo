{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "ld/mri.c",
    "message": "Offset: [56, +oo] Size: 16 by call to `exp_nameop`.",
    "warning_function_name": "mri_draw_tree",
    "warning_line": "base = p->vma ? p->vma : exp_nameop (NAME, \".\");",
    "warning_context": "  if (address != NULL)\n    {\n      struct section_name_struct *alist;\n      struct section_name_struct *olist;\n\n      if (order == NULL)\n\torder = address;\n\n      for (alist = address;\n\t   alist != NULL;\n\t   alist = alist->next)\n\t{\n\t  int done = 0;\n\n\t  for (olist = order; done == 0 && olist != NULL; olist = olist->next)\n\t    {\n\t      if (strcmp (alist->name, olist->name) == 0)\n\t\t{\n\t\t  olist->vma = alist->vma;\n\t\t  done = 1;\n\t\t}\n\t    }\n\n\t  if (!done)\n\t    {\n\t      /* Add this onto end of order list.  */\n\t      mri_add_to_list (&order, alist->name, alist->vma, 0, 0, 0);\n\t    }\n\t}\n    }\n\n  /* If we're only supposed to load a subset of them in, then prune\n     the list.  */\n  if (only_load != NULL)\n    {\n      struct section_name_struct *ptr1;\n      struct section_name_struct *ptr2;\n\n      if (order == NULL)\n\torder = only_load;\n\n      /* See if this name is in the list, if it is then we can load it.  */\n      for (ptr1 = only_load; ptr1; ptr1 = ptr1->next)\n\tfor (ptr2 = order; ptr2; ptr2 = ptr2->next)\n\t  if (strcmp (ptr2->name, ptr1->name) == 0)\n\t    ptr2->ok_to_load = 1;\n    }\n  else\n    {\n      /* No only load list, so everything is ok to load.  */\n      struct section_name_struct *ptr;\n\n      for (ptr = order; ptr; ptr = ptr->next)\n\tptr->ok_to_load = 1;\n    }\n\n  /* Create the order of sections to load.  */\n  if (order != NULL)\n    {\n      /* Been told to output the sections in a certain order.  */\n      struct section_name_struct *p = order;\n\n      while (p)\n\t{\n\t  struct section_name_struct *aptr;\n\t  etree_type *align = 0;\n\t  etree_type *subalign = 0;\n\t  struct wildcard_list *tmp;\n\n\t  /* See if an alignment has been specified.  */\n\t  for (aptr = alignment; aptr; aptr = aptr->next)\n\t    if (strcmp (aptr->name, p->name) == 0)\n\t      align = aptr->align;\n\n\t  for (aptr = subalignment; aptr; aptr = aptr->next)\n\t    if (strcmp (aptr->name, p->name) == 0)\n\t      subalign = aptr->subalign;\n\n\t  if (base == 0)\n\t    base = p->vma ? p->vma : exp_nameop (NAME, \".\");\n\n\t  lang_enter_output_section_statement (p->name, base,\n\t\t\t\t\t       p->ok_to_load ? normal_section : noload_section,\n\t\t\t\t\t       align, subalign, NULL, 0, 0);\n\t  base = 0;\n\t  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);\n\t  tmp->next = NULL;\n\t  tmp->spec.name = p->name;\n\t  tmp->spec.exclude_name_list = NULL;\n\t  tmp->spec.sorted = none;\n\t  tmp->spec.section_flag_list = NULL;\n\t  lang_add_wild (NULL, tmp, FALSE);\n\n\t  /* If there is an alias for this section, add it too.  */\n\t  for (aptr = alias; aptr; aptr = aptr->next)\n\t    if (strcmp (aptr->alias, p->name) == 0)\n\t      {\n\t\ttmp = (struct wildcard_list *) xmalloc (sizeof *tmp);\n\t\ttmp->next = NULL;\n\t\ttmp->spec.name = aptr->name;\n\t\ttmp->spec.exclude_name_list = NULL;\n"
}