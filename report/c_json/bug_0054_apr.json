{
    "project": "apr",
    "tool": "CSA",
    "category": "core.uninitialized.Assign",
    "file": "file_io/unix/filepath.c",
    "message": "Assigned value is garbage or undefined",
    "warning_function_name": "apr_filepath_merge",
    "warning_line": "rootpath = getpath;",
    "warning_context": "APR_DECLARE(apr_status_t) apr_filepath_merge(char **newpath,\n                                             const char *rootpath,\n                                             const char *addpath,\n                                             apr_int32_t flags,\n                                             apr_pool_t *p)\n{\n    char *path;\n    apr_size_t rootlen; /* is the length of the src rootpath */\n    apr_size_t maxlen;  /* maximum total path length */\n    apr_size_t keptlen; /* is the length of the retained rootpath */\n    apr_size_t pathlen; /* is the length of the result path */\n    apr_size_t seglen;  /* is the end of the current segment */\n    apr_status_t rv;\n\n    /* Treat null as an empty path.\n     */\n    if (!addpath)\n        addpath = \"\";\n\n    if (addpath[0] == '/') {\n        /* If addpath is rooted, then rootpath is unused.\n         * Ths violates any APR_FILEPATH_SECUREROOTTEST and\n         * APR_FILEPATH_NOTABSOLUTE flags specified.\n         */\n        if (flags & APR_FILEPATH_SECUREROOTTEST)\n            return APR_EABOVEROOT;\n        if (flags & APR_FILEPATH_NOTABSOLUTE)\n            return APR_EABSOLUTE;\n\n        /* If APR_FILEPATH_NOTABOVEROOT wasn't specified,\n         * we won't test the root again, it's ignored.\n         * Waste no CPU retrieving the working path.\n         */\n        if (!rootpath && !(flags & APR_FILEPATH_NOTABOVEROOT))\n            rootpath = \"\";\n    }\n    else {\n        /* If APR_FILEPATH_NOTABSOLUTE is specified, the caller\n         * requires a relative result.  If the rootpath is\n         * ommitted, we do not retrieve the working path,\n         * if rootpath was supplied as absolute then fail.\n         */\n        if (flags & APR_FILEPATH_NOTABSOLUTE) {\n            if (!rootpath)\n                rootpath = \"\";\n            else if (rootpath[0] == '/')\n                return APR_EABSOLUTE;\n        }\n    }\n\n    if (!rootpath) {\n        /* Start with the current working path.  This is bass akwards,\n         * but required since the compiler (at least vc) doesn't like\n         * passing the address of a char const* for a char** arg.\n         */\n        char *getpath;\n        rv = apr_filepath_get(&getpath, flags, p);\n        rootpath = getpath;\n        if (rv != APR_SUCCESS)\n            return errno;\n\n        /* XXX: Any kernel subject to goofy, uncanonical results\n         * must run the rootpath against the user's given flags.\n         * Simplest would be a recursive call to apr_filepath_merge\n         * with an empty (not null) rootpath and addpath of the cwd.\n         */\n    }\n\n    rootlen = strlen(rootpath);\n    maxlen = rootlen + strlen(addpath) + 4; /* 4 for slashes at start, after\n                                             * root, and at end, plus trailing\n                                             * null */\n    if (maxlen > APR_PATH_MAX) {\n        return APR_ENAMETOOLONG;\n    }\n    path = (char *)apr_palloc(p, maxlen);\n\n    if (addpath[0] == '/') {\n        /* Ignore the given root path, strip off leading\n         * '/'s to a single leading '/' from the addpath,\n         * and leave addpath at the first non-'/' character.\n         */\n        keptlen = 0;\n        while (addpath[0] == '/')\n            ++addpath;\n        path[0] = '/';\n        pathlen = 1;\n    }\n    else {\n        /* If both paths are relative, fail early\n         */\n        if (rootpath[0] != '/' && (flags & APR_FILEPATH_NOTRELATIVE))\n            return APR_ERELATIVE;\n\n        /* Base the result path on the rootpath\n         */\n        keptlen = rootlen;\n        memcpy(path, rootpath, rootlen);\n\n        /* Always '/' terminate the given root path\n         */\n"
}