{
    "Project": "sed",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: [1, +oo] Size: 1.",
    "Code_line": "  if (codeset[0] == '\\0')",
    "Code_function": "locale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WIN32_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin 2006 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  As long as this is not fixed, return the suffix\n     of the locale name from the environment variables (if present) or\n     the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n\t{\n\t  locale = getenv (\"LC_CTYPE\");\n\t  if (locale == NULL || locale[0] == '\\0')\n\t    locale = getenv (\"LANG\");\n\t}\n      if (locale != NULL && locale[0] != '\\0')\n\t{\n\t  /* If the locale name contains an encoding after the dot, return\n\t     it.  */\n\t  const char *dot = strchr (locale, '.');\n\n\t  if (dot != NULL)\n\t    {\n\t      const char *modifier;\n\n\t      dot++;\n\t      /* Look for the possible @... trailer and remove it, if any.  */\n\t      modifier = strchr (dot, '@');\n\t      if (modifier == NULL)\n\t\treturn dot;\n\t      if (modifier - dot < sizeof (buf))\n\t\t{\n\t\t  memcpy (buf, dot, modifier - dot);\n\t\t  buf [modifier - dot] = '\\0';\n\t\t  return buf;\n\t\t}\n\t    }\n\t}\n\n      /* Woe32 has a function returning the locale's codepage as a number.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n\t{\n\t  locale = getenv (\"LC_CTYPE\");\n\t  if (locale == NULL || locale[0] == '\\0')\n\t    locale = getenv (\"LANG\");\n\t}\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WIN32_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* Woe32 has a function returning the locale's codepage as a number.  */\n  sprintf (buf, \"CP%u\", GetACP ());\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n\tlocale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n\t{\n\t  const char *modifier;\n\n\t  dot++;\n\t  /* Look for the possible @... trailer and remove it, if any.  */\n\t  modifier = strchr (dot, '@');\n\t  if (modifier == NULL)\n\t    return dot;\n\t  if (modifier - dot < sizeof (buf))\n\t    {\n\t      memcpy (buf, dot, modifier - dot);\n\t      buf [modifier - dot] = '\\0';\n\t      return buf;\n\t    }\n\t}\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n\tcodeset = \"\";\n      else\n\t{\n\t  sprintf (buf, \"CP%u\", cp[0]);\n\t  codeset = buf;\n\t}\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n\t|| (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n\tcodeset = aliases + strlen (aliases) + 1;\n\tbreak;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n  return codeset;\n}"
}