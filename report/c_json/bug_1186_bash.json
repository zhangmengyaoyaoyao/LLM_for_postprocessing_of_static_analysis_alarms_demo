{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      else if (S_ISDIR (mode))",
    "Code_function": "_rl_print_color_indicator (char *f)\n{\n  enum indicator_no colored_filetype;\n  COLOR_EXT_TYPE *ext;\t/* Color extension */\n  size_t len;\t\t/* Length of name */\n\n  const char* name;\n  char *filename;\n  struct stat astat;\n  mode_t mode;\n  int linkok;\n\n  int stat_ok;\n\n  name = f;\n\n  /* This should already have undergone tilde expansion */\n  filename = 0;\n  if (rl_filename_stat_hook)\n    {\n      filename = savestring (f);\n      (*rl_filename_stat_hook) (&filename);\n      name = filename;\n    }\n\n#if defined (HAVE_LSTAT)\n  stat_ok = lstat(name, &astat);\n#else\n  stat_ok = stat(name, &astat);\n#endif\n  if( stat_ok == 0 ) {\n    mode = astat.st_mode;\n    linkok = 1; //f->linkok;\n  }\n  else\n    linkok = -1;\n\n  /* Is this a nonexistent file?  If so, linkok == -1.  */\n\n  if (linkok == -1 && _rl_color_indicator[C_MISSING].string != NULL)\n    colored_filetype = C_MISSING;\n  else if(stat_ok != 0)\n    {\n      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n      colored_filetype = filetype_indicator[normal]; //f->filetype];\n    }\n  else\n    {\n      if (S_ISREG (mode))\n        {\n          colored_filetype = C_FILE;\n\n          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n            colored_filetype = C_SETUID;\n          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n            colored_filetype = C_SETGID;\n          else if (is_colored (C_CAP) && 0) //f->has_capability)\n            colored_filetype = C_CAP;\n          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n            colored_filetype = C_EXEC;\n          else if ((1 < astat.st_nlink) && is_colored (C_MULTIHARDLINK))\n            colored_filetype = C_MULTIHARDLINK;\n        }\n      else if (S_ISDIR (mode))\n        {\n          colored_filetype = C_DIR;\n\n#if defined (S_ISVTX)\n          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n              && is_colored (C_STICKY_OTHER_WRITABLE))\n            colored_filetype = C_STICKY_OTHER_WRITABLE;\n          else\n#endif\n          if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n            colored_filetype = C_OTHER_WRITABLE;\n#if defined (S_ISVTX)\n          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n            colored_filetype = C_STICKY;\n#endif\n        }\n      else if (S_ISLNK (mode))\n        colored_filetype = ((linkok == 0\n                 && (!strncmp (_rl_color_indicator[C_LINK].string, \"target\", 6)\n                     || _rl_color_indicator[C_ORPHAN].string))\n                ? C_ORPHAN : C_LINK);\n      else if (S_ISFIFO (mode))\n        colored_filetype = C_FIFO;\n      else if (S_ISSOCK (mode))\n        colored_filetype = C_SOCK;\n      else if (S_ISBLK (mode))\n        colored_filetype = C_BLK;\n      else if (S_ISCHR (mode))\n        colored_filetype = C_CHR;\n      else\n        {\n          /* Classify a file of some other type as C_ORPHAN.  */\n          colored_filetype = C_ORPHAN;\n        }\n    }\n\n  /* Check the file's suffix only if still classified as C_FILE.  */\n  ext = NULL;\n  if (colored_filetype == C_FILE)\n    {\n      /* Test if NAME has a recognized suffix.  */\n      len = strlen (name);\n      name += len;\t\t/* Pointer to final \\0.  */\n      for (ext = _rl_color_ext_list; ext != NULL; ext = ext->next)\n        {\n          if (ext->ext.len <= len\n              && strncmp (name - ext->ext.len, ext->ext.string,\n                          ext->ext.len) == 0)\n            break;\n        }\n    }\n\n  free (filename);\t/* NULL or savestring return value */\n\n  {\n    const struct bin_str *const s\n      = ext ? &(ext->seq) : &_rl_color_indicator[colored_filetype];\n    if (s->string != NULL)\n      {\n        /* Need to reset so not dealing with attribute combinations */\n        if (is_colored (C_NORM))\n\t  restore_default_color ();\n        _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n        _rl_put_indicator (s);\n        _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n        return 0;\n      }\n    else\n      return 1;\n  }\n}"
}