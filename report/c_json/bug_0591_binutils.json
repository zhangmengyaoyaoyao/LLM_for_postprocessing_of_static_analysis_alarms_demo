{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/app.c",
    "message": "The value read from fromlen was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "ch = GET ();",
    "warning_context": "\t\t    ch = GET ();\n\t\t  if (ch == EOF)\n\t\t    {\n\t\t      as_warn (_(\"end of file in comment; newline inserted\"));\n\t\t      PUT ('\\n');\n\t\t    }\n\t\t  else /* IS_NEWLINE (ch) */\n\t\t    {\n\t\t      /* To process non-zero add_newlines.  */\n\t\t      UNGET (ch);\n\t\t    }\n\t\t  state = 0;\n\t\t  break;\n\t\t}\n\t      /* Looks like `# 123 \"filename\"' from cpp.  */\n\t      UNGET (ch);\n\t      old_state = 4;\n\t      state = -1;\n\t      if (scrub_m68k_mri)\n\t\tout_string = \"\\tlinefile \";\n\t      else\n\t\tout_string = \"\\t.linefile \";\n\t      PUT (*out_string++);\n\t      break;\n\t    }\n\n#ifdef TC_D10V\n\t  /* All insns end in a char for which LEX_IS_SYMBOL_COMPONENT is true.\n\t     Trap is the only short insn that has a first operand that is\n\t     neither register nor label.\n\t     We must prevent exef0f ||trap #1 to degenerate to exef0f ||trap#1 .\n\t     We can't make '#' LEX_IS_SYMBOL_COMPONENT because it is\n\t     already LEX_IS_LINE_COMMENT_START.  However, it is the\n\t     only character in line_comment_chars for d10v, hence we\n\t     can recognize it as such.  */\n\t  /* An alternative approach would be to reset the state to 1 when\n\t     we see '||', '<'- or '->', but that seems to be overkill.  */\n\t  if (state == 10)\n\t    PUT (' ');\n#endif\n\t  /* We have a line comment character which is not at the\n\t     start of a line.  If this is also a normal comment\n\t     character, fall through.  Otherwise treat it as a default\n\t     character.  */\n\t  if (strchr (tc_comment_chars, ch) == NULL\n\t      && (! scrub_m68k_mri\n\t\t  || (ch != '!' && ch != '*')))\n\t    goto de_fault;\n\t  if (scrub_m68k_mri\n\t      && (ch == '!' || ch == '*' || ch == '#')\n\t      && state != 1\n\t      && state != 10)\n\t    goto de_fault;\n\t  /* Fall through.  */\n\tcase LEX_IS_COMMENT_START:\n#if defined TC_ARM && defined OBJ_ELF\n\t  /* On the ARM, `@' is the comment character.\n\t     Unfortunately this is also a special character in ELF .symver\n\t     directives (and .type, though we deal with those another way).\n\t     So we check if this line is such a directive, and treat\n\t     the character as default if so.  This is a hack.  */\n\t  if ((symver_state != NULL) && (*symver_state == 0))\n\t    goto de_fault;\n#endif\n\n#ifdef TC_ARM\n\t  /* For the ARM, care is needed not to damage occurrences of \\@\n\t     by stripping the @ onwards.  Yuck.  */\n\t  if (to > tostart && *(to - 1) == '\\\\')\n\t    /* Do not treat the @ as a start-of-comment.  */\n\t    goto de_fault;\n#endif\n\n#ifdef WARN_COMMENTS\n\t  if (!found_comment)\n\t    as_where (&found_comment_file, &found_comment);\n#endif\n\t  do\n\t    {\n\t      ch = GET ();\n\t    }\n\t  while (ch != EOF && !IS_NEWLINE (ch));\n\t  if (ch == EOF)\n\t    as_warn (_(\"end of file in comment; newline inserted\"));\n\t  state = 0;\n\t  PUT ('\\n');\n\t  break;\n\n#ifdef H_TICK_HEX\n\tcase LEX_IS_H:\n\t  /* Look for strings like H'[0-9A-Fa-f] and if found, replace\n\t     the H' with 0x to make them gas-style hex characters.  */\n\t  if (enable_h_tick_hex)\n\t    {\n\t      char quot;\n\n\t      quot = GET ();\n\t      if (quot == '\\'')\n\t\t{\n\t\t  UNGET ('x');\n\t\t  ch = '0';\n"
}