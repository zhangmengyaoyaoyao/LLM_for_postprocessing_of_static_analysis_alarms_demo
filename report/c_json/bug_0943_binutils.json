{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t  string_append (declp, optable[i].out);",
    "Code_function": "demangle_function_name (struct work_stuff *work, const char **mangled,\n                        string *declp, const char *scan)\n{\n  size_t i;\n  string type;\n  const char *tem;\n\n  string_appendn (declp, (*mangled), scan - (*mangled));\n  string_need (declp, 1);\n  *(declp -> p) = '\\0';\n\n  /* Consume the function name, including the \"__\" separating the name\n     from the signature.  We are guaranteed that SCAN points to the\n     separator.  */\n\n  (*mangled) = scan + 2;\n  /* We may be looking at an instantiation of a template function:\n     foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a\n     following _F marks the start of the function arguments.  Handle\n     the template arguments first. */\n\n  if (HP_DEMANGLING && (**mangled == 'X'))\n    {\n      demangle_arm_hp_template (work, mangled, 0, declp);\n      /* This leaves MANGLED pointing to the 'F' marking func args */\n    }\n\n  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n    {\n\n      /* See if we have an ARM style constructor or destructor operator.\n\t If so, then just record it, clear the decl, and return.\n\t We can't build the actual constructor/destructor decl until later,\n\t when we recover the class name from the signature.  */\n\n      if (strcmp (declp -> b, \"__ct\") == 0)\n\t{\n\t  work -> constructor += 1;\n\t  string_clear (declp);\n\t  return 1;\n\t}\n      else if (strcmp (declp -> b, \"__dt\") == 0)\n\t{\n\t  work -> destructor += 1;\n\t  string_clear (declp);\n\t  return 1;\n\t}\n    }\n\n  if (declp->p - declp->b >= 3\n      && declp->b[0] == 'o'\n      && declp->b[1] == 'p'\n      && strchr (cplus_markers, declp->b[2]) != NULL)\n    {\n      /* see if it's an assignment expression */\n      if (declp->p - declp->b >= 10 /* op$assign_ */\n\t  && memcmp (declp->b + 3, \"assign_\", 7) == 0)\n\t{\n\t  for (i = 0; i < ARRAY_SIZE (optable); i++)\n\t    {\n\t      int len = declp->p - declp->b - 10;\n\t      if ((int) strlen (optable[i].in) == len\n\t\t  && memcmp (optable[i].in, declp->b + 10, len) == 0)\n\t\t{\n\t\t  string_clear (declp);\n\t\t  string_append (declp, \"operator\");\n\t\t  string_append (declp, optable[i].out);\n\t\t  string_append (declp, \"=\");\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for (i = 0; i < ARRAY_SIZE (optable); i++)\n\t    {\n\t      int len = declp->p - declp->b - 3;\n\t      if ((int) strlen (optable[i].in) == len\n\t\t  && memcmp (optable[i].in, declp->b + 3, len) == 0)\n\t\t{\n\t\t  string_clear (declp);\n\t\t  string_append (declp, \"operator\");\n\t\t  string_append (declp, optable[i].out);\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  else if (declp->p - declp->b >= 5 && memcmp (declp->b, \"type\", 4) == 0\n\t   && strchr (cplus_markers, declp->b[4]) != NULL)\n    {\n      /* type conversion operator */\n      tem = declp->b + 5;\n      if (do_type (work, &tem, &type))\n\t{\n\t  string_clear (declp);\n\t  string_append (declp, \"operator \");\n\t  string_appends (declp, &type);\n\t  string_delete (&type);\n\t}\n    }\n  else if (declp->b[0] == '_' && declp->b[1] == '_'\n\t   && declp->b[2] == 'o' && declp->b[3] == 'p')\n    {\n      /* ANSI.  */\n      /* type conversion operator.  */\n      tem = declp->b + 4;\n      if (do_type (work, &tem, &type))\n\t{\n\t  string_clear (declp);\n\t  string_append (declp, \"operator \");\n\t  string_appends (declp, &type);\n\t  string_delete (&type);\n\t}\n    }\n  else if (declp->b[0] == '_' && declp->b[1] == '_'\n\t   && ISLOWER((unsigned char)declp->b[2])\n\t   && ISLOWER((unsigned char)declp->b[3]))\n    {\n      if (declp->b[4] == '\\0')\n\t{\n\t  /* Operator.  */\n\t  for (i = 0; i < ARRAY_SIZE (optable); i++)\n\t    {\n\t      if (strlen (optable[i].in) == 2\n\t\t  && memcmp (optable[i].in, declp->b + 2, 2) == 0)\n\t\t{\n\t\t  string_clear (declp);\n\t\t  string_append (declp, \"operator\");\n\t\t  string_append (declp, optable[i].out);\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  if (declp->b[2] == 'a' && declp->b[5] == '\\0')\n\t    {\n\t      /* Assignment.  */\n\t      for (i = 0; i < ARRAY_SIZE (optable); i++)\n\t\t{\n\t\t  if (strlen (optable[i].in) == 3\n\t\t      && memcmp (optable[i].in, declp->b + 2, 3) == 0)\n\t\t    {\n\t\t      string_clear (declp);\n\t\t      string_append (declp, \"operator\");\n\t\t      string_append (declp, optable[i].out);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  /* If a function name was obtained but it's not valid, we were not\n     successful.  */\n  if (LEN_STRING (declp) == 1 && declp->b[0] == '.')\n    return 0;\n  else\n    return 1;\n}"
}