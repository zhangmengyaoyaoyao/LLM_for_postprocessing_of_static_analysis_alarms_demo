{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `ret` last assigned on line 2313 could be null and is dereferenced at line 2315, column 24.",
    "Code_line": "      di->expansion += ret->u.s_builtin.type->len;",
    "Code_function": "cplus_demangle_type (struct d_info *di)\n{\n  char peek;\n  struct demangle_component *ret;\n  int can_subst;\n\n  /* The ABI specifies that when CV-qualifiers are used, the base type\n     is substitutable, and the fully qualified type is substitutable,\n     but the base type with a strict subset of the CV-qualifiers is\n     not substitutable.  The natural recursive implementation of the\n     CV-qualifiers would cause subsets to be substitutable, so instead\n     we pull them all off now.\n\n     FIXME: The ABI says that order-insensitive vendor qualifiers\n     should be handled in the same way, but we have no way to tell\n     which vendor qualifiers are order-insensitive and which are\n     order-sensitive.  So we just assume that they are all\n     order-sensitive.  g++ 3.4 supports only one vendor qualifier,\n     __vector, and it treats it as order-sensitive when mangling\n     names.  */\n\n  peek = d_peek_char (di);\n  if (peek == 'r' || peek == 'V' || peek == 'K')\n    {\n      struct demangle_component **pret;\n\n      pret = d_cv_qualifiers (di, &ret, 0);\n      if (pret == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'F')\n\t{\n\t  /* cv-qualifiers before a function type apply to 'this',\n\t     so avoid adding the unqualified function type to\n\t     the substitution list.  */\n\t  *pret = d_function_type (di);\n\t}\n      else\n\t*pret = cplus_demangle_type (di);\n      if (!*pret)\n\treturn NULL;\n      if ((*pret)->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t  || (*pret)->type == DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t{\n\t  /* Move the ref-qualifier outside the cv-qualifiers so that\n\t     they are printed in the right order.  */\n\t  struct demangle_component *fn = d_left (*pret);\n\t  d_left (*pret) = ret;\n\t  ret = *pret;\n\t  *pret = fn;\n\t}\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n      return ret;\n    }\n\n  can_subst = 1;\n\n  switch (peek)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':\n    case 'o':                               case 's': case 't':\n    case 'v': case 'w': case 'x': case 'y': case 'z':\n      ret = d_make_builtin_type (di,\n\t\t\t\t &cplus_demangle_builtin_types[peek - 'a']);\n      di->expansion += ret->u.s_builtin.type->len;\n      can_subst = 0;\n      d_advance (di, 1);\n      break;\n\n    case 'u':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,\n\t\t\t d_source_name (di), NULL);\n      break;\n\n    case 'F':\n      ret = d_function_type (di);\n      break;\n\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case 'N':\n    case 'Z':\n      ret = d_class_enum_type (di);\n      break;\n\n    case 'A':\n      ret = d_array_type (di);\n      break;\n\n    case 'M':\n      ret = d_pointer_to_member_type (di);\n      break;\n\n    case 'T':\n      ret = d_template_param (di);\n      if (d_peek_char (di) == 'I')\n\t{\n\t  /* This may be <template-template-param> <template-args>.\n\t     If this is the type for a conversion operator, we can\n\t     have a <template-template-param> here only by following\n\t     a derivation like this:\n\n\t     <nested-name>\n\t     -> <template-prefix> <template-args>\n\t     -> <prefix> <template-unqualified-name> <template-args>\n\t     -> <unqualified-name> <template-unqualified-name> <template-args>\n\t     -> <source-name> <template-unqualified-name> <template-args>\n\t     -> <source-name> <operator-name> <template-args>\n\t     -> <source-name> cv <type> <template-args>\n\t     -> <source-name> cv <template-template-param> <template-args> <template-args>\n\n\t     where the <template-args> is followed by another.\n\t     Otherwise, we must have a derivation like this:\n\n\t     <nested-name>\n\t     -> <template-prefix> <template-args>\n\t     -> <prefix> <template-unqualified-name> <template-args>\n\t     -> <unqualified-name> <template-unqualified-name> <template-args>\n\t     -> <source-name> <template-unqualified-name> <template-args>\n\t     -> <source-name> <operator-name> <template-args>\n\t     -> <source-name> cv <type> <template-args>\n\t     -> <source-name> cv <template-param> <template-args>\n\n\t     where we need to leave the <template-args> to be processed\n\t     by d_prefix (following the <template-prefix>).\n\n\t     The <template-template-param> part is a substitution\n\t     candidate.  */\n\t  if (! di->is_conversion)\n\t    {\n\t      if (! d_add_substitution (di, ret))\n\t\treturn NULL;\n\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t d_template_args (di));\n\t    }\n\t  else\n\t    {\n\t      struct demangle_component *args;\n\t      struct d_info_checkpoint checkpoint;\n\n\t      d_checkpoint (di, &checkpoint);\n\t      args = d_template_args (di);\n\t      if (d_peek_char (di) == 'I')\n\t\t{\n\t\t  if (! d_add_substitution (di, ret))\n\t\t    return NULL;\n\t\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t     args);\n\t\t}\n\t      else\n\t\td_backtrack (di, &checkpoint);\n\t    }\n\t}\n      break;\n\n    case 'S':\n      /* If this is a special substitution, then it is the start of\n\t <class-enum-type>.  */\n      {\n\tchar peek_next;\n\n\tpeek_next = d_peek_next_char (di);\n\tif (IS_DIGIT (peek_next)\n\t    || peek_next == '_'\n\t    || IS_UPPER (peek_next))\n\t  {\n\t    ret = d_substitution (di, 0);\n\t    /* The substituted name may have been a template name and\n\t       may be followed by tepmlate args.  */\n\t    if (d_peek_char (di) == 'I')\n\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t d_template_args (di));\n\t    else\n\t      can_subst = 0;\n\t  }\n\telse\n\t  {\n\t    ret = d_class_enum_type (di);\n\t    /* If the substitution was a complete type, then it is not\n\t       a new substitution candidate.  However, if the\n\t       substitution was followed by template arguments, then\n\t       the whole thing is a substitution candidate.  */\n\t    if (ret != NULL && ret->type == DEMANGLE_COMPONENT_SUB_STD)\n\t      can_subst = 0;\n\t  }\n      }\n      break;\n\n    case 'O':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_RVALUE_REFERENCE,\n                         cplus_demangle_type (di), NULL);\n      break;\n\n    case 'P':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_POINTER,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'R':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_REFERENCE,\n                         cplus_demangle_type (di), NULL);\n      break;\n\n    case 'C':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_COMPLEX,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'G':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_IMAGINARY,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'U':\n      d_advance (di, 1);\n      ret = d_source_name (di);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,\n\t\t\t cplus_demangle_type (di), ret);\n      break;\n\n    case 'D':\n      can_subst = 0;\n      d_advance (di, 1);\n      peek = d_next_char (di);\n      switch (peek)\n\t{\n\tcase 'T':\n\tcase 't':\n\t  /* decltype (expression) */\n\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_DECLTYPE,\n\t\t\t     d_expression (di), NULL);\n\t  if (ret && d_next_char (di) != 'E')\n\t    ret = NULL;\n\t  can_subst = 1;\n\t  break;\n\n\tcase 'p':\n\t  /* Pack expansion.  */\n\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t     cplus_demangle_type (di), NULL);\n\t  can_subst = 1;\n\t  break;\n\n\tcase 'a':\n\t  /* auto */\n\t  ret = d_make_name (di, \"auto\", 4);\n\t  break;\n\n\tcase 'f':\n\t  /* 32-bit decimal floating point */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[26]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\tcase 'd':\n\t  /* 64-bit DFP */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[27]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\tcase 'e':\n\t  /* 128-bit DFP */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[28]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\tcase 'h':\n\t  /* 16-bit half-precision FP */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[29]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\tcase 's':\n\t  /* char16_t */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[30]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\tcase 'i':\n\t  /* char32_t */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[31]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\n\tcase 'F':\n\t  /* Fixed point types. DF<int bits><length><fract bits><sat>  */\n\t  ret = d_make_empty (di);\n\t  ret->type = DEMANGLE_COMPONENT_FIXED_TYPE;\n\t  if ((ret->u.s_fixed.accum = IS_DIGIT (d_peek_char (di))))\n\t    /* For demangling we don't care about the bits.  */\n\t    d_number (di);\n\t  ret->u.s_fixed.length = cplus_demangle_type (di);\n\t  if (ret->u.s_fixed.length == NULL)\n\t    return NULL;\n\t  d_number (di);\n\t  peek = d_next_char (di);\n\t  ret->u.s_fixed.sat = (peek == 's');\n\t  break;\n\n\tcase 'v':\n\t  ret = d_vector_type (di);\n\t  can_subst = 1;\n\t  break;\n\n        case 'n':\n          /* decltype(nullptr) */\n\t  ret = d_make_builtin_type (di, &cplus_demangle_builtin_types[32]);\n\t  di->expansion += ret->u.s_builtin.type->len;\n\t  break;\n\n\tdefault:\n\t  return NULL;\n\t}\n      break;\n\n    default:\n      return NULL;\n    }\n\n  if (can_subst)\n    {\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n    }\n\n  return ret;\n}"
}