{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "bfd/dwarf2.c",
    "message": "Offset: [1, 20] Size: 2 by call to `bfd_follow_gnu_debuglink`.",
    "warning_function_name": "_bfd_dwarf2_slurp_debug_info",
    "warning_line": "char * debug_filename = bfd_follow_gnu_debuglink (abfd, DEBUGDIR);",
    "warning_context": "bfd_boolean\n_bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n\t\t\t      const struct dwarf_debug_section *debug_sections,\n\t\t\t      asymbol **symbols,\n\t\t\t      void **pinfo,\n\t\t\t      bfd_boolean do_place)\n{\n  bfd_size_type amt = sizeof (struct dwarf2_debug);\n  bfd_size_type total_size;\n  asection *msec;\n  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;\n\n  if (stash != NULL)\n    {\n      if (section_vma_same (abfd, stash))\n\treturn TRUE;\n      _bfd_dwarf2_cleanup_debug_info (abfd, pinfo);\n      memset (stash, 0, amt);\n    }\n  else\n    {\n      stash = (struct dwarf2_debug *) bfd_zalloc (abfd, amt);\n      if (! stash)\n\treturn FALSE;\n    }\n  stash->debug_sections = debug_sections;\n  stash->syms = symbols;\n  if (!save_section_vma (abfd, stash))\n    return FALSE;\n\n  *pinfo = stash;\n\n  if (debug_bfd == NULL)\n    debug_bfd = abfd;\n\n  msec = find_debug_info (debug_bfd, debug_sections, NULL);\n  if (msec == NULL && abfd == debug_bfd)\n    {\n      char * debug_filename = bfd_follow_gnu_debuglink (abfd, DEBUGDIR);\n\n      if (debug_filename == NULL)\n\t/* No dwarf2 info, and no gnu_debuglink to follow.\n\t   Note that at this point the stash has been allocated, but\n\t   contains zeros.  This lets future calls to this function\n\t   fail more quickly.  */\n\treturn FALSE;\n\n      if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL\n\t  || ! bfd_check_format (debug_bfd, bfd_object)\n\t  || (msec = find_debug_info (debug_bfd,\n\t\t\t\t      debug_sections, NULL)) == NULL\n\t  || !bfd_generic_link_read_symbols (debug_bfd))\n\t{\n\t  if (debug_bfd)\n\t    bfd_close (debug_bfd);\n\t  /* FIXME: Should we report our failure to follow the debuglink ?  */\n\t  free (debug_filename);\n\t  return FALSE;\n\t}\n\n      symbols = bfd_get_outsymbols (debug_bfd);\n      stash->syms = symbols;\n      stash->close_on_cleanup = TRUE;\n    }\n  stash->bfd_ptr = debug_bfd;\n\n  if (do_place\n      && !place_sections (abfd, stash))\n    return FALSE;\n\n  /* There can be more than one DWARF2 info section in a BFD these\n     days.  First handle the easy case when there's only one.  If\n     there's more than one, try case two: none of the sections is\n     compressed.  In that case, read them all in and produce one\n     large stash.  We do this in two passes - in the first pass we\n     just accumulate the section sizes, and in the second pass we\n     read in the section's contents.  (The allows us to avoid\n     reallocing the data as we add sections to the stash.)  If\n     some or all sections are compressed, then do things the slow\n     way, with a bunch of reallocs.  */\n\n  if (! find_debug_info (debug_bfd, debug_sections, msec))\n    {\n      /* Case 1: only one info section.  */\n      total_size = msec->size;\n      if (! read_section (debug_bfd, &stash->debug_sections[debug_info],\n\t\t\t  symbols, 0,\n\t\t\t  &stash->info_ptr_memory, &total_size))\n\treturn FALSE;\n    }\n  else\n    {\n      /* Case 2: multiple sections.  */\n      for (total_size = 0;\n\t   msec;\n\t   msec = find_debug_info (debug_bfd, debug_sections, msec))\n\ttotal_size += msec->size;\n\n      stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);\n      if (stash->info_ptr_memory == NULL)\n\treturn FALSE;\n"
}