{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from temp was never initialized.",
    "warning_function_name": "parameter_brace_patsub",
    "warning_line": "return temp;",
    "warning_context": "\t special.  THIS IS NOT BACKWARDS COMPATIBLE WITH BASH-4.2. */\n      if (shell_compatibility_level > 42)\n\trep = expand_string_if_necessary (rep, quoted & ~(Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT), expand_string_unsplit);\n      /* This is the bash-4.2 code. */      \n      else if ((mflags & MATCH_QUOTED) == 0)\n\trep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);\n      else\n\trep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);\n    }\n\n  /* ksh93 doesn't allow the match specifier to be a part of the expanded\n     pattern.  This is an extension.  Make sure we don't anchor the pattern\n     at the beginning or end of the string if we're doing global replacement,\n     though. */\n  p = pat;\n  if (mflags & MATCH_GLOBREP)\n    mflags |= MATCH_ANY;\n  else if (pat && pat[0] == '#')\n    {\n      mflags |= MATCH_BEG;\n      p++;\n    }\n  else if (pat && pat[0] == '%')\n    {\n      mflags |= MATCH_END;\n      p++;\n    }\n  else\n    mflags |= MATCH_ANY;\n\n  /* OK, we now want to substitute REP for PAT in VAL.  If\n     flags & MATCH_GLOBREP is non-zero, the substitution is done\n     everywhere, otherwise only the first occurrence of PAT is\n     replaced.  The pattern matching code doesn't understand\n     CTLESC quoting CTLESC and CTLNUL so we use the dequoted variable\n     values passed in (VT_VARIABLE) so the pattern substitution\n     code works right.  We need to requote special chars after\n     we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the\n     other cases if QUOTED == 0, since the posparams and arrays\n     indexed by * or @ do special things when QUOTED != 0. */\n\n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp = pat_subst (val, p, rep, mflags);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp)\n\t{\n\t  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n    case VT_POSPARMS:\n      temp = pos_params_pat_subst (val, p, rep, mflags);\n      if (temp && (mflags & MATCH_QUOTED) == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n      temp = assoc_p (v) ? assoc_patsub (assoc_cell (v), p, rep, mflags)\n\t\t\t : array_patsub (array_cell (v), p, rep, mflags);\n      /* Don't call quote_escapes anymore; array_patsub calls\n\t array_quote_escapes as appropriate before adding the\n\t space separators; ditto for assoc_patsub. */\n      break;\n#endif\n    }\n\n  FREE (pat);\n  FREE (rep);\n  free (lpatsub);\n\n  return temp;\n}\n\n/****************************************************************/\n/*\t\t\t\t\t\t\t\t*/\n/*   Functions to perform case modification on variable values  */\n/*\t\t\t\t\t\t\t\t*/\n/****************************************************************/\n\n/* Do case modification on the positional parameters. */\n\nstatic char *\npos_params_modcase (string, pat, modop, mflags)\n     char *string, *pat;\n     int modop;\n     int mflags;\n{\n  WORD_LIST *save, *params;\n  WORD_DESC *w;\n  char *ret;\n  int pchar, qflags;\n\n"
}