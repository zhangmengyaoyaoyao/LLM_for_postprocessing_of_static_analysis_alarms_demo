{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "io.c",
    "message": "Offset: [1, 2] Size: 2 by call to `devopen`.",
    "warning_function_name": "redirect",
    "warning_line": "fd = devopen(str, binmode(\"r\"));",
    "warning_context": "\t\t    && memcmp(rp->value, str, redir_exp->stlen) == 0\n\t\t    && ((rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY)) == tflag\n\t\t\t|| (outflag != 0\n\t\t\t    && (rp->flag & (RED_FILE|RED_WRITE)) == outflag))) {\n\n\t\t\tint rpflag = (rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\t\t\tint newflag = (tflag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\n\t\t\tif (do_lint && rpflag != newflag)\n\t\t\t\tlintwarn(\n\t\t_(\"unnecessary mixing of `>' and `>>' for file `%.*s'\"),\n\t\t\t\t\t(int) redir_exp->stlen, rp->value);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rp == NULL) {\n\t\tnew_rp = true;\n\t\tif (save_rp != NULL) {\n\t\t\trp = save_rp;\n\t\t\tefree(rp->value);\n\t\t} else\n\t\t\temalloc(rp, struct redirect *, sizeof(struct redirect), \"redirect\");\n\t\temalloc(str, char *, redir_exp->stlen + 1, \"redirect\");\n\t\tmemcpy(str, redir_exp->stptr, redir_exp->stlen);\n\t\tstr[redir_exp->stlen] = '\\0';\n\t\trp->value = str;\n\t\trp->flag = tflag;\n\t\tinit_output_wrapper(& rp->output);\n\t\trp->output.name = str;\n\t\trp->iop = NULL;\n\t\trp->pid = -1;\n\t\trp->status = 0;\n\t} else\n\t\tstr = rp->value;\t/* get \\0 terminated string */\n\tsave_rp = rp;\n\n\twhile (rp->output.fp == NULL && rp->iop == NULL) {\n\t\tif (! new_rp && (rp->flag & RED_EOF) != 0) {\n\t\t\t/*\n\t\t\t * Encountered EOF on file or pipe -- must be cleared\n\t\t\t * by explicit close() before reading more\n\t\t\t */\n\t\t\tsave_rp = NULL;\n\t\t\treturn rp;\n\t\t}\n\t\tmode = NULL;\n\t\terrno = 0;\n\t\tswitch (redirtype) {\n\t\tcase redirect_output:\n\t\t\tmode = binmode(\"w\");\n\t\t\tif ((rp->flag & RED_USED) != 0)\n\t\t\t\tmode = (rp->mode[1] == 'b') ? \"ab\" : \"a\";\n\t\t\tbreak;\n\t\tcase redirect_append:\n\t\t\tmode = binmode(\"a\");\n\t\t\tbreak;\n\t\tcase redirect_pipe:\n\t\t\t/* synchronize output before new pipe */\n\t\t\t(void) flush_io();\n\n\t\t\tos_restore_mode(fileno(stdin));\n\t\t\tif ((rp->output.fp = popen(str, binmode(\"w\"))) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for output (%s)\"),\n\t\t\t\t\t\tstr, strerror(errno));\n\n\t\t\t/* set close-on-exec */\n\t\t\tos_close_on_exec(fileno(rp->output.fp), str, \"pipe\", \"to\");\n\t\t\trp->flag |= RED_NOBUF;\n\t\t\tbreak;\n\t\tcase redirect_pipein:\n\t\t\tdirection = \"from\";\n\t\t\tif (gawk_popen(str, rp) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for input (%s)\"),\n\t\t\t\t\tstr, strerror(errno));\n\t\t\tbreak;\n\t\tcase redirect_input:\n\t\t\tdirection = \"from\";\n\t\t\tfd = devopen(str, binmode(\"r\"));\n\t\t\tif (fd == INVALID_HANDLE && errno == EISDIR) {\n\t\t\t\t*errflg = EISDIR;\n\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trp->iop = iop_alloc(fd, str, errno);\n\t\t\tfind_input_parser(rp->iop);\n\t\t\tiop_finish(rp->iop);\n\t\t\tif (! rp->iop->valid) {\n\t\t\t\tif (! do_traditional && rp->iop->errcode != 0)\n\t\t\t\t\tupdate_ERRNO_int(rp->iop->errcode);\n\t\t\t\tiop_close(rp->iop);\n\t\t\t\trp->iop = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase redirect_twoway:\n\t\t\tdirection = \"to/from\";\n\t\t\tif (! two_way_open(str, rp)) {\n#ifdef HAVE_SOCKETS\n\t\t\t\tif (inetfile(str, NULL)) {\n\t\t\t\t\t*errflg = errno;\n"
}