{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "expand_arith_string",
    "warning_line": "ADVANCE_CHAR (string, slen, i);",
    "warning_context": "char *\nexpand_arith_string (string, quoted)\n     char *string;\n     int quoted;\n{\n  WORD_DESC td;\n  WORD_LIST *list, *tlist;\n  size_t slen;\n  int i, saw_quote;\n  char *ret;\n  DECLARE_MBSTATE;\n\n  /* Don't need string length for ADVANCE_CHAR unless multibyte chars possible. */\n  slen = (MB_CUR_MAX > 1) ? strlen (string) : 0;\n  i = saw_quote = 0;\n  while (string[i])\n    {\n      if (EXP_CHAR (string[i]))\n\tbreak;\n      else if (string[i] == '\\'' || string[i] == '\\\\' || string[i] == '\"')\n\tsaw_quote = 1;\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  if (string[i])\n    {\n      /* This is expanded version of expand_string_internal as it's called by\n\t expand_string_leave_quoted  */\n      td.flags = W_NOPROCSUB;\t/* don't want process substitution */\n      td.word = savestring (string);\n      list = call_expand_word_internal (&td, quoted, 0, (int *)NULL, (int *)NULL);\n      /* This takes care of the calls from expand_string_leave_quoted and\n\t expand_string */\n      if (list)\n\t{\n\t  tlist = word_list_split (list);\n\t  dispose_words (list);\n\t  list = tlist;\n\t  if (list)\n\t    dequote_list (list);\n\t}\n      /* This comes from expand_string_if_necessary */\n      if (list)\n\t{\n\t  ret = string_list (list);\n\t  dispose_words (list);\n\t}\n      else\n\tret = (char *)NULL;\n      FREE (td.word);\n    }\n  else if (saw_quote && ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) == 0))\n    ret = string_quote_removal (string, quoted);\n  else\n    ret = savestring (string);\n\n  return ret;\n}\n"
}