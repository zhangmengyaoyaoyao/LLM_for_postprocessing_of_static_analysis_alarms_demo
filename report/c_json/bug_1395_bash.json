{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from tlen was never initialized.",
    "Code_line": "\t  if (mlen >= tlen)",
    "Code_function": "rl_complete_internal (what_to_do)\n     int what_to_do;\n{\n  char **matches;\n  rl_compentry_func_t *our_func;\n  int start, end, delimiter, found_quote, i, nontrivial_lcd;\n  char *text, *saved_line_buffer;\n  char quote_char;\n#if 1\n  int tlen, mlen;\n#endif\n\n  RL_SETSTATE(RL_STATE_COMPLETING);\n\n  set_completion_defaults (what_to_do);\n\n  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;\n  our_func = rl_completion_entry_function\n\t\t? rl_completion_entry_function\n\t\t: rl_filename_completion_function;\n  /* We now look backwards for the start of a filename/variable word. */\n  end = rl_point;\n  found_quote = delimiter = 0;\n  quote_char = '\\0';\n\n  if (rl_point)\n    /* This (possibly) changes rl_point.  If it returns a non-zero char,\n       we know we have an open quote. */\n    quote_char = _rl_find_completion_word (&found_quote, &delimiter);\n\n  start = rl_point;\n  rl_point = end;\n\n  text = rl_copy_text (start, end);\n  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);\n  /* nontrivial_lcd is set if the common prefix adds something to the word\n     being completed. */\n  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;\n  if (what_to_do == '!' || what_to_do == '@')\n    tlen = strlen (text);\n  xfree (text);\n\n  if (matches == 0)\n    {\n      rl_ding ();\n      FREE (saved_line_buffer);\n      completion_changed_buffer = 0;\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_reset_completion_state ();\n      return (0);\n    }\n\n  /* If we are matching filenames, the attempted completion function will\n     have set rl_filename_completion_desired to a non-zero value.  The basic\n     rl_filename_completion_function does this. */\n  i = rl_filename_completion_desired;\n\n  if (postprocess_matches (&matches, i) == 0)\n    {\n      rl_ding ();\n      FREE (saved_line_buffer);\n      completion_changed_buffer = 0;\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_reset_completion_state ();\n      return (0);\n    }\n\n  switch (what_to_do)\n    {\n    case TAB:\n    case '!':\n    case '@':\n      /* Insert the first match with proper quoting. */\n      if (what_to_do == TAB)\n        {\n          if (*matches[0])\n\t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n        }\n      else if (*matches[0] && matches[1] == 0)\n\t/* should we perform the check only if there are multiple matches? */\n\tinsert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n      else if (*matches[0])\t/* what_to_do != TAB && multiple matches */\n\t{\n\t  mlen = *matches[0] ? strlen (matches[0]) : 0;\n\t  if (mlen >= tlen)\n\t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n\t}\n\n      /* If there are more matches, ring the bell to indicate.\n\t If we are in vi mode, Posix.2 says to not ring the bell.\n\t If the `show-all-if-ambiguous' variable is set, display\n\t all the matches immediately.  Otherwise, if this was the\n\t only match, and we are hacking files, check the file to\n\t see if it was a directory.  If so, and the `mark-directories'\n\t variable is set, add a '/' to the name.  If not, and we\n\t are at the end of the line, then add a space.  */\n      if (matches[1])\n\t{\n\t  if (what_to_do == '!')\n\t    {\n\t      display_matches (matches);\n\t      break;\n\t    }\n\t  else if (what_to_do == '@')\n\t    {\n\t      if (nontrivial_lcd == 0)\n\t\tdisplay_matches (matches);\n\t      break;\n\t    }\n\t  else if (rl_editing_mode != vi_mode)\n\t    rl_ding ();\t/* There are other matches remaining. */\n\t}\n      else\n\tappend_to_match (matches[0], delimiter, quote_char, nontrivial_lcd);\n\n      break;\n\n    case '*':\n      insert_all_matches (matches, start, &quote_char);\n      break;\n\n    case '?':\n      if (rl_completion_display_matches_hook == 0)\n\t{\n\t  _rl_sigcleanup = _rl_complete_sigcleanup;\n\t  _rl_sigcleanarg = matches;\n\t}\n      display_matches (matches);\n      _rl_sigcleanup = 0;\n      _rl_sigcleanarg = 0;\n      break;\n\n    default:\n      _rl_ttymsg (\"bad value %d for what_to_do in rl_complete\", what_to_do);\n      rl_ding ();\n      FREE (saved_line_buffer);\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_free_match_list (matches);\n      _rl_reset_completion_state ();\n      return 1;\n    }\n\n  _rl_free_match_list (matches);\n\n  /* Check to see if the line has changed through all of this manipulation. */\n  if (saved_line_buffer)\n    {\n      completion_changed_buffer = strcmp (rl_line_buffer, saved_line_buffer) != 0;\n      xfree (saved_line_buffer);\n    }\n\n  RL_UNSETSTATE(RL_STATE_COMPLETING);\n  _rl_reset_completion_state ();\n  return 0;\n}"
}