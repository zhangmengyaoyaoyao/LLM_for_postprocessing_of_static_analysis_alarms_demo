{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/app.c",
    "message": "The value read from fromlen was never initialized.",
    "warning_function_name": "process_escape",
    "warning_line": "ch2 = GET ();",
    "warning_context": "\t      && lex[ch] == LEX_IS_COLON\n\t      && ! scrub_m68k_mri)\n\t    {\n\t      state = 1;\n\t      PUT (ch);\n\t      break;\n\t    }\n\n\t  switch (state)\n\t    {\n\t    case 1:\n\t      /* We can arrive here if we leave a leading whitespace\n\t\t character at the beginning of a line.  */\n\t      goto recycle;\n\t    case 2:\n\t      state = 3;\n\t      if (to + 1 < toend)\n\t\t{\n\t\t  /* Optimize common case by skipping UNGET/GET.  */\n\t\t  PUT (' ');\t/* Sp after opco */\n\t\t  goto recycle;\n\t\t}\n\t      UNGET (ch);\n\t      PUT (' ');\n\t      break;\n\t    case 3:\n#ifndef TC_KEEP_OPERAND_SPACES\n\t      /* For TI C6X, we keep these spaces as they may separate\n\t\t functional unit specifiers from operands.  */\n\t      if (scrub_m68k_mri)\n#endif\n\t\t{\n\t\t  /* In MRI mode, we keep these spaces.  */\n\t\t  UNGET (ch);\n\t\t  PUT (' ');\n\t\t  break;\n\t\t}\n\t      goto recycle;\t/* Sp in operands */\n\t    case 9:\n\t    case 10:\n#ifndef TC_KEEP_OPERAND_SPACES\n\t      if (scrub_m68k_mri)\n#endif\n\t\t{\n\t\t  /* In MRI mode, we keep these spaces.  */\n\t\t  state = 3;\n\t\t  UNGET (ch);\n\t\t  PUT (' ');\n\t\t  break;\n\t\t}\n\t      state = 10;\t/* Sp after symbol char */\n\t      goto recycle;\n\t    case 11:\n\t      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)\n\t\tstate = 1;\n\t      else\n\t\t{\n\t\t  /* We know that ch is not ':', since we tested that\n\t\t     case above.  Therefore this is not a label, so it\n\t\t     must be the opcode, and we've just seen the\n\t\t     whitespace after it.  */\n\t\t  state = 3;\n\t\t}\n\t      UNGET (ch);\n\t      PUT (' ');\t/* Sp after label definition.  */\n\t      break;\n\t    default:\n\t      BAD_CASE (state);\n\t    }\n\t  break;\n\n\tcase LEX_IS_TWOCHAR_COMMENT_1ST:\n\t  ch2 = GET ();\n\t  if (ch2 == '*')\n\t    {\n\t      for (;;)\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      ch2 = GET ();\n\t\t      if (ch2 != EOF && IS_NEWLINE (ch2))\n\t\t\tadd_newlines++;\n\t\t    }\n\t\t  while (ch2 != EOF && ch2 != '*');\n\n\t\t  while (ch2 == '*')\n\t\t    ch2 = GET ();\n\n\t\t  if (ch2 == EOF || ch2 == '/')\n\t\t    break;\n\n\t\t  /* This UNGET will ensure that we count newlines\n\t\t     correctly.  */\n\t\t  UNGET (ch2);\n\t\t}\n\n\t      if (ch2 == EOF)\n\t\tas_warn (_(\"end of file in multiline comment\"));\n\n\t      ch = ' ';\n\t      goto recycle;\n"
}