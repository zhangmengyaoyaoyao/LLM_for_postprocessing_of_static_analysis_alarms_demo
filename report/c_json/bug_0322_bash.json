{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "execute_cmd.c",
    "message": "The value read from lastpipe_jid was never initialized.",
    "warning_function_name": "execute_pipeline",
    "warning_line": "exec_result = job_exit_status (lastpipe_jid);",
    "warning_context": "      if (prev >= 0)\n\tadd_unwind_protect (close, prev);\n      dummyfd = fildes[1];\n      add_unwind_protect (close, dummyfd);\n\n#if defined (JOB_CONTROL)\n      add_unwind_protect (restore_signal_mask, &oset);\n#endif /* JOB_CONTROL */\n\n      if (ignore_return && cmd->value.Connection->first)\n\tcmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;\n      execute_command_internal (cmd->value.Connection->first, asynchronous,\n\t\t\t\tprev, fildes[1], fd_bitmap);\n\n      if (prev >= 0)\n\tclose (prev);\n\n      prev = fildes[0];\n      close (fildes[1]);\n\n      dispose_fd_bitmap (fd_bitmap);\n      discard_unwind_frame (\"pipe-file-descriptors\");\n\n      cmd = cmd->value.Connection->second;\n    }\n\n  lastpid = last_made_pid;\n\n  /* Now execute the rightmost command in the pipeline.  */\n  if (ignore_return && cmd)\n    cmd->flags |= CMD_IGNORE_RETURN;\n\n  lastpipe_flag = 0;\n\n  begin_unwind_frame (\"lastpipe-exec\");\n  lstdin = -1;\n  /* If the `lastpipe' option is set with shopt, and job control is not\n     enabled, execute the last element of non-async pipelines in the\n     current shell environment. */\n  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)\n    {\n      lstdin = move_to_high_fd (0, 1, -1);\n      if (lstdin > 0)\n\t{\n\t  do_piping (prev, pipe_out);\n\t  prev = NO_PIPE;\n\t  add_unwind_protect (restore_stdin, lstdin);\n\t  lastpipe_flag = 1;\n\t  freeze_jobs_list ();\n\t  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);\t/* XXX */\n\t  add_unwind_protect (lastpipe_cleanup, lastpipe_jid);\n\t}\n      if (cmd)\n\tcmd->flags |= CMD_LASTPIPE;\n    }\t  \n  if (prev >= 0)\n    add_unwind_protect (close, prev);\n\n  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);\n\n  if (lstdin > 0)\n    restore_stdin (lstdin);\n\n  if (prev >= 0)\n    close (prev);\n\n#if defined (JOB_CONTROL)\n  UNBLOCK_CHILD (oset);\n#endif\n\n  QUIT;\n\n  if (lastpipe_flag)\n    {\n#if defined (JOB_CONTROL)\n      append_process (savestring (the_printed_command), dollar_dollar_pid, exec_result, lastpipe_jid);\n#endif\n      lstdin = wait_for (lastpid);\n#if defined (JOB_CONTROL)\n      exec_result = job_exit_status (lastpipe_jid);\n#endif\n      unfreeze_jobs_list ();\n    }\n\n  discard_unwind_frame (\"lastpipe-exec\");\n\n  return (exec_result);\n}\n\nstatic int\nexecute_connection (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous, pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  COMMAND *tc, *second;\n  int ignore_return, exec_result, was_error_trap, invert;\n  volatile int save_line_number;\n\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n"
}