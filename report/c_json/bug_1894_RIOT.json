{
    "Project": "RIOT",
    "Tool": "Infer",
    "category": "Uninitialized Value",
    "file": "sys/hashes/md5.c",
    "message": "The value read from x[_] was never initialized.",
    "warning_function_name": "ermute(",
    "warning_line": "a = md5H( b, c, d ) + x[ K[1][i] ];",
    "warning_context": "static void permute(uint32_t abcd[4], const uint8_t block[64] )\n{\n    uint8_t s;\n    uint32_t a, b, c, d;\n    uint32_t keep_abcd[4];\n    uint32_t x[16];\n\n    /* Store the current ABCD values for later re-use */\n    for (int i = 0; i < 4; i++) {\n        keep_abcd[i] = abcd[i];\n    }\n\n    /* Convert the input block into an array of unsigned longs, taking care\n     * to read the block in Little Endian order (the algorithm assumes this).\n     * The uint32_t values are then handled in host order. */\n    for (int i = 0, j = 0; i < 16; i++) {\n        x[i]  =  (uint32_t)block[j++];\n        x[i] |= ((uint32_t)block[j++] << 8);\n        x[i] |= ((uint32_t)block[j++] << 16);\n        x[i] |= ((uint32_t)block[j++] << 24);\n    }\n\n    /* This loop performs the four rounds of permutations.\n     * The rounds are each very similar.  The differences are in three areas:\n     *   - The function (F, G, H, or I) used to perform bitwise permutations\n     *     on the registers,\n     *   - The order in which values from X[] are chosen.\n     *   - Changes to the number of bits by which the registers are rotated.\n     * This implementation uses a switch statement to deal with some of the\n     * differences between rounds.  Other differences are handled by storing\n     * values in arrays and using the round number to select the correct set\n     * of values.\n     *\n     * (My implementation appears to be a poor compromise between speed, size,\n     * and clarity.  Ugh.  [crh]) */\n    for (int round = 0; round < 4; round++) {\n        for (int i = 0; i < 16; i++) {\n            /* <j> handles the rotation of ABCD */\n            int j = (4 - (i % 4)) & 0x3;\n            /* <s> is the bit shift for this iteration */\n            s = S[round][i % 4];\n\n            /* Copy the b,c,d values per ABCD rotation. This isn't really\n             * necessary, it just looks clean & will hopefully be optimized\n             * away. */\n            b = abcd[(j + 1) & 0x3];\n            c = abcd[(j + 2) & 0x3];\n            d = abcd[(j + 3) & 0x3];\n\n            /* The actual perumation function.\n             * This is broken out to minimize the code within the switch(). */\n            switch (round) {\n                case 0:         /* round 1 */\n                    a = md5F( b, c, d ) + x[i];\n                    break;\n                case 1:         /* round 2 */\n                    a = md5G( b, c, d ) + x[ K[0][i] ];\n                    break;\n                case 2:         /* round 3 */\n                    a = md5H( b, c, d ) + x[ K[1][i] ];\n                    break;\n                default:        /* round 4 */\n                    a = md5I( b, c, d ) + x[ K[2][i] ];\n                    break;\n            }\n            a = 0xFFFFFFFF & (abcd[j] + a + T[round][i]);\n            abcd[j] = b + (0xFFFFFFFF & ((a << s) | (a >> (32 - s))));\n        }\n    }\n\n    /* Use the stored original A, B, C, D values to perform\n     * one last convolution. */\n    for (int i = 0; i < 4; i++) {\n        abcd[i] = (abcd[i] + keep_abcd[i]);\n    }\n}\n"
}