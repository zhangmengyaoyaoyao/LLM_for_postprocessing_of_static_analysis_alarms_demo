{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Code_line": "\tparse_args(argc, argv);",
    "Code_function": "main(int argc, char **argv)\n{\n\tint i;\n\tchar *extra_stack;\n\tint have_srcfile = 0;\n\tSRCFILE *s;\n\n\t/* do these checks early */\n\tif (getenv(\"TIDYMEM\") != NULL)\n\t\tdo_flags |= DO_TIDY_MEM;\n\n#ifdef HAVE_MCHECK_H\n#ifdef HAVE_MTRACE\n\tif (do_tidy_mem)\n\t\tmtrace();\n#endif /* HAVE_MTRACE */\n#endif /* HAVE_MCHECK_H */\n\n\tmyname = gawk_name(argv[0]);\n\tos_arg_fixup(&argc, &argv); /* emulate redirection, expand wildcards */\n\n\tif (argc < 2)\n\t\tusage(EXIT_FAILURE, stderr);\n\n\t(void) bindtextdomain(PACKAGE, LOCALEDIR);\n\t(void) textdomain(PACKAGE);\n\n\t(void) signal(SIGFPE, catchsig);\n#ifdef SIGBUS\n\t(void) signal(SIGBUS, catchsig);\n#endif\n#ifdef SIGPIPE\n\t/*\n\t * Ignore SIGPIPE so that writes to pipes that fail don't\n\t * kill the process but instead return -1 and set errno.\n\t * That lets us print a fatal message instead of dieing suddenly.\n\t *\n\t * Note that this requires ignoring EPIPE when writing and\n\t * flushing stdout/stderr in other parts of the program. E.g.,\n\t *\n\t * \tgawk 'BEGIN { print \"hi\" }' | exit\n\t *\n\t * should not give us \"broken pipe\" messages --- mainly because\n\t * it did not do so in the past and people would complain.\n\t */\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t(void) sigsegv_install_handler(catchsegv);\n#define STACK_SIZE (16*1024)\n\temalloc(extra_stack, char *, STACK_SIZE, \"main\");\n\t(void) stackoverflow_install_handler(catchstackoverflow, extra_stack, STACK_SIZE);\n#undef STACK_SIZE\n\n\t/* initialize the null string */\n\tNnull_string = make_string(\"\", 0);\n\n\t/* Robustness: check that file descriptors 0, 1, 2 are open */\n\tinit_fds();\n\n\t/* init array handling. */\n\tarray_init();\n\n\t/* init the symbol tables */\n\tinit_symbol_table();\n\n\toutput_fp = stdout;\n\n\t/* initialize global (main) execution context */\n\tpush_context(new_context());\n\n\tparse_args(argc, argv);\n\n\tset_locale_stuff();\n\n\t/*\n\t * In glibc, MB_CUR_MAX is actually a function.  This value is\n\t * tested *a lot* in many speed-critical places in gawk. Caching\n\t * this value once makes a speed difference.\n\t */\n\tgawk_mb_cur_max = MB_CUR_MAX;\n#ifdef LIBC_IS_BORKED\n{\n\tconst char *env_lc;\n\n\tenv_lc = getenv(\"LC_ALL\");\n\tif (env_lc == NULL)\n\t\tenv_lc = getenv(\"LANG\");\n\tif (env_lc != NULL && env_lc[1] == '\\0' && tolower(env_lc[0]) == 'c')\n\t\tgawk_mb_cur_max = 1;\n}\n#endif\n\n\t/* init the cache for checking bytes if they're characters */\n\tinit_btowc_cache();\n\n\n\tif (do_nostalgia)\n\t\tnostalgia();\n\n\t/* check for POSIXLY_CORRECT environment variable */\n\tif (! do_posix && getenv(\"POSIXLY_CORRECT\") != NULL) {\n\t\tdo_flags |= DO_POSIX;\n\t\tif (do_lint)\n\t\t\tlintwarn(\n\t_(\"environment variable `POSIXLY_CORRECT' set: turning on `--posix'\"));\n\t}\n\n\tif (do_posix) {\n\t\tuse_lc_numeric = true;\n\t\tif (do_traditional)\t/* both on command line */\n\t\t\twarning(_(\"`--posix' overrides `--traditional'\"));\n\t\telse\n\t\t\tdo_flags |= DO_TRADITIONAL;\n\t\t\t/*\n\t\t\t * POSIX compliance also implies\n\t\t\t * no GNU extensions either.\n\t\t\t */\n\t}\n\n\tif (do_traditional && do_non_decimal_data) {\n\t\tdo_flags &= ~DO_NON_DEC_DATA;\n\t\twarning(_(\"`--posix'/`--traditional' overrides `--non-decimal-data'\"));\n\t}\n\n\tif (do_lint && os_is_setuid())\n\t\twarning(_(\"running %s setuid root may be a security problem\"), myname);\n\n\tif (do_binary) {\n\t\tif (do_posix)\n\t\t\twarning(_(\"`--posix' overrides `--characters-as-bytes'\"));\n\t\telse\n\t\t\tgawk_mb_cur_max = 1;\t/* hands off my data! */\n#if defined(LC_ALL)\n\t\tsetlocale(LC_ALL, \"C\");\n#endif\n\t}\n\n\tif (do_debug)\t/* Need to register the debugger pre-exec hook before any other */\n\t\tinit_debug();\n\n#ifdef HAVE_MPFR\n\t/* Set up MPFR defaults, and register pre-exec hook to process arithmetic opcodes */\n\tif (do_mpfr)\n\t\tinit_mpfr(DEFAULT_PREC, DEFAULT_ROUNDMODE);\n#endif\n\n\t/* load group set */\n\tinit_groupset();\n\n#ifdef HAVE_MPFR\n\tif (do_mpfr) {\n\t\tmpz_init(Nnull_string->mpg_i);\n\t\tNnull_string->flags = (MALLOC|STRCUR|STRING|MPZN|NUMCUR|NUMBER);\n\t} else\n#endif\n\t{\n\t\tNnull_string->numbr = 0.0;\n\t\tNnull_string->flags = (MALLOC|STRCUR|STRING|NUMCUR|NUMBER);\n\t}\n\n\t/*\n\t * Tell the regex routines how they should work.\n\t * Do this before initializing variables, since\n\t * they could want to do a regexp compile.\n\t */\n\tresetup();\n\n\t/* Set up the special variables */\n\tinit_vars();\n\n\t/* Set up the field variables */\n\tinit_fields();\n\n\t/* Now process the pre-assignments */\n\tfor (i = 0; i <= numassigns; i++) {\n\t\tif (preassigns[i].type == PRE_ASSIGN)\n\t\t\t(void) arg_assign(preassigns[i].val, true);\n\t\telse\t/* PRE_ASSIGN_FS */\n\t\t\tcmdline_fs(preassigns[i].val);\n\t\tefree(preassigns[i].val);\n\t}\n\n\tif (preassigns != NULL)\n\t\tefree(preassigns);\n\n\tif ((BINMODE & BINMODE_INPUT) != 0)\n\t\tif (os_setbinmode(fileno(stdin), O_BINARY) == -1)\n\t\t\tfatal(_(\"can't set binary mode on stdin (%s)\"), strerror(errno));\n\tif ((BINMODE & BINMODE_OUTPUT) != 0) {\n\t\tif (os_setbinmode(fileno(stdout), O_BINARY) == -1)\n\t\t\tfatal(_(\"can't set binary mode on stdout (%s)\"), strerror(errno));\n\t\tif (os_setbinmode(fileno(stderr), O_BINARY) == -1)\n\t\t\tfatal(_(\"can't set binary mode on stderr (%s)\"), strerror(errno));\n\t}\n\n#ifdef GAWKDEBUG\n\tsetbuf(stdout, (char *) NULL);\t/* make debugging easier */\n#endif\n\tif (os_isatty(fileno(stdout)))\n\t\toutput_is_tty = true;\n\n\t/* initialize API before loading extension libraries */\n\tinit_ext_api();\n\n\t/* load extension libs */\n        for (s = srcfiles->next; s != srcfiles; s = s->next) {\n                if (s->stype == SRC_EXTLIB)\n\t\t\tload_ext(s->fullpath);\n\t\telse if (s->stype != SRC_INC)\n\t\t\thave_srcfile++;\n        }\n\n\t/* do version check after extensions are loaded to get extension info */\n\tif (do_version)\n\t\tversion();\n\n\t/* No -f or --source options, use next arg */\n\tif (! have_srcfile) {\n\t\tif (optind > argc - 1 || stopped_early) /* no args left or no program */\n\t\t\tusage(EXIT_FAILURE, stderr);\n\t\t(void) add_srcfile(SRC_CMDLINE, argv[optind], srcfiles, NULL, NULL);\n\t\toptind++;\n\t}\n\n\t/* Select the interpreter routine */\n\tinit_interpret();\n\n\tinit_args(optind, argc,\n\t\t\tdo_posix ? argv[0] : myname,\n\t\t\targv);\n\n#if defined(LC_NUMERIC)\n\t/*\n\t * FRAGILE!  CAREFUL!\n\t * Pre-initing the variables with arg_assign() can change the\n\t * locale.  Force it to C before parsing the program.\n\t */\n\tsetlocale(LC_NUMERIC, \"C\");\n#endif\n\t/* Read in the program */\n\tif (parse_program(& code_block) != 0)\n\t\texit(EXIT_FAILURE);\n\n\tif (do_intl)\n\t\texit(EXIT_SUCCESS);\n\n\tinstall_builtins();\n\n\tif (do_lint)\n\t\tshadow_funcs();\n\n\tif (do_lint && code_block->nexti->opcode == Op_atexit)\n\t\tlintwarn(_(\"no program text at all!\"));\n\n\tload_symbols();\n\n\tif (do_profile)\n\t\tinit_profiling_signals();\n\n#if defined(LC_NUMERIC)\n\t/*\n\t * See comment above about using locale's decimal point.\n\t *\n\t * 10/2005:\n\t * Bitter experience teaches us that most people the world over\n\t * use period as the decimal point, not whatever their locale\n\t * uses.  Thus, only use the locale's decimal point if being\n\t * posixly anal-retentive.\n\t *\n\t * 7/2007:\n\t * Be a little bit kinder. Allow the --use-lc-numeric option\n\t * to also use the local decimal point. This avoids the draconian\n\t * strictness of POSIX mode if someone just wants to parse their\n\t * data using the local decimal point.\n\t */\n\tif (use_lc_numeric)\n\t\tsetlocale(LC_NUMERIC, locale);\n#endif\n\n\tinit_io();\n\toutput_fp = stdout;\n\n\tif (do_debug)\n\t\tdebug_prog(code_block);\n\telse if (do_pretty_print && ! do_debug && getenv(\"GAWK_NO_PP_RUN\") != NULL)\n\t\t/* hack to run pretty printer only. need a better solution */\n\t\t;\n\telse\n\t\tinterpret(code_block);\n\n\tif (do_pretty_print) {\n\t\tdump_prog(code_block);\n\t\tdump_funcs();\n\t}\n\n\tif (do_dump_vars)\n\t\tdump_vars(varfile);\n\n#ifdef HAVE_MPFR\n\tif (do_mpfr)\n\t\tcleanup_mpfr();\n#endif\n\n\tif (do_tidy_mem)\n\t\trelease_all_vars();\n\n\t/* keep valgrind happier */\n\tif (extra_stack)\n\t\tefree(extra_stack);\n\n\tfinal_exit(exit_val);\n\treturn exit_val;\t/* to suppress warnings */\n}"
}