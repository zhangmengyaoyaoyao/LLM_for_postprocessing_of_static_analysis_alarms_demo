{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "\t      h->type = bfd_link_hash_defined;",
    "Code_function": "exp_fold_tree_1 (etree_type *tree)\n{\n  if (tree == NULL)\n    {\n      memset (&expld.result, 0, sizeof (expld.result));\n      return;\n    }\n\n  switch (tree->type.node_class)\n    {\n    case etree_value:\n      if (expld.section == bfd_abs_section_ptr\n\t  && !config.sane_expr)\n\tnew_abs (tree->value.value);\n      else\n\tnew_number (tree->value.value);\n      expld.result.str = tree->value.str;\n      break;\n\n    case etree_rel:\n      if (expld.phase != lang_first_phase_enum)\n\t{\n\t  asection *output_section = tree->rel.section->output_section;\n\t  new_rel (tree->rel.value + tree->rel.section->output_offset,\n\t\t   output_section);\n\t}\n      else\n\tmemset (&expld.result, 0, sizeof (expld.result));\n      break;\n\n    case etree_assert:\n      exp_fold_tree_1 (tree->assert_s.child);\n      if (expld.phase == lang_final_phase_enum && !expld.result.value)\n\teinfo (\"%X%P: %s\\n\", tree->assert_s.message);\n      break;\n\n    case etree_unary:\n      fold_unary (tree);\n      break;\n\n    case etree_binary:\n      fold_binary (tree);\n      break;\n\n    case etree_trinary:\n      fold_trinary (tree);\n      break;\n\n    case etree_assign:\n    case etree_provide:\n    case etree_provided:\n      if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)\n\t{\n\t  if (tree->type.node_class != etree_assign)\n\t    einfo (_(\"%F%S can not PROVIDE assignment to\"\n\t\t     \" location counter\\n\"), tree);\n\t  if (expld.phase != lang_first_phase_enum)\n\t    {\n\t      /* Notify the folder that this is an assignment to dot.  */\n\t      expld.assigning_to_dot = TRUE;\n\t      exp_fold_tree_1 (tree->assign.src);\n\t      expld.assigning_to_dot = FALSE;\n\n\t      /* If we are assigning to dot inside an output section\n\t\t arrange to keep the section, except for certain\n\t\t expressions that evaluate to zero.  We ignore . = 0,\n\t\t . = . + 0, and . = ALIGN (. != 0 ? expr : 1).  */\n\t      if (expld.phase == lang_mark_phase_enum\n\t\t  && expld.section != bfd_abs_section_ptr\n\t\t  && !(expld.result.valid_p\n\t\t       && expld.result.value == 0\n\t\t       && (is_value (tree->assign.src, 0)\n\t\t\t   || is_sym_value (tree->assign.src, 0)\n\t\t\t   || is_dot_plus_0 (tree->assign.src)\n\t\t\t   || is_align_conditional (tree->assign.src))))\n\t\texpld.section->flags |= SEC_KEEP;\n\n\t      if (!expld.result.valid_p)\n\t\t{\n\t\t  if (expld.phase != lang_mark_phase_enum)\n\t\t    einfo (_(\"%F%S invalid assignment to\"\n\t\t\t     \" location counter\\n\"), tree);\n\t\t}\n\t      else if (expld.dotp == NULL)\n\t\teinfo (_(\"%F%S assignment to location counter\"\n\t\t\t \" invalid outside of SECTIONS\\n\"), tree);\n\n\t      /* After allocation, assignment to dot should not be\n\t\t done inside an output section since allocation adds a\n\t\t padding statement that effectively duplicates the\n\t\t assignment.  */\n\t      else if (expld.phase <= lang_allocating_phase_enum\n\t\t       || expld.section == bfd_abs_section_ptr)\n\t\t{\n\t\t  bfd_vma nextdot;\n\n\t\t  nextdot = expld.result.value;\n\t\t  if (expld.result.section != NULL)\n\t\t    nextdot += expld.result.section->vma;\n\t\t  else\n\t\t    nextdot += expld.section->vma;\n\t\t  if (nextdot < expld.dot\n\t\t      && expld.section != bfd_abs_section_ptr)\n\t\t    einfo (_(\"%F%S cannot move location counter backwards\"\n\t\t\t     \" (from %V to %V)\\n\"),\n\t\t\t   tree, expld.dot, nextdot);\n\t\t  else\n\t\t    {\n\t\t      expld.dot = nextdot;\n\t\t      *expld.dotp = nextdot;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    memset (&expld.result, 0, sizeof (expld.result));\n\t}\n      else\n\t{\n\t  struct bfd_link_hash_entry *h = NULL;\n\n\t  if (tree->type.node_class == etree_provide)\n\t    {\n\t      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n\t\t\t\t\tFALSE, FALSE, TRUE);\n\t      if (h == NULL\n\t\t  || !(h->type == bfd_link_hash_new\n\t\t       || h->type == bfd_link_hash_undefined\n\t\t       || h->linker_def))\n\t\t{\n\t\t  /* Do nothing.  The symbol was never referenced, or\n\t\t     was defined in some object file.  Undefined weak\n\t\t     symbols stay undefined.  */\n\t\t  break;\n\t\t}\n\t    }\n\n\t  expld.assign_name = tree->assign.dst;\n\t  exp_fold_tree_1 (tree->assign.src);\n\t  /* expld.assign_name remaining equal to tree->assign.dst\n\t     below indicates the evaluation of tree->assign.src did\n\t     not use the value of tree->assign.dst.  We don't allow\n\t     self assignment until the final phase for two reasons:\n\t     1) Expressions are evaluated multiple times.  With\n\t     relaxation, the number of times may vary.\n\t     2) Section relative symbol values cannot be correctly\n\t     converted to absolute values, as is required by many\n\t     expressions, until final section sizing is complete.  */\n\t  if ((expld.result.valid_p\n\t       && (expld.phase == lang_final_phase_enum\n\t\t   || expld.assign_name != NULL))\n\t      || (expld.phase <= lang_mark_phase_enum\n\t\t  && tree->type.node_class == etree_assign\n\t\t  && tree->assign.defsym))\n\t    {\n\t      if (h == NULL)\n\t\t{\n\t\t  h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n\t\t\t\t\t    TRUE, FALSE, TRUE);\n\t\t  if (h == NULL)\n\t\t    einfo (_(\"%P%F:%s: hash creation failed\\n\"),\n\t\t\t   tree->assign.dst);\n\t\t}\n\n\t      /* FIXME: Should we worry if the symbol is already\n\t\t defined?  */\n\t      update_definedness (tree->assign.dst, h);\n\t      h->type = bfd_link_hash_defined;\n\t      h->u.def.value = expld.result.value;\n\t      if (expld.result.section == NULL)\n\t\texpld.result.section = expld.section;\n\t      h->u.def.section = expld.result.section;\n\t      if (tree->type.node_class == etree_provide)\n\t\ttree->type.node_class = etree_provided;\n\n\t      /* Copy the symbol type if this is a simple assignment of\n\t         one symbol to another.  This could be more general\n\t\t (e.g. a ?: operator with NAMEs in each branch).  */\n\t      if (tree->assign.src->type.node_class == etree_name)\n\t\t{\n\t\t  struct bfd_link_hash_entry *hsrc;\n\n\t\t  hsrc = bfd_link_hash_lookup (link_info.hash,\n\t\t\t\t\t       tree->assign.src->name.name,\n\t\t\t\t\t       FALSE, FALSE, TRUE);\n\t\t  if (hsrc)\n\t\t    bfd_copy_link_hash_symbol_type (link_info.output_bfd, h,\n\t\t\t\t\t\t    hsrc);\n\t\t}\n\t    }\n\t  else if (expld.phase == lang_final_phase_enum)\n\t    {\n\t      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n\t\t\t\t\tFALSE, FALSE, TRUE);\n\t      if (h != NULL\n\t\t  && h->type == bfd_link_hash_new)\n\t\th->type = bfd_link_hash_undefined;\n\t    }\n\t  expld.assign_name = NULL;\n\t}\n      break;\n\n    case etree_name:\n      fold_name (tree);\n      break;\n\n    default:\n      FAIL ();\n      memset (&expld.result, 0, sizeof (expld.result));\n      break;\n    }\n}"
}