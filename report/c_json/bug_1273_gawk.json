{
    "project": "gawk",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "builtin.c",
    "message": "The value read from matchend was never initialized.",
    "warning_function_name": "do_sub",
    "warning_line": "for (scan = matchend; scan < text + textlen; scan++)",
    "warning_context": "\t\t\t\t} else if (*scan == '\\\\'\n\t\t\t\t\t&& (gawk_mb_cur_max == 1\n\t\t\t\t\t\t|| (repllen > 0 && mb_indices[scan - repl] == 1))\n\t\t\t\t) {\n\t\t\t\t\tif (flags & GENSUB) {\t/* gensub, behave sanely */\n\t\t\t\t\t\tif (isdigit((unsigned char) scan[1])) {\n\t\t\t\t\t\t\tint dig = scan[1] - '0';\n\t\t\t\t\t\t\tif (dig < NUMSUBPATS(rp, t->stptr) && SUBPATSTART(rp, tp->stptr, dig) != -1) {\n\t\t\t\t\t\t\t\tchar *start, *end;\n\t\t\n\t\t\t\t\t\t\t\tstart = t->stptr\n\t\t\t\t\t\t\t\t      + SUBPATSTART(rp, t->stptr, dig);\n\t\t\t\t\t\t\t\tend = t->stptr\n\t\t\t\t\t\t\t\t      + SUBPATEND(rp, t->stptr, dig);\n\n\t\t\t\t\t\t\t\tfor (cp = start; cp < end; cp++)\n\t\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t} else\t/* \\q for any q --> q */\n\t\t\t\t\t\t\t*bp++ = *++scan;\n\t\t\t\t\t} else if (do_posix) {\n\t\t\t\t\t\t/* \\& --> &, \\\\ --> \\ */\n\t\t\t\t\t\tif (scan[1] == '&' || scan[1] == '\\\\')\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t*bp++ = *scan;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* gawk default behavior since 1996 */\n\t\t\t\t\t\tif (strncmp(scan, \"\\\\\\\\\\\\&\", 4) == 0) {\n\t\t\t\t\t\t\t/* \\\\\\& --> \\& */\n\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\t*bp++ = '&';\n\t\t\t\t\t\t\tscan += 3;\n\t\t\t\t\t\t} else if (strncmp(scan, \"\\\\\\\\&\", 3) == 0) {\n\t\t\t\t\t\t\t/* \\\\& --> \\<string> */\n\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t\t\t\tscan += 2;\n\t\t\t\t\t\t} else if (scan[1] == '&') {\n\t\t\t\t\t\t\t/* \\& --> & */\n\t\t\t\t\t\t\t*bp++ = '&';\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t*bp++ = *scan;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\t*bp++ = *scan;\n\t\t\tif (matchstart != matchend)\n\t\t\t\tlastmatchnonzero = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * don't want this match, skip over it by copying\n\t\t\t * in current text.\n\t\t\t */\n\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t*bp++ = *cp;\n\t\t}\n\tempty:\n\t\t/* catch the case of gsub(//, \"blah\", whatever), i.e. empty regexp */\n\t\tif (matchstart == matchend && matchend < text + textlen) {\n\t\t\t*bp++ = *matchend;\n\t\t\tmatchend++;\n\t\t}\n\t\ttextlen = text + textlen - matchend;\n\t\ttext = matchend;\n\n\t\tif ((current >= how_many && ! global)\n\t\t    || ((long) textlen <= 0 && matchstart == matchend)\n\t\t    || research(rp, t->stptr, text - t->stptr, textlen, RE_NEED_START) == -1)\n\t\t\tbreak;\n\n\t}\n\tsofar = bp - buf;\n\tif (buflen - sofar - textlen - 1) {\n\t\tbuflen = sofar + textlen + 2;\n\t\terealloc(buf, char *, buflen, \"do_sub\");\n\t\tbp = buf + sofar;\n\t}\n\tfor (scan = matchend; scan < text + textlen; scan++)\n\t\t*bp++ = *scan;\n\t*bp = '\\0';\n\ttextlen = bp - buf;\n\n\tif (mb_indices != NULL)\n\t\tefree(mb_indices);\n\ndone:\n\tDEREF(s);\n\n\tif ((matches == 0 || (flags & LITERAL) != 0) && buf != NULL) {\n\t\tefree(buf); \n\t\tbuf = NULL;\n\t}\n\n\tif (flags & GENSUB) {\n\t\tif (matches > 0) {\n\t\t\t/* return the result string */\n\t\t\tDEREF(t);\n\t\t\tassert(buf != NULL);\n\t\t\treturn make_str_node(buf, textlen, ALREADY_MALLOCED);\t\n"
}