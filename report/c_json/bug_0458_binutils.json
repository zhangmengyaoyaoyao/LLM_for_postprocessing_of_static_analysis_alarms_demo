{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/stabs.c",
    "message": "Offset: [16, +oo] (⇐ [12, +oo] + 4) Size: [1, +oo].",
    "warning_function_name": "_bfd_link_section_stabs",
    "warning_line": "incl_type = incl_sym[TYPEOFF];",
    "warning_context": "     -split-by-reloc/-split-by-file is used.  We must keep track of\n     each stab section's place in the single concatenated string\n     table.  */\n  next_stroff = pstring_offset ? *pstring_offset : 0;\n  skip = 0;\n\n  symend = stabbuf + stabsec->size;\n  for (sym = stabbuf, pstridx = secinfo->stridxs;\n       sym < symend;\n       sym += STABSIZE, ++pstridx)\n    {\n      bfd_size_type symstroff;\n      int type;\n      const char *string;\n\n      if (*pstridx != 0)\n\t/* This symbol has already been handled by an N_BINCL pass.  */\n\tcontinue;\n\n      type = sym[TYPEOFF];\n\n      if (type == 0)\n\t{\n\t  /* Special type 0 stabs indicate the offset to the next\n\t     string table.  We only copy the very first one.  */\n\t  stroff = next_stroff;\n\t  next_stroff += bfd_get_32 (abfd, sym + 8);\n\t  if (pstring_offset)\n\t    *pstring_offset = next_stroff;\n\t  if (! first)\n\t    {\n\t      *pstridx = (bfd_size_type) -1;\n\t      ++skip;\n\t      continue;\n\t    }\n\t  first = FALSE;\n\t}\n\n      /* Store the string in the hash table, and record the index.  */\n      symstroff = stroff + bfd_get_32 (abfd, sym + STRDXOFF);\n      if (symstroff >= stabstrsec->size)\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"%B(%A+0x%lx): Stabs entry has invalid string index.\"),\n\t     abfd, stabsec, (long) (sym - stabbuf));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto error_return;\n\t}\n      string = (char *) stabstrbuf + symstroff;\n      *pstridx = _bfd_stringtab_add (sinfo->strings, string, TRUE, TRUE);\n\n      /* An N_BINCL symbol indicates the start of the stabs entries\n\t for a header file.  We need to scan ahead to the next N_EINCL\n\t symbol, ignoring nesting, adding up all the characters in the\n\t symbol names, not including the file numbers in types (the\n\t first number after an open parenthesis).  */\n      if (type == (int) N_BINCL)\n\t{\n\t  bfd_vma sum_chars;\n\t  bfd_vma num_chars;\n\t  bfd_vma buf_len = 0;\n\t  char * symb;\n\t  char * symb_rover;\n\t  int nest;\n\t  bfd_byte * incl_sym;\n\t  struct stab_link_includes_entry * incl_entry;\n\t  struct stab_link_includes_totals * t;\n\t  struct stab_excl_list * ne;\n\n\t  symb = symb_rover = NULL;\n\t  sum_chars = num_chars = 0;\n\t  nest = 0;\n\n\t  for (incl_sym = sym + STABSIZE;\n\t       incl_sym < symend;\n\t       incl_sym += STABSIZE)\n\t    {\n\t      int incl_type;\n\n\t      incl_type = incl_sym[TYPEOFF];\n\t      if (incl_type == 0)\n\t\tbreak;\n\t      else if (incl_type == (int) N_EXCL)\n\t\tcontinue;\n\t      else if (incl_type == (int) N_EINCL)\n\t\t{\n\t\t  if (nest == 0)\n\t\t    break;\n\t\t  --nest;\n\t\t}\n\t      else if (incl_type == (int) N_BINCL)\n\t\t++nest;\n\t      else if (nest == 0)\n\t\t{\n\t\t  const char *str;\n\n\t\t  str = ((char *) stabstrbuf\n\t\t\t + stroff\n\t\t\t + bfd_get_32 (abfd, incl_sym + STRDXOFF));\n\t\t  for (; *str != '\\0'; str++)\n\t\t    {\n"
}