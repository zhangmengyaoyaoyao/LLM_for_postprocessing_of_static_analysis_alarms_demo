{
    "project": "binutils",
    "tool": "Cppcheck",
    "category": "uninitvar",
    "file": "bfd/elf32-arm.c",
    "message": "Uninitialized variable: &rel",
    "warning_function_name": "elf32_arm_finish_dynamic_sections",
    "warning_line": "SWAP_RELOC_IN (htab) (output_bfd, p, &rel);",
    "warning_context": "\t  else\n\t    {\n\t      got_displacement = got_address - (plt_address + 16);\n\n\t      plt0_entry = elf32_arm_plt0_entry;\n\t      put_arm_insn (htab, output_bfd, plt0_entry[0],\n\t\t\t    splt->contents + 0);\n\t      put_arm_insn (htab, output_bfd, plt0_entry[1],\n\t\t\t    splt->contents + 4);\n\t      put_arm_insn (htab, output_bfd, plt0_entry[2],\n\t\t\t    splt->contents + 8);\n\t      put_arm_insn (htab, output_bfd, plt0_entry[3],\n\t\t\t    splt->contents + 12);\n\n#ifdef FOUR_WORD_PLT\n\t      /* The displacement value goes in the otherwise-unused\n\t\t last word of the second entry.  */\n\t      bfd_put_32 (output_bfd, got_displacement, splt->contents + 28);\n#else\n\t      bfd_put_32 (output_bfd, got_displacement, splt->contents + 16);\n#endif\n\t    }\n\t}\n\n      /* UnixWare sets the entsize of .plt to 4, although that doesn't\n\t really seem like the right value.  */\n      if (splt->output_section->owner == output_bfd)\n\telf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;\n\n      if (htab->dt_tlsdesc_plt)\n\t{\n\t  bfd_vma got_address\n\t    = sgot->output_section->vma + sgot->output_offset;\n\t  bfd_vma gotplt_address = (htab->root.sgot->output_section->vma\n\t\t\t\t    + htab->root.sgot->output_offset);\n\t  bfd_vma plt_address\n\t    = splt->output_section->vma + splt->output_offset;\n\n\t  arm_put_trampoline (htab, output_bfd,\n\t\t\t      splt->contents + htab->dt_tlsdesc_plt,\n\t\t\t      dl_tlsdesc_lazy_trampoline, 6);\n\n\t  bfd_put_32 (output_bfd,\n\t\t      gotplt_address + htab->dt_tlsdesc_got\n\t\t      - (plt_address + htab->dt_tlsdesc_plt)\n\t\t      - dl_tlsdesc_lazy_trampoline[6],\n\t\t      splt->contents + htab->dt_tlsdesc_plt + 24);\n\t  bfd_put_32 (output_bfd,\n\t\t      got_address - (plt_address + htab->dt_tlsdesc_plt)\n\t\t      - dl_tlsdesc_lazy_trampoline[7],\n\t\t      splt->contents + htab->dt_tlsdesc_plt + 24 + 4);\n\t}\n\n      if (htab->tls_trampoline)\n\t{\n\t  arm_put_trampoline (htab, output_bfd,\n\t\t\t      splt->contents + htab->tls_trampoline,\n\t\t\t      tls_trampoline, 3);\n#ifdef FOUR_WORD_PLT\n\t  bfd_put_32 (output_bfd, 0x00000000,\n\t\t      splt->contents + htab->tls_trampoline + 12);\n#endif\n\t}\n\n      if (htab->vxworks_p && !info->shared && htab->root.splt->size > 0)\n\t{\n\t  /* Correct the .rel(a).plt.unloaded relocations.  They will have\n\t     incorrect symbol indexes.  */\n\t  int num_plts;\n\t  unsigned char *p;\n\n\t  num_plts = ((htab->root.splt->size - htab->plt_header_size)\n\t\t      / htab->plt_entry_size);\n\t  p = htab->srelplt2->contents + RELOC_SIZE (htab);\n\n\t  for (; num_plts; num_plts--)\n\t    {\n\t      Elf_Internal_Rela rel;\n\n\t      SWAP_RELOC_IN (htab) (output_bfd, p, &rel);\n\t      rel.r_info = ELF32_R_INFO (htab->root.hgot->indx, R_ARM_ABS32);\n\t      SWAP_RELOC_OUT (htab) (output_bfd, &rel, p);\n\t      p += RELOC_SIZE (htab);\n\n\t      SWAP_RELOC_IN (htab) (output_bfd, p, &rel);\n\t      rel.r_info = ELF32_R_INFO (htab->root.hplt->indx, R_ARM_ABS32);\n\t      SWAP_RELOC_OUT (htab) (output_bfd, &rel, p);\n\t      p += RELOC_SIZE (htab);\n\t    }\n\t}\n    }\n\n  if (htab->nacl_p && htab->root.iplt != NULL && htab->root.iplt->size > 0)\n    /* NaCl uses a special first entry in .iplt too.  */\n    arm_nacl_put_plt0 (htab, output_bfd, htab->root.iplt, 0);\n\n  /* Fill in the first three entries in the global offset table.  */\n  if (sgot)\n    {\n      if (sgot->size > 0)\n\t{\n"
}