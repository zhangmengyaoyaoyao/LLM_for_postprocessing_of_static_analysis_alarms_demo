{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "\t      really_longopts[irl] = ld_options[i].opt;",
    "Code_function": "parse_args (unsigned argc, char **argv)\n{\n  unsigned i;\n  int is, il, irl;\n  int ingroup = 0;\n  char *default_dirlist = NULL;\n  char *shortopts;\n  struct option *longopts;\n  struct option *really_longopts;\n  int last_optind;\n  enum report_method how_to_report_unresolved_symbols = RM_GENERATE_ERROR;\n\n  shortopts = (char *) xmalloc (OPTION_COUNT * 3 + 2);\n  longopts = (struct option *)\n      xmalloc (sizeof (*longopts) * (OPTION_COUNT + 1));\n  really_longopts = (struct option *)\n      malloc (sizeof (*really_longopts) * (OPTION_COUNT + 1));\n\n  /* Starting the short option string with '-' is for programs that\n     expect options and other ARGV-elements in any order and that care about\n     the ordering of the two.  We describe each non-option ARGV-element\n     as if it were the argument of an option with character code 1.  */\n  shortopts[0] = '-';\n  is = 1;\n  il = 0;\n  irl = 0;\n  for (i = 0; i < OPTION_COUNT; i++)\n    {\n      if (ld_options[i].shortopt != '\\0')\n\t{\n\t  shortopts[is] = ld_options[i].shortopt;\n\t  ++is;\n\t  if (ld_options[i].opt.has_arg == required_argument\n\t      || ld_options[i].opt.has_arg == optional_argument)\n\t    {\n\t      shortopts[is] = ':';\n\t      ++is;\n\t      if (ld_options[i].opt.has_arg == optional_argument)\n\t\t{\n\t\t  shortopts[is] = ':';\n\t\t  ++is;\n\t\t}\n\t    }\n\t}\n      if (ld_options[i].opt.name != NULL)\n\t{\n\t  if (ld_options[i].control == EXACTLY_TWO_DASHES)\n\t    {\n\t      really_longopts[irl] = ld_options[i].opt;\n\t      ++irl;\n\t    }\n\t  else\n\t    {\n\t      longopts[il] = ld_options[i].opt;\n\t      ++il;\n\t    }\n\t}\n    }\n  shortopts[is] = '\\0';\n  longopts[il].name = NULL;\n  really_longopts[irl].name = NULL;\n\n  ldemul_add_options (is, &shortopts, il, &longopts, irl, &really_longopts);\n\n  /* The -G option is ambiguous on different platforms.  Sometimes it\n     specifies the largest data size to put into the small data\n     section.  Sometimes it is equivalent to --shared.  Unfortunately,\n     the first form takes an argument, while the second does not.\n\n     We need to permit the --shared form because on some platforms,\n     such as Solaris, gcc -shared will pass -G to the linker.\n\n     To permit either usage, we look through the argument list.  If we\n     find -G not followed by a number, we change it into --shared.\n     This will work for most normal cases.  */\n  for (i = 1; i < argc; i++)\n    if (strcmp (argv[i], \"-G\") == 0\n\t&& (i + 1 >= argc\n\t    || ! ISDIGIT (argv[i + 1][0])))\n      argv[i] = (char *) \"--shared\";\n\n  /* Because we permit long options to start with a single dash, and\n     we have a --library option, and the -l option is conventionally\n     used with an immediately following argument, we can have bad\n     results if somebody tries to use -l with a library whose name\n     happens to start with \"ibrary\", as in -li.  We avoid problems by\n     simply turning -l into --library.  This means that users will\n     have to use two dashes in order to use --library, which is OK\n     since that's how it is documented.\n\n     FIXME: It's possible that this problem can arise for other short\n     options as well, although the user does always have the recourse\n     of adding a space between the option and the argument.  */\n  for (i = 1; i < argc; i++)\n    {\n      if (argv[i][0] == '-'\n\t  && argv[i][1] == 'l'\n\t  && argv[i][2] != '\\0')\n\t{\n\t  char *n;\n\n\t  n = (char *) xmalloc (strlen (argv[i]) + 20);\n\t  sprintf (n, \"--library=%s\", argv[i] + 2);\n\t  argv[i] = n;\n\t}\n    }\n\n  last_optind = -1;\n  while (1)\n    {\n      int longind;\n      int optc;\n      static unsigned int defsym_count;\n\n      /* Using last_optind lets us avoid calling ldemul_parse_args\n\t multiple times on a single option, which would lead to\n\t confusion in the internal static variables maintained by\n\t getopt.  This could otherwise happen for an argument like\n\t -nx, in which the -n is parsed as a single option, and we\n\t loop around to pick up the -x.  */\n      if (optind != last_optind)\n\tif (ldemul_parse_args (argc, argv))\n\t  continue;\n\n      /* getopt_long_only is like getopt_long, but '-' as well as '--'\n\t can indicate a long option.  */\n      opterr = 0;\n      last_optind = optind;\n      optc = getopt_long_only (argc, argv, shortopts, longopts, &longind);\n      if (optc == '?')\n\t{\n\t  optind = last_optind;\n\t  optc = getopt_long (argc, argv, \"-\", really_longopts, &longind);\n\t}\n\n      if (ldemul_handle_option (optc))\n\tcontinue;\n\n      if (optc == -1)\n\tbreak;\n\n      switch (optc)\n\t{\n\tcase '?':\n\t  einfo (_(\"%P: unrecognized option '%s'\\n\"), argv[last_optind]);\n\t  /* Fall through.  */\n\n\tdefault:\n\t  einfo (_(\"%P%F: use the --help option for usage information\\n\"));\n\n\tcase 1:\t\t\t/* File name.  */\n\t  lang_add_input_file (optarg, lang_input_file_is_file_enum, NULL);\n\t  break;\n\n\tcase OPTION_IGNORE:\n\t  break;\n\tcase 'a':\n\t  /* For HP/UX compatibility.  Actually -a shared should mean\n\t     ``use only shared libraries'' but, then, we don't\n\t     currently support shared libraries on HP/UX anyhow.  */\n\t  if (strcmp (optarg, \"archive\") == 0)\n\t    input_flags.dynamic = FALSE;\n\t  else if (strcmp (optarg, \"shared\") == 0\n\t\t   || strcmp (optarg, \"default\") == 0)\n\t    input_flags.dynamic = TRUE;\n\t  else\n\t    einfo (_(\"%P%F: unrecognized -a option `%s'\\n\"), optarg);\n\t  break;\n\tcase OPTION_ASSERT:\n\t  /* FIXME: We just ignore these, but we should handle them.  */\n\t  if (strcmp (optarg, \"definitions\") == 0)\n\t    ;\n\t  else if (strcmp (optarg, \"nodefinitions\") == 0)\n\t    ;\n\t  else if (strcmp (optarg, \"nosymbolic\") == 0)\n\t    ;\n\t  else if (strcmp (optarg, \"pure-text\") == 0)\n\t    ;\n\t  else\n\t    einfo (_(\"%P%F: unrecognized -assert option `%s'\\n\"), optarg);\n\t  break;\n\tcase 'A':\n\t  ldfile_add_arch (optarg);\n\t  break;\n\tcase 'b':\n\t  lang_add_target (optarg);\n\t  break;\n\tcase 'c':\n\t  ldfile_open_command_file (optarg);\n\t  parser_input = input_mri_script;\n\t  yyparse ();\n\t  break;\n\tcase OPTION_CALL_SHARED:\n\t  input_flags.dynamic = TRUE;\n\t  break;\n\tcase OPTION_NON_SHARED:\n\t  input_flags.dynamic = FALSE;\n\t  break;\n\tcase OPTION_CREF:\n\t  command_line.cref = TRUE;\n\t  link_info.notice_all = TRUE;\n\t  break;\n\tcase 'd':\n\t  command_line.force_common_definition = TRUE;\n\t  break;\n\tcase OPTION_DEFSYM:\n\t  lex_string = optarg;\n\t  lex_redirect (optarg, \"--defsym\", ++defsym_count);\n\t  parser_input = input_defsym;\n\t  yyparse ();\n\t  lex_string = NULL;\n\t  break;\n\tcase OPTION_DEMANGLE:\n\t  demangling = TRUE;\n\t  if (optarg != NULL)\n\t    {\n\t      enum demangling_styles style;\n\n\t      style = cplus_demangle_name_to_style (optarg);\n\t      if (style == unknown_demangling)\n\t\teinfo (_(\"%F%P: unknown demangling style `%s'\\n\"),\n\t\t       optarg);\n\n\t      cplus_demangle_set_style (style);\n\t    }\n\t  break;\n\tcase 'I':\t\t/* Used on Solaris.  */\n\tcase OPTION_DYNAMIC_LINKER:\n\t  command_line.interpreter = optarg;\n\t  break;\n\tcase OPTION_SYSROOT:\n\t  /* Already handled in ldmain.c.  */\n\t  break;\n\tcase OPTION_EB:\n\t  command_line.endian = ENDIAN_BIG;\n\t  break;\n\tcase OPTION_EL:\n\t  command_line.endian = ENDIAN_LITTLE;\n\t  break;\n\tcase OPTION_EMBEDDED_RELOCS:\n\t  command_line.embedded_relocs = TRUE;\n\t  break;\n\tcase OPTION_EXPORT_DYNAMIC:\n\tcase 'E': /* HP/UX compatibility.  */\n\t  link_info.export_dynamic = TRUE;\n\t  break;\n\tcase OPTION_NO_EXPORT_DYNAMIC:\n\t  link_info.export_dynamic = FALSE;\n\t  break;\n\tcase 'e':\n\t  lang_add_entry (optarg, TRUE);\n\t  break;\n\tcase 'f':\n\t  if (command_line.auxiliary_filters == NULL)\n\t    {\n\t      command_line.auxiliary_filters = (char **)\n                  xmalloc (2 * sizeof (char *));\n\t      command_line.auxiliary_filters[0] = optarg;\n\t      command_line.auxiliary_filters[1] = NULL;\n\t    }\n\t  else\n\t    {\n\t      int c;\n\t      char **p;\n\n\t      c = 0;\n\t      for (p = command_line.auxiliary_filters; *p != NULL; p++)\n\t\t++c;\n\t      command_line.auxiliary_filters = (char **)\n                  xrealloc (command_line.auxiliary_filters,\n\t\t\t    (c + 2) * sizeof (char *));\n\t      command_line.auxiliary_filters[c] = optarg;\n\t      command_line.auxiliary_filters[c + 1] = NULL;\n\t    }\n\t  break;\n\tcase 'F':\n\t  command_line.filter_shlib = optarg;\n\t  break;\n\tcase OPTION_FORCE_EXE_SUFFIX:\n\t  command_line.force_exe_suffix = TRUE;\n\t  break;\n\tcase 'G':\n\t  {\n\t    char *end;\n\t    g_switch_value = strtoul (optarg, &end, 0);\n\t    if (*end)\n\t      einfo (_(\"%P%F: invalid number `%s'\\n\"), optarg);\n\t  }\n\t  break;\n\tcase 'g':\n\t  /* Ignore.  */\n\t  break;\n\tcase OPTION_GC_SECTIONS:\n\t  link_info.gc_sections = TRUE;\n\t  break;\n\tcase OPTION_PRINT_GC_SECTIONS:\n\t  link_info.print_gc_sections = TRUE;\n\t  break;\n\tcase OPTION_HELP:\n\t  help ();\n\t  xexit (0);\n\t  break;\n\tcase 'L':\n\t  ldfile_add_library_path (optarg, TRUE);\n\t  break;\n\tcase 'l':\n\t  lang_add_input_file (optarg, lang_input_file_is_l_enum, NULL);\n\t  break;\n\tcase 'M':\n\t  config.map_filename = \"-\";\n\t  break;\n\tcase 'm':\n\t  /* Ignore.  Was handled in a pre-parse.   */\n\t  break;\n\tcase OPTION_MAP:\n\t  config.map_filename = optarg;\n\t  break;\n\tcase 'N':\n\t  config.text_read_only = FALSE;\n\t  config.magic_demand_paged = FALSE;\n\t  input_flags.dynamic = FALSE;\n\t  break;\n\tcase OPTION_NO_OMAGIC:\n\t  config.text_read_only = TRUE;\n\t  config.magic_demand_paged = TRUE;\n\t  /* NB/ Does not set input_flags.dynamic to TRUE.\n\t     Use --call-shared or -Bdynamic for this.  */\n\t  break;\n\tcase 'n':\n\t  config.magic_demand_paged = FALSE;\n\t  input_flags.dynamic = FALSE;\n\t  break;\n\tcase OPTION_NO_DEFINE_COMMON:\n\t  command_line.inhibit_common_definition = TRUE;\n\t  break;\n\tcase OPTION_NO_DEMANGLE:\n\t  demangling = FALSE;\n\t  break;\n\tcase OPTION_NO_GC_SECTIONS:\n\t  link_info.gc_sections = FALSE;\n\t  break;\n\tcase OPTION_NO_PRINT_GC_SECTIONS:\n\t  link_info.print_gc_sections = FALSE;\n\t  break;\n\tcase OPTION_NO_KEEP_MEMORY:\n\t  link_info.keep_memory = FALSE;\n\t  break;\n\tcase OPTION_NO_UNDEFINED:\n\t  link_info.unresolved_syms_in_objects\n\t    = how_to_report_unresolved_symbols;\n\t  break;\n\tcase OPTION_ALLOW_SHLIB_UNDEFINED:\n\t  link_info.unresolved_syms_in_shared_libs = RM_IGNORE;\n\t  break;\n\tcase OPTION_NO_ALLOW_SHLIB_UNDEFINED:\n\t  link_info.unresolved_syms_in_shared_libs\n\t    = how_to_report_unresolved_symbols;\n\t  break;\n\tcase OPTION_UNRESOLVED_SYMBOLS:\n\t  if (strcmp (optarg, \"ignore-all\") == 0)\n\t    {\n\t      link_info.unresolved_syms_in_objects = RM_IGNORE;\n\t      link_info.unresolved_syms_in_shared_libs = RM_IGNORE;\n\t    }\n\t  else if (strcmp (optarg, \"report-all\") == 0)\n\t    {\n\t      link_info.unresolved_syms_in_objects\n\t\t= how_to_report_unresolved_symbols;\n\t      link_info.unresolved_syms_in_shared_libs\n\t\t= how_to_report_unresolved_symbols;\n\t    }\n\t  else if (strcmp (optarg, \"ignore-in-object-files\") == 0)\n\t    {\n\t      link_info.unresolved_syms_in_objects = RM_IGNORE;\n\t      link_info.unresolved_syms_in_shared_libs\n\t\t= how_to_report_unresolved_symbols;\n\t    }\n      \t  else if (strcmp (optarg, \"ignore-in-shared-libs\") == 0)\n\t    {\n\t      link_info.unresolved_syms_in_objects\n\t\t= how_to_report_unresolved_symbols;\n\t      link_info.unresolved_syms_in_shared_libs = RM_IGNORE;\n\t    }\n\t  else\n\t    einfo (_(\"%P%F: bad --unresolved-symbols option: %s\\n\"), optarg);\n\t  break;\n\tcase OPTION_WARN_UNRESOLVED_SYMBOLS:\n\t  how_to_report_unresolved_symbols = RM_GENERATE_WARNING;\n\t  if (link_info.unresolved_syms_in_objects == RM_GENERATE_ERROR)\n\t    link_info.unresolved_syms_in_objects = RM_GENERATE_WARNING;\n\t  if (link_info.unresolved_syms_in_shared_libs == RM_GENERATE_ERROR)\n\t    link_info.unresolved_syms_in_shared_libs = RM_GENERATE_WARNING;\n\t  break;\n\n\tcase OPTION_ERROR_UNRESOLVED_SYMBOLS:\n\t  how_to_report_unresolved_symbols = RM_GENERATE_ERROR;\n\t  if (link_info.unresolved_syms_in_objects == RM_GENERATE_WARNING)\n\t    link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;\n\t  if (link_info.unresolved_syms_in_shared_libs == RM_GENERATE_WARNING)\n\t    link_info.unresolved_syms_in_shared_libs = RM_GENERATE_ERROR;\n\t  break;\n\tcase OPTION_ALLOW_MULTIPLE_DEFINITION:\n\t  link_info.allow_multiple_definition = TRUE;\n\t  break;\n\tcase OPTION_NO_UNDEFINED_VERSION:\n\t  link_info.allow_undefined_version = FALSE;\n\t  break;\n\tcase OPTION_DEFAULT_SYMVER:\n\t  link_info.create_default_symver = TRUE;\n\t  break;\n\tcase OPTION_DEFAULT_IMPORTED_SYMVER:\n\t  link_info.default_imported_symver = TRUE;\n\t  break;\n\tcase OPTION_NO_WARN_MISMATCH:\n\t  command_line.warn_mismatch = FALSE;\n\t  break;\n\tcase OPTION_NO_WARN_SEARCH_MISMATCH:\n\t  command_line.warn_search_mismatch = FALSE;\n\t  break;\n\tcase OPTION_NOINHIBIT_EXEC:\n\t  force_make_executable = TRUE;\n\t  break;\n\tcase OPTION_NOSTDLIB:\n\t  config.only_cmd_line_lib_dirs = TRUE;\n\t  break;\n\tcase OPTION_NO_WHOLE_ARCHIVE:\n\t  input_flags.whole_archive = FALSE;\n\t  break;\n\tcase 'O':\n\t  /* FIXME \"-O<non-digits> <value>\" used to set the address of\n\t     section <non-digits>.  Was this for compatibility with\n\t     something, or can we create a new option to do that\n\t     (with a syntax similar to -defsym)?\n\t     getopt can't handle two args to an option without kludges.  */\n\n\t  /* Enable optimizations of output files.  */\n\t  link_info.optimize = strtoul (optarg, NULL, 0) ? TRUE : FALSE;\n\t  break;\n\tcase 'o':\n\t  lang_add_output (optarg, 0);\n\t  break;\n\tcase OPTION_OFORMAT:\n\t  lang_add_output_format (optarg, NULL, NULL, 0);\n\t  break;\n\tcase OPTION_PRINT_SYSROOT:\n\t  if (*ld_sysroot)\n\t    puts (ld_sysroot);\n\t  xexit (0);\n\t  break;\n\tcase OPTION_PRINT_OUTPUT_FORMAT:\n\t  command_line.print_output_format = TRUE;\n\t  break;\n#ifdef ENABLE_PLUGINS\n\tcase OPTION_PLUGIN:\n\t  plugin_opt_plugin (optarg);\n\t  break;\n\tcase OPTION_PLUGIN_OPT:\n\t  if (plugin_opt_plugin_arg (optarg))\n\t    einfo(_(\"%P%F: bad -plugin-opt option\\n\"));\n\t  break;\n#endif /* ENABLE_PLUGINS */\n\tcase 'q':\n\t  link_info.emitrelocations = TRUE;\n\t  break;\n\tcase 'i':\n\tcase 'r':\n\t  if (optind == last_optind)\n\t    /* This can happen if the user put \"-rpath,a\" on the command\n\t       line.  (Or something similar.  The comma is important).\n\t       Getopt becomes confused and thinks that this is a -r option\n\t       but it cannot parse the text after the -r so it refuses to\n\t       increment the optind counter.  Detect this case and issue\n\t       an error message here.  We cannot just make this a warning,\n\t       increment optind, and continue because getopt is too confused\n\t       and will seg-fault the next time around.  */\n\t    einfo(_(\"%P%F: bad -rpath option\\n\"));\n\n\t  link_info.relocatable = TRUE;\n\t  config.build_constructors = FALSE;\n\t  config.magic_demand_paged = FALSE;\n\t  config.text_read_only = FALSE;\n\t  input_flags.dynamic = FALSE;\n\t  break;\n\tcase 'R':\n\t  /* The GNU linker traditionally uses -R to mean to include\n\t     only the symbols from a file.  The Solaris linker uses -R\n\t     to set the path used by the runtime linker to find\n\t     libraries.  This is the GNU linker -rpath argument.  We\n\t     try to support both simultaneously by checking the file\n\t     named.  If it is a directory, rather than a regular file,\n\t     we assume -rpath was meant.  */\n\t  {\n\t    struct stat s;\n\n\t    if (stat (optarg, &s) >= 0\n\t\t&& ! S_ISDIR (s.st_mode))\n\t      {\n\t\tlang_add_input_file (optarg,\n\t\t\t\t     lang_input_file_is_symbols_only_enum,\n\t\t\t\t     NULL);\n\t\tbreak;\n\t      }\n\t  }\n\t  /* Fall through.  */\n\tcase OPTION_RPATH:\n\t  if (command_line.rpath == NULL)\n\t    command_line.rpath = xstrdup (optarg);\n\t  else\n\t    {\n\t      size_t rpath_len = strlen (command_line.rpath);\n\t      size_t optarg_len = strlen (optarg);\n\t      char *buf;\n\t      char *cp = command_line.rpath;\n\n\t      /* First see whether OPTARG is already in the path.  */\n\t      do\n\t\t{\n\t\t  if (strncmp (optarg, cp, optarg_len) == 0\n\t\t      && (cp[optarg_len] == 0\n\t\t\t  || cp[optarg_len] == config.rpath_separator))\n\t\t    /* We found it.  */\n\t\t    break;\n\n\t\t  /* Not yet found.  */\n\t\t  cp = strchr (cp, config.rpath_separator);\n\t\t  if (cp != NULL)\n\t\t    ++cp;\n\t\t}\n\t      while (cp != NULL);\n\n\t      if (cp == NULL)\n\t\t{\n\t\t  buf = (char *) xmalloc (rpath_len + optarg_len + 2);\n\t\t  sprintf (buf, \"%s%c%s\", command_line.rpath,\n\t\t\t   config.rpath_separator, optarg);\n\t\t  free (command_line.rpath);\n\t\t  command_line.rpath = buf;\n\t\t}\n\t    }\n\t  break;\n\tcase OPTION_RPATH_LINK:\n\t  if (command_line.rpath_link == NULL)\n\t    command_line.rpath_link = xstrdup (optarg);\n\t  else\n\t    {\n\t      char *buf;\n\n\t      buf = (char *) xmalloc (strlen (command_line.rpath_link)\n                                      + strlen (optarg)\n                                      + 2);\n\t      sprintf (buf, \"%s%c%s\", command_line.rpath_link,\n\t\t       config.rpath_separator, optarg);\n\t      free (command_line.rpath_link);\n\t      command_line.rpath_link = buf;\n\t    }\n\t  break;\n\tcase OPTION_NO_RELAX:\n\t  DISABLE_RELAXATION;\n\t  break;\n\tcase OPTION_RELAX:\n\t  ENABLE_RELAXATION;\n\t  break;\n\tcase OPTION_RETAIN_SYMBOLS_FILE:\n\t  add_keepsyms_file (optarg);\n\t  break;\n\tcase 'S':\n\t  link_info.strip = strip_debugger;\n\t  break;\n\tcase 's':\n\t  link_info.strip = strip_all;\n\t  break;\n\tcase OPTION_STRIP_DISCARDED:\n\t  link_info.strip_discarded = TRUE;\n\t  break;\n\tcase OPTION_NO_STRIP_DISCARDED:\n\t  link_info.strip_discarded = FALSE;\n\t  break;\n\tcase OPTION_SHARED:\n\t  if (config.has_shared)\n\t    {\n\t      link_info.shared = TRUE;\n\t      /* When creating a shared library, the default\n\t\t behaviour is to ignore any unresolved references.  */\n\t      if (link_info.unresolved_syms_in_objects == RM_NOT_YET_SET)\n\t\tlink_info.unresolved_syms_in_objects = RM_IGNORE;\n\t      if (link_info.unresolved_syms_in_shared_libs == RM_NOT_YET_SET)\n\t\tlink_info.unresolved_syms_in_shared_libs = RM_IGNORE;\n\t    }\n\t  else\n\t    einfo (_(\"%P%F: -shared not supported\\n\"));\n\t  break;\n\tcase OPTION_PIE:\n\t  if (config.has_shared)\n\t    {\n\t      link_info.shared = TRUE;\n\t      link_info.pie = TRUE;\n\t    }\n\t  else\n\t    einfo (_(\"%P%F: -pie not supported\\n\"));\n\t  break;\n\tcase 'h':\t\t/* Used on Solaris.  */\n\tcase OPTION_SONAME:\n\t  if (optarg[0] == '\\0' && command_line.soname\n\t      && command_line.soname[0])\n\t    einfo (_(\"%P: SONAME must not be empty string; keeping previous one\\n\"));\n\t  else\n\t    command_line.soname = optarg;\n\t  break;\n\tcase OPTION_SORT_COMMON:\n\t  if (optarg == NULL\n\t      || strcmp (optarg, N_(\"descending\")) == 0)\n            config.sort_common = sort_descending;\n          else if (strcmp (optarg, N_(\"ascending\")) == 0)\n\t    config.sort_common = sort_ascending;\n\t  else\n\t    einfo (_(\"%P%F: invalid common section sorting option: %s\\n\"),\n\t\t   optarg);\n\t  break;\n\tcase OPTION_SORT_SECTION:\n\t  if (strcmp (optarg, N_(\"name\")) == 0)\n\t    sort_section = by_name;\n\t  else if (strcmp (optarg, N_(\"alignment\")) == 0)\n\t    sort_section = by_alignment;\n\t  else\n\t    einfo (_(\"%P%F: invalid section sorting option: %s\\n\"),\n\t\t   optarg);\n\t  break;\n\tcase OPTION_STATS:\n\t  config.stats = TRUE;\n\t  break;\n\tcase OPTION_SYMBOLIC:\n\t  command_line.symbolic = symbolic;\n\t  break;\n\tcase OPTION_SYMBOLIC_FUNCTIONS:\n\t  command_line.symbolic = symbolic_functions;\n\t  break;\n\tcase 't':\n\t  trace_files = TRUE;\n\t  break;\n\tcase 'T':\n\t  previous_script_handle = saved_script_handle;\n\t  ldfile_open_command_file (optarg);\n\t  parser_input = input_script;\n\t  yyparse ();\n\t  previous_script_handle = NULL;\n\t  break;\n\tcase OPTION_DEFAULT_SCRIPT:\n\t  command_line.default_script = optarg;\n\t  break;\n\tcase OPTION_SECTION_START:\n\t  {\n\t    char *optarg2;\n\t    char *sec_name;\n\t    int len;\n\n\t    /* Check for <something>=<somthing>...  */\n\t    optarg2 = strchr (optarg, '=');\n\t    if (optarg2 == NULL)\n\t      einfo (_(\"%P%F: invalid argument to option\"\n\t\t       \" \\\"--section-start\\\"\\n\"));\n\n\t    optarg2++;\n\n\t    /* So far so good.  Are all the args present?  */\n\t    if ((*optarg == '\\0') || (*optarg2 == '\\0'))\n\t      einfo (_(\"%P%F: missing argument(s) to option\"\n\t\t       \" \\\"--section-start\\\"\\n\"));\n\n\t    /* We must copy the section name as set_section_start\n\t       doesn't do it for us.  */\n\t    len = optarg2 - optarg;\n\t    sec_name = (char *) xmalloc (len);\n\t    memcpy (sec_name, optarg, len - 1);\n\t    sec_name[len - 1] = 0;\n\n\t    /* Then set it...  */\n\t    set_section_start (sec_name, optarg2);\n\t  }\n\t  break;\n\tcase OPTION_TARGET_HELP:\n\t  /* Mention any target specific options.  */\n\t  ldemul_list_emulation_options (stdout);\n\t  exit (0);\n\tcase OPTION_TBSS:\n\t  set_segment_start (\".bss\", optarg);\n\t  break;\n\tcase OPTION_TDATA:\n\t  set_segment_start (\".data\", optarg);\n\t  break;\n\tcase OPTION_TTEXT:\n\t  set_segment_start (\".text\", optarg);\n\t  break;\n\tcase OPTION_TTEXT_SEGMENT:\n\t  set_segment_start (\".text-segment\", optarg);\n\t  break;\n\tcase OPTION_TRODATA_SEGMENT:\n\t  set_segment_start (\".rodata-segment\", optarg);\n\t  break;\n\tcase OPTION_TLDATA_SEGMENT:\n\t  set_segment_start (\".ldata-segment\", optarg);\n\t  break;\n\tcase OPTION_TRADITIONAL_FORMAT:\n\t  link_info.traditional_format = TRUE;\n\t  break;\n\tcase OPTION_TASK_LINK:\n\t  link_info.task_link = TRUE;\n\t  /* Fall through - do an implied -r option.  */\n\tcase OPTION_UR:\n\t  link_info.relocatable = TRUE;\n\t  config.build_constructors = TRUE;\n\t  config.magic_demand_paged = FALSE;\n\t  config.text_read_only = FALSE;\n\t  input_flags.dynamic = FALSE;\n\t  break;\n\tcase 'u':\n\t  ldlang_add_undef (optarg, TRUE);\n\t  break;\n\tcase OPTION_UNIQUE:\n\t  if (optarg != NULL)\n\t    lang_add_unique (optarg);\n\t  else\n\t    config.unique_orphan_sections = TRUE;\n\t  break;\n\tcase OPTION_VERBOSE:\n\t  ldversion (1);\n\t  version_printed = TRUE;\n\t  verbose = TRUE;\n\t  overflow_cutoff_limit = -2;\n\t  if (optarg != NULL)\n\t    {\n\t      char *end;\n\t      int level ATTRIBUTE_UNUSED = strtoul (optarg, &end, 0);\n\t      if (*end)\n\t\teinfo (_(\"%P%F: invalid number `%s'\\n\"), optarg);\n#ifdef ENABLE_PLUGINS\n\t      report_plugin_symbols = level > 1;\n#endif /* ENABLE_PLUGINS */\n\t    }\n\t  break;\n\tcase 'v':\n\t  ldversion (0);\n\t  version_printed = TRUE;\n\t  break;\n\tcase 'V':\n\t  ldversion (1);\n\t  version_printed = TRUE;\n\t  break;\n\tcase OPTION_VERSION:\n\t  ldversion (2);\n\t  xexit (0);\n\t  break;\n\tcase OPTION_VERSION_SCRIPT:\n\t  /* This option indicates a small script that only specifies\n\t     version information.  Read it, but don't assume that\n\t     we've seen a linker script.  */\n\t  {\n\t    FILE *hold_script_handle;\n\n\t    hold_script_handle = saved_script_handle;\n\t    ldfile_open_command_file (optarg);\n\t    saved_script_handle = hold_script_handle;\n\t    parser_input = input_version_script;\n\t    yyparse ();\n\t  }\n\t  break;\n\tcase OPTION_VERSION_EXPORTS_SECTION:\n\t  /* This option records a version symbol to be applied to the\n\t     symbols listed for export to be found in the object files\n\t     .exports sections.  */\n\t  command_line.version_exports_section = optarg;\n\t  break;\n\tcase OPTION_DYNAMIC_LIST_DATA:\n\t  command_line.dynamic_list = dynamic_list_data;\n\t  if (command_line.symbolic == symbolic)\n\t    command_line.symbolic = symbolic_unset;\n\t  break;\n\tcase OPTION_DYNAMIC_LIST_CPP_TYPEINFO:\n\t  lang_append_dynamic_list_cpp_typeinfo ();\n\t  if (command_line.dynamic_list != dynamic_list_data)\n\t    command_line.dynamic_list = dynamic_list;\n\t  if (command_line.symbolic == symbolic)\n\t    command_line.symbolic = symbolic_unset;\n\t  break;\n\tcase OPTION_DYNAMIC_LIST_CPP_NEW:\n\t  lang_append_dynamic_list_cpp_new ();\n\t  if (command_line.dynamic_list != dynamic_list_data)\n\t    command_line.dynamic_list = dynamic_list;\n\t  if (command_line.symbolic == symbolic)\n\t    command_line.symbolic = symbolic_unset;\n\t  break;\n\tcase OPTION_DYNAMIC_LIST:\n\t  /* This option indicates a small script that only specifies\n\t     a dynamic list.  Read it, but don't assume that we've\n\t     seen a linker script.  */\n\t  {\n\t    FILE *hold_script_handle;\n\n\t    hold_script_handle = saved_script_handle;\n\t    ldfile_open_command_file (optarg);\n\t    saved_script_handle = hold_script_handle;\n\t    parser_input = input_dynamic_list;\n\t    yyparse ();\n\t  }\n\t  if (command_line.dynamic_list != dynamic_list_data)\n\t    command_line.dynamic_list = dynamic_list;\n\t  if (command_line.symbolic == symbolic)\n\t    command_line.symbolic = symbolic_unset;\n\t  break;\n\tcase OPTION_WARN_COMMON:\n\t  config.warn_common = TRUE;\n\t  break;\n\tcase OPTION_WARN_CONSTRUCTORS:\n\t  config.warn_constructors = TRUE;\n\t  break;\n\tcase OPTION_WARN_FATAL:\n\t  config.fatal_warnings = TRUE;\n\t  break;\n\tcase OPTION_NO_WARN_FATAL:\n\t  config.fatal_warnings = FALSE;\n\t  break;\n\tcase OPTION_WARN_MULTIPLE_GP:\n\t  config.warn_multiple_gp = TRUE;\n\t  break;\n\tcase OPTION_WARN_ONCE:\n\t  config.warn_once = TRUE;\n\t  break;\n\tcase OPTION_WARN_SECTION_ALIGN:\n\t  config.warn_section_align = TRUE;\n\t  break;\n\tcase OPTION_WARN_SHARED_TEXTREL:\n\t  link_info.warn_shared_textrel = TRUE;\n\t  break;\n\tcase OPTION_WARN_ALTERNATE_EM:\n\t  link_info.warn_alternate_em = TRUE;\n\t  break;\n\tcase OPTION_WHOLE_ARCHIVE:\n\t  input_flags.whole_archive = TRUE;\n\t  break;\n\tcase OPTION_ADD_DT_NEEDED_FOR_DYNAMIC:\n\t  input_flags.add_DT_NEEDED_for_dynamic = TRUE;\n\t  break;\n\tcase OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC:\n\t  input_flags.add_DT_NEEDED_for_dynamic = FALSE;\n\t  break;\n\tcase OPTION_ADD_DT_NEEDED_FOR_REGULAR:\n\t  input_flags.add_DT_NEEDED_for_regular = TRUE;\n\t  break;\n\tcase OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR:\n\t  input_flags.add_DT_NEEDED_for_regular = FALSE;\n\t  break;\n\tcase OPTION_WRAP:\n\t  add_wrap (optarg);\n\t  break;\n\tcase OPTION_IGNORE_UNRESOLVED_SYMBOL:\n\t  add_ignoresym (&link_info, optarg);\n\t  break;\n\tcase OPTION_DISCARD_NONE:\n\t  link_info.discard = discard_none;\n\t  break;\n\tcase 'X':\n\t  link_info.discard = discard_l;\n\t  break;\n\tcase 'x':\n\t  link_info.discard = discard_all;\n\t  break;\n\tcase 'Y':\n\t  if (CONST_STRNEQ (optarg, \"P,\"))\n\t    optarg += 2;\n\t  if (default_dirlist != NULL)\n\t    free (default_dirlist);\n\t  default_dirlist = xstrdup (optarg);\n\t  break;\n\tcase 'y':\n\t  add_ysym (optarg);\n\t  break;\n\tcase OPTION_SPARE_DYNAMIC_TAGS:\n\t  link_info.spare_dynamic_tags = strtoul (optarg, NULL, 0);\n\t  break;\n\tcase OPTION_SPLIT_BY_RELOC:\n\t  if (optarg != NULL)\n\t    config.split_by_reloc = strtoul (optarg, NULL, 0);\n\t  else\n\t    config.split_by_reloc = 32768;\n\t  break;\n\tcase OPTION_SPLIT_BY_FILE:\n\t  if (optarg != NULL)\n\t    config.split_by_file = bfd_scan_vma (optarg, NULL, 0);\n\t  else\n\t    config.split_by_file = 1;\n\t  break;\n\tcase OPTION_CHECK_SECTIONS:\n\t  command_line.check_section_addresses = 1;\n\t  break;\n\tcase OPTION_NO_CHECK_SECTIONS:\n\t  command_line.check_section_addresses = 0;\n\t  break;\n\tcase OPTION_ACCEPT_UNKNOWN_INPUT_ARCH:\n\t  command_line.accept_unknown_input_arch = TRUE;\n\t  break;\n\tcase OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH:\n\t  command_line.accept_unknown_input_arch = FALSE;\n\t  break;\n\tcase '(':\n\t  lang_enter_group ();\n\t  ingroup++;\n\t  break;\n\tcase ')':\n\t  if (! ingroup)\n\t    einfo (_(\"%P%F: group ended before it began (--help for usage)\\n\"));\n\n\t  lang_leave_group ();\n\t  ingroup--;\n\t  break;\n\n\tcase OPTION_INIT:\n\t  link_info.init_function = optarg;\n\t  break;\n\n\tcase OPTION_FINI:\n\t  link_info.fini_function = optarg;\n\t  break;\n\n\tcase OPTION_REDUCE_MEMORY_OVERHEADS:\n\t  link_info.reduce_memory_overheads = TRUE;\n\t  if (config.hash_table_size == 0)\n\t    config.hash_table_size = 1021;\n\t  break;\n\n        case OPTION_HASH_SIZE:\n\t  {\n\t    bfd_size_type new_size;\n\n            new_size = strtoul (optarg, NULL, 0);\n            if (new_size)\n              config.hash_table_size = new_size;\n            else\n              einfo (_(\"%P%X: --hash-size needs a numeric argument\\n\"));\n          }\n          break;\n\n\tcase OPTION_PUSH_STATE:\n\t  input_flags.pushed = xmemdup (&input_flags,\n\t\t\t\t\tsizeof (input_flags),\n\t\t\t\t\tsizeof (input_flags));\n\t  break;\n\n\tcase OPTION_POP_STATE:\n\t  if (input_flags.pushed == NULL)\n\t    einfo (_(\"%P%F: no state pushed before popping\\n\"));\n\t  else\n\t    {\n\t      struct lang_input_statement_flags *oldp = input_flags.pushed;\n\t      memcpy (&input_flags, oldp, sizeof (input_flags));\n\t      free (oldp);\n\t    }\n\t  break;\n\t}\n    }\n\n  if (command_line.soname && command_line.soname[0] == '\\0')\n    {\n      einfo (_(\"%P: SONAME must not be empty string; ignored\\n\"));\n      command_line.soname = NULL;\n    }\n\n  while (ingroup)\n    {\n      lang_leave_group ();\n      ingroup--;\n    }\n\n  if (default_dirlist != NULL)\n    {\n      set_default_dirlist (default_dirlist);\n      free (default_dirlist);\n    }\n\n  if (link_info.unresolved_syms_in_objects == RM_NOT_YET_SET)\n    /* FIXME: Should we allow emulations a chance to set this ?  */\n    link_info.unresolved_syms_in_objects = how_to_report_unresolved_symbols;\n\n  if (link_info.unresolved_syms_in_shared_libs == RM_NOT_YET_SET)\n    /* FIXME: Should we allow emulations a chance to set this ?  */\n    link_info.unresolved_syms_in_shared_libs = how_to_report_unresolved_symbols;\n\n  if (link_info.relocatable)\n    {\n      if (command_line.check_section_addresses < 0)\n\tcommand_line.check_section_addresses = 0;\n      if (link_info.shared)\n\teinfo (_(\"%P%F: -r and -shared may not be used together\\n\"));\n    }\n\n  /* We may have -Bsymbolic, -Bsymbolic-functions, --dynamic-list-data,\n     --dynamic-list-cpp-new, --dynamic-list-cpp-typeinfo and\n     --dynamic-list FILE.  -Bsymbolic and -Bsymbolic-functions are\n     for shared libraries.  -Bsymbolic overrides all others and vice\n     versa.  */\n  switch (command_line.symbolic)\n    {\n    case symbolic_unset:\n      break;\n    case symbolic:\n      /* -Bsymbolic is for shared library only.  */\n      if (link_info.shared)\n\t{\n\t  link_info.symbolic = TRUE;\n\t  /* Should we free the unused memory?  */\n\t  link_info.dynamic_list = NULL;\n\t  command_line.dynamic_list = dynamic_list_unset;\n\t}\n      break;\n    case symbolic_functions:\n      /* -Bsymbolic-functions is for shared library only.  */\n      if (link_info.shared)\n\tcommand_line.dynamic_list = dynamic_list_data;\n      break;\n    }\n\n  switch (command_line.dynamic_list)\n    {\n    case dynamic_list_unset:\n      break;\n    case dynamic_list_data:\n      link_info.dynamic_data = TRUE;\n    case dynamic_list:\n      link_info.dynamic = TRUE;\n      break;\n    }\n\n  if (! link_info.shared)\n    {\n      if (command_line.filter_shlib)\n\teinfo (_(\"%P%F: -F may not be used without -shared\\n\"));\n      if (command_line.auxiliary_filters)\n\teinfo (_(\"%P%F: -f may not be used without -shared\\n\"));\n    }\n\n  if (! link_info.shared || link_info.pie)\n    link_info.executable = TRUE;\n\n  /* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I\n     don't see how else this can be handled, since in this case we\n     must preserve all externally visible symbols.  */\n  if (link_info.relocatable && link_info.strip == strip_all)\n    {\n      link_info.strip = strip_debugger;\n      if (link_info.discard == discard_sec_merge)\n\tlink_info.discard = discard_all;\n    }\n}"
}