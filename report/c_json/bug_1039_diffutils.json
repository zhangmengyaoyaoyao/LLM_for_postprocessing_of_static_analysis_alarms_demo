{
    "Project": "diffutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t      case 'd':",
    "Code_function": "edit (struct line_filter *left, char const *lname, lin lline, lin llen,\n      struct line_filter *right, char const *rname, lin rline, lin rlen,\n      FILE *outfile)\n{\n  for (;;)\n    {\n      int cmd0 IF_LINT (= 0);\n      int cmd1 IF_LINT (= 0);\n      bool gotcmd = false;\n\n      while (! gotcmd)\n\t{\n\t  if (putchar ('%') != '%')\n\t    perror_fatal (_(\"write failed\"));\n\t  ck_fflush (stdout);\n\n\t  cmd0 = skip_white ();\n\t  switch (cmd0)\n\t    {\n\t    case '1': case '2': case 'l': case 'r':\n\t    case 's': case 'v': case 'q':\n\t      if (skip_white () != '\\n')\n\t\t{\n\t\t  give_help ();\n\t\t  flush_line ();\n\t\t  continue;\n\t\t}\n\t      gotcmd = true;\n\t      break;\n\n\t    case 'e':\n\t      cmd1 = skip_white ();\n\t      switch (cmd1)\n\t\t{\n\t\tcase '1': case '2': case 'b': case 'd': case 'l': case 'r':\n\t\t  if (skip_white () != '\\n')\n\t\t    {\n\t\t      give_help ();\n\t\t      flush_line ();\n\t\t      continue;\n\t\t    }\n\t\t  gotcmd = true;\n\t\t  break;\n\t\tcase '\\n':\n\t\t  gotcmd = true;\n\t\t  break;\n\t\tdefault:\n\t\t  give_help ();\n\t\t  flush_line ();\n\t\t  continue;\n\t\t}\n\t      break;\n\n\t    case EOF:\n\t      if (feof (stdin))\n\t\t{\n\t\t  gotcmd = true;\n\t\t  cmd0 = 'q';\n\t\t  break;\n\t\t}\n\t      /* Fall through.  */\n\t    default:\n\t      flush_line ();\n\t      /* Fall through.  */\n\t    case '\\n':\n\t      give_help ();\n\t      continue;\n\t    }\n\t}\n\n      switch (cmd0)\n\t{\n\tcase '1': case 'l':\n\t  lf_copy (left, llen, outfile);\n\t  lf_skip (right, rlen);\n\t  return true;\n\tcase '2': case 'r':\n\t  lf_copy (right, rlen, outfile);\n\t  lf_skip (left, llen);\n\t  return true;\n\tcase 's':\n\t  suppress_common_lines = true;\n\t  break;\n\tcase 'v':\n\t  suppress_common_lines = false;\n\t  break;\n\tcase 'q':\n\t  return false;\n\tcase 'e':\n\t  {\n\t    int fd;\n\n\t    if (tmpname)\n\t      tmp = fopen (tmpname, \"w\");\n\t    else\n\t      {\n\t\tif ((fd = temporary_file ()) < 0)\n\t\t  perror_fatal (\"mkstemp\");\n\t\ttmp = fdopen (fd, \"w\");\n\t      }\n\n\t    if (! tmp)\n\t      perror_fatal (tmpname);\n\n\t    switch (cmd1)\n\t      {\n\t      case 'd':\n\t\tif (llen)\n\t\t  {\n\t\t    if (llen == 1)\n\t\t      fprintf (tmp, \"--- %s %ld\\n\", lname, (long int) lline);\n\t\t    else\n\t\t      fprintf (tmp, \"--- %s %ld,%ld\\n\", lname,\n\t\t\t       (long int) lline,\n\t\t\t       (long int) (lline + llen - 1));\n\t\t  }\n\t\t/* Fall through.  */\n\t      case '1': case 'b': case 'l':\n\t\tlf_copy (left, llen, tmp);\n\t\tbreak;\n\n\t      default:\n\t\tlf_skip (left, llen);\n\t\tbreak;\n\t      }\n\n\t    switch (cmd1)\n\t      {\n\t      case 'd':\n\t\tif (rlen)\n\t\t  {\n\t\t    if (rlen == 1)\n\t\t      fprintf (tmp, \"+++ %s %ld\\n\", rname, (long int) rline);\n\t\t    else\n\t\t      fprintf (tmp, \"+++ %s %ld,%ld\\n\", rname,\n\t\t\t       (long int) rline,\n\t\t\t       (long int) (rline + rlen - 1));\n\t\t  }\n\t\t/* Fall through.  */\n\t      case '2': case 'b': case 'r':\n\t\tlf_copy (right, rlen, tmp);\n\t\tbreak;\n\n\t      default:\n\t\tlf_skip (right, rlen);\n\t\tbreak;\n\t      }\n\n\t    ck_fclose (tmp);\n\n\t    {\n\t      int wstatus;\n\t      int werrno = 0;\n\t      char const *argv[3];\n\n\t      ignore_SIGINT = true;\n\t      checksigs ();\n\t      argv[0] = editor_program;\n\t      argv[1] = tmpname;\n\t      argv[2] = 0;\n\n\t      {\n#if ! HAVE_WORKING_FORK\n\t\tchar *command = system_quote_argv (SCI_SYSTEM, (char **) argv);\n\t\twstatus = system (command);\n\t\tif (wstatus == -1)\n\t\t  werrno = errno;\n\t\tfree (command);\n#else\n\t\tpid_t pid;\n\n\t\tpid = fork ();\n\t\tif (pid == 0)\n\t\t  {\n\t\t    execvp (editor_program, (char **) argv);\n\t\t    _exit (errno == ENOENT ? 127 : 126);\n\t\t  }\n\n\t\tif (pid < 0)\n\t\t  perror_fatal (\"fork\");\n\n\t\twhile (waitpid (pid, &wstatus, 0) < 0)\n\t\t  if (errno == EINTR)\n\t\t    checksigs ();\n\t\t  else\n\t\t    perror_fatal (\"waitpid\");\n#endif\n\t      }\n\n\t      ignore_SIGINT = false;\n\t      check_child_status (werrno, wstatus, EXIT_SUCCESS,\n\t\t\t\t  editor_program);\n\t    }\n\n\t    {\n\t      char buf[SDIFF_BUFSIZE];\n\t      size_t size;\n\t      tmp = ck_fopen (tmpname, \"r\");\n\t      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)\n\t\t{\n\t\t  checksigs ();\n\t\t  ck_fwrite (buf, size, outfile);\n\t\t}\n\t      ck_fclose (tmp);\n\t    }\n\t    return true;\n\t  }\n\tdefault:\n\t  give_help ();\n\t  break;\n\t}\n    }\n}"
}