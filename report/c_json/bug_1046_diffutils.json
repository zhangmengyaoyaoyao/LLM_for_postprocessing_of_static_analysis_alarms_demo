{
    "Project": "diffutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from prefixes[_] was never initialized.",
    "Code_line": "                          SNPRINTF_BUF (arg);",
    "Code_function": "VASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp,\n            const FCHAR_T *format, va_list args)\n{\n  DIRECTIVES d;\n  arguments a;\n\n  if (PRINTF_PARSE (format, &d, &a) < 0)\n    /* errno is already set.  */\n    return NULL;\n\n#define CLEANUP() \\\n  if (d.dir != d.direct_alloc_dir)                                      \\\n    free (d.dir);                                                       \\\n  if (a.arg != a.direct_alloc_arg)                                      \\\n    free (a.arg);\n\n  if (PRINTF_FETCHARGS (args, &a) < 0)\n    {\n      CLEANUP ();\n      errno = EINVAL;\n      return NULL;\n    }\n\n  {\n    size_t buf_neededlength;\n    TCHAR_T *buf;\n    TCHAR_T *buf_malloced;\n    const FCHAR_T *cp;\n    size_t i;\n    DIRECTIVE *dp;\n    /* Output string accumulator.  */\n    DCHAR_T *result;\n    size_t allocated;\n    size_t length;\n\n    /* Allocate a small buffer that will hold a directive passed to\n       sprintf or snprintf.  */\n    buf_neededlength =\n      xsum4 (7, d.max_width_length, d.max_precision_length, 6);\n#if HAVE_ALLOCA\n    if (buf_neededlength < 4000 / sizeof (TCHAR_T))\n      {\n        buf = (TCHAR_T *) alloca (buf_neededlength * sizeof (TCHAR_T));\n        buf_malloced = NULL;\n      }\n    else\n#endif\n      {\n        size_t buf_memsize = xtimes (buf_neededlength, sizeof (TCHAR_T));\n        if (size_overflow_p (buf_memsize))\n          goto out_of_memory_1;\n        buf = (TCHAR_T *) malloc (buf_memsize);\n        if (buf == NULL)\n          goto out_of_memory_1;\n        buf_malloced = buf;\n      }\n\n    if (resultbuf != NULL)\n      {\n        result = resultbuf;\n        allocated = *lengthp;\n      }\n    else\n      {\n        result = NULL;\n        allocated = 0;\n      }\n    length = 0;\n    /* Invariants:\n       result is either == resultbuf or == NULL or malloc-allocated.\n       If length > 0, then result != NULL.  */\n\n    /* Ensures that allocated >= needed.  Aborts through a jump to\n       out_of_memory if needed is SIZE_MAX or otherwise too big.  */\n#define ENSURE_ALLOCATION(needed) \\\n    if ((needed) > allocated)                                                \\\n      {                                                                      \\\n        size_t memory_size;                                                  \\\n        DCHAR_T *memory;                                                     \\\n                                                                             \\\n        allocated = (allocated > 0 ? xtimes (allocated, 2) : 12);            \\\n        if ((needed) > allocated)                                            \\\n          allocated = (needed);                                              \\\n        memory_size = xtimes (allocated, sizeof (DCHAR_T));                  \\\n        if (size_overflow_p (memory_size))                                   \\\n          goto out_of_memory;                                                \\\n        if (result == resultbuf || result == NULL)                           \\\n          memory = (DCHAR_T *) malloc (memory_size);                         \\\n        else                                                                 \\\n          memory = (DCHAR_T *) realloc (result, memory_size);                \\\n        if (memory == NULL)                                                  \\\n          goto out_of_memory;                                                \\\n        if (result == resultbuf && length > 0)                               \\\n          DCHAR_CPY (memory, result, length);                                \\\n        result = memory;                                                     \\\n      }\n\n    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)\n      {\n        if (cp != dp->dir_start)\n          {\n            size_t n = dp->dir_start - cp;\n            size_t augmented_length = xsum (length, n);\n\n            ENSURE_ALLOCATION (augmented_length);\n            /* This copies a piece of FCHAR_T[] into a DCHAR_T[].  Here we\n               need that the format string contains only ASCII characters\n               if FCHAR_T and DCHAR_T are not the same type.  */\n            if (sizeof (FCHAR_T) == sizeof (DCHAR_T))\n              {\n                DCHAR_CPY (result + length, (const DCHAR_T *) cp, n);\n                length = augmented_length;\n              }\n            else\n              {\n                do\n                  result[length++] = (unsigned char) *cp++;\n                while (--n > 0);\n              }\n          }\n        if (i == d.count)\n          break;\n\n        /* Execute a single directive.  */\n        if (dp->conversion == '%')\n          {\n            size_t augmented_length;\n\n            if (!(dp->arg_index == ARG_NONE))\n              abort ();\n            augmented_length = xsum (length, 1);\n            ENSURE_ALLOCATION (augmented_length);\n            result[length] = '%';\n            length = augmented_length;\n          }\n        else\n          {\n            if (!(dp->arg_index != ARG_NONE))\n              abort ();\n\n            if (dp->conversion == 'n')\n              {\n                switch (a.arg[dp->arg_index].type)\n                  {\n                  case TYPE_COUNT_SCHAR_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_schar_pointer = length;\n                    break;\n                  case TYPE_COUNT_SHORT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_short_pointer = length;\n                    break;\n                  case TYPE_COUNT_INT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_int_pointer = length;\n                    break;\n                  case TYPE_COUNT_LONGINT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_longint_pointer = length;\n                    break;\n#if HAVE_LONG_LONG_INT\n                  case TYPE_COUNT_LONGLONGINT_POINTER:\n                    *a.arg[dp->arg_index].a.a_count_longlongint_pointer = length;\n                    break;\n#endif\n                  default:\n                    abort ();\n                  }\n              }\n#if ENABLE_UNISTDIO\n            /* The unistdio extensions.  */\n            else if (dp->conversion == 'U')\n              {\n                arg_type type = a.arg[dp->arg_index].type;\n                int flags = dp->flags;\n                int has_width;\n                size_t width;\n                int has_precision;\n                size_t precision;\n\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n\n                has_precision = 0;\n                precision = 0;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n                switch (type)\n                  {\n                  case TYPE_U8_STRING:\n                    {\n                      const uint8_t *arg = a.arg[dp->arg_index].a.a_u8_string;\n                      const uint8_t *arg_end;\n                      size_t characters;\n\n                      if (has_precision)\n                        {\n                          /* Use only PRECISION characters, from the left.  */\n                          arg_end = arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              int count = u8_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                {\n                                  if (!(result == resultbuf || result == NULL))\n                                    free (result);\n                                  if (buf_malloced != NULL)\n                                    free (buf_malloced);\n                                  CLEANUP ();\n                                  errno = EILSEQ;\n                                  return NULL;\n                                }\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else if (has_width)\n                        {\n                          /* Use the entire string, and count the number of\n                             characters.  */\n                          arg_end = arg;\n                          characters = 0;\n                          for (;;)\n                            {\n                              int count = u8_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                {\n                                  if (!(result == resultbuf || result == NULL))\n                                    free (result);\n                                  if (buf_malloced != NULL)\n                                    free (buf_malloced);\n                                  CLEANUP ();\n                                  errno = EILSEQ;\n                                  return NULL;\n                                }\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                          /* Use the entire string.  */\n                          arg_end = arg + u8_strlen (arg);\n                          /* The number of characters doesn't matter.  */\n                          characters = 0;\n                        }\n\n                      if (has_width && width > characters\n                          && !(dp->flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n\n# if DCHAR_IS_UINT8_T\n                      {\n                        size_t n = arg_end - arg;\n                        ENSURE_ALLOCATION (xsum (length, n));\n                        DCHAR_CPY (result + length, arg, n);\n                        length += n;\n                      }\n# else\n                      { /* Convert.  */\n                        DCHAR_T *converted = result + length;\n                        size_t converted_len = allocated - length;\n#  if DCHAR_IS_TCHAR\n                        /* Convert from UTF-8 to locale encoding.  */\n                        converted =\n                          u8_conv_to_encoding (locale_charset (),\n                                               iconveh_question_mark,\n                                               arg, arg_end - arg, NULL,\n                                               converted, &converted_len);\n#  else\n                        /* Convert from UTF-8 to UTF-16/UTF-32.  */\n                        converted =\n                          U8_TO_DCHAR (arg, arg_end - arg,\n                                       converted, &converted_len);\n#  endif\n                        if (converted == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        if (converted != result + length)\n                          {\n                            ENSURE_ALLOCATION (xsum (length, converted_len));\n                            DCHAR_CPY (result + length, converted, converted_len);\n                            free (converted);\n                          }\n                        length += converted_len;\n                      }\n# endif\n\n                      if (has_width && width > characters\n                          && (dp->flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n                    }\n                    break;\n\n                  case TYPE_U16_STRING:\n                    {\n                      const uint16_t *arg = a.arg[dp->arg_index].a.a_u16_string;\n                      const uint16_t *arg_end;\n                      size_t characters;\n\n                      if (has_precision)\n                        {\n                          /* Use only PRECISION characters, from the left.  */\n                          arg_end = arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              int count = u16_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                {\n                                  if (!(result == resultbuf || result == NULL))\n                                    free (result);\n                                  if (buf_malloced != NULL)\n                                    free (buf_malloced);\n                                  CLEANUP ();\n                                  errno = EILSEQ;\n                                  return NULL;\n                                }\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else if (has_width)\n                        {\n                          /* Use the entire string, and count the number of\n                             characters.  */\n                          arg_end = arg;\n                          characters = 0;\n                          for (;;)\n                            {\n                              int count = u16_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                {\n                                  if (!(result == resultbuf || result == NULL))\n                                    free (result);\n                                  if (buf_malloced != NULL)\n                                    free (buf_malloced);\n                                  CLEANUP ();\n                                  errno = EILSEQ;\n                                  return NULL;\n                                }\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                          /* Use the entire string.  */\n                          arg_end = arg + u16_strlen (arg);\n                          /* The number of characters doesn't matter.  */\n                          characters = 0;\n                        }\n\n                      if (has_width && width > characters\n                          && !(dp->flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n\n# if DCHAR_IS_UINT16_T\n                      {\n                        size_t n = arg_end - arg;\n                        ENSURE_ALLOCATION (xsum (length, n));\n                        DCHAR_CPY (result + length, arg, n);\n                        length += n;\n                      }\n# else\n                      { /* Convert.  */\n                        DCHAR_T *converted = result + length;\n                        size_t converted_len = allocated - length;\n#  if DCHAR_IS_TCHAR\n                        /* Convert from UTF-16 to locale encoding.  */\n                        converted =\n                          u16_conv_to_encoding (locale_charset (),\n                                                iconveh_question_mark,\n                                                arg, arg_end - arg, NULL,\n                                                converted, &converted_len);\n#  else\n                        /* Convert from UTF-16 to UTF-8/UTF-32.  */\n                        converted =\n                          U16_TO_DCHAR (arg, arg_end - arg,\n                                        converted, &converted_len);\n#  endif\n                        if (converted == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        if (converted != result + length)\n                          {\n                            ENSURE_ALLOCATION (xsum (length, converted_len));\n                            DCHAR_CPY (result + length, converted, converted_len);\n                            free (converted);\n                          }\n                        length += converted_len;\n                      }\n# endif\n\n                      if (has_width && width > characters\n                          && (dp->flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n                    }\n                    break;\n\n                  case TYPE_U32_STRING:\n                    {\n                      const uint32_t *arg = a.arg[dp->arg_index].a.a_u32_string;\n                      const uint32_t *arg_end;\n                      size_t characters;\n\n                      if (has_precision)\n                        {\n                          /* Use only PRECISION characters, from the left.  */\n                          arg_end = arg;\n                          characters = 0;\n                          for (; precision > 0; precision--)\n                            {\n                              int count = u32_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                {\n                                  if (!(result == resultbuf || result == NULL))\n                                    free (result);\n                                  if (buf_malloced != NULL)\n                                    free (buf_malloced);\n                                  CLEANUP ();\n                                  errno = EILSEQ;\n                                  return NULL;\n                                }\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else if (has_width)\n                        {\n                          /* Use the entire string, and count the number of\n                             characters.  */\n                          arg_end = arg;\n                          characters = 0;\n                          for (;;)\n                            {\n                              int count = u32_strmblen (arg_end);\n                              if (count == 0)\n                                break;\n                              if (count < 0)\n                                {\n                                  if (!(result == resultbuf || result == NULL))\n                                    free (result);\n                                  if (buf_malloced != NULL)\n                                    free (buf_malloced);\n                                  CLEANUP ();\n                                  errno = EILSEQ;\n                                  return NULL;\n                                }\n                              arg_end += count;\n                              characters++;\n                            }\n                        }\n                      else\n                        {\n                          /* Use the entire string.  */\n                          arg_end = arg + u32_strlen (arg);\n                          /* The number of characters doesn't matter.  */\n                          characters = 0;\n                        }\n\n                      if (has_width && width > characters\n                          && !(dp->flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n\n# if DCHAR_IS_UINT32_T\n                      {\n                        size_t n = arg_end - arg;\n                        ENSURE_ALLOCATION (xsum (length, n));\n                        DCHAR_CPY (result + length, arg, n);\n                        length += n;\n                      }\n# else\n                      { /* Convert.  */\n                        DCHAR_T *converted = result + length;\n                        size_t converted_len = allocated - length;\n#  if DCHAR_IS_TCHAR\n                        /* Convert from UTF-32 to locale encoding.  */\n                        converted =\n                          u32_conv_to_encoding (locale_charset (),\n                                                iconveh_question_mark,\n                                                arg, arg_end - arg, NULL,\n                                                converted, &converted_len);\n#  else\n                        /* Convert from UTF-32 to UTF-8/UTF-16.  */\n                        converted =\n                          U32_TO_DCHAR (arg, arg_end - arg,\n                                        converted, &converted_len);\n#  endif\n                        if (converted == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        if (converted != result + length)\n                          {\n                            ENSURE_ALLOCATION (xsum (length, converted_len));\n                            DCHAR_CPY (result + length, converted, converted_len);\n                            free (converted);\n                          }\n                        length += converted_len;\n                      }\n# endif\n\n                      if (has_width && width > characters\n                          && (dp->flags & FLAG_LEFT))\n                        {\n                          size_t n = width - characters;\n                          ENSURE_ALLOCATION (xsum (length, n));\n                          DCHAR_SET (result + length, ' ', n);\n                          length += n;\n                        }\n                    }\n                    break;\n\n                  default:\n                    abort ();\n                  }\n              }\n#endif\n#if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || (NEED_PRINTF_DIRECTIVE_LS && !defined IN_LIBINTL)) && HAVE_WCHAR_T\n            else if (dp->conversion == 's'\n# if WIDE_CHAR_VERSION\n                     && a.arg[dp->arg_index].type != TYPE_WIDE_STRING\n# else\n                     && a.arg[dp->arg_index].type == TYPE_WIDE_STRING\n# endif\n                    )\n              {\n                /* The normal handling of the 's' directive below requires\n                   allocating a temporary buffer.  The determination of its\n                   length (tmp_length), in the case when a precision is\n                   specified, below requires a conversion between a char[]\n                   string and a wchar_t[] wide string.  It could be done, but\n                   we have no guarantee that the implementation of sprintf will\n                   use the exactly same algorithm.  Without this guarantee, it\n                   is possible to have buffer overrun bugs.  In order to avoid\n                   such bugs, we implement the entire processing of the 's'\n                   directive ourselves.  */\n                int flags = dp->flags;\n                int has_width;\n                size_t width;\n                int has_precision;\n                size_t precision;\n\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n\n# if WIDE_CHAR_VERSION\n                /* %s in vasnwprintf.  See the specification of fwprintf.  */\n                {\n                  const char *arg = a.arg[dp->arg_index].a.a_string;\n                  const char *arg_end;\n                  size_t characters;\n\n                  if (has_precision)\n                    {\n                      /* Use only as many bytes as needed to produce PRECISION\n                         wide characters, from the left.  */\n#  if HAVE_MBRTOWC\n                      mbstate_t state;\n                      memset (&state, '\\0', sizeof (mbstate_t));\n#  endif\n                      arg_end = arg;\n                      characters = 0;\n                      for (; precision > 0; precision--)\n                        {\n                          int count;\n#  if HAVE_MBRTOWC\n                          count = mbrlen (arg_end, MB_CUR_MAX, &state);\n#  else\n                          count = mblen (arg_end, MB_CUR_MAX);\n#  endif\n                          if (count == 0)\n                            /* Found the terminating NUL.  */\n                            break;\n                          if (count < 0)\n                            {\n                              /* Invalid or incomplete multibyte character.  */\n                              if (!(result == resultbuf || result == NULL))\n                                free (result);\n                              if (buf_malloced != NULL)\n                                free (buf_malloced);\n                              CLEANUP ();\n                              errno = EILSEQ;\n                              return NULL;\n                            }\n                          arg_end += count;\n                          characters++;\n                        }\n                    }\n                  else if (has_width)\n                    {\n                      /* Use the entire string, and count the number of wide\n                         characters.  */\n#  if HAVE_MBRTOWC\n                      mbstate_t state;\n                      memset (&state, '\\0', sizeof (mbstate_t));\n#  endif\n                      arg_end = arg;\n                      characters = 0;\n                      for (;;)\n                        {\n                          int count;\n#  if HAVE_MBRTOWC\n                          count = mbrlen (arg_end, MB_CUR_MAX, &state);\n#  else\n                          count = mblen (arg_end, MB_CUR_MAX);\n#  endif\n                          if (count == 0)\n                            /* Found the terminating NUL.  */\n                            break;\n                          if (count < 0)\n                            {\n                              /* Invalid or incomplete multibyte character.  */\n                              if (!(result == resultbuf || result == NULL))\n                                free (result);\n                              if (buf_malloced != NULL)\n                                free (buf_malloced);\n                              CLEANUP ();\n                              errno = EILSEQ;\n                              return NULL;\n                            }\n                          arg_end += count;\n           "
}