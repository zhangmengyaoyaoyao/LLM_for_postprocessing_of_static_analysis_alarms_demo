{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t      if (m1 && m2)",
    "Code_function": "{\n  CHAR *prest;\t\t\t/* pointer to rest of pattern */\n  CHAR *psub;\t\t\t/* pointer to sub-pattern */\n  CHAR *pnext;\t\t\t/* pointer to next sub-pattern */\n  CHAR *srest;\t\t\t/* pointer to rest of string */\n  int m1, m2, xflags;\t\t/* xflags = flags passed to recursive matches */\n\n#if DEBUG_MATCHING\nfprintf(stderr, \"extmatch: xc = %c\\n\", xc);\nfprintf(stderr, \"extmatch: s = %s; se = %s\\n\", s, se);\nfprintf(stderr, \"extmatch: p = %s; pe = %s\\n\", p, pe);\nfprintf(stderr, \"extmatch: flags = %d\\n\", flags);\n#endif\n\n  prest = PATSCAN (p + (*p == L('(')), pe, 0); /* ) */\n  if (prest == 0)\n    /* If PREST is 0, we failed to scan a valid pattern.  In this\n       case, we just want to compare the two as strings. */\n    return (STRCOMPARE (p - 1, pe, s, se));\n\n  switch (xc)\n    {\n    case L('+'):\t\t/* match one or more occurrences */\n    case L('*'):\t\t/* match zero or more occurrences */\n      /* If we can get away with no matches, don't even bother.  Just\n\t call GMATCH on the rest of the pattern and return success if\n\t it succeeds. */\n      if (xc == L('*') && (GMATCH (s, se, prest, pe, flags) == 0))\n\treturn 0;\n\n      /* OK, we have to do this the hard way.  First, we make sure one of\n\t the subpatterns matches, then we try to match the rest of the\n\t string. */\n      for (psub = p + 1; ; psub = pnext)\n\t{\n\t  pnext = PATSCAN (psub, pe, L('|'));\n\t  for (srest = s; srest <= se; srest++)\n\t    {\n\t      /* Match this substring (S -> SREST) against this\n\t\t subpattern (psub -> pnext - 1) */\n\t      m1 = GMATCH (s, srest, psub, pnext - 1, flags) == 0;\n\t      /* OK, we matched a subpattern, so make sure the rest of the\n\t\t string matches the rest of the pattern.  Also handle\n\t\t multiple matches of the pattern. */\n\t      if (m1)\n\t\t{\n\t\t  /* if srest > s, we are not at start of string */\n\t\t  xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;\n\t\t  m2 = (GMATCH (srest, se, prest, pe, xflags) == 0) ||\n\t\t\t(s != srest && GMATCH (srest, se, p - 1, pe, xflags) == 0);\n\t\t}\n\t      if (m1 && m2)\n\t\treturn (0);\n\t    }\n\t  if (pnext == prest)\n\t    break;\n\t}\n      return (FNM_NOMATCH);\n\n    case L('?'):\t\t/* match zero or one of the patterns */\n    case L('@'):\t\t/* match one (or more) of the patterns */\n      /* If we can get away with no matches, don't even bother.  Just\n\t call gmatch on the rest of the pattern and return success if\n\t it succeeds. */\n      if (xc == L('?') && (GMATCH (s, se, prest, pe, flags) == 0))\n\treturn 0;\n\n      /* OK, we have to do this the hard way.  First, we see if one of\n\t the subpatterns matches, then, if it does, we try to match the\n\t rest of the string. */\n      for (psub = p + 1; ; psub = pnext)\n\t{\n\t  pnext = PATSCAN (psub, pe, L('|'));\n\t  srest = (prest == pe) ? se : s;\n\t  for ( ; srest <= se; srest++)\n\t    {\n\t      /* if srest > s, we are not at start of string */\n\t      xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;\n\t      if (GMATCH (s, srest, psub, pnext - 1, flags) == 0 &&\n\t\t  GMATCH (srest, se, prest, pe, xflags) == 0)\n\t\treturn (0);\n\t    }\n\t  if (pnext == prest)\n\t    break;\n\t}\n      return (FNM_NOMATCH);\n\n    case '!':\t\t/* match anything *except* one of the patterns */\n      for (srest = s; srest <= se; srest++)\n\t{\n\t  m1 = 0;\n\t  for (psub = p + 1; ; psub = pnext)\n\t    {\n\t      pnext = PATSCAN (psub, pe, L('|'));\n\t      /* If one of the patterns matches, just bail immediately. */\n\t      if (m1 = (GMATCH (s, srest, psub, pnext - 1, flags) == 0))\n\t\tbreak;\n\t      if (pnext == prest)\n\t\tbreak;\n\t    }\n\t  /* if srest > s, we are not at start of string */\n\t  xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;\n\t  if (m1 == 0 && GMATCH (srest, se, prest, pe, xflags) == 0)\n\t    return (0);\n\t}\n      return (FNM_NOMATCH);\n    }\n\n  return (FNM_NOMATCH);\n}"
}