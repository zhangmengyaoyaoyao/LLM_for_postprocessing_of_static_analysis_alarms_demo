{
    "project": "RIOT",
    "tool": "Cppcheck",
    "category": "Divide By Zero",
    "file": "sys/quad_math/qdivrem.c",
    "message": "Division by zero.",
    "warning_function_name": "__qdivrem",
    "warning_line": "tmp.ul[H] = tmp.ul[L] = 1 / zero;",
    "warning_context": "u_quad_t\n__qdivrem(u_quad_t uq, u_quad_t vq, u_quad_t *arq)\n{\n    union uu tmp;\n    digit *u, *v, *q;\n    digit v1, v2;\n    u_int qhat, rhat, t;\n    int m, n, d, j, i;\n    digit uspace[5], vspace[5], qspace[5];\n\n    /*\n     * Take care of special cases: divide by zero, and u < v.\n     */\n    if (vq == 0) {\n        /* divide by zero. */\n        static volatile const unsigned int zero = 0;\n\n        /* cppcheck-suppress zerodiv\n         * (reason: division by zero is on purpose here) */\n        tmp.ul[H] = tmp.ul[L] = 1 / zero;\n\n        if (arq) {\n            *arq = uq;\n        }\n\n        return tmp.q;\n    }\n\n    if (uq < vq) {\n        if (arq) {\n            *arq = uq;\n        }\n\n        return 0;\n    }\n\n    u = &uspace[0];\n    v = &vspace[0];\n    q = &qspace[0];\n\n    /*\n     * Break dividend and divisor into digits in base B, then\n     * count leading zeros to determine m and n.  When done, we\n     * will have:\n     *  u = (u[1]u[2]...u[m+n]) sub B\n     *  v = (v[1]v[2]...v[n]) sub B\n     *  v[1] != 0\n     *  1 < n <= 4 (if n = 1, we use a different division algorithm)\n     *  m >= 0 (otherwise u < v, which we already checked)\n     *  m + n = 4\n     * and thus\n     *  m = 4 - n <= 2\n     */\n    tmp.uq = uq;\n    u[0] = 0;\n    u[1] = (digit) HHALF(tmp.ul[H]);\n    u[2] = (digit) LHALF(tmp.ul[H]);\n    u[3] = (digit) HHALF(tmp.ul[L]);\n    u[4] = (digit) LHALF(tmp.ul[L]);\n    tmp.uq = vq;\n    v[1] = (digit) HHALF(tmp.ul[H]);\n    v[2] = (digit) LHALF(tmp.ul[H]);\n    v[3] = (digit) HHALF(tmp.ul[L]);\n    v[4] = (digit) LHALF(tmp.ul[L]);\n\n    for (n = 4; v[1] == 0; v++) {\n        if (--n == 1) {\n            u_int rbj;  /* r*B+u[j] (not root boy jim) */\n            digit q1, q2, q3, q4;\n\n            /*\n             * Change of plan, per exercise 16.\n             *  r = 0;\n             *  for j = 1..4:\n             *      q[j] = floor((r*B + u[j]) / v),\n             *      r = (r*B + u[j]) % v;\n             * We unroll this completely here.\n             */\n            t = v[2];   /* nonzero, by definition */\n            q1 = (digit) (u[1] / t);\n            rbj = COMBINE(u[1] % t, u[2]);\n            q2 = (digit) (rbj / t);\n            rbj = COMBINE(rbj % t, u[3]);\n            q3 = (digit) (rbj / t);\n            rbj = COMBINE(rbj % t, u[4]);\n            q4 = (digit) (rbj / t);\n\n            if (arq) {\n                *arq = rbj % t;\n            }\n\n            tmp.ul[H] = COMBINE(q1, q2);\n            tmp.ul[L] = COMBINE(q3, q4);\n            return tmp.q;\n        }\n    }\n\n    /*\n     * By adjusting q once we determine m, we can guarantee that\n     * there is a complete four-digit quotient at &qspace[1] when\n     * we finally stop.\n"
}