{
    "Project": "Zephyr",
    "Tool": "Infer",
    "Bug Type": "Uninitialized Value",
    "Message": "The value read from evt.status was never initialized.",
    "Code_line": "\treturn evt;",
    "Code_function": "osEvent osSignalWait(int32_t signals, uint32_t millisec)\n{\n\tint retval, key;\n\tosEvent evt;\n\tu32_t time_delta_ms, timeout = millisec;\n\tu64_t time_stamp_start, hwclk_cycles_delta, time_delta_ns;\n\n\tif (k_is_in_isr()) {\n\t\tevt.status = osErrorISR;\n\t\treturn evt;\n\t}\n\n\t/* Check if signals is within the permitted range */\n\tif ((signals & 0x80000000) || (signals > MAX_VALID_SIGNAL_VAL)) {\n\t\tevt.status = osErrorValue;\n\t\treturn evt;\n\t}\n\n\tosThreadDef_t *thread_def = k_thread_custom_data_get();\n\n\tfor (;;) {\n\n\t\ttime_stamp_start = (u64_t)k_cycle_get_32();\n\n\t\tswitch (millisec) {\n\t\tcase 0:\n\t\t\tretval = k_poll(thread_def->poll_event, 1, K_NO_WAIT);\n\t\t\tbreak;\n\t\tcase osWaitForever:\n\t\t\tretval = k_poll(thread_def->poll_event, 1, K_FOREVER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tretval = k_poll(thread_def->poll_event, 1, timeout);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (retval) {\n\t\tcase 0:\n\t\t\tevt.status = osEventSignal;\n\t\t\tbreak;\n\t\tcase -EAGAIN:\n\t\t\tif (millisec == 0U) {\n\t\t\t\tevt.status = osOK;\n\t\t\t} else {\n\t\t\t\tevt.status = osEventTimeout;\n\t\t\t}\n\t\t\treturn evt;\n\t\tdefault:\n\t\t\tevt.status = osErrorValue;\n\t\t\treturn evt;\n\t\t}\n\n\t\t__ASSERT(thread_def->poll_event->state\n\t\t\t\t== K_POLL_STATE_SIGNALED,\n\t\t\t\"event state not signalled!\");\n\t\t__ASSERT(thread_def->poll_event->signal->signaled == 1,\n\t\t\t\"event signaled is not 1\");\n\n\t\t/* Reset the states to facilitate the next trigger */\n\t\tthread_def->poll_event->signal->signaled = 0;\n\t\tthread_def->poll_event->state = K_POLL_STATE_NOT_READY;\n\n\t\t/* Check if all events we are waiting on have been signalled */\n\t\tif ((thread_def->signal_results & signals) == signals) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If we need to wait on more signals, we need to adjust the\n\t\t * timeout value accordingly based on the time that has\n\t\t * already elapsed.\n\t\t */\n\t\thwclk_cycles_delta = (u64_t)k_cycle_get_32() - time_stamp_start;\n\t\ttime_delta_ns =\n\t\t\t(u32_t)k_cyc_to_ns_floor64(hwclk_cycles_delta);\n\t\ttime_delta_ms =\t(u32_t)time_delta_ns/NSEC_PER_MSEC;\n\n\t\tif (timeout > time_delta_ms) {\n\t\t\ttimeout -= time_delta_ms;\n\t\t} else {\n\t\t\ttimeout = 0U;\n\t\t}\n\t}\n\n\tevt.value.signals = thread_def->signal_results;\n\n\t/* Clear signal flags as the thread is ready now */\n\tkey = irq_lock();\n\tthread_def->signal_results &= ~(signals);\n\tirq_unlock(key);\n\n\treturn evt;\n}"
}