{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "extension/gawkfts.c",
    "message": "Offset: 2 Size: 1 by call to `fts_stat`.",
    "warning_function_name": "fts_read",
    "warning_line": "p->fts_info = fts_stat(sp, p, 0);",
    "warning_context": "FTSENT *\nfts_read(FTS *sp)\n{\n\tFTSENT *p, *tmp;\n\tint instr;\n\tchar *t;\n\tint saved_errno;\n\n\t_DIAGASSERT(sp != NULL);\n\n\t/* If finished or unrecoverable error, return NULL. */\n\tif (sp->fts_cur == NULL || ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/* Save and zero out user instructions. */\n\tinstr = p->fts_instr;\n\tp->fts_instr = FTS_NOINSTR;\n\n\t/* Any type of file may be re-visited; re-stat and re-turn. */\n\tif (instr == FTS_AGAIN) {\n\t\tp->fts_info = fts_stat(sp, p, 0);\n\t\treturn (p);\n\t}\n\n\t/*\n\t * Following a symlink -- SLNONE test allows application to see\n\t * SLNONE and recover.  If indirecting through a symlink, have\n\t * keep a pointer to current location.  If unable to get that\n\t * pointer, follow fails.\n\t */\n\tif (instr == FTS_FOLLOW &&\n\t    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\tif ((p->fts_symfd = open(\".\", O_RDONLY | O_CLOEXEC, 0))\n\t\t\t    == -1) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t} else\n\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t}\n\t\treturn (p);\n\t}\n\n\t/* Directory in pre-order. */\n\tif (p->fts_info == FTS_D) {\n\t\t/* If skipped or crossed mount point, do post-order visit. */\n\t\tif (instr == FTS_SKIP ||\n\t\t    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {\n\t\t\tif (p->fts_flags & FTS_SYMFOLLOW)\n\t\t\t\t(void)close(p->fts_symfd);\n\t\t\tif (sp->fts_child) {\n\t\t\t\tfts_lfree(sp->fts_child);\n\t\t\t\tsp->fts_child = NULL;\n\t\t\t}\n\t\t\tp->fts_info = FTS_DP;\n\t\t\treturn (p);\n\t\t}\n\n\t\t/* Rebuild if only read the names and now traversing. */\n\t\tif (sp->fts_child && ISSET(FTS_NAMEONLY)) {\n\t\t\tCLR(FTS_NAMEONLY);\n\t\t\tfts_lfree(sp->fts_child);\n\t\t\tsp->fts_child = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */\n\t\tif (sp->fts_child) {\n\t\t\tif (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_flags |= FTS_DONTCHDIR;\n\t\t\t\tfor (p = sp->fts_child; p; p = p->fts_link)\n\t\t\t\t\tp->fts_accpath =\n\t\t\t\t\t    p->fts_parent->fts_accpath;\n\t\t\t}\n\t\t} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n\t\t\tif (ISSET(FTS_STOP))\n\t\t\t\treturn (NULL);\n\t\t\treturn (p);\n\t\t}\n\t\tp = sp->fts_child;\n\t\tsp->fts_child = NULL;\n\t\tgoto name;\n\t}\n\n\t/* Move to the next node on this level. */\nnext:\ttmp = p;\n"
}