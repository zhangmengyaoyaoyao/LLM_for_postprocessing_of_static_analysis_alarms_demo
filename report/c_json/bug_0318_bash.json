{
    "project": "bash",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "lib/readline/complete.c",
    "message": "pointer `username` last assigned on line 2173 could be null and is dereferenced at line 2196, column 28.",
    "warning_function_name": "print_filename",
    "warning_line": "if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))",
    "warning_context": "  match_list[1] = (char *)NULL;\n\n  while (string = (*entry_function) (text, matches))\n    {\n      if (RL_SIG_RECEIVED ())\n\t{\n\t  /* Start at 1 because we don't set matches[0] in this function.\n\t     Only free the list members if we're building match list from\n\t     rl_filename_completion_function, since we know that doesn't\n\t     free the strings it returns. */\n\t  if (entry_function == rl_filename_completion_function)\n\t    {\n\t      for (i = 1; match_list[i]; i++)\n\t\txfree (match_list[i]);\n\t    }\n\t  xfree (match_list);\n\t  match_list = 0;\n\t  match_list_size = 0;\n\t  matches = 0;\n\t  RL_CHECK_SIGNALS ();\n\t}\n\n      if (matches + 1 >= match_list_size)\n\tmatch_list = (char **)xrealloc\n\t  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));\n\n      if (match_list == 0)\n\treturn (match_list);\n\n      match_list[++matches] = string;\n      match_list[matches + 1] = (char *)NULL;\n    }\n\n  /* If there were any matches, then look through them finding out the\n     lowest common denominator.  That then becomes match_list[0]. */\n  if (matches)\n    compute_lcd_of_matches (match_list, matches, text);\n  else\t\t\t\t/* There were no matches. */\n    {\n      xfree (match_list);\n      match_list = (char **)NULL;\n    }\n  return (match_list);\n}\n\n/* A completion function for usernames.\n   TEXT contains a partial username preceded by a random\n   character (usually `~').  */\nchar *\nrl_username_completion_function (text, state)\n     const char *text;\n     int state;\n{\n#if defined (__WIN32__) || defined (__OPENNT)\n  return (char *)NULL;\n#else /* !__WIN32__ && !__OPENNT) */\n  static char *username = (char *)NULL;\n  static struct passwd *entry;\n  static int namelen, first_char, first_char_loc;\n  char *value;\n\n  if (state == 0)\n    {\n      FREE (username);\n\n      first_char = *text;\n      first_char_loc = first_char == '~';\n\n      username = savestring (&text[first_char_loc]);\n      namelen = strlen (username);\n#if defined (HAVE_GETPWENT)\n      setpwent ();\n#endif\n    }\n\n#if defined (HAVE_GETPWENT)\n  while (entry = getpwent ())\n    {\n      /* Null usernames should result in all users as possible completions. */\n      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))\n\tbreak;\n    }\n#endif\n\n  if (entry == 0)\n    {\n#if defined (HAVE_GETPWENT)\n      endpwent ();\n#endif\n      return ((char *)NULL);\n    }\n  else\n    {\n      value = (char *)xmalloc (2 + strlen (entry->pw_name));\n\n      *value = *text;\n\n      strcpy (value + first_char_loc, entry->pw_name);\n\n      if (first_char == '~')\n\trl_filename_completion_desired = 1;\n"
}