{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset: [0, 255] Size: 8 by call to `setbit`.",
    "Code_line": "                  setbit (c2, ccl);",
    "Code_function": "lex (void)\n{\n  int c, c2;\n  bool backslash = false;\n  charclass ccl;\n  int i;\n\n  /* Basic plan: We fetch a character.  If it's a backslash,\n     we set the backslash flag and go through the loop again.\n     On the plus side, this avoids having a duplicate of the\n     main switch inside the backslash case.  On the minus side,\n     it means that just about every case begins with\n     \"if (backslash) ...\".  */\n  for (i = 0; i < 2; ++i)\n    {\n      FETCH_WC (c, wctok, NULL);\n\n      switch (c)\n        {\n        case '\\\\':\n          if (backslash)\n            goto normal_char;\n          if (lexleft == 0)\n            dfaerror (_(\"unfinished \\\\ escape\"));\n          backslash = true;\n          break;\n\n        case '^':\n          if (backslash)\n            goto normal_char;\n          if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || lasttok == END || lasttok == LPAREN || lasttok == OR)\n            return lasttok = BEGLINE;\n          goto normal_char;\n\n        case '$':\n          if (backslash)\n            goto normal_char;\n          if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS\n              || lexleft == 0\n              || (syntax_bits & RE_NO_BK_PARENS\n                  ? lexleft > 0 && *lexptr == ')'\n                  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == ')')\n              || (syntax_bits & RE_NO_BK_VBAR\n                  ? lexleft > 0 && *lexptr == '|'\n                  : lexleft > 1 && lexptr[0] == '\\\\' && lexptr[1] == '|')\n              || ((syntax_bits & RE_NEWLINE_ALT)\n                  && lexleft > 0 && *lexptr == '\\n'))\n            return lasttok = ENDLINE;\n          goto normal_char;\n\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (backslash && !(syntax_bits & RE_NO_BK_REFS))\n            {\n              laststart = false;\n              return lasttok = BACKREF;\n            }\n          goto normal_char;\n\n        case '`':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = BEGLINE; /* FIXME: should be beginning of string */\n          goto normal_char;\n\n        case '\\'':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = ENDLINE;   /* FIXME: should be end of string */\n          goto normal_char;\n\n        case '<':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = BEGWORD;\n          goto normal_char;\n\n        case '>':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = ENDWORD;\n          goto normal_char;\n\n        case 'b':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = LIMWORD;\n          goto normal_char;\n\n        case 'B':\n          if (backslash && !(syntax_bits & RE_NO_GNU_OPS))\n            return lasttok = NOTLIMWORD;\n          goto normal_char;\n\n        case '?':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = QMARK;\n\n        case '*':\n          if (backslash)\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = STAR;\n\n        case '+':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n          return lasttok = PLUS;\n\n        case '{':\n          if (!(syntax_bits & RE_INTERVALS))\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))\n            goto normal_char;\n          if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)\n            goto normal_char;\n\n          /* Cases:\n             {M} - exact count\n             {M,} - minimum count, maximum is infinity\n             {,N} - 0 through N\n             {,} - 0 to infinity (same as '*')\n             {M,N} - M through N */\n          {\n            char const *p = lexptr;\n            char const *lim = p + lexleft;\n            minrep = maxrep = -1;\n            for (; p != lim && ISASCIIDIGIT (*p); p++)\n              {\n                if (minrep < 0)\n                  minrep = *p - '0';\n                else\n                  minrep = MIN (RE_DUP_MAX + 1, minrep * 10 + *p - '0');\n              }\n            if (p != lim)\n              {\n                if (*p != ',')\n                  maxrep = minrep;\n                else\n                  {\n                    if (minrep < 0)\n                      minrep = 0;\n                    while (++p != lim && ISASCIIDIGIT (*p))\n                      {\n                        if (maxrep < 0)\n                          maxrep = *p - '0';\n                        else\n                          maxrep = MIN (RE_DUP_MAX + 1, maxrep * 10 + *p - '0');\n                      }\n                  }\n              }\n            if (! ((! backslash || (p != lim && *p++ == '\\\\'))\n                   && p != lim && *p++ == '}'\n                   && 0 <= minrep && (maxrep < 0 || minrep <= maxrep)))\n              {\n                if (syntax_bits & RE_INVALID_INTERVAL_ORD)\n                  goto normal_char;\n                dfaerror (_(\"invalid content of \\\\{\\\\}\"));\n              }\n            if (RE_DUP_MAX < maxrep)\n              dfaerror (_(\"regular expression too big\"));\n            lexptr = p;\n            lexleft = lim - p;\n          }\n          laststart = false;\n          return lasttok = REPMN;\n\n        case '|':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))\n            goto normal_char;\n          laststart = true;\n          return lasttok = OR;\n\n        case '\\n':\n          if (syntax_bits & RE_LIMITED_OPS\n              || backslash || !(syntax_bits & RE_NEWLINE_ALT))\n            goto normal_char;\n          laststart = true;\n          return lasttok = OR;\n\n        case '(':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          ++parens;\n          laststart = true;\n          return lasttok = LPAREN;\n\n        case ')':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n            goto normal_char;\n          --parens;\n          laststart = false;\n          return lasttok = RPAREN;\n\n        case '.':\n          if (backslash)\n            goto normal_char;\n          if (dfa->multibyte)\n            {\n              /* In multibyte environment period must match with a single\n                 character not a byte.  So we use ANYCHAR.  */\n              laststart = false;\n              return lasttok = ANYCHAR;\n            }\n          zeroset (ccl);\n          notset (ccl);\n          if (!(syntax_bits & RE_DOT_NEWLINE))\n            clrbit (eolbyte, ccl);\n          if (syntax_bits & RE_DOT_NOT_NULL)\n            clrbit ('\\0', ccl);\n          laststart = false;\n          return lasttok = CSET + charclass_index (ccl);\n\n        case 's':\n        case 'S':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          if (!dfa->multibyte)\n            {\n              zeroset (ccl);\n              for (c2 = 0; c2 < NOTCHAR; ++c2)\n                if (isspace (c2))\n                  setbit (c2, ccl);\n              if (c == 'S')\n                notset (ccl);\n              laststart = false;\n              return lasttok = CSET + charclass_index (ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\s and \\S are documented to be equivalent to [[:space:]] and\n             [^[:space:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          PUSH_LEX_STATE (c == 's' ? \"[:space:]]\" : \"^[:space:]]\");\n\n          lasttok = parse_bracket_exp ();\n\n          POP_LEX_STATE ();\n\n          laststart = false;\n          return lasttok;\n\n        case 'w':\n        case 'W':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n\n          if (!dfa->multibyte)\n            {\n              zeroset (ccl);\n              for (c2 = 0; c2 < NOTCHAR; ++c2)\n                if (IS_WORD_CONSTITUENT (c2))\n                  setbit (c2, ccl);\n              if (c == 'W')\n                notset (ccl);\n              laststart = false;\n              return lasttok = CSET + charclass_index (ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\w and \\W are documented to be equivalent to [_[:alnum:]] and\n             [^_[:alnum:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          PUSH_LEX_STATE (c == 'w' ? \"_[:alnum:]]\" : \"^_[:alnum:]]\");\n\n          lasttok = parse_bracket_exp ();\n\n          POP_LEX_STATE ();\n\n          laststart = false;\n          return lasttok;\n\n        case '[':\n          if (backslash)\n            goto normal_char;\n          laststart = false;\n          return lasttok = parse_bracket_exp ();\n\n        default:\n        normal_char:\n          laststart = false;\n          /* For multibyte character sets, folding is done in atom.  Always\n             return WCHAR.  */\n          if (dfa->multibyte)\n            return lasttok = WCHAR;\n\n          if (case_fold && isalpha (c))\n            {\n              zeroset (ccl);\n              setbit_case_fold_c (c, ccl);\n              return lasttok = CSET + charclass_index (ccl);\n            }\n\n          return lasttok = c;\n        }\n    }\n\n  /* The above loop should consume at most a backslash\n     and some other character.  */\n  abort ();\n  return END;                   /* keeps pedantic compilers happy.  */\n}"
}