{
    "Project": "tiff",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [0, 255] Size: [0, +oo] by call to `PickContigCase`.",
    "Code_line": "\t\tif (!PickContigCase(img)) {",
    "Code_function": "TIFFRGBAImageBegin(TIFFRGBAImage* img, TIFF* tif, int stop, char emsg[1024])\n{\n\tuint16* sampleinfo;\n\tuint16 extrasamples;\n\tuint16 planarconfig;\n\tuint16 compress;\n\tint colorchannels;\n\tuint16 *red_orig, *green_orig, *blue_orig;\n\tint n_color;\n\n\t/* Initialize to normal values */\n\timg->row_offset = 0;\n\timg->col_offset = 0;\n\timg->redcmap = NULL;\n\timg->greencmap = NULL;\n\timg->bluecmap = NULL;\n\timg->req_orientation = ORIENTATION_BOTLEFT;     /* It is the default */\n\n\timg->tif = tif;\n\timg->stoponerr = stop;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &img->bitspersample);\n\tswitch (img->bitspersample) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 4:\n\t\tcase 8:\n\t\tcase 16:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle images with %d-bit samples\",\n\t\t\t    img->bitspersample);\n\t\t\treturn (0);\n\t}\n\timg->alpha = 0;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &img->samplesperpixel);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_EXTRASAMPLES,\n\t    &extrasamples, &sampleinfo);\n\tif (extrasamples >= 1)\n\t{\n\t\tswitch (sampleinfo[0]) {\n\t\t\tcase EXTRASAMPLE_UNSPECIFIED:          /* Workaround for some images without */\n\t\t\t\tif (img->samplesperpixel > 3)  /* correct info about alpha channel */\n\t\t\t\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\t\t\tbreak;\n\t\t\tcase EXTRASAMPLE_ASSOCALPHA:           /* data is pre-multiplied */\n\t\t\tcase EXTRASAMPLE_UNASSALPHA:           /* data is not pre-multiplied */\n\t\t\t\timg->alpha = sampleinfo[0];\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef DEFAULT_EXTRASAMPLE_AS_ALPHA\n\tif( !TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric))\n\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\n\tif( extrasamples == 0\n\t    && img->samplesperpixel == 4\n\t    && img->photometric == PHOTOMETRIC_RGB )\n\t{\n\t\timg->alpha = EXTRASAMPLE_ASSOCALPHA;\n\t\textrasamples = 1;\n\t}\n#endif\n\n\tcolorchannels = img->samplesperpixel - extrasamples;\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &compress);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_PLANARCONFIG, &planarconfig);\n\tif (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &img->photometric)) {\n\t\tswitch (colorchannels) {\n\t\t\tcase 1:\n\t\t\t\tif (isCCITTCompression(tif))\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISWHITE;\n\t\t\t\telse\n\t\t\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(emsg, \"Missing needed %s tag\", photoTag);\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\tswitch (img->photometric) {\n\t\tcase PHOTOMETRIC_PALETTE:\n\t\t\tif (!TIFFGetField(tif, TIFFTAG_COLORMAP,\n\t\t\t    &red_orig, &green_orig, &blue_orig)) {\n\t\t\t\tsprintf(emsg, \"Missing required \\\"Colormap\\\" tag\");\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t/* copy the colormaps so we can modify them */\n\t\t\tn_color = (1L << img->bitspersample);\n\t\t\timg->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\timg->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);\n\t\t\tif( !img->redcmap || !img->greencmap || !img->bluecmap ) {\n\t\t\t\tsprintf(emsg, \"Out of memory for colormap copy\");\n\t\t\t\treturn (0);\n\t\t\t}\n\n\t\t\t_TIFFmemcpy( img->redcmap, red_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->greencmap, green_orig, n_color * 2 );\n\t\t\t_TIFFmemcpy( img->bluecmap, blue_orig, n_color * 2 );\n\n\t\t\t/* fall thru... */\n\t\tcase PHOTOMETRIC_MINISWHITE:\n\t\tcase PHOTOMETRIC_MINISBLACK:\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG\n\t\t\t    && img->samplesperpixel != 1\n\t\t\t    && img->bitspersample < 8 ) {\n\t\t\t\tsprintf(emsg,\n\t\t\t\t    \"Sorry, can not handle contiguous data with %s=%d, \"\n\t\t\t\t    \"and %s=%d and Bits/Sample=%d\",\n\t\t\t\t    photoTag, img->photometric,\n\t\t\t\t    \"Samples/pixel\", img->samplesperpixel,\n\t\t\t\t    img->bitspersample);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_YCBCR:\n\t\t\t/* It would probably be nice to have a reality check here. */\n\t\t\tif (planarconfig == PLANARCONFIG_CONTIG)\n\t\t\t\t/* can rely on libjpeg to convert to RGB */\n\t\t\t\t/* XXX should restore current state on exit */\n\t\t\t\tswitch (compress) {\n\t\t\t\t\tcase COMPRESSION_JPEG:\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * TODO: when complete tests verify complete desubsampling\n\t\t\t\t\t\t * and YCbCr handling, remove use of TIFFTAG_JPEGCOLORMODE in\n\t\t\t\t\t\t * favor of tif_getimage.c native handling\n\t\t\t\t\t\t */\n\t\t\t\t\t\tTIFFSetField(tif, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n\t\t\t\t\t\timg->photometric = PHOTOMETRIC_RGB;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* do nothing */;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t/*\n\t\t\t * TODO: if at all meaningful and useful, make more complete\n\t\t\t * support check here, or better still, refactor to let supporting\n\t\t\t * code decide whether there is support and what meaningfull\n\t\t\t * error to return\n\t\t\t */\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_RGB:\n\t\t\tif (colorchannels < 3) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle RGB image with %s=%d\",\n\t\t\t\t    \"Color channels\", colorchannels);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_SEPARATED:\n\t\t\t{\n\t\t\t\tuint16 inkset;\n\t\t\t\tTIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);\n\t\t\t\tif (inkset != INKSET_CMYK) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"InkSet\", inkset);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (img->samplesperpixel < 4) {\n\t\t\t\t\tsprintf(emsg, \"Sorry, can not handle separated image with %s=%d\",\n\t\t\t\t\t    \"Samples/pixel\", img->samplesperpixel);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGL:\n\t\t\tif (compress != COMPRESSION_SGILOG) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogL data must have %s=%d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_MINISBLACK;\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_LOGLUV:\n\t\t\tif (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {\n\t\t\t\tsprintf(emsg, \"Sorry, LogLuv data must have %s=%d or %d\",\n\t\t\t\t    \"Compression\", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (planarconfig != PLANARCONFIG_CONTIG) {\n\t\t\t\tsprintf(emsg, \"Sorry, can not handle LogLuv images with %s=%d\",\n\t\t\t\t    \"Planarconfiguration\", planarconfig);\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tTIFFSetField(tif, TIFFTAG_SGILOGDATAFMT, SGILOGDATAFMT_8BIT);\n\t\t\timg->photometric = PHOTOMETRIC_RGB;\t\t/* little white lie */\n\t\t\timg->bitspersample = 8;\n\t\t\tbreak;\n\t\tcase PHOTOMETRIC_CIELAB:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(emsg, \"Sorry, can not handle image with %s=%d\",\n\t\t\t    photoTag, img->photometric);\n\t\t\treturn (0);\n\t}\n\timg->Map = NULL;\n\timg->BWmap = NULL;\n\timg->PALmap = NULL;\n\timg->ycbcr = NULL;\n\timg->cielab = NULL;\n\tTIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &img->width);\n\tTIFFGetField(tif, TIFFTAG_IMAGELENGTH, &img->height);\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_ORIENTATION, &img->orientation);\n\timg->isContig =\n\t    !(planarconfig == PLANARCONFIG_SEPARATE && colorchannels > 1);\n\tif (img->isContig) {\n\t\tif (!PickContigCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (!PickSeparateCase(img)) {\n\t\t\tsprintf(emsg, \"Sorry, can not handle image\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
}