{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-20, 219] (â‡ [-108, 131] + 88) Size: 4064 by call to `bfd_zalloc`.",
    "Code_line": "\t\t  stab->used_by_bfd = bfd_zalloc (abfd, amt);",
    "Code_function": "coff_link_add_symbols (bfd *abfd,\n\t\t       struct bfd_link_info *info)\n{\n  unsigned int n_tmask = coff_data (abfd)->local_n_tmask;\n  unsigned int n_btshft = coff_data (abfd)->local_n_btshft;\n  unsigned int n_btmask = coff_data (abfd)->local_n_btmask;\n  bfd_boolean keep_syms;\n  bfd_boolean default_copy;\n  bfd_size_type symcount;\n  struct coff_link_hash_entry **sym_hash;\n  bfd_size_type symesz;\n  bfd_byte *esym;\n  bfd_byte *esym_end;\n  bfd_size_type amt;\n\n  symcount = obj_raw_syment_count (abfd);\n\n  if (symcount == 0)\n    return TRUE;\t\t/* Nothing to do.  */\n\n  /* Keep the symbols during this function, in case the linker needs\n     to read the generic symbols in order to report an error message.  */\n  keep_syms = obj_coff_keep_syms (abfd);\n  obj_coff_keep_syms (abfd) = TRUE;\n\n  if (info->keep_memory)\n    default_copy = FALSE;\n  else\n    default_copy = TRUE;\n\n  /* We keep a list of the linker hash table entries that correspond\n     to particular symbols.  */\n  amt = symcount * sizeof (struct coff_link_hash_entry *);\n  sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);\n  if (sym_hash == NULL)\n    goto error_return;\n  obj_coff_sym_hashes (abfd) = sym_hash;\n\n  symesz = bfd_coff_symesz (abfd);\n  BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));\n  esym = (bfd_byte *) obj_coff_external_syms (abfd);\n  esym_end = esym + symcount * symesz;\n  while (esym < esym_end)\n    {\n      struct internal_syment sym;\n      enum coff_symbol_classification classification;\n      bfd_boolean copy;\n\n      bfd_coff_swap_sym_in (abfd, esym, &sym);\n\n      classification = bfd_coff_classify_symbol (abfd, &sym);\n      if (classification != COFF_SYMBOL_LOCAL)\n\t{\n\t  const char *name;\n\t  char buf[SYMNMLEN + 1];\n\t  flagword flags;\n\t  asection *section;\n\t  bfd_vma value;\n\t  bfd_boolean addit;\n\n\t  /* This symbol is externally visible.  */\n\n\t  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);\n\t  if (name == NULL)\n\t    goto error_return;\n\n\t  /* We must copy the name into memory if we got it from the\n             syment itself, rather than the string table.  */\n\t  copy = default_copy;\n\t  if (sym._n._n_n._n_zeroes != 0\n\t      || sym._n._n_n._n_offset == 0)\n\t    copy = TRUE;\n\n\t  value = sym.n_value;\n\n\t  switch (classification)\n\t    {\n\t    default:\n\t      abort ();\n\n\t    case COFF_SYMBOL_GLOBAL:\n\t      flags = BSF_EXPORT | BSF_GLOBAL;\n\t      section = coff_section_from_bfd_index (abfd, sym.n_scnum);\n\t      if (! obj_pe (abfd))\n\t\tvalue -= section->vma;\n\t      break;\n\n\t    case COFF_SYMBOL_UNDEFINED:\n\t      flags = 0;\n\t      section = bfd_und_section_ptr;\n\t      break;\n\n\t    case COFF_SYMBOL_COMMON:\n\t      flags = BSF_GLOBAL;\n\t      section = bfd_com_section_ptr;\n\t      break;\n\n\t    case COFF_SYMBOL_PE_SECTION:\n\t      flags = BSF_SECTION_SYM | BSF_GLOBAL;\n\t      section = coff_section_from_bfd_index (abfd, sym.n_scnum);\n\t      break;\n\t    }\n\n\t  if (IS_WEAK_EXTERNAL (abfd, sym))\n\t    flags = BSF_WEAK;\n\n\t  addit = TRUE;\n\n\t  /* In the PE format, section symbols actually refer to the\n             start of the output section.  We handle them specially\n             here.  */\n\t  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)\n\t    {\n\t      *sym_hash = coff_link_hash_lookup (coff_hash_table (info),\n\t\t\t\t\t\t name, FALSE, copy, FALSE);\n\t      if (*sym_hash != NULL)\n\t\t{\n\t\t  if (((*sym_hash)->coff_link_hash_flags\n\t\t       & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0\n\t\t      && (*sym_hash)->root.type != bfd_link_hash_undefined\n\t\t      && (*sym_hash)->root.type != bfd_link_hash_undefweak)\n\t\t    (*_bfd_error_handler)\n\t\t      (\"Warning: symbol `%s' is both section and non-section\",\n\t\t       name);\n\n\t\t  addit = FALSE;\n\t\t}\n\t    }\n\n\t  /* The Microsoft Visual C compiler does string pooling by\n\t     hashing the constants to an internal symbol name, and\n\t     relying on the linker comdat support to discard\n\t     duplicate names.  However, if one string is a literal and\n\t     one is a data initializer, one will end up in the .data\n\t     section and one will end up in the .rdata section.  The\n\t     Microsoft linker will combine them into the .data\n\t     section, which seems to be wrong since it might cause the\n\t     literal to change.\n\n\t     As long as there are no external references to the\n\t     symbols, which there shouldn't be, we can treat the .data\n\t     and .rdata instances as separate symbols.  The comdat\n\t     code in the linker will do the appropriate merging.  Here\n\t     we avoid getting a multiple definition error for one of\n\t     these special symbols.\n\n\t     FIXME: I don't think this will work in the case where\n\t     there are two object files which use the constants as a\n\t     literal and two object files which use it as a data\n\t     initializer.  One or the other of the second object files\n\t     is going to wind up with an inappropriate reference.  */\n\t  if (obj_pe (abfd)\n\t      && (classification == COFF_SYMBOL_GLOBAL\n\t\t  || classification == COFF_SYMBOL_PE_SECTION)\n\t      && coff_section_data (abfd, section) != NULL\n\t      && coff_section_data (abfd, section)->comdat != NULL\n\t      && CONST_STRNEQ (name, \"??_\")\n\t      && strcmp (name, coff_section_data (abfd, section)->comdat->name) == 0)\n\t    {\n\t      if (*sym_hash == NULL)\n\t\t*sym_hash = coff_link_hash_lookup (coff_hash_table (info),\n\t\t\t\t\t\t   name, FALSE, copy, FALSE);\n\t      if (*sym_hash != NULL\n\t\t  && (*sym_hash)->root.type == bfd_link_hash_defined\n\t\t  && coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat != NULL\n\t\t  && strcmp (coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat->name,\n\t\t\t     coff_section_data (abfd, section)->comdat->name) == 0)\n\t\taddit = FALSE;\n\t    }\n\n\t  if (addit)\n\t    {\n\t      if (! (bfd_coff_link_add_one_symbol\n\t\t     (info, abfd, name, flags, section, value,\n\t\t      (const char *) NULL, copy, FALSE,\n\t\t      (struct bfd_link_hash_entry **) sym_hash)))\n\t\tgoto error_return;\n\t    }\n\n\t  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)\n\t    (*sym_hash)->coff_link_hash_flags |=\n\t      COFF_LINK_HASH_PE_SECTION_SYMBOL;\n\n\t  /* Limit the alignment of a common symbol to the possible\n             alignment of a section.  There is no point to permitting\n             a higher alignment for a common symbol: we can not\n             guarantee it, and it may cause us to allocate extra space\n             in the common section.  */\n\t  if (section == bfd_com_section_ptr\n\t      && (*sym_hash)->root.type == bfd_link_hash_common\n\t      && ((*sym_hash)->root.u.c.p->alignment_power\n\t\t  > bfd_coff_default_section_alignment_power (abfd)))\n\t    (*sym_hash)->root.u.c.p->alignment_power\n\t      = bfd_coff_default_section_alignment_power (abfd);\n\n\t  if (bfd_get_flavour (info->output_bfd) == bfd_get_flavour (abfd))\n\t    {\n\t      /* If we don't have any symbol information currently in\n                 the hash table, or if we are looking at a symbol\n                 definition, then update the symbol class and type in\n                 the hash table.  */\n  \t      if (((*sym_hash)->symbol_class == C_NULL\n  \t\t   && (*sym_hash)->type == T_NULL)\n  \t\t  || sym.n_scnum != 0\n  \t\t  || (sym.n_value != 0\n  \t\t      && (*sym_hash)->root.type != bfd_link_hash_defined\n  \t\t      && (*sym_hash)->root.type != bfd_link_hash_defweak))\n  \t\t{\n  \t\t  (*sym_hash)->symbol_class = sym.n_sclass;\n  \t\t  if (sym.n_type != T_NULL)\n  \t\t    {\n  \t\t      /* We want to warn if the type changed, but not\n  \t\t\t if it changed from an unspecified type.\n  \t\t\t Testing the whole type byte may work, but the\n  \t\t\t change from (e.g.) a function of unspecified\n  \t\t\t type to function of known type also wants to\n  \t\t\t skip the warning.  */\n  \t\t      if ((*sym_hash)->type != T_NULL\n  \t\t\t  && (*sym_hash)->type != sym.n_type\n  \t\t          && !(DTYPE ((*sym_hash)->type) == DTYPE (sym.n_type)\n  \t\t               && (BTYPE ((*sym_hash)->type) == T_NULL\n  \t\t                   || BTYPE (sym.n_type) == T_NULL)))\n  \t\t\t(*_bfd_error_handler)\n  \t\t\t  (_(\"Warning: type of symbol `%s' changed from %d to %d in %B\"),\n  \t\t\t   abfd, name, (*sym_hash)->type, sym.n_type);\n\n  \t\t      /* We don't want to change from a meaningful\n  \t\t\t base type to a null one, but if we know\n  \t\t\t nothing, take what little we might now know.  */\n  \t\t      if (BTYPE (sym.n_type) != T_NULL\n  \t\t\t  || (*sym_hash)->type == T_NULL)\n\t\t\t(*sym_hash)->type = sym.n_type;\n  \t\t    }\n  \t\t  (*sym_hash)->auxbfd = abfd;\n\t\t  if (sym.n_numaux != 0)\n\t\t    {\n\t\t      union internal_auxent *alloc;\n\t\t      unsigned int i;\n\t\t      bfd_byte *eaux;\n\t\t      union internal_auxent *iaux;\n\n\t\t      (*sym_hash)->numaux = sym.n_numaux;\n\t\t      alloc = ((union internal_auxent *)\n\t\t\t       bfd_hash_allocate (&info->hash->table,\n\t\t\t\t\t\t  (sym.n_numaux\n\t\t\t\t\t\t   * sizeof (*alloc))));\n\t\t      if (alloc == NULL)\n\t\t\tgoto error_return;\n\t\t      for (i = 0, eaux = esym + symesz, iaux = alloc;\n\t\t\t   i < sym.n_numaux;\n\t\t\t   i++, eaux += symesz, iaux++)\n\t\t\tbfd_coff_swap_aux_in (abfd, eaux, sym.n_type,\n\t\t\t\t\t      sym.n_sclass, (int) i,\n\t\t\t\t\t      sym.n_numaux, iaux);\n\t\t      (*sym_hash)->aux = alloc;\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (classification == COFF_SYMBOL_PE_SECTION\n\t      && (*sym_hash)->numaux != 0)\n\t    {\n\t      /* Some PE sections (such as .bss) have a zero size in\n                 the section header, but a non-zero size in the AUX\n                 record.  Correct that here.\n\n\t\t FIXME: This is not at all the right place to do this.\n\t\t For example, it won't help objdump.  This needs to be\n\t\t done when we swap in the section header.  */\n\t      BFD_ASSERT ((*sym_hash)->numaux == 1);\n\t      if (section->size == 0)\n\t\tsection->size = (*sym_hash)->aux[0].x_scn.x_scnlen;\n\n\t      /* FIXME: We could test whether the section sizes\n                 matches the size in the aux entry, but apparently\n                 that sometimes fails unexpectedly.  */\n\t    }\n\t}\n\n      esym += (sym.n_numaux + 1) * symesz;\n      sym_hash += sym.n_numaux + 1;\n    }\n\n  /* If this is a non-traditional, non-relocatable link, try to\n     optimize the handling of any .stab/.stabstr sections.  */\n  if (! info->relocatable\n      && ! info->traditional_format\n      && bfd_get_flavour (info->output_bfd) == bfd_get_flavour (abfd)\n      && (info->strip != strip_all && info->strip != strip_debugger))\n    {\n      asection *stabstr;\n\n      stabstr = bfd_get_section_by_name (abfd, \".stabstr\");\n\n      if (stabstr != NULL)\n\t{\n\t  bfd_size_type string_offset = 0;\n\t  asection *stab;\n\n\t  for (stab = abfd->sections; stab; stab = stab->next)\n\t    if (CONST_STRNEQ (stab->name, \".stab\")\n\t\t&& (!stab->name[5]\n\t\t    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))\n\t    {\n\t      struct coff_link_hash_table *table;\n\t      struct coff_section_tdata *secdata\n\t\t= coff_section_data (abfd, stab);\n\n\t      if (secdata == NULL)\n\t\t{\n\t\t  amt = sizeof (struct coff_section_tdata);\n\t\t  stab->used_by_bfd = bfd_zalloc (abfd, amt);\n\t\t  if (stab->used_by_bfd == NULL)\n\t\t    goto error_return;\n\t\t  secdata = coff_section_data (abfd, stab);\n\t\t}\n\n\t      table = coff_hash_table (info);\n\n\t      if (! _bfd_link_section_stabs (abfd, &table->stab_info,\n\t\t\t\t\t     stab, stabstr,\n\t\t\t\t\t     &secdata->stab_info,\n\t\t\t\t\t     &string_offset))\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  obj_coff_keep_syms (abfd) = keep_syms;\n\n  return TRUE;\n\n error_return:\n  obj_coff_keep_syms (abfd) = keep_syms;\n  return FALSE;\n}"
}