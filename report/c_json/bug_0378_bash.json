{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "param_expand",
    "warning_line": "SCOPY_CHAR_I (twochars, '\\\\', c, string, sindex, string_size);",
    "warning_context": "\t  goto add_string;\n\t  break;\n\n\tcase '`':\t\t/* Backquoted command substitution. */\n\t  {\n\t    t_index = sindex++;\n\n\t    temp = string_extract (string, &sindex, \"`\", SX_REQMATCH);\n\t    /* The test of sindex against t_index is to allow bare instances of\n\t       ` to pass through, for backwards compatibility. */\n\t    if (temp == &extract_string_error || temp == &extract_string_fatal)\n\t      {\n\t\tif (sindex - 1 == t_index)\n\t\t  {\n\t\t    sindex = t_index;\n\t\t    goto add_character;\n\t\t  }\n\t\tlast_command_exit_value = EXECUTION_FAILURE;\n\t\treport_error (_(\"bad substitution: no closing \\\"`\\\" in %s\") , string+t_index);\n\t\tfree (string);\n\t\tfree (istring);\n\t\treturn ((temp == &extract_string_error) ? &expand_word_error\n\t\t\t\t\t\t\t: &expand_word_fatal);\n\t      }\n\t\t\n\t    if (expanded_something)\n\t      *expanded_something = 1;\n\n\t    if (word->flags & W_NOCOMSUB)\n\t      /* sindex + 1 because string[sindex] == '`' */\n\t      temp1 = substring (string, t_index, sindex + 1);\n\t    else\n\t      {\n\t\tde_backslash (temp);\n\t\ttword = command_substitute (temp, quoted);\n\t\ttemp1 = tword ? tword->word : (char *)NULL;\n\t\tif (tword)\n\t\t  dispose_word_desc (tword);\n\t      }\n\t    FREE (temp);\n\t    temp = temp1;\n\t    goto dollar_add_string;\n\t  }\n\n\tcase '\\\\':\n\t  if (string[sindex + 1] == '\\n')\n\t    {\n\t      sindex += 2;\n\t      continue;\n\t    }\n\n\t  c = string[++sindex];\n\n\t  if (quoted & Q_HERE_DOCUMENT)\n\t    tflag = CBSHDOC;\n\t  else if (quoted & Q_DOUBLE_QUOTES)\n\t    tflag = CBSDQUOTE;\n\t  else\n\t    tflag = 0;\n\n\t  /* From Posix discussion on austin-group list:  Backslash escaping\n\t     a } in ${...} is removed.  Issue 0000221 */\n\t  if ((quoted & Q_DOLBRACE) && c == RBRACE)\n\t    {\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\t  /* This is the fix for \" $@\\ \" */\n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0) && isexp == 0 && isifs (c))\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t      DEFAULT_ARRAY_SIZE);\n\t      istring[istring_index++] = CTLESC;\n\t      istring[istring_index++] = '\\\\';\n\t      istring[istring_index] = '\\0';\n\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))\n\t    {\n\t      SCOPY_CHAR_I (twochars, '\\\\', c, string, sindex, string_size);\n\t    }\n\t  else if (c == 0)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\t\t/* add_character: label increments sindex */\n\t      goto add_character;\n\t    }\n\t  else\n\t    {\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\n\t  sindex++;\nadd_twochars:\n\t  /* BEFORE jumping here, we need to increment sindex if appropriate */\n\t  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t  DEFAULT_ARRAY_SIZE);\n\t  istring[istring_index++] = twochars[0];\n\t  istring[istring_index++] = twochars[1];\n\t  istring[istring_index] = '\\0';\n\n"
}