{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `s` last assigned on line 6406 could be null and is dereferenced at line 6408, column 7.",
    "Code_line": "      s->size = dynsymcount * bed->s->sizeof_sym;",
    "Code_function": "bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)\n{\n  const struct elf_backend_data *bed;\n\n  if (!is_elf_hash_table (info->hash))\n    return TRUE;\n\n  bed = get_elf_backend_data (output_bfd);\n  (*bed->elf_backend_init_index_section) (output_bfd, info);\n\n  if (elf_hash_table (info)->dynamic_sections_created)\n    {\n      bfd *dynobj;\n      asection *s;\n      bfd_size_type dynsymcount;\n      unsigned long section_sym_count;\n      unsigned int dtagcount;\n\n      dynobj = elf_hash_table (info)->dynobj;\n\n      /* Assign dynsym indicies.  In a shared library we generate a\n\t section symbol for each output section, which come first.\n\t Next come all of the back-end allocated local dynamic syms,\n\t followed by the rest of the global symbols.  */\n\n      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,\n\t\t\t\t\t\t    &section_sym_count);\n\n      /* Work out the size of the symbol version section.  */\n      s = bfd_get_linker_section (dynobj, \".gnu.version\");\n      BFD_ASSERT (s != NULL);\n      if (dynsymcount != 0\n\t  && (s->flags & SEC_EXCLUDE) == 0)\n\t{\n\t  s->size = dynsymcount * sizeof (Elf_External_Versym);\n\t  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);\n\t  if (s->contents == NULL)\n\t    return FALSE;\n\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_VERSYM, 0))\n\t    return FALSE;\n\t}\n\n      /* Set the size of the .dynsym and .hash sections.  We counted\n\t the number of dynamic symbols in elf_link_add_object_symbols.\n\t We will build the contents of .dynsym and .hash when we build\n\t the final symbol table, because until then we do not know the\n\t correct value to give the symbols.  We built the .dynstr\n\t section as we went along in elf_link_add_object_symbols.  */\n      s = bfd_get_linker_section (dynobj, \".dynsym\");\n      BFD_ASSERT (s != NULL);\n      s->size = dynsymcount * bed->s->sizeof_sym;\n\n      if (dynsymcount != 0)\n\t{\n\t  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);\n\t  if (s->contents == NULL)\n\t    return FALSE;\n\n\t  /* The first entry in .dynsym is a dummy symbol.\n\t     Clear all the section syms, in case we don't output them all.  */\n\t  ++section_sym_count;\n\t  memset (s->contents, 0, section_sym_count * bed->s->sizeof_sym);\n\t}\n\n      elf_hash_table (info)->bucketcount = 0;\n\n      /* Compute the size of the hashing table.  As a side effect this\n\t computes the hash values for all the names we export.  */\n      if (info->emit_hash)\n\t{\n\t  unsigned long int *hashcodes;\n\t  struct hash_codes_info hashinf;\n\t  bfd_size_type amt;\n\t  unsigned long int nsyms;\n\t  size_t bucketcount;\n\t  size_t hash_entry_size;\n\n\t  /* Compute the hash values for all exported symbols.  At the same\n\t     time store the values in an array so that we could use them for\n\t     optimizations.  */\n\t  amt = dynsymcount * sizeof (unsigned long int);\n\t  hashcodes = (unsigned long int *) bfd_malloc (amt);\n\t  if (hashcodes == NULL)\n\t    return FALSE;\n\t  hashinf.hashcodes = hashcodes;\n\t  hashinf.error = FALSE;\n\n\t  /* Put all hash values in HASHCODES.  */\n\t  elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t  elf_collect_hash_codes, &hashinf);\n\t  if (hashinf.error)\n\t    {\n\t      free (hashcodes);\n\t      return FALSE;\n\t    }\n\n\t  nsyms = hashinf.hashcodes - hashcodes;\n\t  bucketcount\n\t    = compute_bucket_count (info, hashcodes, nsyms, 0);\n\t  free (hashcodes);\n\n\t  if (bucketcount == 0)\n\t    return FALSE;\n\n\t  elf_hash_table (info)->bucketcount = bucketcount;\n\n\t  s = bfd_get_linker_section (dynobj, \".hash\");\n\t  BFD_ASSERT (s != NULL);\n\t  hash_entry_size = elf_section_data (s)->this_hdr.sh_entsize;\n\t  s->size = ((2 + bucketcount + dynsymcount) * hash_entry_size);\n\t  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);\n\t  if (s->contents == NULL)\n\t    return FALSE;\n\n\t  bfd_put (8 * hash_entry_size, output_bfd, bucketcount, s->contents);\n\t  bfd_put (8 * hash_entry_size, output_bfd, dynsymcount,\n\t\t   s->contents + hash_entry_size);\n\t}\n\n      if (info->emit_gnu_hash)\n\t{\n\t  size_t i, cnt;\n\t  unsigned char *contents;\n\t  struct collect_gnu_hash_codes cinfo;\n\t  bfd_size_type amt;\n\t  size_t bucketcount;\n\n\t  memset (&cinfo, 0, sizeof (cinfo));\n\n\t  /* Compute the hash values for all exported symbols.  At the same\n\t     time store the values in an array so that we could use them for\n\t     optimizations.  */\n\t  amt = dynsymcount * 2 * sizeof (unsigned long int);\n\t  cinfo.hashcodes = (long unsigned int *) bfd_malloc (amt);\n\t  if (cinfo.hashcodes == NULL)\n\t    return FALSE;\n\n\t  cinfo.hashval = cinfo.hashcodes + dynsymcount;\n\t  cinfo.min_dynindx = -1;\n\t  cinfo.output_bfd = output_bfd;\n\t  cinfo.bed = bed;\n\n\t  /* Put all hash values in HASHCODES.  */\n\t  elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t  elf_collect_gnu_hash_codes, &cinfo);\n\t  if (cinfo.error)\n\t    {\n\t      free (cinfo.hashcodes);\n\t      return FALSE;\n\t    }\n\n\t  bucketcount\n\t    = compute_bucket_count (info, cinfo.hashcodes, cinfo.nsyms, 1);\n\n\t  if (bucketcount == 0)\n\t    {\n\t      free (cinfo.hashcodes);\n\t      return FALSE;\n\t    }\n\n\t  s = bfd_get_linker_section (dynobj, \".gnu.hash\");\n\t  BFD_ASSERT (s != NULL);\n\n\t  if (cinfo.nsyms == 0)\n\t    {\n\t      /* Empty .gnu.hash section is special.  */\n\t      BFD_ASSERT (cinfo.min_dynindx == -1);\n\t      free (cinfo.hashcodes);\n\t      s->size = 5 * 4 + bed->s->arch_size / 8;\n\t      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);\n\t      if (contents == NULL)\n\t\treturn FALSE;\n\t      s->contents = contents;\n\t      /* 1 empty bucket.  */\n\t      bfd_put_32 (output_bfd, 1, contents);\n\t      /* SYMIDX above the special symbol 0.  */\n\t      bfd_put_32 (output_bfd, 1, contents + 4);\n\t      /* Just one word for bitmask.  */\n\t      bfd_put_32 (output_bfd, 1, contents + 8);\n\t      /* Only hash fn bloom filter.  */\n\t      bfd_put_32 (output_bfd, 0, contents + 12);\n\t      /* No hashes are valid - empty bitmask.  */\n\t      bfd_put (bed->s->arch_size, output_bfd, 0, contents + 16);\n\t      /* No hashes in the only bucket.  */\n\t      bfd_put_32 (output_bfd, 0,\n\t\t\t  contents + 16 + bed->s->arch_size / 8);\n\t    }\n\t  else\n\t    {\n\t      unsigned long int maskwords, maskbitslog2, x;\n\t      BFD_ASSERT (cinfo.min_dynindx != -1);\n\n\t      x = cinfo.nsyms;\n\t      maskbitslog2 = 1;\n\t      while ((x >>= 1) != 0)\n\t\t++maskbitslog2;\n\t      if (maskbitslog2 < 3)\n\t\tmaskbitslog2 = 5;\n\t      else if ((1 << (maskbitslog2 - 2)) & cinfo.nsyms)\n\t\tmaskbitslog2 = maskbitslog2 + 3;\n\t      else\n\t\tmaskbitslog2 = maskbitslog2 + 2;\n\t      if (bed->s->arch_size == 64)\n\t\t{\n\t\t  if (maskbitslog2 == 5)\n\t\t    maskbitslog2 = 6;\n\t\t  cinfo.shift1 = 6;\n\t\t}\n\t      else\n\t\tcinfo.shift1 = 5;\n\t      cinfo.mask = (1 << cinfo.shift1) - 1;\n\t      cinfo.shift2 = maskbitslog2;\n\t      cinfo.maskbits = 1 << maskbitslog2;\n\t      maskwords = 1 << (maskbitslog2 - cinfo.shift1);\n\t      amt = bucketcount * sizeof (unsigned long int) * 2;\n\t      amt += maskwords * sizeof (bfd_vma);\n\t      cinfo.bitmask = (bfd_vma *) bfd_malloc (amt);\n\t      if (cinfo.bitmask == NULL)\n\t\t{\n\t\t  free (cinfo.hashcodes);\n\t\t  return FALSE;\n\t\t}\n\n\t      cinfo.counts = (long unsigned int *) (cinfo.bitmask + maskwords);\n\t      cinfo.indx = cinfo.counts + bucketcount;\n\t      cinfo.symindx = dynsymcount - cinfo.nsyms;\n\t      memset (cinfo.bitmask, 0, maskwords * sizeof (bfd_vma));\n\n\t      /* Determine how often each hash bucket is used.  */\n\t      memset (cinfo.counts, 0, bucketcount * sizeof (cinfo.counts[0]));\n\t      for (i = 0; i < cinfo.nsyms; ++i)\n\t\t++cinfo.counts[cinfo.hashcodes[i] % bucketcount];\n\n\t      for (i = 0, cnt = cinfo.symindx; i < bucketcount; ++i)\n\t\tif (cinfo.counts[i] != 0)\n\t\t  {\n\t\t    cinfo.indx[i] = cnt;\n\t\t    cnt += cinfo.counts[i];\n\t\t  }\n\t      BFD_ASSERT (cnt == dynsymcount);\n\t      cinfo.bucketcount = bucketcount;\n\t      cinfo.local_indx = cinfo.min_dynindx;\n\n\t      s->size = (4 + bucketcount + cinfo.nsyms) * 4;\n\t      s->size += cinfo.maskbits / 8;\n\t      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);\n\t      if (contents == NULL)\n\t\t{\n\t\t  free (cinfo.bitmask);\n\t\t  free (cinfo.hashcodes);\n\t\t  return FALSE;\n\t\t}\n\n\t      s->contents = contents;\n\t      bfd_put_32 (output_bfd, bucketcount, contents);\n\t      bfd_put_32 (output_bfd, cinfo.symindx, contents + 4);\n\t      bfd_put_32 (output_bfd, maskwords, contents + 8);\n\t      bfd_put_32 (output_bfd, cinfo.shift2, contents + 12);\n\t      contents += 16 + cinfo.maskbits / 8;\n\n\t      for (i = 0; i < bucketcount; ++i)\n\t\t{\n\t\t  if (cinfo.counts[i] == 0)\n\t\t    bfd_put_32 (output_bfd, 0, contents);\n\t\t  else\n\t\t    bfd_put_32 (output_bfd, cinfo.indx[i], contents);\n\t\t  contents += 4;\n\t\t}\n\n\t      cinfo.contents = contents;\n\n\t      /* Renumber dynamic symbols, populate .gnu.hash section.  */\n\t      elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t      elf_renumber_gnu_hash_syms, &cinfo);\n\n\t      contents = s->contents + 16;\n\t      for (i = 0; i < maskwords; ++i)\n\t\t{\n\t\t  bfd_put (bed->s->arch_size, output_bfd, cinfo.bitmask[i],\n\t\t\t   contents);\n\t\t  contents += bed->s->arch_size / 8;\n\t\t}\n\n\t      free (cinfo.bitmask);\n\t      free (cinfo.hashcodes);\n\t    }\n\t}\n\n      s = bfd_get_linker_section (dynobj, \".dynstr\");\n      BFD_ASSERT (s != NULL);\n\n      elf_finalize_dynstr (output_bfd, info);\n\n      s->size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);\n\n      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)\n\tif (!_bfd_elf_add_dynamic_entry (info, DT_NULL, 0))\n\t  return FALSE;\n    }\n\n  return TRUE;\n}"
}