{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Code_line": "\t\t\t\t\t*dest++ = '\\\\';",
    "Code_function": "make_regexp(const char *s, size_t len, bool ignorecase, bool dfa, bool canfatal)\n{\n\tstatic char metas[] = \".*+(){}[]|?^$\\\\\";\n\tRegexp *rp;\n\tconst char *rerr;\n\tconst char *src = s;\n\tstatic char *buf = NULL;\n\tstatic size_t buflen;\n\tconst char *end = s + len;\n\tchar *dest;\n\tint c, c2;\n\tstatic bool first = true;\n\tstatic bool no_dfa = false;\n\tbool has_anchor = false;\n\treg_syntax_t dfa_syn;\n\tint i;\n\n\t/*\n\t * The number of bytes in the current multibyte character.\n\t * It is 0, when the current character is a singlebyte character.\n\t */\n\tsize_t is_multibyte = 0;\n\tmbstate_t mbs;\n\n\tmemset(&mbs, 0, sizeof(mbstate_t)); /* Initialize.  */\n\n\tif (first) {\n\t\tfirst = false;\n\t\t/* for debugging and testing */\n\t\tno_dfa = (getenv(\"GAWK_NO_DFA\") != NULL);\n\t}\n\n\t/* always check */\n\tcheck_bracket_exp((char *) s, len);\n\n\t/* Handle escaped characters first. */\n\n\t/*\n\t * Build a copy of the string (in buf) with the\n\t * escaped characters translated, and generate the regex\n\t * from that.\n\t */\n\tif (buf == NULL) {\n\t\temalloc(buf, char *, len + 2, \"make_regexp\");\n\t\tbuflen = len;\n\t} else if (len > buflen) {\n\t\terealloc(buf, char *, len + 2, \"make_regexp\");\n\t\tbuflen = len;\n\t}\n\tdest = buf;\n\n\twhile (src < end) {\n\t\tif (gawk_mb_cur_max > 1 && ! is_multibyte) {\n\t\t\t/* The previous byte is a singlebyte character, or last byte\n\t\t\t   of a multibyte character.  We check the next character.  */\n\t\t\tis_multibyte = mbrlen(src, end - src, &mbs);\n\t\t\tif (   is_multibyte == 1\n\t\t\t    || is_multibyte == (size_t) -1\n\t\t\t    || is_multibyte == (size_t) -2\n\t\t\t    || is_multibyte == 0) {\n\t\t\t\t/* We treat it as a single-byte character.  */\n\t\t\t\tis_multibyte = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* We skip multibyte character, since it must not be a special\n\t\t   character.  */\n\t\tif ((gawk_mb_cur_max == 1 || ! is_multibyte) &&\n\t\t    (*src == '\\\\')) {\n\t\t\tc = *++src;\n\t\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\tcase 'b':\n\t\t\tcase 'f':\n\t\t\tcase 'n':\n\t\t\tcase 'r':\n\t\t\tcase 't':\n\t\t\tcase 'v':\n\t\t\tcase 'x':\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tc2 = parse_escape(&src);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tcant_happen();\n\t\t\t\t/*\n\t\t\t\t * Unix awk treats octal (and hex?) chars\n\t\t\t\t * literally in re's, so escape regexp\n\t\t\t\t * metacharacters.\n\t\t\t\t */\n\t\t\t\tif (do_traditional\n\t\t\t\t    && ! do_posix\n\t\t\t\t    && (isdigit(c) || c == 'x')\n\t\t\t\t    && strchr(\"()|*+?.^$\\\\[]\", c2) != NULL)\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c2;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\tcase '9':\t/* a\\9b not valid */\n\t\t\t\t*dest++ = c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\tcase 'y':\t/* normally \\b */\n\t\t\t\t/* gnu regex op */\n\t\t\t\tif (! do_traditional) {\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t\t*dest++ = 'b';\n\t\t\t\t\tsrc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else, fall through */\n\t\t\tdefault:\n\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\t} /* switch */\n\t\t} else {\n\t\t\tc = *src;\n\t\t\tif (c == '^' || c == '$')\n\t\t\t\thas_anchor = true;\n\n\t\t\t*dest++ = *src++;\t/* not '\\\\' */\n\t\t}\n\t\tif (gawk_mb_cur_max > 1 && is_multibyte)\n\t\t\tis_multibyte--;\n\t} /* while */\n\n\t*dest = '\\0';\n\tlen = dest - buf;\n\n\temalloc(rp, Regexp *, sizeof(*rp), \"make_regexp\");\n\tmemset((char *) rp, 0, sizeof(*rp));\n\trp->dfareg = NULL;\n\trp->pat.allocated = 0;\t/* regex will allocate the buffer */\n\temalloc(rp->pat.fastmap, char *, 256, \"make_regexp\");\n\n\t/*\n\t * Lo these many years ago, had I known what a P.I.T.A. IGNORECASE\n\t * was going to turn out to be, I wouldn't have bothered with it.\n\t *\n\t * In the case where we have a multibyte character set, we have no\n\t * choice but to use RE_ICASE, since the casetable is for single-byte\n\t * character sets only.\n\t *\n\t * On the other hand, if we do have a single-byte character set,\n\t * using the casetable should give  a performance improvement, since\n\t * it's computed only once, not each time a regex is compiled.  We\n\t * also think it's probably better for portability.  See the\n\t * discussion by the definition of casetable[] in eval.c.\n\t */\n\n\tignorecase = !! ignorecase;\t/* force to 1 or 0 */\n\tif (ignorecase) {\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tsyn |= RE_ICASE;\n\t\t\trp->pat.translate = NULL;\n\t\t} else {\n\t\t\tsyn &= ~RE_ICASE;\n\t\t\trp->pat.translate = (RE_TRANSLATE_TYPE) casetable;\n\t\t}\n\t} else {\n\t\trp->pat.translate = NULL;\n\t\tsyn &= ~RE_ICASE;\n\t}\n\n\tdfa_syn = syn;\n\tif (ignorecase)\n\t\tdfa_syn |= RE_ICASE;\n\tdfasyntax(dfa_syn, ignorecase, '\\n');\n\tre_set_syntax(syn);\n\n\tif ((rerr = re_compile_pattern(buf, len, &(rp->pat))) != NULL) {\n\t\trefree(rp);\n\t\tif (! canfatal) {\n\t\t\t/* rerr already gettextized inside regex routines */\n\t\t\terror(\"%s: /%s/\", rerr, buf);\n \t\t\treturn NULL;\n\t\t}\n\t\tfatal(\"%s: /%s/\", rerr, buf);\n\t}\n\n\t/* gack. this must be done *after* re_compile_pattern */\n\trp->pat.newline_anchor = false; /* don't get \\n in middle of string */\n\tif (dfa && ! no_dfa) {\n\t\trp->dfa = true;\n\t\trp->dfareg = dfaalloc();\n\t\tdfacomp(buf, len, rp->dfareg, true);\n\t} else\n\t\trp->dfa = false;\n\trp->has_anchor = has_anchor;\n\n\t/* Additional flags that help with RS as regexp. */\n\tfor (i = 0; i < len; i++) {\n\t\tif (strchr(metas, buf[i]) != NULL) {\n\t\t\trp->has_meta = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (strchr(\"*+|?\", buf[i]) != NULL) {\n\t\t\trp->maybe_long = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rp;\n}"
}