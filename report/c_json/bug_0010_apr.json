{
    "Project": "apr",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "file_io/unix/open.c",
    "message": "The value read from thlock was never initialized.",
    "warning_function_name": "apr_file_open",
    "warning_line": "(*new)->thlock = thlock;",
    "warning_context": "    }\n\n#ifdef O_CLOEXEC\n    /* Introduced in Linux 2.6.23. Silently ignored on earlier Linux kernels.\n     */\n    if (!(flag & APR_FOPEN_NOCLEANUP)) {\n        oflags |= O_CLOEXEC;\n}\n#endif\n \n#if APR_HAS_LARGE_FILES && defined(_LARGEFILE64_SOURCE)\n    oflags |= O_LARGEFILE;\n#elif defined(O_LARGEFILE)\n    if (flag & APR_FOPEN_LARGEFILE) {\n        oflags |= O_LARGEFILE;\n    }\n#endif\n\n#if APR_HAS_THREADS\n    if ((flag & APR_FOPEN_BUFFERED) && (flag & APR_FOPEN_XTHREAD)) {\n        rv = apr_thread_mutex_create(&thlock,\n                                     APR_THREAD_MUTEX_DEFAULT, pool);\n        if (rv) {\n            return rv;\n        }\n    }\n#endif\n\n    if (perm == APR_OS_DEFAULT) {\n        fd = open(fname, oflags, 0666);\n    }\n    else {\n        fd = open(fname, oflags, apr_unix_perms2mode(perm));\n    } \n    if (fd < 0) {\n       return errno;\n    }\n    if (!(flag & APR_FOPEN_NOCLEANUP)) {\n#ifdef O_CLOEXEC\n        static int has_o_cloexec = 0;\n        if (!has_o_cloexec)\n#endif\n        {\n            int flags;\n\n            if ((flags = fcntl(fd, F_GETFD)) == -1) {\n                close(fd);\n                return errno;\n            }\n            if ((flags & FD_CLOEXEC) == 0) {\n                flags |= FD_CLOEXEC;\n                if (fcntl(fd, F_SETFD, flags) == -1) {\n                    close(fd);\n                    return errno;\n                }\n            }\n#ifdef O_CLOEXEC\n            else {\n                has_o_cloexec = 1;\n            }\n#endif\n        }\n    }\n\n    (*new) = (apr_file_t *)apr_pcalloc(pool, sizeof(apr_file_t));\n    (*new)->pool = pool;\n    (*new)->flags = flag;\n    (*new)->filedes = fd;\n\n    (*new)->fname = apr_pstrdup(pool, fname);\n\n    (*new)->blocking = BLK_ON;\n    (*new)->buffered = (flag & APR_FOPEN_BUFFERED) > 0;\n\n    if ((*new)->buffered) {\n        (*new)->buffer = apr_palloc(pool, APR_FILE_DEFAULT_BUFSIZE);\n        (*new)->bufsize = APR_FILE_DEFAULT_BUFSIZE;\n#if APR_HAS_THREADS\n        if ((*new)->flags & APR_FOPEN_XTHREAD) {\n            (*new)->thlock = thlock;\n        }\n#endif\n    }\n    else {\n        (*new)->buffer = NULL;\n    }\n\n    (*new)->is_pipe = 0;\n    (*new)->timeout = -1;\n    (*new)->ungetchar = -1;\n    (*new)->eof_hit = 0;\n    (*new)->filePtr = 0;\n    (*new)->bufpos = 0;\n    (*new)->dataRead = 0;\n    (*new)->direction = 0;\n#ifndef WAITIO_USES_POLL\n    /* Start out with no pollset.  apr_wait_for_io_or_timeout() will\n     * initialize the pollset if needed.\n     */\n    (*new)->pollset = NULL;\n#endif\n"
}