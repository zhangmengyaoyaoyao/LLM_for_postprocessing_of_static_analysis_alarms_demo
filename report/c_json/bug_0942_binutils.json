{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t  *ptype = debug_make_function_type (minfo->dhandle, *ptype, args,",
    "Code_function": "stab_demangle_type (struct stab_demangle_info *minfo, const char **pp,\n\t\t    debug_type *ptype)\n{\n  const char *orig;\n\n  orig = *pp;\n\n  switch (**pp)\n    {\n    case 'P':\n    case 'p':\n      /* A pointer type.  */\n      ++*pp;\n      if (! stab_demangle_type (minfo, pp, ptype))\n\treturn FALSE;\n      if (ptype != NULL)\n\t*ptype = debug_make_pointer_type (minfo->dhandle, *ptype);\n      break;\n\n    case 'R':\n      /* A reference type.  */\n      ++*pp;\n      if (! stab_demangle_type (minfo, pp, ptype))\n\treturn FALSE;\n      if (ptype != NULL)\n\t*ptype = debug_make_reference_type (minfo->dhandle, *ptype);\n      break;\n\n    case 'A':\n      /* An array.  */\n      {\n\tunsigned long high;\n\n\t++*pp;\n\thigh = 0;\n\twhile (**pp != '\\0' && **pp != '_')\n\t  {\n\t    if (! ISDIGIT (**pp))\n\t      {\n\t\tstab_bad_demangle (orig);\n\t\treturn FALSE;\n\t      }\n\t    high *= 10;\n\t    high += **pp - '0';\n\t    ++*pp;\n\t  }\n\tif (**pp != '_')\n\t  {\n\t    stab_bad_demangle (orig);\n\t    return FALSE;\n\t  }\n\t++*pp;\n\n\tif (! stab_demangle_type (minfo, pp, ptype))\n\t  return FALSE;\n\tif (ptype != NULL)\n\t  {\n\t    debug_type int_type;\n\n\t    int_type = debug_find_named_type (minfo->dhandle, \"int\");\n\t    if (int_type == NULL)\n\t      int_type = debug_make_int_type (minfo->dhandle, 4, FALSE);\n\t    *ptype = debug_make_array_type (minfo->dhandle, *ptype, int_type,\n\t\t\t\t\t    0, high, FALSE);\n\t  }\n      }\n      break;\n\n    case 'T':\n      /* A back reference to a remembered type.  */\n      {\n\tunsigned int i;\n\tconst char *p;\n\n\t++*pp;\n\tif (! stab_demangle_get_count (pp, &i))\n\t  {\n\t    stab_bad_demangle (orig);\n\t    return FALSE;\n\t  }\n\tif (i >= minfo->typestring_count)\n\t  {\n\t    stab_bad_demangle (orig);\n\t    return FALSE;\n\t  }\n\tp = minfo->typestrings[i].typestring;\n\tif (! stab_demangle_type (minfo, &p, ptype))\n\t  return FALSE;\n      }\n      break;\n\n    case 'F':\n      /* A function.  */\n      {\n\tdebug_type *args;\n\tbfd_boolean varargs;\n\n\t++*pp;\n\tif (! stab_demangle_args (minfo, pp,\n\t\t\t\t  (ptype == NULL\n\t\t\t\t   ? (debug_type **) NULL\n\t\t\t\t   : &args),\n\t\t\t\t  (ptype == NULL\n\t\t\t\t   ? (bfd_boolean *) NULL\n\t\t\t\t   : &varargs)))\n\t  return FALSE;\n\tif (**pp != '_')\n\t  {\n\t    /* cplus_demangle will accept a function without a return\n\t       type, but I don't know when that will happen, or what\n\t       to do if it does.  */\n\t    stab_bad_demangle (orig);\n\t    return FALSE;\n\t  }\n\t++*pp;\n\tif (! stab_demangle_type (minfo, pp, ptype))\n\t  return FALSE;\n\tif (ptype != NULL)\n\t  *ptype = debug_make_function_type (minfo->dhandle, *ptype, args,\n\t\t\t\t\t     varargs);\n\n      }\n      break;\n\n    case 'M':\n    case 'O':\n      {\n\tbfd_boolean memberp;\n\tdebug_type class_type = DEBUG_TYPE_NULL;\n\tdebug_type *args;\n\tbfd_boolean varargs;\n\tunsigned int n;\n\tconst char *name;\n\n\tmemberp = **pp == 'M';\n\targs = NULL;\n\tvarargs = FALSE;\n\n\t++*pp;\n\tif (ISDIGIT (**pp))\n\t  {\n\t    n = stab_demangle_count (pp);\n\t    if (strlen (*pp) < n)\n\t      {\n\t\tstab_bad_demangle (orig);\n\t\treturn FALSE;\n\t      }\n\t    name = *pp;\n\t    *pp += n;\n\n\t    if (ptype != NULL)\n\t      {\n\t\tclass_type = stab_find_tagged_type (minfo->dhandle,\n\t\t\t\t\t\t    minfo->info,\n\t\t\t\t\t\t    name, (int) n,\n\t\t\t\t\t\t    DEBUG_KIND_CLASS);\n\t\tif (class_type == DEBUG_TYPE_NULL)\n\t\t  return FALSE;\n\t      }\n\t  }\n\telse if (**pp == 'Q')\n\t  {\n\t    if (! stab_demangle_qualified (minfo, pp,\n\t\t\t\t\t   (ptype == NULL\n\t\t\t\t\t    ? (debug_type *) NULL\n\t\t\t\t\t    : &class_type)))\n\t      return FALSE;\n\t  }\n\telse\n\t  {\n\t    stab_bad_demangle (orig);\n\t    return FALSE;\n\t  }\n\n\tif (memberp)\n\t  {\n\t    if (**pp == 'C')\n\t      {\n\t\t++*pp;\n\t      }\n\t    else if (**pp == 'V')\n\t      {\n\t\t++*pp;\n\t      }\n\t    if (**pp != 'F')\n\t      {\n\t\tstab_bad_demangle (orig);\n\t\treturn FALSE;\n\t      }\n\t    ++*pp;\n\t    if (! stab_demangle_args (minfo, pp,\n\t\t\t\t      (ptype == NULL\n\t\t\t\t       ? (debug_type **) NULL\n\t\t\t\t       : &args),\n\t\t\t\t      (ptype == NULL\n\t\t\t\t       ? (bfd_boolean *) NULL\n\t\t\t\t       : &varargs)))\n\t      return FALSE;\n\t  }\n\n\tif (**pp != '_')\n\t  {\n\t    stab_bad_demangle (orig);\n\t    return FALSE;\n\t  }\n\t++*pp;\n\n\tif (! stab_demangle_type (minfo, pp, ptype))\n\t  return FALSE;\n\n\tif (ptype != NULL)\n\t  {\n\t    if (! memberp)\n\t      *ptype = debug_make_offset_type (minfo->dhandle, class_type,\n\t\t\t\t\t       *ptype);\n\t    else\n\t      {\n\t\t/* FIXME: We have no way to record constp or\n                   volatilep.  */\n\t\t*ptype = debug_make_method_type (minfo->dhandle, *ptype,\n\t\t\t\t\t\t class_type, args, varargs);\n\t      }\n\t  }\n      }\n      break;\n\n    case 'G':\n      ++*pp;\n      if (! stab_demangle_type (minfo, pp, ptype))\n\treturn FALSE;\n      break;\n\n    case 'C':\n      ++*pp;\n      if (! stab_demangle_type (minfo, pp, ptype))\n\treturn FALSE;\n      if (ptype != NULL)\n\t*ptype = debug_make_const_type (minfo->dhandle, *ptype);\n      break;\n\n    case 'Q':\n      {\n\tif (! stab_demangle_qualified (minfo, pp, ptype))\n\t  return FALSE;\n      }\n      break;\n\n    default:\n      if (! stab_demangle_fund_type (minfo, pp, ptype))\n\treturn FALSE;\n      break;\n    }\n\n  return TRUE;\n}"
}