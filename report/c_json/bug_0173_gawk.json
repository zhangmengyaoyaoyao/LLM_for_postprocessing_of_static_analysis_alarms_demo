{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "\t\tmemset(sp, 0, pcount * sizeof(NODE *));",
    "Code_function": "setup_frame(INSTRUCTION *pc)\n{\n\tNODE *r = NULL;\n\tNODE *m, *f, *fp;\n\tNODE **sp = NULL;\n\tint pcount, arg_count, i, j;\n\tbool tail_optimize = false;\n\n\tf = pc->func_body;\n\tpcount = f->param_cnt;\n\tfp = f->fparms;\n\targ_count = (pc + 1)->expr_count;\n\n\t/* tail recursion optimization */\n\ttail_optimize =  ((pc + 1)->tail_call && do_optimize\n\t\t\t\t&& ! do_debug && ! do_profile);\n\n\tif (tail_optimize) {\n\t\t/* free local vars of calling frame */\n\n\t\tNODE *func;\n\t\tint n;\n\n\t\tfunc = frame_ptr->func_node;\n\t\tfor (n = func->param_cnt, sp = frame_ptr->stack; n > 0; n--) {\n\t\t\tr = *sp++;\n\t\t\tif (r->type == Node_var)     /* local variable */\n\t\t\t\tDEREF(r->var_value);\n\t\t\telse if (r->type == Node_var_array)     /* local array */\n\t\t\t\tassoc_clear(r);\n\t\t}\n\t\tsp = frame_ptr->stack;\n\n\t} else if (pcount > 0) {\n\t\temalloc(sp, NODE **, pcount * sizeof(NODE *), \"setup_frame\");\n\t\tmemset(sp, 0, pcount * sizeof(NODE *));\n\t}\n\n\n\t/* check for extra args */\n\tif (arg_count > pcount) {\n\t\twarning(\n\t\t\t_(\"function `%s' called with more arguments than declared\"),\n       \t\t\tf->vname);\n\t\tdo {\n\t\t\tr = POP();\n\t\t\tif (r->type == Node_val)\n\t\t\t\tDEREF(r);\n\t\t} while (--arg_count > pcount);\n\t}\n\n\tfor (i = 0, j = arg_count - 1; i < pcount; i++, j--) {\n\t\tif (tail_optimize)\n\t\t\tr = sp[i];\n\t\telse {\n\t\t\tgetnode(r);\n\t\t\tmemset(r, 0, sizeof(NODE));\n\t\t\tsp[i] = r;\n\t\t}\n\n\t\tif (i >= arg_count) {\n\t\t\t/* local variable */\n\t\t\tr->type = Node_var_new;\n\t\t\tr->vname = fp[i].param;\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = PEEK(j); /* arguments in reverse order on runtime stack */\n\n\t\tif (m->type == Node_param_list)\n\t\t\tm = GET_PARAM(m->param_cnt);\n\n\t\t/* $0 needs to be passed by value to a function */\n\t\tif (m == fields_arr[0]) {\n\t\t\tDEREF(m);\n\t\t\tm = dupnode(m);\n\t\t}\n\n\t\tswitch (m->type) {\n\t\tcase Node_var_new:\n\t\tcase Node_var_array:\n\t\t\tr->type = Node_array_ref;\n\t\t\tr->orig_array = r->prev_array = m;\n\t\t\tbreak;\n\n\t\tcase Node_array_ref:\n\t\t\tr->type = Node_array_ref;\n\t\t\tr->orig_array = m->orig_array;\n\t\t\tr->prev_array = m;\n\t\t\tbreak;\n\n\t\tcase Node_var:\n\t\t\t/* Untyped (Node_var_new) variable as param became a\n\t\t\t * scalar during evaluation of expression for a\n\t\t\t * subsequent param.\n\t\t\t */\n\t\t\tr->type = Node_var;\n\t\t\tr->var_value = dupnode(Nnull_string);\n\t\t\tbreak;\n\n\t\tcase Node_val:\n\t\t\tr->type = Node_var;\n\t\t\tr->var_value = m;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\t\tr->vname = fp[i].param;\n\t}\n\n\tstack_adj(-arg_count);\t/* adjust stack pointer */\n\n\tif (tail_optimize) {\n\t\tframe_ptr->num_tail_calls++;\n\t\treturn f->code_ptr;\n\t}\n\n\tif (pc->opcode == Op_indirect_func_call) {\n\t\tr = POP();\t/* indirect var */\n\t\tDEREF(r);\n\t}\n\n\tframe_ptr->vname = source;\t/* save current source */\n\n\tif (do_profile || do_debug)\n\t\tpush_frame(frame_ptr);\n\n\t/* save current frame in stack */\n\tPUSH(frame_ptr);\n\n\t/* setup new frame */\n\tgetnode(frame_ptr);\n\tframe_ptr->type = Node_frame;\n\tframe_ptr->stack = sp;\n\tframe_ptr->prev_frame_size = (stack_ptr - stack_bottom); /* size of the previous stack frame */\n\tframe_ptr->func_node = f;\n\tframe_ptr->num_tail_calls = 0;\n\tframe_ptr->vname = NULL;\n\tframe_ptr->reti = pc; /* on return execute pc->nexti */\n\n\treturn f->code_ptr;\n}"
}