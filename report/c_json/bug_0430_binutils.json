{
    "project": "binutils",
    "tool": "Cppcheck",
    "category": "uninitvar",
    "file": "bfd/elfnn-ia64.c",
    "message": "Uninitialized variables: &key.got_offset, &key.fptr_offset, &key.pltoff_offset, &key.plt_offset, &key.plt2_offset, &key.tprel_offset, &key.dtpmod_offset, &key.dtprel_offset, &key.h, &key.reloc_entries, &key.got_done, &key.fptr_done, &key.pltoff_done, &key.tprel_done, &key.dtpmod_done, &key.dtprel_done, &key.want_got, &key.want_gotx, &key.want_fptr, &key.want_ltoff_fptr, &key.want_plt, &key.want_plt2, &key.want_pltoff, &key.want_tprel, &key.want_dtpmod, &key.want_dtprel",
    "warning_function_name": "get_dyn_sym_info",
    "warning_line": "dyn_i = bsearch (&key, info, sorted_count,",
    "warning_context": "static struct elfNN_ia64_dyn_sym_info *\nget_dyn_sym_info (struct elfNN_ia64_link_hash_table *ia64_info,\n\t\t  struct elf_link_hash_entry *h, bfd *abfd,\n\t\t  const Elf_Internal_Rela *rel, bfd_boolean create)\n{\n  struct elfNN_ia64_dyn_sym_info **info_p, *info, *dyn_i, key;\n  unsigned int *count_p, *sorted_count_p, *size_p;\n  unsigned int count, sorted_count, size;\n  bfd_vma addend = rel ? rel->r_addend : 0;\n  bfd_size_type amt;\n\n  if (h)\n    {\n      struct elfNN_ia64_link_hash_entry *global_h;\n\n      global_h = (struct elfNN_ia64_link_hash_entry *) h;\n      info_p = &global_h->info;\n      count_p = &global_h->count;\n      sorted_count_p = &global_h->sorted_count;\n      size_p = &global_h->size;\n    }\n  else\n    {\n      struct elfNN_ia64_local_hash_entry *loc_h;\n\n      loc_h = get_local_sym_hash (ia64_info, abfd, rel, create);\n      if (!loc_h)\n\t{\n\t  BFD_ASSERT (!create);\n\t  return NULL;\n\t}\n\n      info_p = &loc_h->info;\n      count_p = &loc_h->count;\n      sorted_count_p = &loc_h->sorted_count;\n      size_p = &loc_h->size;\n    }\n\n  count = *count_p;\n  sorted_count = *sorted_count_p;\n  size = *size_p;\n  info = *info_p;\n  if (create)\n    {\n      /* When we create the array, we don't check for duplicates,\n         except in the previously sorted section if one exists, and\n\t against the last inserted entry.  This allows insertions to\n\t be fast.  */\n      if (info)\n\t{\n\t  if (sorted_count)\n\t    {\n\t      /* Try bsearch first on the sorted section.  */\n\t      key.addend = addend;\n\t      dyn_i = bsearch (&key, info, sorted_count,\n\t\t\t       sizeof (*info), addend_compare);\n\n\t      if (dyn_i)\n\t\t{\n\t\t  return dyn_i;\n\t\t}\n\t    }\n\n\t  /* Do a quick check for the last inserted entry.  */\n\t  dyn_i = info + count - 1;\n\t  if (dyn_i->addend == addend)\n\t    {\n\t      return dyn_i;\n\t    }\n\t}\n\n      if (size == 0)\n\t{\n\t  /* It is the very first element. We create the array of size\n\t     1.  */\n\t  size = 1;\n\t  amt = size * sizeof (*info);\n\t  info = bfd_malloc (amt);\n\t}\n      else if (size <= count)\n\t{\n\t  /* We double the array size every time when we reach the\n\t     size limit.  */\n\t  size += size;\n\t  amt = size * sizeof (*info);\n\t  info = bfd_realloc (info, amt);\n\t}\n      else\n\tgoto has_space;\n\n      if (info == NULL)\n\treturn NULL;\n      *size_p = size;\n      *info_p = info;\n\nhas_space:\n      /* Append the new one to the array.  */\n      dyn_i = info + count;\n      memset (dyn_i, 0, sizeof (*dyn_i));\n      dyn_i->got_offset = (bfd_vma) -1;\n      dyn_i->addend = addend;\n"
}