{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `temp` last assigned on line 188 could be null and is dereferenced at line 192, column 7.",
    "Code_line": "      temp[0] = '\\0';",
    "Code_function": "quote_string_for_globbing (pathname, qflags)\n     const char *pathname;\n     int qflags;\n{\n  char *temp;\n  register int i, j;\n  int brack, cclass, collsym, equiv, c, last_was_backslash;\n\n  temp = (char *)xmalloc (2 * strlen (pathname) + 1);\n\n  if ((qflags & QGLOB_CVTNULL) && QUOTED_NULL (pathname))\n    {\n      temp[0] = '\\0';\n      return temp;\n    }\n\n  brack = cclass = collsym = equiv = last_was_backslash = 0;\n  for (i = j = 0; pathname[i]; i++)\n    {\n      /* Fix for CTLESC at the end of the string? */\n      if (pathname[i] == CTLESC && pathname[i+1] == '\\0')\n\t{\n\t  temp[j++] = pathname[i++];\n\t  break;\n\t}\n      /* If we are parsing regexp, turn CTLESC CTLESC into CTLESC. It's not an\n\t ERE special character, so we should just be able to pass it through. */\n      else if ((qflags & QGLOB_REGEXP) && pathname[i] == CTLESC && pathname[i+1] == CTLESC)\n\t{\n\t  i++;\n\t  temp[j++] = pathname[i];\n\t  continue;\n\t}\n      else if (pathname[i] == CTLESC)\n\t{\n\t  if ((qflags & QGLOB_FILENAME) && pathname[i+1] == '/')\n\t    continue;\n\t  /* What to do if preceding char is backslash? */\n\t  if (pathname[i+1] != CTLESC && (qflags & QGLOB_REGEXP) && ere_char (pathname[i+1]) == 0)\n\t    continue;\n\t  temp[j++] = '\\\\';\n\t  i++;\n\t  if (pathname[i] == '\\0')\n\t    break;\n\t}\n      else if ((qflags & QGLOB_REGEXP) && (i == 0 || pathname[i-1] != CTLESC) && pathname[i] == '[')\t/*]*/\n\t{\n\t  brack = 1;\n\t  temp[j++] = pathname[i++];\t/* open bracket */\n\t  c = pathname[i++];\t/* c == char after open bracket */\n\t  do\n\t    {\n\t      if (c == 0)\n\t\tgoto endpat;\n\t      else if (c == CTLESC)\n\t\t{\n\t\t  /* skip c, check for EOS, let assignment at end of loop */\n\t\t  /* pathname[i] == backslash-escaped character */\n\t\t  if (pathname[i] == 0)\n\t\t    goto endpat;\n\t\t  temp[j++] = pathname[i++];\n\t\t}\n\t      else if (c == '[' && pathname[i] == ':')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  cclass = 1;\n\t\t}\n\t      else if (cclass && c == ':' && pathname[i] == ']')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  cclass = 0;\n\t\t}\n\t      else if (c == '[' && pathname[i] == '=')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  if (pathname[i] == ']')\n\t\t    temp[j++] = pathname[i++];\t\t/* right brack can be in equiv */\n\t\t  equiv = 1;\n\t\t}\n\t      else if (equiv && c == '=' && pathname[i] == ']')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  equiv = 0;\n\t\t}\n\t      else if (c == '[' && pathname[i] == '.')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  if (pathname[i] == ']')\n\t\t    temp[j++] = pathname[i++];\t\t/* right brack can be in collsym */\n\t\t  collsym = 1;\n\t\t}\n\t      else if (collsym && c == '.' && pathname[i] == ']')\n\t\t{\n\t\t  temp[j++] = c;\n\t\t  temp[j++] = pathname[i++];\n\t\t  collsym = 0;\n\t\t}\n\t      else\n\t\ttemp[j++] = c;\n\t    }\n\t  while ((c = pathname[i++]) != ']');\n\t  temp[j++] = c;\t/* closing right bracket */\n\t  i--;\t\t\t/* increment will happen above in loop */\n\t  continue;\t\t/* skip double assignment below */\n\t}\n      else if (pathname[i] == '\\\\' && (qflags & QGLOB_REGEXP) == 0)\n\t{\n\t  /* XXX - if not quoting regexp, use backslash as quote char. Should\n\t     we just pass it through without treating it as special? That is\n\t     what ksh93 seems to do. */\n\n\t  /* If we want to pass through backslash unaltered, comment out these\n\t     lines. */\n\t  temp[j++] = '\\\\';\n\n\t  i++;\n\t  if (pathname[i] == '\\0')\n\t    break;\n\t}\n      else if (pathname[i] == '\\\\' && (qflags & QGLOB_REGEXP))\n        last_was_backslash = 1;\n      temp[j++] = pathname[i];\n    }\nendpat:\n  temp[j] = '\\0';\n\n  return (temp);\n}"
}