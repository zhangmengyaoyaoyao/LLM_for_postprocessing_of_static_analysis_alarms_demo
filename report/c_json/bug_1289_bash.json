{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-1, +oo] (‚áê [1, 3] + [-2, +oo]) Size: 24 by call to `get_history_event`.",
    "Code_line": "      event = get_history_event (fake_s, &fake_i, 0);",
    "Code_function": "history_expand_internal (string, start, qc, end_index_ptr, ret_string, current_line)\n     char *string;\n     int start, qc, *end_index_ptr;\n     char **ret_string;\n     char *current_line;\t/* for !# */\n{\n  int i, n, starting_index;\n  int substitute_globally, subst_bywords, want_quotes, print_only;\n  char *event, *temp, *result, *tstr, *t, c, *word_spec;\n  int result_len;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n\n  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n  result = (char *)xmalloc (result_len = 128);\n\n  i = start;\n\n  /* If it is followed by something that starts a word specifier,\n     then !! is implied as the event specifier. */\n\n  if (member (string[i + 1], \":$*%^\"))\n    {\n      char fake_s[3];\n      int fake_i = 0;\n      i++;\n      fake_s[0] = fake_s[1] = history_expansion_char;\n      fake_s[2] = '\\0';\n      event = get_history_event (fake_s, &fake_i, 0);\n    }\n  else if (string[i + 1] == '#')\n    {\n      i += 2;\n      event = current_line;\n    }\n  else\n    event = get_history_event (string, &i, qc);\n\n  if (event == 0)\n    {\n      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);\n      xfree (result);\n      return (-1);\n    }\n\n  /* If a word specifier is found, then do what that requires. */\n  starting_index = i;\n  word_spec = get_history_word_specifier (string, event, &i);\n\n  /* There is no such thing as a `malformed word specifier'.  However,\n     it is possible for a specifier that has no match.  In that case,\n     we complain. */\n  if (word_spec == (char *)&error_pointer)\n    {\n      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);\n      xfree (result);\n      return (-1);\n    }\n\n  /* If no word specifier, than the thing of interest was the event. */\n  temp = word_spec ? savestring (word_spec) : savestring (event);\n  FREE (word_spec);\n\n  /* Perhaps there are other modifiers involved.  Do what they say. */\n  want_quotes = substitute_globally = subst_bywords = print_only = 0;\n  starting_index = i;\n\n  while (string[i] == ':')\n    {\n      c = string[i + 1];\n\n      if (c == 'g' || c == 'a')\n\t{\n\t  substitute_globally = 1;\n\t  i++;\n\t  c = string[i + 1];\n\t}\n      else if (c == 'G')\n\t{\n\t  subst_bywords = 1;\n\t  i++;\n\t  c = string[i + 1];\n\t}\n\n      switch (c)\n\t{\n\tdefault:\n\t  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);\n\t  xfree (result);\n\t  xfree (temp);\n\t  return -1;\n\n\tcase 'q':\n\t  want_quotes = 'q';\n\t  break;\n\n\tcase 'x':\n\t  want_quotes = 'x';\n\t  break;\n\n\t  /* :p means make this the last executed line.  So we\n\t     return an error state after adding this line to the\n\t     history. */\n\tcase 'p':\n\t  print_only++;\n\t  break;\n\n\t  /* :t discards all but the last part of the pathname. */\n\tcase 't':\n\t  tstr = strrchr (temp, '/');\n\t  if (tstr)\n\t    {\n\t      tstr++;\n\t      t = savestring (tstr);\n\t      xfree (temp);\n\t      temp = t;\n\t    }\n\t  break;\n\n\t  /* :h discards the last part of a pathname. */\n\tcase 'h':\n\t  tstr = strrchr (temp, '/');\n\t  if (tstr)\n\t    *tstr = '\\0';\n\t  break;\n\n\t  /* :r discards the suffix. */\n\tcase 'r':\n\t  tstr = strrchr (temp, '.');\n\t  if (tstr)\n\t    *tstr = '\\0';\n\t  break;\n\n\t  /* :e discards everything but the suffix. */\n\tcase 'e':\n\t  tstr = strrchr (temp, '.');\n\t  if (tstr)\n\t    {\n\t      t = savestring (tstr);\n\t      xfree (temp);\n\t      temp = t;\n\t    }\n\t  break;\n\n\t/* :s/this/that substitutes `that' for the first\n\t   occurrence of `this'.  :gs/this/that substitutes `that'\n\t   for each occurrence of `this'.  :& repeats the last\n\t   substitution.  :g& repeats the last substitution\n\t   globally. */\n\n\tcase '&':\n\tcase 's':\n\t  {\n\t    char *new_event;\n\t    int delimiter, failed, si, l_temp, ws, we;\n\n\t    if (c == 's')\n\t      {\n\t\tif (i + 2 < (int)strlen (string))\n\t\t  {\n#if defined (HANDLE_MULTIBYTE)\n\t\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t\t      {\n\t\t\t_rl_adjust_point (string, i + 2, &ps);\n\t\t\tif (_rl_get_char_len (string + i + 2, &ps) > 1)\n\t\t\t  delimiter = 0;\n\t\t\telse\n\t\t\t  delimiter = string[i + 2];\n\t\t      }\n\t\t    else\n#endif /* HANDLE_MULTIBYTE */\n\t\t      delimiter = string[i + 2];\n\t\t  }\n\t\telse\n\t\t  break;\t/* no search delimiter */\n\n\t\ti += 3;\n\n\t\tt = get_subst_pattern (string, &i, delimiter, 0, &subst_lhs_len);\n\t\t/* An empty substitution lhs with no previous substitution\n\t\t   uses the last search string as the lhs. */\n\t\tif (t)\n\t\t  {\n\t\t    FREE (subst_lhs);\n\t\t    subst_lhs = t;\n\t\t  }\n\t\telse if (!subst_lhs)\n\t\t  {\n\t\t    if (search_string && *search_string)\n\t\t      {\n\t\t\tsubst_lhs = savestring (search_string);\n\t\t\tsubst_lhs_len = strlen (subst_lhs);\n\t\t      }\n\t\t    else\n\t\t      {\n\t\t\tsubst_lhs = (char *) NULL;\n\t\t\tsubst_lhs_len = 0;\n\t\t      }\n\t\t  }\n\n\t\tFREE (subst_rhs);\n\t\tsubst_rhs = get_subst_pattern (string, &i, delimiter, 1, &subst_rhs_len);\n\n\t\t/* If `&' appears in the rhs, it's supposed to be replaced\n\t\t   with the lhs. */\n\t\tif (member ('&', subst_rhs))\n\t\t  postproc_subst_rhs ();\n\t      }\n\t    else\n\t      i += 2;\n\n\t    /* If there is no lhs, the substitution can't succeed. */\n\t    if (subst_lhs_len == 0)\n\t      {\n\t\t*ret_string = hist_error (string, starting_index, i, NO_PREV_SUBST);\n\t\txfree (result);\n\t\txfree (temp);\n\t\treturn -1;\n\t      }\n\n\t    l_temp = strlen (temp);\n\t    /* Ignore impossible cases. */\n\t    if (subst_lhs_len > l_temp)\n\t      {\n\t\t*ret_string = hist_error (string, starting_index, i, SUBST_FAILED);\n\t\txfree (result);\n\t\txfree (temp);\n\t\treturn (-1);\n\t      }\n\n\t    /* Find the first occurrence of THIS in TEMP. */\n\t    /* Substitute SUBST_RHS for SUBST_LHS in TEMP.  There are three\n\t       cases to consider:\n\n\t\t 1.  substitute_globally == subst_bywords == 0\n\t\t 2.  substitute_globally == 1 && subst_bywords == 0\n\t\t 3.  substitute_globally == 0 && subst_bywords == 1\n\n\t       In the first case, we substitute for the first occurrence only.\n\t       In the second case, we substitute for every occurrence.\n\t       In the third case, we tokenize into words and substitute the\n\t       first occurrence of each word. */\n\n\t    si = we = 0;\n\t    for (failed = 1; (si + subst_lhs_len) <= l_temp; si++)\n\t      {\n\t\t/* First skip whitespace and find word boundaries if\n\t\t   we're past the end of the word boundary we found\n\t\t   the last time. */\n\t\tif (subst_bywords && si > we)\n\t\t  {\n\t\t    for (; temp[si] && whitespace (temp[si]); si++)\n\t\t      ;\n\t\t    ws = si;\n\t\t    we = history_tokenize_word (temp, si);\n\t\t  }\n\n\t\tif (STREQN (temp+si, subst_lhs, subst_lhs_len))\n\t\t  {\n\t\t    int len = subst_rhs_len - subst_lhs_len + l_temp;\n\t\t    new_event = (char *)xmalloc (1 + len);\n\t\t    strncpy (new_event, temp, si);\n\t\t    strncpy (new_event + si, subst_rhs, subst_rhs_len);\n\t\t    strncpy (new_event + si + subst_rhs_len,\n\t\t\t     temp + si + subst_lhs_len,\n\t\t\t     l_temp - (si + subst_lhs_len));\n\t\t    new_event[len] = '\\0';\n\t\t    xfree (temp);\n\t\t    temp = new_event;\n\n\t\t    failed = 0;\n\n\t\t    if (substitute_globally)\n\t\t      {\n\t\t\t/* Reported to fix a bug that causes it to skip every\n\t\t\t   other match when matching a single character.  Was\n\t\t\t   si += subst_rhs_len previously. */\n\t\t\tsi += subst_rhs_len - 1;\n\t\t\tl_temp = strlen (temp);\n\t\t\tsubstitute_globally++;\n\t\t\tcontinue;\n\t\t      }\n\t\t    else if (subst_bywords)\n\t\t      {\n\t\t\tsi = we;\n\t\t\tl_temp = strlen (temp);\n\t\t\tcontinue;\n\t\t      }\n\t\t    else\n\t\t      break;\n\t\t  }\n\t      }\n\n\t    if (substitute_globally > 1)\n\t      {\n\t\tsubstitute_globally = 0;\n\t\tcontinue;\t/* don't want to increment i */\n\t      }\n\n\t    if (failed == 0)\n\t      continue;\t\t/* don't want to increment i */\n\n\t    *ret_string = hist_error (string, starting_index, i, SUBST_FAILED);\n\t    xfree (result);\n\t    xfree (temp);\n\t    return (-1);\n\t  }\n\t}\n      i += 2;\n    }\n  /* Done with modifiers. */\n  /* Believe it or not, we have to back the pointer up by one. */\n  --i;\n\n  if (want_quotes)\n    {\n      char *x;\n\n      if (want_quotes == 'q')\n\tx = sh_single_quote (temp);\n      else if (want_quotes == 'x')\n\tx = quote_breaks (temp);\n      else\n\tx = savestring (temp);\n\n      xfree (temp);\n      temp = x;\n    }\n\n  n = strlen (temp);\n  if (n >= result_len)\n    result = (char *)xrealloc (result, n + 2);\n  strcpy (result, temp);\n  xfree (temp);\n\n  *end_index_ptr = i;\n  *ret_string = result;\n  return (print_only);\n}"
}