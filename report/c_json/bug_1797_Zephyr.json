{
    "project": "Zephyr",
    "tool": "Infer",
    "category": "Uninitialized Value",
    "file": "kernel/poll.c",
    "message": "The value read from expr_copy was never initialized.",
    "warning_function_name": "z_vrfy_k_poll",
    "warning_line": "Z_OOPS(Z_SYSCALL_OBJ(e->signal, K_OBJ_POLL_SIGNAL));",
    "warning_context": "static inline int z_vrfy_k_poll(struct k_poll_event *events,\n\t\t\t\tint num_events, s32_t timeout)\n{\n\tint ret;\n\tk_spinlock_key_t key;\n\tstruct k_poll_event *events_copy = NULL;\n\tu32_t bounds;\n\n\t/* Validate the events buffer and make a copy of it in an\n\t * allocated kernel-side buffer.\n\t */\n\tif (Z_SYSCALL_VERIFY(num_events > 0)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (Z_SYSCALL_VERIFY_MSG(!u32_mul_overflow(num_events,\n\t\t\t\t\t\t   sizeof(struct k_poll_event),\n\t\t\t\t\t\t   &bounds),\n\t\t\t\t \"num_events too large\")) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tevents_copy = z_thread_malloc(bounds);\n\tif (!events_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey = k_spin_lock(&lock);\n\tif (Z_SYSCALL_MEMORY_WRITE(events, bounds)) {\n\t\tk_spin_unlock(&lock, key);\n\t\tgoto oops_free;\n\t}\n\t(void)memcpy(events_copy, events, bounds);\n\tk_spin_unlock(&lock, key);\n\n\t/* Validate what's inside events_copy */\n\tfor (int i = 0; i < num_events; i++) {\n\t\tstruct k_poll_event *e = &events_copy[i];\n\n\t\tif (Z_SYSCALL_VERIFY(e->mode == K_POLL_MODE_NOTIFY_ONLY)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tswitch (e->type) {\n\t\tcase K_POLL_TYPE_IGNORE:\n\t\t\tbreak;\n\t\tcase K_POLL_TYPE_SIGNAL:\n\t\t\tZ_OOPS(Z_SYSCALL_OBJ(e->signal, K_OBJ_POLL_SIGNAL));\n\t\t\tbreak;\n\t\tcase K_POLL_TYPE_SEM_AVAILABLE:\n\t\t\tZ_OOPS(Z_SYSCALL_OBJ(e->sem, K_OBJ_SEM));\n\t\t\tbreak;\n\t\tcase K_POLL_TYPE_DATA_AVAILABLE:\n\t\t\tZ_OOPS(Z_SYSCALL_OBJ(e->queue, K_OBJ_QUEUE));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tret = k_poll(events_copy, num_events, timeout);\n\t(void)memcpy((void *)events, events_copy, bounds);\nout_free:\n\tk_free(events_copy);\nout:\n\treturn ret;\noops_free:\n\tk_free(events_copy);\n\tZ_OOPS(1);\n}\n"
}