{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "  lh.standard_opcode_lengths[0] = 1;",
    "Code_function": "decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n{\n  bfd *abfd = unit->abfd;\n  struct line_info_table* table;\n  bfd_byte *line_ptr;\n  bfd_byte *line_end;\n  struct line_head lh;\n  unsigned int i, bytes_read, offset_size;\n  char *cur_file, *cur_dir;\n  unsigned char op_code, extended_op, adj_opcode;\n  unsigned int exop_len;\n  bfd_size_type amt;\n\n  if (! read_section (abfd, &stash->debug_sections[debug_line],\n\t\t      stash->syms, unit->line_offset,\n\t\t      &stash->dwarf_line_buffer, &stash->dwarf_line_size))\n    return NULL;\n\n  amt = sizeof (struct line_info_table);\n  table = (struct line_info_table *) bfd_alloc (abfd, amt);\n  if (table == NULL)\n    return NULL;\n  table->abfd = abfd;\n  table->comp_dir = unit->comp_dir;\n\n  table->num_files = 0;\n  table->files = NULL;\n\n  table->num_dirs = 0;\n  table->dirs = NULL;\n\n  table->num_sequences = 0;\n  table->sequences = NULL;\n\n  table->lcl_head = NULL;\n\n  if (stash->dwarf_line_size < 16)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Line info section is too small (%ld)\"),\n\t (long) stash->dwarf_line_size);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr = stash->dwarf_line_buffer + unit->line_offset;\n  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;\n\n  /* Read in the prologue.  */\n  lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n  line_ptr += 4;\n  offset_size = 4;\n  if (lh.total_length == 0xffffffff)\n    {\n      lh.total_length = read_8_bytes (abfd, line_ptr, line_end);\n      line_ptr += 8;\n      offset_size = 8;\n    }\n  else if (lh.total_length == 0 && unit->addr_size == 8)\n    {\n      /* Handle (non-standard) 64-bit DWARF2 formats.  */\n      lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n      line_ptr += 4;\n      offset_size = 8;\n    }\n\n  if (lh.total_length > stash->dwarf_line_size)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Line info data is bigger (0x%lx) than the section (0x%lx)\"),\n\t (long) lh.total_length, (long) stash->dwarf_line_size);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  line_end = line_ptr + lh.total_length;\n\n  lh.version = read_2_bytes (abfd, line_ptr, line_end);\n  if (lh.version < 2 || lh.version > 4)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Unhandled .debug_line version %d.\"), lh.version);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr += 2;\n\n  if (line_ptr + offset_size + (lh.version >=4 ? 6 : 5) >= line_end)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Ran out of room reading prologue\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  if (offset_size == 4)\n    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);\n  else\n    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);\n  line_ptr += offset_size;\n\n  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (lh.version >= 4)\n    {\n      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n  else\n    lh.maximum_ops_per_insn = 1;\n\n  if (lh.maximum_ops_per_insn == 0)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Invalid maximum operations per instruction.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_range = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (line_ptr + (lh.opcode_base - 1) >= line_end)\n    {\n      (*_bfd_error_handler) (_(\"Dwarf Error: Ran out of room reading opcodes\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  amt = lh.opcode_base * sizeof (unsigned char);\n  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);\n\n  lh.standard_opcode_lengths[0] = 1;\n\n  for (i = 1; i < lh.opcode_base; ++i)\n    {\n      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n\n  /* Read directory table.  */\n  while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n    {\n      line_ptr += bytes_read;\n\n      if ((table->num_dirs % DIR_ALLOC_CHUNK) == 0)\n\t{\n\t  char **tmp;\n\n\t  amt = table->num_dirs + DIR_ALLOC_CHUNK;\n\t  amt *= sizeof (char *);\n\n\t  tmp = (char **) bfd_realloc (table->dirs, amt);\n\t  if (tmp == NULL)\n\t    goto fail;\n\t  table->dirs = tmp;\n\t}\n\n      table->dirs[table->num_dirs++] = cur_dir;\n    }\n\n  line_ptr += bytes_read;\n\n  /* Read file name table.  */\n  while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n    {\n      line_ptr += bytes_read;\n\n      if ((table->num_files % FILE_ALLOC_CHUNK) == 0)\n\t{\n\t  struct fileinfo *tmp;\n\n\t  amt = table->num_files + FILE_ALLOC_CHUNK;\n\t  amt *= sizeof (struct fileinfo);\n\n\t  tmp = (struct fileinfo *) bfd_realloc (table->files, amt);\n\t  if (tmp == NULL)\n\t    goto fail;\n\t  table->files = tmp;\n\t}\n\n      table->files[table->num_files].name = cur_file;\n      table->files[table->num_files].dir =\n\tsafe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n      line_ptr += bytes_read;\n      table->files[table->num_files].time = safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n      line_ptr += bytes_read;\n      table->files[table->num_files].size = safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n      line_ptr += bytes_read;\n      table->num_files++;\n    }\n\n  line_ptr += bytes_read;\n\n  /* Read the statement sequences until there's nothing left.  */\n  while (line_ptr < line_end)\n    {\n      /* State machine registers.  */\n      bfd_vma address = 0;\n      unsigned char op_index = 0;\n      char * filename = table->num_files ? concat_filename (table, 1) : NULL;\n      unsigned int line = 1;\n      unsigned int column = 0;\n      unsigned int discriminator = 0;\n      int is_stmt = lh.default_is_stmt;\n      int end_sequence = 0;\n      /* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some\n\t compilers generate address sequences that are wildly out of\n\t order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler\n\t for ia64-Linux).  Thus, to determine the low and high\n\t address, we must compare on every DW_LNS_copy, etc.  */\n      bfd_vma low_pc  = (bfd_vma) -1;\n      bfd_vma high_pc = 0;\n\n      /* Decode the table.  */\n      while (! end_sequence)\n\t{\n\t  op_code = read_1_byte (abfd, line_ptr, line_end);\n\t  line_ptr += 1;\n\n\t  if (op_code >= lh.opcode_base)\n\t    {\n\t      /* Special operand.  */\n\t      adj_opcode = op_code - lh.opcode_base;\n\t      if (lh.line_range == 0)\n\t\tgoto line_fail;\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (adj_opcode / lh.line_range\n\t\t\t    * lh.minimum_instruction_length);\n\t      else\n\t\t{\n\t\t  address += ((op_index + adj_opcode / lh.line_range)\n\t\t\t      / lh.maximum_ops_per_insn\n\t\t\t      * lh.minimum_instruction_length);\n\t\t  op_index = ((op_index + adj_opcode / lh.line_range)\n\t\t\t      % lh.maximum_ops_per_insn);\n\t\t}\n\t      line += lh.line_base + (adj_opcode % lh.line_range);\n\t      /* Append row to matrix using current values.  */\n\t      if (!add_line_info (table, address, op_index, filename,\n\t\t\t\t  line, column, discriminator, 0))\n\t\tgoto line_fail;\n\t      discriminator = 0;\n\t      if (address < low_pc)\n\t\tlow_pc = address;\n\t      if (address > high_pc)\n\t\thigh_pc = address;\n\t    }\n\t  else switch (op_code)\n\t    {\n\t    case DW_LNS_extended_op:\n\t      exop_len = safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t      line_ptr += bytes_read;\n\t      extended_op = read_1_byte (abfd, line_ptr, line_end);\n\t      line_ptr += 1;\n\n\t      switch (extended_op)\n\t\t{\n\t\tcase DW_LNE_end_sequence:\n\t\t  end_sequence = 1;\n\t\t  if (!add_line_info (table, address, op_index, filename, line,\n\t\t\t\t      column, discriminator, end_sequence))\n\t\t    goto line_fail;\n\t\t  discriminator = 0;\n\t\t  if (address < low_pc)\n\t\t    low_pc = address;\n\t\t  if (address > high_pc)\n\t\t    high_pc = address;\n\t\t  if (!arange_add (unit, &unit->arange, low_pc, high_pc))\n\t\t    goto line_fail;\n\t\t  break;\n\t\tcase DW_LNE_set_address:\n\t\t  address = read_address (unit, line_ptr, line_end);\n\t\t  op_index = 0;\n\t\t  line_ptr += unit->addr_size;\n\t\t  break;\n\t\tcase DW_LNE_define_file:\n\t\t  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);\n\t\t  line_ptr += bytes_read;\n\t\t  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)\n\t\t    {\n\t\t      struct fileinfo *tmp;\n\n\t\t      amt = table->num_files + FILE_ALLOC_CHUNK;\n\t\t      amt *= sizeof (struct fileinfo);\n\t\t      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);\n\t\t      if (tmp == NULL)\n\t\t\tgoto line_fail;\n\t\t      table->files = tmp;\n\t\t    }\n\t\t  table->files[table->num_files].name = cur_file;\n\t\t  table->files[table->num_files].dir =\n\t\t    safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->files[table->num_files].time =\n\t\t    safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->files[table->num_files].size =\n\t\t    safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->num_files++;\n\t\t  break;\n\t\tcase DW_LNE_set_discriminator:\n\t\t  discriminator =\n\t\t    safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  break;\n\t\tcase DW_LNE_HP_source_file_correlation:\n\t\t  line_ptr += exop_len - 1;\n\t\t  break;\n\t\tdefault:\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"Dwarf Error: mangled line number section.\"));\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\tline_fail:\n\t\t  if (filename != NULL)\n\t\t    free (filename);\n\t\t  goto fail;\n\t\t}\n\t      break;\n\t    case DW_LNS_copy:\n\t      if (!add_line_info (table, address, op_index,\n\t\t\t\t  filename, line, column, discriminator, 0))\n\t\tgoto line_fail;\n\t      discriminator = 0;\n\t      if (address < low_pc)\n\t\tlow_pc = address;\n\t      if (address > high_pc)\n\t\thigh_pc = address;\n\t      break;\n\t    case DW_LNS_advance_pc:\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (lh.minimum_instruction_length\n\t\t\t    * safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t\tFALSE, line_end));\n\t      else\n\t\t{\n\t\t  bfd_vma adjust = safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t\t     FALSE, line_end);\n\t\t  address = ((op_index + adjust) / lh.maximum_ops_per_insn\n\t\t\t     * lh.minimum_instruction_length);\n\t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n\t\t}\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_advance_line:\n\t      line += safe_read_leb128 (abfd, line_ptr, &bytes_read, TRUE, line_end);\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_set_file:\n\t      {\n\t\tunsigned int file;\n\n\t\t/* The file and directory tables are 0\n\t\t   based, the references are 1 based.  */\n\t\tfile = safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t\tline_ptr += bytes_read;\n\t\tif (filename)\n\t\t  free (filename);\n\t\tfilename = concat_filename (table, file);\n\t\tbreak;\n\t      }\n\t    case DW_LNS_set_column:\n\t      column = safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_negate_stmt:\n\t      is_stmt = (!is_stmt);\n\t      break;\n\t    case DW_LNS_set_basic_block:\n\t      break;\n\t    case DW_LNS_const_add_pc:\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (lh.minimum_instruction_length\n\t\t\t    * ((255 - lh.opcode_base) / lh.line_range));\n\t      else\n\t\t{\n\t\t  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);\n\t\t  address += (lh.minimum_instruction_length\n\t\t\t      * ((op_index + adjust)\n\t\t\t\t / lh.maximum_ops_per_insn));\n\t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n\t\t}\n\t      break;\n\t    case DW_LNS_fixed_advance_pc:\n\t      address += read_2_bytes (abfd, line_ptr, line_end);\n\t      op_index = 0;\n\t      line_ptr += 2;\n\t      break;\n\t    default:\n\t      /* Unknown standard opcode, ignore it.  */\n\t      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)\n\t\t{\n\t\t  (void) safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t}\n\t      break;\n\t    }\n\t}\n\n      if (filename)\n\tfree (filename);\n    }\n\n  if (sort_line_sequences (table))\n    return table;\n\n fail:\n  if (table->sequences != NULL)\n    free (table->sequences);\n  if (table->files != NULL)\n    free (table->files);\n  if (table->dirs != NULL)\n    free (table->dirs);\n  return NULL;\n}"
}