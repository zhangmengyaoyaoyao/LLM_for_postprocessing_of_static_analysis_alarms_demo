{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "      section->used_by_bfd = bfd_zalloc (abfd, amt);",
    "Code_function": "coff_find_nearest_line_with_names (bfd *abfd,\n                                   asymbol **symbols,\n                                   asection *section,\n                                   bfd_vma offset,\n                                   const char **filename_ptr,\n                                   const char **functionname_ptr,\n                                   unsigned int *line_ptr,\n                                   const struct dwarf_debug_section *debug_sections)\n{\n  bfd_boolean found;\n  unsigned int i;\n  unsigned int line_base;\n  coff_data_type *cof = coff_data (abfd);\n  /* Run through the raw syments if available.  */\n  combined_entry_type *p;\n  combined_entry_type *pend;\n  alent *l;\n  struct coff_section_tdata *sec_data;\n  bfd_size_type amt;\n\n  /* Before looking through the symbol table, try to use a .stab\n     section to find the information.  */\n  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,\n\t\t\t\t\t     &found, filename_ptr,\n\t\t\t\t\t     functionname_ptr, line_ptr,\n\t\t\t\t\t     &coff_data(abfd)->line_info))\n    return FALSE;\n\n  if (found)\n    return TRUE;\n\n  /* Also try examining DWARF2 debugging information.  */\n  if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,\n\t\t\t\t     filename_ptr, functionname_ptr,\n\t\t\t\t     line_ptr, NULL, debug_sections, 0,\n\t\t\t\t     &coff_data(abfd)->dwarf2_find_line_info))\n    return TRUE;\n\n  *filename_ptr = 0;\n  *functionname_ptr = 0;\n  *line_ptr = 0;\n\n  /* Don't try and find line numbers in a non coff file.  */\n  if (!bfd_family_coff (abfd))\n    return FALSE;\n\n  if (cof == NULL)\n    return FALSE;\n\n  /* Find the first C_FILE symbol.  */\n  p = cof->raw_syments;\n  if (!p)\n    return FALSE;\n\n  pend = p + cof->raw_syment_count;\n  while (p < pend)\n    {\n      BFD_ASSERT (p->is_sym);\n      if (p->u.syment.n_sclass == C_FILE)\n\tbreak;\n      p += 1 + p->u.syment.n_numaux;\n    }\n\n  if (p < pend)\n    {\n      bfd_vma sec_vma;\n      bfd_vma maxdiff;\n\n      /* Look through the C_FILE symbols to find the best one.  */\n      sec_vma = bfd_get_section_vma (abfd, section);\n      *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;\n      maxdiff = (bfd_vma) 0 - (bfd_vma) 1;\n      while (1)\n\t{\n\t  bfd_vma file_addr;\n\t  combined_entry_type *p2;\n\n\t  for (p2 = p + 1 + p->u.syment.n_numaux;\n\t       p2 < pend;\n\t       p2 += 1 + p2->u.syment.n_numaux)\n\t    {\n\t      BFD_ASSERT (p2->is_sym);\n\t      if (p2->u.syment.n_scnum > 0\n\t\t  && (section\n\t\t      == coff_section_from_bfd_index (abfd,\n\t\t\t\t\t\t      p2->u.syment.n_scnum)))\n\t\tbreak;\n\t      if (p2->u.syment.n_sclass == C_FILE)\n\t\t{\n\t\t  p2 = pend;\n\t\t  break;\n\t\t}\n\t    }\n\t  if (p2 >= pend)\n\t    break;\n\n\t  file_addr = (bfd_vma) p2->u.syment.n_value;\n\t  /* PR 11512: Include the section address of the function name symbol.  */\n\t  if (p2->u.syment.n_scnum > 0)\n\t    file_addr += coff_section_from_bfd_index (abfd,\n\t\t\t\t\t\t      p2->u.syment.n_scnum)->vma;\n\t  /* We use <= MAXDIFF here so that if we get a zero length\n             file, we actually use the next file entry.  */\n\t  if (p2 < pend\n\t      && offset + sec_vma >= file_addr\n\t      && offset + sec_vma - file_addr <= maxdiff)\n\t    {\n\t      *filename_ptr = (char *) p->u.syment._n._n_n._n_offset;\n\t      maxdiff = offset + sec_vma - p2->u.syment.n_value;\n\t    }\n\n\t  /* Avoid endless loops on erroneous files by ensuring that\n\t     we always move forward in the file.  */\n\t  if (p >= cof->raw_syments + p->u.syment.n_value)\n\t    break;\n\n\t  p = cof->raw_syments + p->u.syment.n_value;\n\t  if (p > pend || p->u.syment.n_sclass != C_FILE)\n\t    break;\n\t}\n    }\n\n  /* Now wander though the raw linenumbers of the section.  */\n  /* If we have been called on this section before, and the offset we\n     want is further down then we can prime the lookup loop.  */\n  sec_data = coff_section_data (abfd, section);\n  if (sec_data != NULL\n      && sec_data->i > 0\n      && offset >= sec_data->offset)\n    {\n      i = sec_data->i;\n      *functionname_ptr = sec_data->function;\n      line_base = sec_data->line_base;\n    }\n  else\n    {\n      i = 0;\n      line_base = 0;\n    }\n\n  if (section->lineno != NULL)\n    {\n      bfd_vma last_value = 0;\n\n      l = &section->lineno[i];\n\n      for (; i < section->lineno_count; i++)\n\t{\n\t  if (l->line_number == 0)\n\t    {\n\t      /* Get the symbol this line number points at.  */\n\t      coff_symbol_type *coff = (coff_symbol_type *) (l->u.sym);\n\t      if (coff->symbol.value > offset)\n\t\tbreak;\n\t      *functionname_ptr = coff->symbol.name;\n\t      last_value = coff->symbol.value;\n\t      if (coff->native)\n\t\t{\n\t\t  combined_entry_type *s = coff->native;\n\n\t\t  BFD_ASSERT (s->is_sym);\n\t\t  s = s + 1 + s->u.syment.n_numaux;\n\n\t\t  /* In XCOFF a debugging symbol can follow the\n\t\t     function symbol.  */\n\t\t  if (s->u.syment.n_scnum == N_DEBUG)\n\t\t    s = s + 1 + s->u.syment.n_numaux;\n\n\t\t  /* S should now point to the .bf of the function.  */\n\t\t  if (s->u.syment.n_numaux)\n\t\t    {\n\t\t      /* The linenumber is stored in the auxent.  */\n\t\t      union internal_auxent *a = &((s + 1)->u.auxent);\n\n\t\t      line_base = a->x_sym.x_misc.x_lnsz.x_lnno;\n\t\t      *line_ptr = line_base;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      if (l->u.offset > offset)\n\t\tbreak;\n\t      *line_ptr = l->line_number + line_base - 1;\n\t    }\n\t  l++;\n\t}\n\n      /* If we fell off the end of the loop, then assume that this\n\t symbol has no line number info.  Otherwise, symbols with no\n\t line number info get reported with the line number of the\n\t last line of the last symbol which does have line number\n\t info.  We use 0x100 as a slop to account for cases where the\n\t last line has executable code.  */\n      if (i >= section->lineno_count\n\t  && last_value != 0\n\t  && offset - last_value > 0x100)\n\t{\n\t  *functionname_ptr = NULL;\n\t  *line_ptr = 0;\n\t}\n    }\n\n  /* Cache the results for the next call.  */\n  if (sec_data == NULL && section->owner == abfd)\n    {\n      amt = sizeof (struct coff_section_tdata);\n      section->used_by_bfd = bfd_zalloc (abfd, amt);\n      sec_data = (struct coff_section_tdata *) section->used_by_bfd;\n    }\n  if (sec_data != NULL)\n    {\n      sec_data->offset = offset;\n      sec_data->i = i - 1;\n      sec_data->function = *functionname_ptr;\n      sec_data->line_base = line_base;\n    }\n\n  return TRUE;\n}"
}