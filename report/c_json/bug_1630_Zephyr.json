{
    "Project": "Zephyr",
    "Tool": "Infer",
    "Bug Type": "Uninitialized Value",
    "Code_line": "\t\t\tif (net_pkt_skip(pkt, opt_len)) {",
    "Code_function": "static inline int ipv6_handle_ext_hdr_options(struct net_pkt *pkt,\n\t\t\t\t\t      struct net_ipv6_hdr *hdr,\n\t\t\t\t\t      u16_t pkt_len)\n{\n\tu16_t exthdr_len = 0U;\n\tu16_t length = 0U;\n\n\tif (net_pkt_read_u8(pkt, (u8_t *)&exthdr_len)) {\n\t\treturn -ENOBUFS;\n\t}\n\n\texthdr_len = exthdr_len * 8U + 8;\n\tif (exthdr_len > pkt_len) {\n\t\tNET_DBG(\"Corrupted packet, extension header %d too long \"\n\t\t\t\"(max %d bytes)\", exthdr_len, pkt_len);\n\t\treturn -EINVAL;\n\t}\n\n\tlength += 2U;\n\n\twhile (length < exthdr_len) {\n\t\tu8_t opt_type, opt_len;\n\n\t\t/* Each extension option has type and length */\n\t\tif (net_pkt_read_u8(pkt, &opt_type)) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tif (opt_type != NET_IPV6_EXT_HDR_OPT_PAD1) {\n\t\t\tif (net_pkt_read_u8(pkt, &opt_len)) {\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t}\n\n\t\tswitch (opt_type) {\n\t\tcase NET_IPV6_EXT_HDR_OPT_PAD1:\n\t\t\tlength++;\n\t\t\tbreak;\n\t\tcase NET_IPV6_EXT_HDR_OPT_PADN:\n\t\t\tNET_DBG(\"PADN option\");\n\t\t\tlength += opt_len + 2;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Make sure that the option length is not too large.\n\t\t\t * The former 1 + 1 is the length of extension type +\n\t\t\t * length fields.\n\t\t\t * The latter 1 + 1 is the length of the sub-option\n\t\t\t * type and length fields.\n\t\t\t */\n\t\t\tif (opt_len > (exthdr_len - (1 + 1 + 1 + 1))) {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (ipv6_drop_on_unknown_option(pkt, hdr,\n\t\t\t\t\t\t\topt_type, length)) {\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\n\t\t\tif (net_pkt_skip(pkt, opt_len)) {\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\n\t\t\tlength += opt_len + 2;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn exthdr_len;\n}"
}