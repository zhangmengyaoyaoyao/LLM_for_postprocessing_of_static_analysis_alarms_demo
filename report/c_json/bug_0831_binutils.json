{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "      if (! elf_i386_tls_transition (info, abfd, sec, NULL,",
    "Code_function": "elf_i386_gc_sweep_hook (bfd *abfd,\n\t\t\tstruct bfd_link_info *info,\n\t\t\tasection *sec,\n\t\t\tconst Elf_Internal_Rela *relocs)\n{\n  struct elf_i386_link_hash_table *htab;\n  Elf_Internal_Shdr *symtab_hdr;\n  struct elf_link_hash_entry **sym_hashes;\n  bfd_signed_vma *local_got_refcounts;\n  const Elf_Internal_Rela *rel, *relend;\n\n  if (info->relocatable)\n    return TRUE;\n\n  htab = elf_i386_hash_table (info);\n  if (htab == NULL)\n    return FALSE;\n\n  elf_section_data (sec)->local_dynrel = NULL;\n\n  symtab_hdr = &elf_symtab_hdr (abfd);\n  sym_hashes = elf_sym_hashes (abfd);\n  local_got_refcounts = elf_local_got_refcounts (abfd);\n\n  relend = relocs + sec->reloc_count;\n  for (rel = relocs; rel < relend; rel++)\n    {\n      unsigned long r_symndx;\n      unsigned int r_type;\n      struct elf_link_hash_entry *h = NULL;\n\n      r_symndx = ELF32_R_SYM (rel->r_info);\n      if (r_symndx >= symtab_hdr->sh_info)\n\t{\n\t  h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n\t  while (h->root.type == bfd_link_hash_indirect\n\t\t || h->root.type == bfd_link_hash_warning)\n\t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\t}\n      else\n\t{\n\t  /* A local symbol.  */\n\t  Elf_Internal_Sym *isym;\n\n\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n\t\t\t\t\tabfd, r_symndx);\n\n\t  /* Check relocation against local STT_GNU_IFUNC symbol.  */\n\t  if (isym != NULL\n\t      && ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)\n\t    {\n\t      h = elf_i386_get_local_sym_hash (htab, abfd, rel, FALSE);\n\t      if (h == NULL)\n\t\tabort ();\n\t    }\n\t}\n\n      if (h)\n\t{\n\t  struct elf_i386_link_hash_entry *eh;\n\t  struct elf_dyn_relocs **pp;\n\t  struct elf_dyn_relocs *p;\n\n\t  eh = (struct elf_i386_link_hash_entry *) h;\n\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)\n\t    if (p->sec == sec)\n\t      {\n\t\t/* Everything must go for SEC.  */\n\t\t*pp = p->next;\n\t\tbreak;\n\t      }\n\t}\n\n      r_type = ELF32_R_TYPE (rel->r_info);\n      if (! elf_i386_tls_transition (info, abfd, sec, NULL,\n\t\t\t\t     symtab_hdr, sym_hashes,\n\t\t\t\t     &r_type, GOT_UNKNOWN,\n\t\t\t\t     rel, relend, h, r_symndx))\n\treturn FALSE;\n\n      switch (r_type)\n\t{\n\tcase R_386_TLS_LDM:\n\t  if (htab->tls_ldm_got.refcount > 0)\n\t    htab->tls_ldm_got.refcount -= 1;\n\t  break;\n\n\tcase R_386_TLS_GD:\n\tcase R_386_TLS_GOTDESC:\n\tcase R_386_TLS_DESC_CALL:\n\tcase R_386_TLS_IE_32:\n\tcase R_386_TLS_IE:\n\tcase R_386_TLS_GOTIE:\n\tcase R_386_GOT32:\n\t  if (h != NULL)\n\t    {\n\t      if (h->got.refcount > 0)\n\t\th->got.refcount -= 1;\n\t      if (h->type == STT_GNU_IFUNC)\n\t\t{\n\t\t  if (h->plt.refcount > 0)\n\t\t    h->plt.refcount -= 1;\n\t\t}\n\t    }\n\t  else if (local_got_refcounts != NULL)\n\t    {\n\t      if (local_got_refcounts[r_symndx] > 0)\n\t\tlocal_got_refcounts[r_symndx] -= 1;\n\t    }\n\t  break;\n\n\tcase R_386_32:\n\tcase R_386_PC32:\n\tcase R_386_SIZE32:\n\t  if (info->shared\n\t      && (h == NULL || h->type != STT_GNU_IFUNC))\n\t    break;\n\t  /* Fall through */\n\n\tcase R_386_PLT32:\n\t  if (h != NULL)\n\t    {\n\t      if (h->plt.refcount > 0)\n\t\th->plt.refcount -= 1;\n\t    }\n\t  break;\n\n\tcase R_386_GOTOFF:\n\t  if (h != NULL && h->type == STT_GNU_IFUNC)\n\t    {\n\t      if (h->got.refcount > 0)\n\t\th->got.refcount -= 1;\n\t      if (h->plt.refcount > 0)\n\t\th->plt.refcount -= 1;\n\t    }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n\n  return TRUE;\n}"
}