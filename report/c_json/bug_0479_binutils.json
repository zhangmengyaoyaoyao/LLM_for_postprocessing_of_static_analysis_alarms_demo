{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/cofflink.c",
    "message": "Offset added: [-20, 219] (⇐ [-108, 131] + 88) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "coff_link_add_symbols",
    "warning_line": "stab->used_by_bfd = bfd_zalloc (abfd, amt);",
    "warning_context": "  \t\t    }\n  \t\t  (*sym_hash)->auxbfd = abfd;\n\t\t  if (sym.n_numaux != 0)\n\t\t    {\n\t\t      union internal_auxent *alloc;\n\t\t      unsigned int i;\n\t\t      bfd_byte *eaux;\n\t\t      union internal_auxent *iaux;\n\n\t\t      (*sym_hash)->numaux = sym.n_numaux;\n\t\t      alloc = ((union internal_auxent *)\n\t\t\t       bfd_hash_allocate (&info->hash->table,\n\t\t\t\t\t\t  (sym.n_numaux\n\t\t\t\t\t\t   * sizeof (*alloc))));\n\t\t      if (alloc == NULL)\n\t\t\tgoto error_return;\n\t\t      for (i = 0, eaux = esym + symesz, iaux = alloc;\n\t\t\t   i < sym.n_numaux;\n\t\t\t   i++, eaux += symesz, iaux++)\n\t\t\tbfd_coff_swap_aux_in (abfd, eaux, sym.n_type,\n\t\t\t\t\t      sym.n_sclass, (int) i,\n\t\t\t\t\t      sym.n_numaux, iaux);\n\t\t      (*sym_hash)->aux = alloc;\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (classification == COFF_SYMBOL_PE_SECTION\n\t      && (*sym_hash)->numaux != 0)\n\t    {\n\t      /* Some PE sections (such as .bss) have a zero size in\n                 the section header, but a non-zero size in the AUX\n                 record.  Correct that here.\n\n\t\t FIXME: This is not at all the right place to do this.\n\t\t For example, it won't help objdump.  This needs to be\n\t\t done when we swap in the section header.  */\n\t      BFD_ASSERT ((*sym_hash)->numaux == 1);\n\t      if (section->size == 0)\n\t\tsection->size = (*sym_hash)->aux[0].x_scn.x_scnlen;\n\n\t      /* FIXME: We could test whether the section sizes\n                 matches the size in the aux entry, but apparently\n                 that sometimes fails unexpectedly.  */\n\t    }\n\t}\n\n      esym += (sym.n_numaux + 1) * symesz;\n      sym_hash += sym.n_numaux + 1;\n    }\n\n  /* If this is a non-traditional, non-relocatable link, try to\n     optimize the handling of any .stab/.stabstr sections.  */\n  if (! info->relocatable\n      && ! info->traditional_format\n      && bfd_get_flavour (info->output_bfd) == bfd_get_flavour (abfd)\n      && (info->strip != strip_all && info->strip != strip_debugger))\n    {\n      asection *stabstr;\n\n      stabstr = bfd_get_section_by_name (abfd, \".stabstr\");\n\n      if (stabstr != NULL)\n\t{\n\t  bfd_size_type string_offset = 0;\n\t  asection *stab;\n\n\t  for (stab = abfd->sections; stab; stab = stab->next)\n\t    if (CONST_STRNEQ (stab->name, \".stab\")\n\t\t&& (!stab->name[5]\n\t\t    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))\n\t    {\n\t      struct coff_link_hash_table *table;\n\t      struct coff_section_tdata *secdata\n\t\t= coff_section_data (abfd, stab);\n\n\t      if (secdata == NULL)\n\t\t{\n\t\t  amt = sizeof (struct coff_section_tdata);\n\t\t  stab->used_by_bfd = bfd_zalloc (abfd, amt);\n\t\t  if (stab->used_by_bfd == NULL)\n\t\t    goto error_return;\n\t\t  secdata = coff_section_data (abfd, stab);\n\t\t}\n\n\t      table = coff_hash_table (info);\n\n\t      if (! _bfd_link_section_stabs (abfd, &table->stab_info,\n\t\t\t\t\t     stab, stabstr,\n\t\t\t\t\t     &secdata->stab_info,\n\t\t\t\t\t     &string_offset))\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  obj_coff_keep_syms (abfd) = keep_syms;\n\n  return TRUE;\n\n error_return:\n"
}