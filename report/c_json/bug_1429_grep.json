{
    "Project": "grep",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "lib/fts.c",
    "message": "Offset added: [1, +oo] Size: [0, +oo].",
    "warning_function_name": "fts_read",
    "warning_line": "memmove(t, p->fts_name, p->fts_namelen + 1);",
    "warning_context": "                        if (ISSET(FTS_STOP))\n                                return (NULL);\n                        /* If fts_build's call to fts_safe_changedir failed\n                           because it was not able to fchdir into a\n                           subdirectory, tell the caller.  */\n                        if (p->fts_errno && p->fts_info != FTS_DNR)\n                                p->fts_info = FTS_ERR;\n                        LEAVE_DIR (sp, p, \"2\");\n                        return (p);\n                }\n                p = sp->fts_child;\n                sp->fts_child = NULL;\n                goto name;\n        }\n\n        /* Move to the next node on this level. */\nnext:   tmp = p;\n\n        /* If we have so many directory entries that we're reading them\n           in batches, and we've reached the end of the current batch,\n           read in a new batch.  */\n        if (p->fts_link == NULL && p->fts_parent->fts_dirp)\n          {\n            p = tmp->fts_parent;\n            sp->fts_cur = p;\n            sp->fts_path[p->fts_pathlen] = '\\0';\n\n            if ((p = fts_build (sp, BREAD)) == NULL)\n              {\n                if (ISSET(FTS_STOP))\n                  return NULL;\n                goto cd_dot_dot;\n              }\n\n            free(tmp);\n            goto name;\n          }\n\n        if ((p = p->fts_link) != NULL) {\n                sp->fts_cur = p;\n                free(tmp);\n\n                /*\n                 * If reached the top, return to the original directory (or\n                 * the root of the tree), and load the file names for the next\n                 * root.\n                 */\n                if (p->fts_level == FTS_ROOTLEVEL) {\n                        if (restore_initial_cwd(sp)) {\n                                SET(FTS_STOP);\n                                return (NULL);\n                        }\n                        free_dir(sp);\n                        fts_load(sp, p);\n                        setup_dir(sp);\n                        goto check_for_dir;\n                }\n\n                /*\n                 * User may have called fts_set on the node.  If skipped,\n                 * ignore.  If followed, get a file descriptor so we can\n                 * get back if necessary.\n                 */\n                if (p->fts_instr == FTS_SKIP)\n                        goto next;\n                if (p->fts_instr == FTS_FOLLOW) {\n                        p->fts_info = fts_stat(sp, p, true);\n                        if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                                if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                        p->fts_errno = errno;\n                                        p->fts_info = FTS_ERR;\n                                } else\n                                        p->fts_flags |= FTS_SYMFOLLOW;\n                        }\n                        p->fts_instr = FTS_NOINSTR;\n                }\n\nname:           t = sp->fts_path + NAPPEND(p->fts_parent);\n                *t++ = '/';\n                memmove(t, p->fts_name, p->fts_namelen + 1);\ncheck_for_dir:\n                sp->fts_cur = p;\n                if (p->fts_info == FTS_NSOK)\n                  {\n                    if (p->fts_statp->st_size == FTS_STAT_REQUIRED)\n                      {\n                        FTSENT *parent = p->fts_parent;\n                        if (FTS_ROOTLEVEL < p->fts_level\n                            /* ->fts_n_dirs_remaining is not valid\n                               for command-line-specified names.  */\n                            && parent->fts_n_dirs_remaining == 0\n                            && ISSET(FTS_NOSTAT)\n                            && ISSET(FTS_PHYSICAL)\n                            && link_count_optimize_ok (parent))\n                          {\n                            /* nothing more needed */\n                          }\n                        else\n                          {\n                            p->fts_info = fts_stat(sp, p, false);\n                            if (S_ISDIR(p->fts_statp->st_mode)\n"
}