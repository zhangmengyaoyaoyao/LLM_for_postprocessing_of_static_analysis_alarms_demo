{
    "Project": "RIOT",
    "Tool": "Cppcheck",
    "category": "Uninitialized Variable",
    "file": "sys/net/gnrc/network_layer/sixlowpan/iphc/gnrc_sixlowpan_iphc.c",
    "message": "Uninitialized variable: ipv6_hdr",
    "warning_function_name": "gnrc_sixlowpan_iphc_recv",
    "warning_line": "ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));",
    "warning_context": "#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_VRB */\n\n    if (rbuf != NULL) {\n        ipv6 = rbuf->pkt;\n        assert(ipv6 != NULL);\n    }\n    else {\n        ipv6 = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),\n                               GNRC_NETTYPE_IPV6);\n        if (ipv6 == NULL) {\n            gnrc_pktbuf_release(sixlo);\n            return;\n        }\n    }\n\n    assert(ipv6->size >= sizeof(ipv6_hdr_t));\n\n    netif = gnrc_pktsnip_search_type(sixlo, GNRC_NETTYPE_NETIF);\n    assert(netif != NULL);\n    iface = gnrc_netif_hdr_get_netif(netif->data);\n    payload_offset = _iphc_ipv6_decode(iphc_hdr, netif->data, iface,\n                                       ipv6->data);\n    if (payload_offset == 0) {\n        /* unable to parse IPHC header */\n        _recv_error_release(sixlo, ipv6, rbuf);\n        return;\n    }\n#ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC\n    if (iphc_hdr[IPHC1_IDX] & SIXLOWPAN_IPHC1_NH) {\n        bool nhc_header = true;\n        ipv6_hdr = ipv6->data;\n        size_t prev_nh_offset = (&ipv6_hdr->nh) - ((uint8_t *)ipv6->data);\n\n        while (nhc_header) {\n            switch (iphc_hdr[payload_offset] & NHC_ID_MASK) {\n                case NHC_IPV6_EXT_ID:\n                case NHC_IPV6_EXT_ID_ALT:\n                    payload_offset = _iphc_nhc_ipv6_decode(sixlo,\n                                                           payload_offset,\n                                                           rbuf,\n                                                           &prev_nh_offset,\n                                                           ipv6,\n                                                           &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* prev_nh_offset is set to 0 if next header is not\n                     * compressed (== NH flag in compression header not set) */\n                    nhc_header = (prev_nh_offset > 0);\n                    break;\n                case NHC_UDP_ID: {\n                    payload_offset = _iphc_nhc_udp_decode(sixlo,\n                                                          payload_offset,\n                                                          rbuf,\n                                                          prev_nh_offset,\n                                                          ipv6,\n                                                          &uncomp_hdr_len);\n                    if (payload_offset == 0) {\n                        _recv_error_release(sixlo, ipv6, rbuf);\n                        return;\n                    }\n                    /* no NHC after UDP header */\n                    nhc_header = false;\n                    break;\n                }\n                default:\n                    nhc_header = false;\n                    break;\n            }\n        }\n    }\n#endif\n    uint16_t payload_len;\n    if (rbuf != NULL) {\n        /* for a fragmented datagram we know the overall length already */\n        payload_len = (uint16_t)(rbuf->super.datagram_size - sizeof(ipv6_hdr_t));\n#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_VRB\n        DEBUG(\"6lo iphc: VRB present, trying to create entry for dst %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6_hdr->dst, sizeof(addr_str)));\n        /* re-assign IPv6 header in case realloc changed the address */\n        ipv6_hdr = ipv6->data;\n        /* only create virtual reassembly buffer entry from IPv6 destination if\n         * the current first fragment is the only received fragment in the\n         * reassembly buffer so far and the hop-limit is larger than 1\n         */\n        if ((rbuf->super.current_size <= sixlo->size) && (ipv6_hdr->hl > 1U) &&\n            /* and there is enough slack for changing compression */\n            (rbuf->super.current_size <= iface->sixlo.max_frag_size) &&\n            (vrbe = gnrc_sixlowpan_frag_vrb_from_route(&rbuf->super, iface,\n                                                       ipv6))) {\n            /* add netif header to `ipv6` so its flags can be used when\n             * forwarding the fragment */\n            LL_DELETE(sixlo, netif);\n            LL_APPEND(ipv6, netif);\n            /* provide space to copy remaining payload */\n            if (gnrc_pktbuf_realloc_data(ipv6, uncomp_hdr_len + sixlo->size -\n                                         payload_offset) != 0) {\n                DEBUG(\"6lo iphc: no space left to copy payload\\n\");\n                gnrc_sixlowpan_frag_vrb_rm(vrbe);\n                _recv_error_release(sixlo, ipv6, rbuf);\n"
}