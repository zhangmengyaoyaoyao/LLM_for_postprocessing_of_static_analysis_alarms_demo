{
    "Project": "apr",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "memory/unix/apr_pools.c",
    "message": "Access to field 'allocator' results in a dereference of a null pointer (loaded from variable 'parent')",
    "warning_function_name": "apr_pool_create_ex",
    "warning_line": "allocator = parent->allocator;",
    "warning_context": "APR_DECLARE(apr_status_t) apr_pool_create_ex(apr_pool_t **newpool,\n                                             apr_pool_t *parent,\n                                             apr_abortfunc_t abort_fn,\n                                             apr_allocator_t *allocator)\n{\n    apr_pool_t *pool;\n    apr_memnode_t *node;\n\n    *newpool = NULL;\n\n    if (!parent)\n        parent = global_pool;\n\n    /* parent will always be non-NULL here except the first time a\n     * pool is created, in which case allocator is guaranteed to be\n     * non-NULL. */\n\n    if (!abort_fn && parent)\n        abort_fn = parent->abort_fn;\n\n    if (allocator == NULL)\n        allocator = parent->allocator;\n\n    if ((node = allocator_alloc(allocator,\n                                MIN_ALLOC - APR_MEMNODE_T_SIZE)) == NULL) {\n        if (abort_fn)\n            abort_fn(APR_ENOMEM);\n\n        return APR_ENOMEM;\n    }\n\n    node->next = node;\n    node->ref = &node->next;\n\n    pool = (apr_pool_t *)node->first_avail;\n    node->first_avail = pool->self_first_avail = (char *)pool + SIZEOF_POOL_T;\n\n    pool->allocator = allocator;\n    pool->active = pool->self = node;\n    pool->abort_fn = abort_fn;\n    pool->child = NULL;\n    pool->cleanups = NULL;\n    pool->free_cleanups = NULL;\n    pool->pre_cleanups = NULL;\n    pool->subprocesses = NULL;\n    pool->user_data = NULL;\n    pool->tag = NULL;\n\n#ifdef NETWARE\n    pool->owner_proc = (apr_os_proc_t)getnlmhandle();\n#endif /* defined(NETWARE) */\n\n    if ((pool->parent = parent) != NULL) {\n#if APR_HAS_THREADS\n        apr_thread_mutex_t *mutex;\n\n        if ((mutex = apr_allocator_mutex_get(parent->allocator)) != NULL)\n            apr_thread_mutex_lock(mutex);\n#endif /* APR_HAS_THREADS */\n\n        if ((pool->sibling = parent->child) != NULL)\n            pool->sibling->ref = &pool->sibling;\n\n        parent->child = pool;\n        pool->ref = &parent->child;\n\n#if APR_HAS_THREADS\n        if (mutex)\n            apr_thread_mutex_unlock(mutex);\n#endif /* APR_HAS_THREADS */\n    }\n    else {\n        pool->sibling = NULL;\n        pool->ref = NULL;\n    }\n\n    *newpool = pool;\n\n    return APR_SUCCESS;\n}\n"
}