{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `code` last assigned on line 3173 could be null and is dereferenced by call to `strcmp()` at line 3267, column 11.",
    "Code_line": "\t    if (!strcmp (code, \"qu\"))",
    "Code_function": "d_expression_1 (struct d_info *di)\n{\n  char peek;\n\n  peek = d_peek_char (di);\n  if (peek == 'L')\n    return d_expr_primary (di);\n  else if (peek == 'T')\n    return d_template_param (di);\n  else if (peek == 's' && d_peek_next_char (di) == 'r')\n    {\n      struct demangle_component *type;\n      struct demangle_component *name;\n\n      d_advance (di, 2);\n      type = cplus_demangle_type (di);\n      name = d_unqualified_name (di);\n      if (d_peek_char (di) != 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n      else\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,\n\t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t\t\t d_template_args (di)));\n    }\n  else if (peek == 's' && d_peek_next_char (di) == 'p')\n    {\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t  d_expression_1 (di), NULL);\n    }\n  else if (peek == 'f' && d_peek_next_char (di) == 'p')\n    {\n      /* Function parameter used in a late-specified return type.  */\n      int index;\n      d_advance (di, 2);\n      if (d_peek_char (di) == 'T')\n\t{\n\t  /* 'this' parameter.  */\n\t  d_advance (di, 1);\n\t  index = 0;\n\t}\n      else\n\t{\n\t  index = d_compact_number (di) + 1;\n\t  if (index == 0)\n\t    return NULL;\n\t}\n      return d_make_function_param (di, index);\n    }\n  else if (IS_DIGIT (peek)\n\t   || (peek == 'o' && d_peek_next_char (di) == 'n'))\n    {\n      /* We can get an unqualified name as an expression in the case of\n         a dependent function call, i.e. decltype(f(t)).  */\n      struct demangle_component *name;\n\n      if (peek == 'o')\n\t/* operator-function-id, i.e. operator+(t).  */\n\td_advance (di, 2);\n\n      name = d_unqualified_name (di);\n      if (name == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t    d_template_args (di));\n      else\n\treturn name;\n    }\n  else if ((peek == 'i' || peek == 't')\n\t   && d_peek_next_char (di) == 'l')\n    {\n      /* Brace-enclosed initializer list, untyped or typed.  */\n      struct demangle_component *type = NULL;\n      if (peek == 't')\n\ttype = cplus_demangle_type (di);\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_INITIALIZER_LIST,\n\t\t\t  type, d_exprlist (di, 'E'));\n    }\n  else\n    {\n      struct demangle_component *op;\n      const char *code = NULL;\n      int args;\n\n      op = d_operator_name (di);\n      if (op == NULL)\n\treturn NULL;\n\n      if (op->type == DEMANGLE_COMPONENT_OPERATOR)\n\t{\n\t  code = op->u.s_operator.op->code;\n\t  di->expansion += op->u.s_operator.op->len - 2;\n\t  if (strcmp (code, \"st\") == 0)\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\tcplus_demangle_type (di));\n\t}\n\n      switch (op->type)\n\t{\n\tdefault:\n\t  return NULL;\n\tcase DEMANGLE_COMPONENT_OPERATOR:\n\t  args = op->u.s_operator.op->args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n\t  args = op->u.s_extended_operator.args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_CAST:\n\t  args = 1;\n\t  break;\n\t}\n\n      switch (args)\n\t{\n\tcase 0:\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_NULLARY, op, NULL);\n\n\tcase 1:\n\t  {\n\t    struct demangle_component *operand;\n\t    int suffix = 0;\n\n\t    if (code && (code[0] == 'p' || code[0] == 'm')\n\t\t&& code[1] == code[0])\n\t      /* pp_ and mm_ are the prefix variants.  */\n\t      suffix = !d_check_char (di, '_');\n\n\t    if (op->type == DEMANGLE_COMPONENT_CAST\n\t\t&& d_check_char (di, '_'))\n\t      operand = d_exprlist (di, 'E');\n\t    else\n\t      operand = d_expression_1 (di);\n\n\t    if (suffix)\n\t      /* Indicate the suffix variant for d_print_comp.  */\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  d_make_comp (di,\n\t\t\t\t\t       DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t       operand, operand));\n\t    else\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  operand);\n\t  }\n\tcase 2:\n\t  {\n\t    struct demangle_component *left;\n\t    struct demangle_component *right;\n\n\t    if (op_is_new_cast (op))\n\t      left = cplus_demangle_type (di);\n\t    else\n\t      left = d_expression_1 (di);\n\t    if (!strcmp (code, \"cl\"))\n\t      right = d_exprlist (di, 'E');\n\t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n\t      {\n\t\tright = d_unqualified_name (di);\n\t\tif (d_peek_char (di) == 'I')\n\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n\t\t\t\t       right, d_template_args (di));\n\t      }\n\t    else\n\t      right = d_expression_1 (di);\n\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t     left, right));\n\t  }\n\tcase 3:\n\t  {\n\t    struct demangle_component *first;\n\t    struct demangle_component *second;\n\t    struct demangle_component *third;\n\n\t    if (!strcmp (code, \"qu\"))\n\t      {\n\t\t/* ?: expression.  */\n\t\tfirst = d_expression_1 (di);\n\t\tsecond = d_expression_1 (di);\n\t\tthird = d_expression_1 (di);\n\t      }\n\t    else if (code[0] == 'n')\n\t      {\n\t\t/* new-expression.  */\n\t\tif (code[1] != 'w' && code[1] != 'a')\n\t\t  return NULL;\n\t\tfirst = d_exprlist (di, '_');\n\t\tsecond = cplus_demangle_type (di);\n\t\tif (d_peek_char (di) == 'E')\n\t\t  {\n\t\t    d_advance (di, 1);\n\t\t    third = NULL;\n\t\t  }\n\t\telse if (d_peek_char (di) == 'p'\n\t\t\t && d_peek_next_char (di) == 'i')\n\t\t  {\n\t\t    /* Parenthesized initializer.  */\n\t\t    d_advance (di, 2);\n\t\t    third = d_exprlist (di, 'E');\n\t\t  }\n\t\telse if (d_peek_char (di) == 'i'\n\t\t\t && d_peek_next_char (di) == 'l')\n\t\t  /* initializer-list.  */\n\t\t  third = d_expression_1 (di);\n\t\telse\n\t\t  return NULL;\n\t      }\n\t    else\n\t      return NULL;\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_TRINARY_ARG1,\n\t\t\t\t\t     first,\n\t\t\t\t\t     d_make_comp (di,\n\t\t\t\t\t\t\t  DEMANGLE_COMPONENT_TRINARY_ARG2,\n\t\t\t\t\t\t\t  second, third)));\n\t  }\n\tdefault:\n\t  return NULL;\n\t}\n    }\n}"
}