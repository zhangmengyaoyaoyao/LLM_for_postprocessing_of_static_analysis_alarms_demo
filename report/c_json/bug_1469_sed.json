{
    "Project": "sed",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "sed/execute.c",
    "message": "Offset added: [1, +oo] Size: [0, +oo] by call to `str_append`.",
    "warning_function_name": "do_subst",
    "warning_line": "str_append(&s_accum, line.active + start, line.length-start);",
    "warning_context": "      if (regs.start[0] == 0 && !sub->global)\n        {\n\t  /* We found a match, set the `replaced' flag. */\n\t  replaced = true;\n\n\t  line.active += regs.end[0];\n\t  line.length -= regs.end[0];\n\t  line.alloc -= regs.end[0];\n\t  goto post_subst;\n        }\n      else if (regs.end[0] == line.length)\n        {\n\t  /* We found a match, set the `replaced' flag. */\n\t  replaced = true;\n\n\t  line.length = regs.start[0];\n\t  goto post_subst;\n        }\n    }\n\n  do\n    {\n      enum replacement_types repl_mod = 0;\n\n      size_t offset = regs.start[0];\n      size_t matched = regs.end[0] - regs.start[0];\n\n      /* Copy stuff to the left of this match into the output string. */\n      if (start < offset)\n\tstr_append(&s_accum, line.active + start, offset - start);\n\n      /* If we're counting up to the Nth match, are we there yet?\n         And even if we are there, there is another case we have to\n\t skip: are we matching an empty string immediately following\n         another match?\n\n         This latter case avoids that baaaac, when passed through\n         s,a*,x,g, gives `xbxxcx' instead of xbxcx.  This behavior is\n         unacceptable because it is not consistently applied (for\n         example, `baaaa' gives `xbx', not `xbxx'). */\n      if ((matched > 0 || count == 0 || offset > last_end)\n\t  && ++count >= sub->numb)\n        {\n          /* We found a match, set the `replaced' flag. */\n          replaced = true;\n\n          /* Now expand the replacement string into the output string. */\n          repl_mod = append_replacement (&s_accum, sub->replacement, &regs, repl_mod);\n\t  again = sub->global;\n        }\n      else\n\t{\n          /* The match was not replaced.  Copy the text until its\n             end; if it was vacuous, skip over one character and\n\t     add that character to the output.  */\n\t  if (matched == 0)\n\t    {\n\t      if (start < line.length)\n\t        matched = 1;\n\t      else\n\t        break;\n\t    }\n\n\t  str_append(&s_accum, line.active + offset, matched);\n        }\n\n      /* Start after the match.  last_end is the real end of the matched\n\t substring, excluding characters that were skipped in case the RE\n\t matched the empty string.  */\n      start = offset + matched;\n      last_end = regs.end[0];\n    }\n  while (again\n\t && start <= line.length\n\t && match_regex(sub->regx, line.active, line.length, start,\n\t\t\t&regs, sub->max_id + 1));\n\n  /* Copy stuff to the right of the last match into the output string. */\n  if (start < line.length)\n    str_append(&s_accum, line.active + start, line.length-start);\n  s_accum.chomped = line.chomped;\n\n  /* Exchange line and s_accum.  This can be much cheaper\n     than copying s_accum.active into line.text (for huge lines). */\n  line_exchange(&line, &s_accum, false);\n\n  /* Finish up. */\n  if (count < sub->numb)\n    return;\n\n post_subst:\n  if (sub->print & 1)\n    output_line(line.active, line.length, line.chomped, &output_file);\n  \n  if (sub->eval) \n    {\n#ifdef HAVE_POPEN\n      FILE *pipe_fp;\n      line_reset(&s_accum, NULL);\n      \n      str_append (&line, \"\", 1);\n"
}