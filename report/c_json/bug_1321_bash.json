{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from printed_len was never initialized.",
    "Code_line": "\t  printed_len++;",
    "Code_function": "print_filename (to_print, full_pathname, prefix_bytes)\n     char *to_print, *full_pathname;\n     int prefix_bytes;\n{\n  int printed_len, extension_char, slen, tlen;\n  char *s, c, *new_full_pathname, *dn;\n\n  extension_char = 0;\n#if defined (COLOR_SUPPORT)\n  /* Defer printing if we want to prefix with a color indicator */\n  if (_rl_colored_stats == 0 || rl_filename_completion_desired == 0)\n#endif\n    printed_len = fnprint (to_print, prefix_bytes);\n\n  if (rl_filename_completion_desired && (\n#if defined (VISIBLE_STATS)\n     rl_visible_stats ||\n#endif\n#if defined (COLOR_SUPPORT)\n     _rl_colored_stats ||\n#endif\n     _rl_complete_mark_directories))\n    {\n      /* If to_print != full_pathname, to_print is the basename of the\n\t path passed.  In this case, we try to expand the directory\n\t name before checking for the stat character. */\n      if (to_print != full_pathname)\n\t{\n\t  /* Terminate the directory name. */\n\t  c = to_print[-1];\n\t  to_print[-1] = '\\0';\n\n\t  /* If setting the last slash in full_pathname to a NUL results in\n\t     full_pathname being the empty string, we are trying to complete\n\t     files in the root directory.  If we pass a null string to the\n\t     bash directory completion hook, for example, it will expand it\n\t     to the current directory.  We just want the `/'. */\n\t  if (full_pathname == 0 || *full_pathname == 0)\n\t    dn = \"/\";\n\t  else if (full_pathname[0] != '/')\n\t    dn = full_pathname;\n\t  else if (full_pathname[1] == 0)\n\t    dn = \"//\";\t\t/* restore trailing slash to `//' */\n\t  else if (full_pathname[1] == '/' && full_pathname[2] == 0)\n\t    dn = \"/\";\t\t/* don't turn /// into // */\n\t  else\n\t    dn = full_pathname;\n\t  s = tilde_expand (dn);\n\t  if (rl_directory_completion_hook)\n\t    (*rl_directory_completion_hook) (&s);\n\n\t  slen = strlen (s);\n\t  tlen = strlen (to_print);\n\t  new_full_pathname = (char *)xmalloc (slen + tlen + 2);\n\t  strcpy (new_full_pathname, s);\n\t  if (s[slen - 1] == '/')\n\t    slen--;\n\t  else\n\t    new_full_pathname[slen] = '/';\n\t  new_full_pathname[slen] = '/';\n\t  strcpy (new_full_pathname + slen + 1, to_print);\n\n#if defined (VISIBLE_STATS)\n\t  if (rl_visible_stats)\n\t    extension_char = stat_char (new_full_pathname);\n\t  else\n#endif\n\t  if (_rl_complete_mark_directories)\n\t    {\n\t      dn = 0;\n\t      if (rl_directory_completion_hook == 0 && rl_filename_stat_hook)\n\t\t{\n\t\t  dn = savestring (new_full_pathname);\n\t\t  (*rl_filename_stat_hook) (&dn);\n\t\t  free (new_full_pathname);\n\t\t  new_full_pathname = dn;\n\t\t}\n\t      if (path_isdir (new_full_pathname))\n\t\textension_char = '/';\n\t    }\n\n#if defined (COLOR_SUPPORT)\n\t  if (_rl_colored_stats)\n\t    {\n\t      colored_stat_start (new_full_pathname);\n\t      printed_len = fnprint (to_print, prefix_bytes);\n\t      colored_stat_end ();\n\t    }\n#endif\n\n\t  xfree (new_full_pathname);\n\t  to_print[-1] = c;\n\t}\n      else\n\t{\n\t  s = tilde_expand (full_pathname);\n#if defined (VISIBLE_STATS)\n\t  if (rl_visible_stats)\n\t    extension_char = stat_char (s);\n\t  else\n#endif\n\t    if (_rl_complete_mark_directories && path_isdir (s))\n\t      extension_char = '/';\n\n#if defined (COLOR_SUPPORT)\n\t  if (_rl_colored_stats)\n\t    {\n\t      colored_stat_start (s);\n\t      printed_len = fnprint (to_print, prefix_bytes);\n\t      colored_stat_end ();\n\t    }\n#endif\n\n\t}\n\n      xfree (s);\n      if (extension_char)\n\t{\n\t  putc (extension_char, rl_outstream);\n\t  printed_len++;\n\t}\n    }\n\n  return printed_len;\n}"
}