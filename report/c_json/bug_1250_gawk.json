{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "builtin.c",
    "message": "Offset: [1, +oo] Size: [0, +oo] by call to `make_str_node`.",
    "warning_function_name": "do_substr",
    "warning_line": "return make_string(\"\", 0);",
    "warning_context": "NODE *\ndo_substr(int nargs)\n{\n\tNODE *t1;\n\tNODE *r;\n\tsize_t indx;\n\tsize_t length = 0;\n\tdouble d_index = 0, d_length = 0;\n\tsize_t src_len;\n\n\tif (nargs == 3) {\n\t\tt1 = POP_NUMBER();\n\t\td_length = get_number_d(t1);\n\t\tDEREF(t1);\n\t}\n\n\tt1 = POP_NUMBER();\n\td_index = get_number_d(t1);\n\tDEREF(t1);\n\n\tt1 = POP_STRING();\n\n\tif (nargs == 3) {\n\t\tif (! (d_length >= 1)) {\n\t\t\tif (do_lint == DO_LINT_ALL)\n\t\t\t\tlintwarn(_(\"substr: length %g is not >= 1\"), d_length);\n\t\t\telse if (do_lint == DO_LINT_INVALID && ! (d_length >= 0))\n\t\t\t\tlintwarn(_(\"substr: length %g is not >= 0\"), d_length);\n\t\t\tDEREF(t1);\n\t\t\t/*\n\t\t\t * Return explicit null string instead of doing\n\t\t\t * dupnode(Nnull_string) so that if the result\n\t\t\t * is checked with the combination of length()\n\t\t\t * and lint, no error is reported about using\n\t\t\t * an uninitialized value. Same thing later, too.\n\t\t\t */\n\t\t\treturn make_string(\"\", 0);\n\t\t}\n\t\tif (do_lint) {\n\t\t\tif (double_to_int(d_length) != d_length)\n\t\t\t\tlintwarn(\n\t\t\t_(\"substr: non-integer length %g will be truncated\"),\n\t\t\t\t\td_length);\n\n\t\t\tif (d_length > SIZE_MAX)\n\t\t\t\tlintwarn(\n\t\t\t_(\"substr: length %g too big for string indexing, truncating to %g\"),\n\t\t\t\t\td_length, (double) SIZE_MAX);\n\t\t}\n\t\tif (d_length < SIZE_MAX)\n\t\t\tlength = d_length;\n\t\telse\n\t\t\tlength = SIZE_MAX;\n\t}\n\n\t/* the weird `! (foo)' tests help catch NaN values. */\n\tif (! (d_index >= 1)) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is invalid, using 1\"),\n\t\t\t\t d_index);\n\t\td_index = 1;\n\t}\n\tif (do_lint && double_to_int(d_index) != d_index)\n\t\tlintwarn(_(\"substr: non-integer start index %g will be truncated\"),\n\t\t\t d_index);\n\n\t/* awk indices are from 1, C's are from 0 */\n\tif (d_index <= SIZE_MAX)\n\t\tindx = d_index - 1;\n\telse\n\t\tindx = SIZE_MAX;\n\n\tif (nargs == 2) {\t/* third arg. missing */\n\t\t/* use remainder of string */\n\t\tlength = t1->stlen - indx;\t/* default to bytes */\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tt1 = force_wstring(t1);\n\t\t\tif (t1->wstlen > 0)\t/* use length of wide char string if we have one */\n\t\t\t\tlength = t1->wstlen - indx;\n\t\t}\n\t\td_length = length;\t/* set here in case used in diagnostics, below */\n\t}\n\n\tif (t1->stlen == 0) {\n\t\t/* substr(\"\", 1, 0) produces a warning only if LINT_ALL */\n\t\tif (do_lint && (do_lint == DO_LINT_ALL || ((indx | length) != 0)))\n\t\t\tlintwarn(_(\"substr: source string is zero length\"));\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\n\t/* get total len of input string, for following checks */\n\tif (gawk_mb_cur_max > 1) {\n\t\tt1 = force_wstring(t1);\n\t\tsrc_len = t1->wstlen;\n\t} else\n\t\tsrc_len = t1->stlen;\n\n\tif (indx >= src_len) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is past end of string\"),\n"
}