{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "skip_to_delim",
    "warning_line": "ADVANCE_CHAR (string, slen, i);",
    "warning_context": "\t  backq = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (skipquote == 0 && invert == 0 && member (c, delims))\n\tbreak;\n      else if (c == '\\'' || c == '\"')\n\t{\n\t  i = (c == '\\'') ? skip_single_quoted (string, slen, ++i)\n\t\t\t  : skip_double_quoted (string, slen, ++i);\n\t  /* no increment, the skip functions increment past the closing quote. */\n\t}\n      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  if (string[i+1] == LPAREN)\n\t    temp = extract_delimited_string (string, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND); /* ) */\n\t  else\n\t    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#if defined (PROCESS_SUBSTITUTION)\n      else if (skipcmd && (c == '<' || c == '>') && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\t  temp = extract_process_subst (string, (c == '<') ? \"<(\" : \">(\", &si);\n\t  free (temp);\t\t/* no SX_ALLOC here */\n\t  i = si;\n\t  if (string[i] == '\\0')\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif /* PROCESS_SUBSTITUTION */\n#if defined (EXTENDED_GLOB)\n      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, \"?*+!@\"))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  open[0] = c;\n\t  open[1] = LPAREN;\n\t  open[2] = '\\0';\n\t  temp = extract_delimited_string (string, &si, open, \"(\", \")\", SX_NOALLOC); /* ) */\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif\n      else if ((flags & SD_GLOB) && c == LBRACK)\n\t{\n\t  si = i + 1;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  temp = extract_delimited_string (string, &si, \"[\", \"[\", \"]\", SX_NOALLOC); /* ] */\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else if ((skipquote || invert) && (member (c, delims) == 0))\n\tbreak;\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(i);\n}\n\n#if defined (READLINE)\n/* Return 1 if the portion of STRING ending at EINDEX is quoted (there is\n   an unclosed quoted string), or if the character at EINDEX is quoted\n   by a backslash. NO_LONGJMP_ON_FATAL_ERROR is used to flag that the various\n   single and double-quoted string parsing functions should not return an\n   error if there are unclosed quotes or braces.  The characters that this\n   recognizes need to be the same as the contents of\n   rl_completer_quote_characters. */\n\nint\nchar_is_quoted (string, eindex)\n     char *string;\n     int eindex;\n{\n  int i, pass_next, c;\n  size_t slen;\n"
}