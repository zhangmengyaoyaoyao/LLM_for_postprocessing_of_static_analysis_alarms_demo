{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t  inv_lbreaks[++newlines] = out + temp;",
    "Code_function": "rl_redisplay ()\n{\n  register int in, out, c, linenum, cursor_linenum;\n  register char *line;\n  int inv_botlin, lb_botlin, lb_linenum, o_cpos;\n  int newlines, lpos, temp, n0, num, prompt_lines_estimate;\n  char *prompt_this_line;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t wc;\n  size_t wc_bytes;\n  int wc_width;\n  mbstate_t ps;\n  int _rl_wrapped_multicolumn = 0;\n#endif\n\n  if (_rl_echoing_p == 0)\n    return;\n\n  /* Block keyboard interrupts because this function manipulates global\n     data structures. */\n  _rl_block_sigint ();\n  RL_SETSTATE (RL_STATE_REDISPLAYING);\n\n  if (!rl_display_prompt)\n    rl_display_prompt = \"\";\n\n  if (line_structures_initialized == 0)\n    {\n      init_line_structures (0);\n      rl_on_new_line ();\n    }\n\n  /* Draw the line into the buffer. */\n  cpos_buffer_position = -1;\n\n  prompt_multibyte_chars = prompt_visible_length - prompt_physical_chars;\n\n  line = invisible_line;\n  out = inv_botlin = 0;\n\n  /* Mark the line as modified or not.  We only do this for history\n     lines. */\n  modmark = 0;\n  if (_rl_mark_modified_lines && current_history () && rl_undo_list)\n    {\n      line[out++] = '*';\n      line[out] = '\\0';\n      modmark = 1;\n    }\n\n  /* If someone thought that the redisplay was handled, but the currently\n     visible line has a different modification state than the one about\n     to become visible, then correct the caller's misconception. */\n  if (visible_line[0] != invisible_line[0])\n    rl_display_fixed = 0;\n\n  /* If the prompt to be displayed is the `primary' readline prompt (the\n     one passed to readline()), use the values we have already expanded.\n     If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the\n     number of non-visible characters in the prompt string. */\n  if (rl_display_prompt == rl_prompt || local_prompt)\n    {\n      if (local_prompt_prefix && forced_display)\n\t_rl_output_some_chars (local_prompt_prefix, strlen (local_prompt_prefix));\n\n      if (local_prompt_len > 0)\n\t{\n\t  temp = local_prompt_len + out + 2;\n\t  if (temp >= line_size)\n\t    {\n\t      line_size = (temp + 1024) - (temp % 1024);\n\t      visible_line = (char *)xrealloc (visible_line, line_size);\n\t      line = invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t    }\n\t  strncpy (line + out, local_prompt, local_prompt_len);\n\t  out += local_prompt_len;\n\t}\n      line[out] = '\\0';\n      wrap_offset = local_prompt_len - prompt_visible_length;\n    }\n  else\n    {\n      int pmtlen;\n      prompt_this_line = strrchr (rl_display_prompt, '\\n');\n      if (!prompt_this_line)\n\tprompt_this_line = rl_display_prompt;\n      else\n\t{\n\t  prompt_this_line++;\n\t  pmtlen = prompt_this_line - rl_display_prompt;\t/* temp var */\n\t  if (forced_display)\n\t    {\n\t      _rl_output_some_chars (rl_display_prompt, pmtlen);\n\t      /* Make sure we are at column zero even after a newline,\n\t\t regardless of the state of terminal output processing. */\n\t      if (pmtlen < 2 || prompt_this_line[-2] != '\\r')\n\t\tcr ();\n\t    }\n\t}\n\n      prompt_physical_chars = pmtlen = strlen (prompt_this_line);\n      temp = pmtlen + out + 2;\n      if (temp >= line_size)\n\t{\n\t  line_size = (temp + 1024) - (temp % 1024);\n\t  visible_line = (char *)xrealloc (visible_line, line_size);\n\t  line = invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t}\n      strncpy (line + out,  prompt_this_line, pmtlen);\n      out += pmtlen;\n      line[out] = '\\0';\n      wrap_offset = prompt_invis_chars_first_line = 0;\n    }\n\n#define CHECK_INV_LBREAKS() \\\n      do { \\\n\tif (newlines >= (inv_lbsize - 2)) \\\n\t  { \\\n\t    inv_lbsize *= 2; \\\n\t    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t  } \\\n      } while (0)\n\n#if defined (HANDLE_MULTIBYTE)\n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    if (newlines >= (line_state_invisible->wbsize - 1)) \\\n\t      { \\\n\t\tline_state_invisible->wbsize *= 2; \\\n\t\tline_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \\\n\t      } \\\n\t    line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#else\n#define CHECK_LPOS() \\\n      do { \\\n\tlpos++; \\\n\tif (lpos >= _rl_screenwidth) \\\n\t  { \\\n\t    if (newlines >= (inv_lbsize - 2)) \\\n\t      { \\\n\t\tinv_lbsize *= 2; \\\n\t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n\t      } \\\n\t    inv_lbreaks[++newlines] = out; \\\n\t    lpos = 0; \\\n\t  } \\\n      } while (0)\n#endif\n\n  /* inv_lbreaks[i] is where line i starts in the buffer. */\n  inv_lbreaks[newlines = 0] = 0;\n  lpos = prompt_physical_chars + modmark;\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (line_state_invisible->wrapped_line, 0, line_state_invisible->wbsize * sizeof (int));\n  num = 0;\n#endif\n\n  /* prompt_invis_chars_first_line is the number of invisible characters in\n     the first physical line of the prompt.\n     wrap_offset - prompt_invis_chars_first_line is the number of invis\n     chars on the second (or, more generally, last) line. */\n\n  /* This is zero-based, used to set the newlines */\n  prompt_lines_estimate = lpos / _rl_screenwidth;\n\n  /* what if lpos is already >= _rl_screenwidth before we start drawing the\n     contents of the command line? */\n  while (lpos >= _rl_screenwidth)\n    {\n      int z;\n      /* fix from Darin Johnson <darin@acuson.com> for prompt string with\n         invisible characters that is longer than the screen width.  The\n         prompt_invis_chars_first_line variable could be made into an array\n         saying how many invisible characters there are per line, but that's\n         probably too much work for the benefit gained.  How many people have\n         prompts that exceed two physical lines?\n         Additional logic fix from Edward Catmur <ed@catmur.co.uk> */\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\t{\n\t  n0 = num;\n          temp = local_prompt_len;\n          while (num < temp)\n\t    {\n\t      z = _rl_col_width  (local_prompt, n0, num, 1);\n\t      if (z > _rl_screenwidth)\n\t\t{\n\t          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n\t          break;\n\t\t}\n\t      else if (z == _rl_screenwidth)\n\t        break;\n\t      num++;\n\t    }\n          temp = num;\n\t}\n      else\n#endif /* !HANDLE_MULTIBYTE */\n\ttemp = ((newlines + 1) * _rl_screenwidth);\n\n      /* Now account for invisible characters in the current line. */\n      /* XXX - this assumes that the invisible characters may be split, but only\n\t between the first and the last lines. */\n      temp += (newlines == 0) ? prompt_invis_chars_first_line\n\t\t\t      : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line);\n\n      inv_lbreaks[++newlines] = temp;\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\tlpos -= _rl_col_width (local_prompt, n0, num, 1);\n      else\n#endif\n\tlpos -= _rl_screenwidth;\n    }\n\n  prompt_last_screen_line = newlines;\n\n  /* Draw the rest of the line (after the prompt) into invisible_line, keeping\n     track of where the cursor is (cpos_buffer_position), the number of the line containing\n     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).\n     It maintains an array of line breaks for display (inv_lbreaks).\n     This handles expanding tabs for display and displaying meta characters. */\n  lb_linenum = 0;\n#if defined (HANDLE_MULTIBYTE)\n  in = 0;\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    {\n      memset (&ps, 0, sizeof (mbstate_t));\n      /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);\n    }\n  else\n    wc_bytes = 1;\n  while (in < rl_end)\n#else\n  for (in = 0; in < rl_end; in++)\n#endif\n    {\n      c = (unsigned char)rl_line_buffer[in];\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  if (MB_INVALIDCH (wc_bytes))\n\t    {\n\t      /* Byte sequence is invalid or shortened.  Assume that the\n\t         first byte represents a character. */\n\t      wc_bytes = 1;\n\t      /* Assume that a character occupies a single column. */\n\t      wc_width = 1;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t    }\n\t  else if (MB_NULLWCH (wc_bytes))\n\t    break;\t\t\t/* Found '\\0' */\n\t  else\n\t    {\n\t      temp = WCWIDTH (wc);\n\t      wc_width = (temp >= 0) ? temp : 1;\n\t    }\n\t}\n#endif\n\n      if (out + 8 >= line_size)\t\t/* XXX - 8 for \\t */\n\t{\n\t  line_size *= 2;\n\t  visible_line = (char *)xrealloc (visible_line, line_size);\n\t  invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t  line = invisible_line;\n\t}\n\n      if (in == rl_point)\n\t{\n\t  cpos_buffer_position = out;\n\t  lb_linenum = newlines;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (META_CHAR (c) && _rl_output_meta_chars == 0)\t/* XXX - clean up */\n#else\n      if (META_CHAR (c))\n#endif\n\t{\n\t  if (_rl_output_meta_chars == 0)\n\t    {\n\t      sprintf (line + out, \"\\\\%o\", c);\n\n\t      if (lpos + 4 >= _rl_screenwidth)\n\t\t{\n\t\t  temp = _rl_screenwidth - lpos;\n\t\t  CHECK_INV_LBREAKS ();\n\t\t  inv_lbreaks[++newlines] = out + temp;\n\t\t  lpos = 4 - temp;\n\t\t}\n\t      else\n\t\tlpos += 4;\n\n\t      out += 4;\n\t    }\n\t  else\n\t    {\n\t      line[out++] = c;\n\t      CHECK_LPOS();\n\t    }\n\t}\n#if defined (DISPLAY_TABS)\n      else if (c == '\\t')\n\t{\n\t  register int newout;\n\n#if 0\n\t  newout = (out | (int)7) + 1;\n#else\n\t  newout = out + 8 - lpos % 8;\n#endif\n\t  temp = newout - out;\n\t  if (lpos + temp >= _rl_screenwidth)\n\t    {\n\t      register int temp2;\n\t      temp2 = _rl_screenwidth - lpos;\n\t      CHECK_INV_LBREAKS ();\n\t      inv_lbreaks[++newlines] = out + temp2;\n\t      lpos = temp - temp2;\n\t      while (out < newout)\n\t\tline[out++] = ' ';\n\t    }\n\t  else\n\t    {\n\t      while (out < newout)\n\t\tline[out++] = ' ';\n\t      lpos += temp;\n\t    }\n\t}\n#endif\n      else if (c == '\\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n\t{\n\t  line[out++] = '\\0';\t/* XXX - sentinel */\n\t  CHECK_INV_LBREAKS ();\n\t  inv_lbreaks[++newlines] = out;\n\t  lpos = 0;\n\t}\n      else if (CTRL_CHAR (c) || c == RUBOUT)\n\t{\n\t  line[out++] = '^';\n\t  CHECK_LPOS();\n\t  line[out++] = CTRL_CHAR (c) ? UNCTRL (c) : '?';\n\t  CHECK_LPOS();\n\t}\n      else\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t    {\n\t      register int i;\n\n\t      _rl_wrapped_multicolumn = 0;\n\n\t      if (_rl_screenwidth < lpos + wc_width)\n\t\tfor (i = lpos; i < _rl_screenwidth; i++)\n\t\t  {\n\t\t    /* The space will be removed in update_line() */\n\t\t    line[out++] = ' ';\n\t\t    _rl_wrapped_multicolumn++;\n\t\t    CHECK_LPOS();\n\t\t  }\n\t      if (in == rl_point)\n\t\t{\n\t\t  cpos_buffer_position = out;\n\t\t  lb_linenum = newlines;\n\t\t}\n\t      for (i = in; i < in+wc_bytes; i++)\n\t\tline[out++] = rl_line_buffer[i];\n\t      for (i = 0; i < wc_width; i++)\n\t\tCHECK_LPOS();\n\t    }\n\t  else\n\t    {\n\t      line[out++] = c;\n\t      CHECK_LPOS();\n\t    }\n#else\n\t  line[out++] = c;\n\t  CHECK_LPOS();\n#endif\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  in += wc_bytes;\n\t  /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n\t  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);\n\t}\n      else\n        in++;\n#endif\n\n    }\n  line[out] = '\\0';\n  if (cpos_buffer_position < 0)\n    {\n      cpos_buffer_position = out;\n      lb_linenum = newlines;\n    }\n\n  inv_botlin = lb_botlin = newlines;\n  CHECK_INV_LBREAKS ();\n  inv_lbreaks[newlines+1] = out;\n  cursor_linenum = lb_linenum;\n\n  /* CPOS_BUFFER_POSITION == position in buffer where cursor should be placed.\n     CURSOR_LINENUM == line number where the cursor should be placed. */\n\n  /* PWP: now is when things get a bit hairy.  The visible and invisible\n     line buffers are really multiple lines, which would wrap every\n     (screenwidth - 1) characters.  Go through each in turn, finding\n     the changed region and updating it.  The line order is top to bottom. */\n\n  /* If we can move the cursor up and down, then use multiple lines,\n     otherwise, let long lines display in a single terminal line, and\n     horizontally scroll it. */\n  displaying_prompt_first_line = 1;\n  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n    {\n      int nleft, pos, changed_screen_line, tx;\n\n      if (!rl_display_fixed || forced_display)\n\t{\n\t  forced_display = 0;\n\n\t  /* If we have more than a screenful of material to display, then\n\t     only display a screenful.  We should display the last screen,\n\t     not the first.  */\n\t  if (out >= _rl_screenchars)\n\t    {\n\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t\tout = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);\n\t      else\n\t\tout = _rl_screenchars - 1;\n\t    }\n\n\t  /* The first line is at character position 0 in the buffer.  The\n\t     second and subsequent lines start at inv_lbreaks[N], offset by\n\t     OFFSET (which has already been calculated above).  */\n\n#define INVIS_FIRST()\t(prompt_physical_chars > _rl_screenwidth ? prompt_invis_chars_first_line : wrap_offset)\n#define WRAP_OFFSET(line, offset)  ((line == 0) \\\n\t\t\t\t\t? (offset ? INVIS_FIRST() : 0) \\\n\t\t\t\t\t: ((line == prompt_last_screen_line) ? wrap_offset-prompt_invis_chars_first_line : 0))\n#define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)\n#define VIS_LLEN(l)\t((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))\n#define INV_LLEN(l)\t(inv_lbreaks[l+1] - inv_lbreaks[l])\n#define VIS_CHARS(line) (visible_line + vis_lbreaks[line])\n#define VIS_LINE(line) ((line) > _rl_vis_botlin) ? \"\" : VIS_CHARS(line)\n#define INV_LINE(line) (invisible_line + inv_lbreaks[line])\n\n#define OLD_CPOS_IN_PROMPT() (cpos_adjusted == 0 && \\\n\t\t\t_rl_last_c_pos != o_cpos && \\\n\t\t\t_rl_last_c_pos > wrap_offset && \\\n\t\t\to_cpos < prompt_last_invisible)\n\n\t  /* For each line in the buffer, do the updating display. */\n\t  for (linenum = 0; linenum <= inv_botlin; linenum++)\n\t    {\n\t      /* This can lead us astray if we execute a program that changes\n\t\t the locale from a non-multibyte to a multibyte one. */\n\t      o_cpos = _rl_last_c_pos;\n\t      cpos_adjusted = 0;\n\t      update_line (VIS_LINE(linenum), INV_LINE(linenum), linenum,\n\t\t\t   VIS_LLEN(linenum), INV_LLEN(linenum), inv_botlin);\n\n\t      /* update_line potentially changes _rl_last_c_pos, but doesn't\n\t\t take invisible characters into account, since _rl_last_c_pos\n\t\t is an absolute cursor position in a multibyte locale.  See\n\t\t if compensating here is the right thing, or if we have to\n\t\t change update_line itself.  There are several cases in which\n\t\t update_line adjusts _rl_last_c_pos itself (so it can pass\n\t\t _rl_move_cursor_relative accurate values); it communicates\n\t\t this back by setting cpos_adjusted.  If we assume that\n\t\t _rl_last_c_pos is correct (an absolute cursor position) each\n\t\t time update_line is called, then we can assume in our\n\t\t calculations that o_cpos does not need to be adjusted by\n\t\t wrap_offset. */\n\t      if (linenum == 0 && (MB_CUR_MAX > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n\t\t_rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n\t      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&\n\t\t\t(MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&\n\t\t\tcpos_adjusted == 0 &&\n\t\t\t_rl_last_c_pos != o_cpos &&\n\t\t\t_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))\n\t\t_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);\n\n\t      /* If this is the line with the prompt, we might need to\n\t\t compensate for invisible characters in the new line. Do\n\t\t this only if there is not more than one new line (which\n\t\t implies that we completely overwrite the old visible line)\n\t\t and the new line is shorter than the old.  Make sure we are\n\t\t at the end of the new line before clearing. */\n\t      if (linenum == 0 &&\n\t\t  inv_botlin == 0 && _rl_last_c_pos == out &&\n\t\t  (wrap_offset > visible_wrap_offset) &&\n\t\t  (_rl_last_c_pos < visible_first_line_len))\n\t\t{\n\t\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t\t    nleft = _rl_screenwidth - _rl_last_c_pos;\n\t\t  else\n\t\t    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;\n\t\t  if (nleft)\n\t\t    _rl_clear_to_eol (nleft);\n\t\t}\n#if 0\n\t      /* This segment is intended to handle the case where the prompt\n\t\t has invisible characters on the second line and the new line\n\t\t to be displayed needs to clear the rest of the old characters\n\t\t out (e.g., when printing the i-search prompt).  In general,\n\t\t the case of the new line being shorter than the old.\n\t\t Incomplete */\n\t      else if (linenum == prompt_last_screen_line &&\n\t\t       prompt_physical_chars > _rl_screenwidth &&\n\t\t       wrap_offset != prompt_invis_chars_first_line &&\n\t\t       _rl_last_c_pos == out &&\n#endif\n\n\n\t      /* Since the new first line is now visible, save its length. */\n\t      if (linenum == 0)\n\t\tvisible_first_line_len = (inv_botlin > 0) ? inv_lbreaks[1] : out - wrap_offset;\n\t    }\n\n\t  /* We may have deleted some lines.  If so, clear the left over\n\t     blank ones at the bottom out. */\n\t  if (_rl_vis_botlin > inv_botlin)\n\t    {\n\t      char *tt;\n\t      for (; linenum <= _rl_vis_botlin; linenum++)\n\t\t{\n\t\t  tt = VIS_CHARS (linenum);\n\t\t  _rl_move_vert (linenum);\n\t\t  _rl_move_cursor_relative (0, tt);\n\t\t  _rl_clear_to_eol\n\t\t    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);\n\t\t}\n\t    }\n\t  _rl_vis_botlin = inv_botlin;\n\n\t  /* CHANGED_SCREEN_LINE is set to 1 if we have moved to a\n\t     different screen line during this redisplay. */\n\t  changed_screen_line = _rl_last_v_pos != cursor_linenum;\n\t  if (changed_screen_line)\n\t    {\n\t      _rl_move_vert (cursor_linenum);\n\t      /* If we moved up to the line with the prompt using _rl_term_up,\n\t\t the physical cursor position on the screen stays the same,\n\t\t but the buffer position needs to be adjusted to account\n\t\t for invisible characters. */\n\t      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)\n\t\t_rl_last_c_pos += wrap_offset;\n\t    }\n\n\t  /* We have to reprint the prompt if it contains invisible\n\t     characters, since it's not generally OK to just reprint\n\t     the characters from the current cursor position.  But we\n\t     only need to reprint it if the cursor is before the last\n\t     invisible character in the prompt string. */\n\t  nleft = prompt_visible_length + wrap_offset;\n\t  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&\n#if 0\n\t      _rl_last_c_pos <= PROMPT_ENDING_INDEX && local_prompt)\n#else\n\t      _rl_last_c_pos < PROMPT_ENDING_INDEX && local_prompt)\n#endif\n\t    {\n#if defined (__MSDOS__)\n\t      putc ('\\r', rl_outstream);\n#else\n\t      if (_rl_term_cr)\n\t\ttputs (_rl_term_cr, 1, _rl_output_character_function);\n#endif\n\t      if (modmark)\n\t\t_rl_output_some_chars (\"*\", 1);\n\n\t      _rl_output_some_chars (local_prompt, nleft);\n\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t\t_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft, 1) - wrap_offset + modmark;\n\t      else\n\t\t_rl_last_c_pos = nleft + modmark;\n\t    }\n\n\t  /* Where on that line?  And where does that line start\n\t     in the buffer? */\n\t  pos = inv_lbreaks[cursor_linenum];\n\t  /* nleft == number of characters in the line buffer between the\n\t     start of the line and the desired cursor position. */\n\t  nleft = cpos_buffer_position - pos;\n\n\t  /* NLEFT is now a number of characters in a buffer.  When in a\n\t     multibyte locale, however, _rl_last_c_pos is an absolute cursor\n\t     position that doesn't take invisible characters in the prompt\n\t     into account.  We use a fudge factor to compensate. */\n\n\t  /* Since _rl_backspace() doesn't know about invisible characters in the\n\t     prompt, and there's no good way to tell it, we compensate for\n\t     those characters here and call _rl_backspace() directly. */\n\t  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)\n\t    {\n\t      /* TX == new physical cursor position in multibyte locale. */\n\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t\ttx = _rl_col_width (&visible_line[pos], 0, nleft, 1) - visible_wrap_offset;\n\t      else\n\t\ttx = nleft;\n\t      if (tx >= 0 && _rl_last_c_pos > tx)\n\t\t{\n\t          _rl_backspace (_rl_last_c_pos - tx);\t/* XXX */\n\t          _rl_last_c_pos = tx;\n\t\t}\n\t    }\n\n\t  /* We need to note that in a multibyte locale we are dealing with\n\t     _rl_last_c_pos as an absolute cursor position, but moving to a\n\t     point specified by a buffer position (NLEFT) that doesn't take\n\t     invisible characters into account. */\n\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n\t  else if (nleft != _rl_last_c_pos)\n\t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n\t}\n    }\n  else\t\t\t\t/* Do horizontal scrolling. */\n    {\n#define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)\n      int lmargin, ndisp, nleft, phys_c_pos, t;\n\n      /* Always at top line. */\n      _rl_last_v_pos = 0;\n\n      /* Compute where in the buffer the displayed line should start.  This\n\t will be LMARGIN. */\n\n      /* The number of characters that will be displayed before the cursor. */\n      ndisp = cpos_buffer_position - wrap_offset;\n      nleft  = prompt_visible_length + wrap_offset;\n      /* Where the new cursor position will be on the screen.  This can be\n\t longer than SCREENWIDTH; if it is, lmargin will be adjusted. */\n      phys_c_pos = cpos_buffer_position - (last_lmargin ? last_lmargin : wrap_offset);\n      t = _rl_screenwidth / 3;\n\n      /* If the number of characters had already exceeded the screenwidth,\n\t last_lmargin will be > 0. */\n\n      /* If the number of characters to be displayed is more than the screen\n\t width, compute the starting offset so that the cursor is about\n\t two-thirds of the way across the screen. */\n      if (phys_c_pos > _rl_screenwidth - 2)\n\t{\n\t  lmargin = cpos_buffer_position - (2 * t);\n\t  if (lmargin < 0)\n\t    lmargin = 0;\n\t  /* If the left margin would be in the middle of a prompt with\n\t     invisible characters, don't display the prompt at all. */\n\t  if (wrap_offset && lmargin > 0 && lmargin < nleft)\n\t    lmargin = nleft;\n\t}\n      else if (ndisp < _rl_screenwidth - 2)\t\t/* XXX - was -1 */\n\tlmargin = 0;\n      else if (phys_c_pos < 1)\n\t{\n\t  /* If we are moving back towards the beginning of the line and\n\t     the last margin is no longer correct, compute a new one. */\n\t  lmargin = ((cpos_buffer_position - 1) / t) * t;\t/* XXX */\n\t  if (wrap_offset && lmargin > 0 && lmargin < nleft)\n\t    lmargin = nleft;\n\t}\n      else\n\tlmargin = last_lmargin;\n\n      displaying_prompt_first_line = lmargin < nleft;\n\n      /* If the first character on the screen isn't the first character\n\t in the display line, indicate this with a special character. */\n      if (lmargin > 0)\n\tline[lmargin] = '<';\n\n      /* If SCREENWIDTH characters starting at LMARGIN do not encompass\n\t the whole line, indicate that with a special character at the\n\t right edge of the screen.  If LMARGIN is 0, we need to take the\n\t wrap offset into account. */\n      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;\n      if (t < out)\n\tline[t - 1] = '>';\n\n      if (rl_display_fixed == 0 || forced_display || lmargin != last_lmargin)\n\t{\n\t  forced_display = 0;\n\t  o_cpos = _rl_last_c_pos;\n\t  cpos_adjusted = 0;\n\t  update_line (&visible_line[last_lmargin],\n\t\t       &invisible_line[lmargin],\n\t\t       0,\n\t\t       _rl_screenwidth + visible_wrap_offset,\n\t\t       _rl_screenwidth + (lmargin ? 0 : wrap_offset),\n\t\t       0);\n\n\t  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&\n\t\tdisplaying_prompt_first_line && OLD_CPOS_IN_PROMPT())\n\t    _rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n\n\t  /* If the visible new line is shorter than the old, but the number\n\t     of invisible characters is greater, and we are at the end of\n\t     the new line, we need to clear to eol. */\n\t  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);\n\t  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&\n\t      (_rl_last_c_pos == out) && displaying_prompt_first_line &&\n\t      t < visible_first_line_len)\n\t    {\n\t      nleft = _rl_screenwidth - t;\n\t      _rl_clear_to_eol (nleft);\n\t    }\n\t  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);\n\t  if (visible_first_line_len > _rl_screenwidth)\n\t    visible_first_line_len = _rl_screenwidth;\n\n\t  _rl_move_cursor_relative (cpos_buffer_position - lmargin, &invisible_line[lmargin]);\n\t  last_lmargin = lmargin;\n\t}\n    }\n  fflush (rl_outstream);\n\n  /* Swap visible and non-visible lines. */\n  {\n    struct line_state *vtemp = line_state_visible;\n\n    line_state_visible = line_state_invisible;\n    line_state_invisible = vtemp;\n\n    rl_display_fixed = 0;\n    /* If we are displaying on a single line, and last_lmargin is > 0, we\n       are not displaying any invisible characters, so set visible_wrap_offset\n       to 0. */\n    if (_rl_horizontal_scroll_mode && last_lmargin)\n      visible_wrap_offset = 0;\n    else\n      visible_wrap_offset = wrap_offset;\n  }\n\n  RL_UNSETSTATE (RL_STATE_REDISPLAYING);\n  _rl_release_sigint ();\n}"
}