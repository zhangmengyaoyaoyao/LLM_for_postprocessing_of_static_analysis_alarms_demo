{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "execute_cmd.c",
    "message": "Access to field 'line' results in a dereference of a null pointer (loaded from variable 'tc')",
    "warning_function_name": "execute_function",
    "warning_line": "line_number = function_line_number = tc->line;",
    "warning_context": "  temporary_env = (HASH_TABLE *)NULL;\n\n  this_shell_function = var;\n  make_funcname_visible (1);\n\n  debug_trap = TRAP_STRING(DEBUG_TRAP);\n  error_trap = TRAP_STRING(ERROR_TRAP);\n  return_trap = TRAP_STRING(RETURN_TRAP);\n  \n  /* The order of the unwind protects for debug_trap, error_trap and\n     return_trap is important here!  unwind-protect commands are run\n     in reverse order of registration.  If this causes problems, take\n     out the xfree unwind-protect calls and live with the small memory leak. */\n\n  /* function_trace_mode != 0 means that all functions inherit the DEBUG trap.\n     if the function has the trace attribute set, it inherits the DEBUG trap */\n  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))\n    {\n      if (subshell == 0)\n\t{\n\t  debug_trap = savestring (debug_trap);\n\t  add_unwind_protect (xfree, debug_trap);\n\t  add_unwind_protect (set_debug_trap, debug_trap);\n\t}\n      restore_default_signal (DEBUG_TRAP);\n    }\n\n  /* error_trace_mode != 0 means that functions inherit the ERR trap. */\n  if (error_trap && error_trace_mode == 0)\n    {\n      if (subshell == 0)\n\t{\n\t  error_trap = savestring (error_trap);\n\t  add_unwind_protect (xfree, error_trap);\n\t  add_unwind_protect (set_error_trap, error_trap);\n\t}\n      restore_default_signal (ERROR_TRAP);\n    }\n\n  /* Shell functions inherit the RETURN trap if function tracing is on\n     globally or on individually for this function. */\n#if 0\n  if (return_trap && ((trace_p (var) == 0) && function_trace_mode == 0))\n#else\n  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))\n#endif\n    {\n      if (subshell == 0)\n\t{\n\t  return_trap = savestring (return_trap);\n\t  add_unwind_protect (xfree, return_trap);\n\t  add_unwind_protect (set_return_trap, return_trap);\n\t}\n      restore_default_signal (RETURN_TRAP);\n    }\n  \n  funcnest++;\n#if defined (ARRAY_VARS)\n  /* This is quite similar to the code in shell.c and elsewhere. */\n  shell_fn = find_function_def (this_shell_function->name);\n  sfile = shell_fn ? shell_fn->source_file : \"\";\n  array_push ((ARRAY *)funcname_a, this_shell_function->name);\n\n  array_push ((ARRAY *)bash_source_a, sfile);\n  t = itos (executing_line_number ());\n  array_push ((ARRAY *)bash_lineno_a, t);\n  free (t);\n#endif\n\n  /* The temporary environment for a function is supposed to apply to\n     all commands executed within the function body. */\n\n  remember_args (words->next, 1);\n\n  /* Update BASH_ARGV and BASH_ARGC */\n  if (debugging_mode)\n    push_args (words->next);\n\n  /* Number of the line on which the function body starts. */\n  line_number = function_line_number = tc->line;\n\n#if defined (JOB_CONTROL)\n  if (subshell)\n    stop_pipeline (async, (COMMAND *)NULL);\n#endif\n\n  fc = tc;\n\n  return_catch_flag++;\n  return_val = setjmp_nosigs (return_catch);\n\n  if (return_val)\n    {\n      result = return_catch_value;\n      /* Run the RETURN trap in the function's context. */\n      save_current = currently_executing_command;\n      run_return_trap ();\n      currently_executing_command = save_current;\n    }\n  else\n    {\n"
}