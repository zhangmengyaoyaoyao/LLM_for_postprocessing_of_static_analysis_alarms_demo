{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset: [1, +oo] Size: [0, +oo].",
    "warning_function_name": "elf_link_add_object_symbols",
    "warning_line": "h = sorted_sym_hash[idx];",
    "warning_context": "\t defined symbol, search time for N weak defined symbols will be\n\t O(N^2). Binary search will cut it down to O(NlogN).  */\n      amt = extsymcount * sizeof (struct elf_link_hash_entry *);\n      sorted_sym_hash = (struct elf_link_hash_entry **) bfd_malloc (amt);\n      if (sorted_sym_hash == NULL)\n\tgoto error_return;\n      sym_hash = sorted_sym_hash;\n      hpp = elf_sym_hashes (abfd);\n      hppend = hpp + extsymcount;\n      sym_count = 0;\n      for (; hpp < hppend; hpp++)\n\t{\n\t  h = *hpp;\n\t  if (h != NULL\n\t      && h->root.type == bfd_link_hash_defined\n\t      && !bed->is_function_type (h->type))\n\t    {\n\t      *sym_hash = h;\n\t      sym_hash++;\n\t      sym_count++;\n\t    }\n\t}\n\n      qsort (sorted_sym_hash, sym_count,\n\t     sizeof (struct elf_link_hash_entry *),\n\t     elf_sort_symbol);\n\n      while (weaks != NULL)\n\t{\n\t  struct elf_link_hash_entry *hlook;\n\t  asection *slook;\n\t  bfd_vma vlook;\n\t  size_t i, j, idx = 0;\n\n\t  hlook = weaks;\n\t  weaks = hlook->u.weakdef;\n\t  hlook->u.weakdef = NULL;\n\n\t  BFD_ASSERT (hlook->root.type == bfd_link_hash_defined\n\t\t      || hlook->root.type == bfd_link_hash_defweak\n\t\t      || hlook->root.type == bfd_link_hash_common\n\t\t      || hlook->root.type == bfd_link_hash_indirect);\n\t  slook = hlook->root.u.def.section;\n\t  vlook = hlook->root.u.def.value;\n\n\t  i = 0;\n\t  j = sym_count;\n\t  while (i != j)\n\t    {\n\t      bfd_signed_vma vdiff;\n\t      idx = (i + j) / 2;\n\t      h = sorted_sym_hash[idx];\n\t      vdiff = vlook - h->root.u.def.value;\n\t      if (vdiff < 0)\n\t\tj = idx;\n\t      else if (vdiff > 0)\n\t\ti = idx + 1;\n\t      else\n\t\t{\n\t\t  long sdiff = slook->id - h->root.u.def.section->id;\n\t\t  if (sdiff < 0)\n\t\t    j = idx;\n\t\t  else if (sdiff > 0)\n\t\t    i = idx + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t    }\n\n\t  /* We didn't find a value/section match.  */\n\t  if (i == j)\n\t    continue;\n\n\t  /* With multiple aliases, or when the weak symbol is already\n\t     strongly defined, we have multiple matching symbols and\n\t     the binary search above may land on any of them.  Step\n\t     one past the matching symbol(s).  */\n\t  while (++idx != j)\n\t    {\n\t      h = sorted_sym_hash[idx];\n\t      if (h->root.u.def.section != slook\n\t\t  || h->root.u.def.value != vlook)\n\t\tbreak;\n\t    }\n\n\t  /* Now look back over the aliases.  Since we sorted by size\n\t     as well as value and section, we'll choose the one with\n\t     the largest size.  */\n\t  while (idx-- != i)\n\t    {\n\t      h = sorted_sym_hash[idx];\n\n\t      /* Stop if value or section doesn't match.  */\n\t      if (h->root.u.def.section != slook\n\t\t  || h->root.u.def.value != vlook)\n\t\tbreak;\n\t      else if (h != hlook)\n\t\t{\n\t\t  hlook->u.weakdef = h;\n\n\t\t  /* If the weak definition is in the list of dynamic\n"
}