{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.uninitialized.Assign",
    "file": "execute_cmd.c",
    "message": "Assigned value is garbage or undefined",
    "warning_function_name": "execute_simple_command",
    "warning_line": "executing_builtin = old_builtin;",
    "warning_context": "\t    }\n\n\t  subshell_level++;\n\t  execute_subshell_builtin_or_function\n\t    (words, simple_command->redirects, builtin, func,\n\t     pipe_in, pipe_out, async, fds_to_close,\n\t     simple_command->flags);\n\t  subshell_level--;\n\t}\n      else\n\t{\n\t  result = execute_builtin_or_function\n\t    (words, builtin, func, simple_command->redirects, fds_to_close,\n\t     simple_command->flags);\n\t  if (builtin)\n\t    {\n\t      if (result > EX_SHERRBASE)\n\t\t{\n\t\t  switch (result)\n\t\t    {\n\t\t    case EX_REDIRFAIL:\n\t\t    case EX_BADASSIGN:\n\t\t    case EX_EXPFAIL:\n\t\t      /* These errors cause non-interactive posix mode shells to exit */\n\t\t      if (posixly_correct && builtin_is_special && interactive_shell == 0)\n\t\t\t{\n\t\t\t  last_command_exit_value = EXECUTION_FAILURE;\n\t\t\t  jump_to_top_level (ERREXIT);\n\t\t\t}\n\t\t    }\n\t\t  result = builtin_status (result);\n\t\t  if (builtin_is_special)\n\t\t    special_builtin_failed = 1;\n\t\t}\n\t      /* In POSIX mode, if there are assignment statements preceding\n\t\t a special builtin, they persist after the builtin\n\t\t completes. */\n\t      if (posixly_correct && builtin_is_special && temporary_env)\n\t\tmerge_temporary_env ();\n\t    }\n\t  else\t\t/* function */\n\t    {\n\t      if (result == EX_USAGE)\n\t\tresult = EX_BADUSAGE;\n\t      else if (result > EX_SHERRBASE)\n\t\tresult = EXECUTION_FAILURE;\n\t    }\n\n\t  set_pipestatus_from_exit (result);\n\n\t  goto return_result;\n\t}\n    }\n\n  if (autocd && interactive && words->word && is_dirname (words->word->word))\n    {\n      words = make_word_list (make_word (\"cd\"), words);\n      xtrace_print_word_list (words, 0);\n      goto run_builtin;\n    }\n\n  if (command_line == 0)\n    command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : \"\");\n\n#if defined (PROCESS_SUBSTITUTION)\n  if ((subshell_environment & SUBSHELL_COMSUB) && (simple_command->flags & CMD_NO_FORK) && fifos_pending() > 0)\n    simple_command->flags &= ~CMD_NO_FORK;\n#endif\n\n  result = execute_disk_command (words, simple_command->redirects, command_line,\n\t\t\tpipe_in, pipe_out, async, fds_to_close,\n\t\t\tsimple_command->flags);\n\n return_result:\n  bind_lastarg (lastarg);\n  FREE (command_line);\n  dispose_words (words);\n  if (builtin)\n    {\n      executing_builtin = old_builtin;\n      executing_command_builtin = old_command_builtin;\n    }\n  discard_unwind_frame (\"simple-command\");\n  this_command_name = (char *)NULL;\t/* points to freed memory now */\n  return (result);\n}\n\n/* Translate the special builtin exit statuses.  We don't really need a\n   function for this; it's a placeholder for future work. */\nstatic int\nbuiltin_status (result)\n     int result;\n{\n  int r;\n\n  switch (result)\n    {\n    case EX_USAGE:\n      r = EX_BADUSAGE;\n      break;\n    case EX_REDIRFAIL:\n"
}