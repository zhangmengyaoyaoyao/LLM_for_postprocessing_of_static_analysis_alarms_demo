{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t  && append_type (info, \" */;\\n\")",
    "Code_function": "pr_class_static_method_variant (void *p, const char *physname,\n\t\t\t\tenum debug_visibility visibility,\n\t\t\t\tbfd_boolean constp, bfd_boolean volatilep)\n{\n  struct pr_handle *info = (struct pr_handle *) p;\n  char *method_type;\n\n  assert (info->stack != NULL);\n  assert (info->stack->next != NULL);\n  assert (info->stack->next->method != NULL);\n\n  /* Put the const and volatile qualifiers on the type.  */\n  if (volatilep)\n    {\n      if (! append_type (info, \" volatile\"))\n\treturn FALSE;\n    }\n  if (constp)\n    {\n      if (! append_type (info, \" const\"))\n\treturn FALSE;\n    }\n\n  /* Mark it as static.  */\n  if (! prepend_type (info, \"static \"))\n    return FALSE;\n\n  /* Stick the name of the method into its type.  */\n  if (! substitute_type (info, info->stack->next->method))\n    return FALSE;\n\n  /* Get the type.  */\n  method_type = pop_type (info);\n  if (method_type == NULL)\n    return FALSE;\n\n  /* Now the top of the stack is the class.  */\n\n  if (! pr_fix_visibility (info, visibility))\n    return FALSE;\n\n  return (append_type (info, method_type)\n\t  && append_type (info, \" /* \")\n\t  && append_type (info, physname)\n\t  && append_type (info, \" */;\\n\")\n\t  && indent_type (info));\n}"
}