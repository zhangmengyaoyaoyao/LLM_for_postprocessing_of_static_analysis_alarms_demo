{
    "Project": "grep",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "lib/mbsstr.c",
    "message": "Offset: [1, +oo] (‚áê [0, +oo] + [1, +oo]) Size: [0, +oo].",
    "warning_function_name": "knuth_morris_pratt_multibyte",
    "warning_line": "size_t count = table[j];",
    "warning_context": "     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        mbchar_t *b = &needle_mbchars[i - 1];\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (mb_equal (*b, needle_mbchars[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    mbui_iterator_t rhaystack;\n    mbui_iterator_t phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    mbui_init (rhaystack, haystack);\n    mbui_init (phaystack, haystack);\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (mbui_avail (phaystack))\n      if (mb_equal (needle_mbchars[j], mbui_cur (phaystack)))\n        {\n          j++;\n          mbui_advance (phaystack);\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = mbui_cur_ptr (rhaystack);\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          size_t count = table[j];\n          j -= count;\n          for (; count > 0; count--)\n            {\n              if (!mbui_avail (rhaystack))\n                abort ();\n              mbui_advance (rhaystack);\n            }\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          if (!mbui_avail (rhaystack))\n            abort ();\n          mbui_advance (rhaystack);\n          mbui_advance (phaystack);\n        }\n  }\n\n  freea (memory);\n  return true;\n}\n"
}