{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "command.c",
    "message": "Offset: [-59, 54] Size: 55.",
    "warning_function_name": "yyparse",
    "warning_line": "yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;",
    "warning_context": "\t\t\tyyerror(_(\"non-zero integer value\"));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2222 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 152:\n#line 716 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif ((yyvsp[0])->a_int == 0)\n\t\t\tyyerror(_(\"non-zero integer value\"));\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2232 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 153:\n#line 725 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2238 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 154:\n#line 727 \"command.y\" /* yacc.c:1646  */\n    { (yyval) = (yyvsp[0]); }\n#line 2244 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 155:\n#line 729 \"command.y\" /* yacc.c:1646  */\n    {\n\t\t(yyvsp[0])->a_int = - (yyvsp[0])->a_int;\n\t\t(yyval) = (yyvsp[0]);\n\t  }\n#line 2253 \"command.c\" /* yacc.c:1646  */\n    break;\n\n  case 156:\n#line 737 \"command.y\" /* yacc.c:1646  */\n    {\n\t\tif (lexptr_begin != NULL) {\n\t\t\tif (input_from_tty && lexptr_begin[0] != '\\0')\n\t\t\t\tadd_history(lexptr_begin);\n\t\t\tefree(lexptr_begin);\n\t\t\tlexptr_begin = NULL;\n\t\t}\n\t  }\n#line 2266 \"command.c\" /* yacc.c:1646  */\n    break;\n\n\n#line 2270 \"command.c\" /* yacc.c:1646  */\n      default: break;\n    }\n  /* User semantic actions sometimes alter yychar, and that requires\n     that yytoken be updated with the new translation.  We take the\n     approach of translating immediately before every use of yytoken.\n     One alternative is translating here after every semantic action,\n     but that translation would be missed if the semantic action invokes\n     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or\n     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an\n     incorrect destructor might then be invoked immediately.  In the\n     case of YYERROR or YYBACKUP, subsequent parser actions might lead\n     to an incorrect destructor call or verbose syntax error message\n     before the lookahead is translated.  */\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n  /* Now 'shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*--------------------------------------.\n| yyerrlab -- here on detecting error.  |\n`--------------------------------------*/\nyyerrlab:\n  /* Make sure we have latest lookahead translation.  See comments at\n     user semantic actions for why this is necessary.  */\n  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);\n\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n"
}