{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "bfd/elf.c",
    "message": "Offset: [max(1, `abfd->tdata.elf_obj_data->strtab_hdr.sh_name`), `abfd->tdata.elf_obj_data->strtab_hdr.sh_name`] Size: [0, +oo] by call to `_bfd_elf_strtab_addref`.",
    "warning_function_name": "assign_section_numbers",
    "warning_line": "_bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);",
    "warning_context": "  struct elf_obj_tdata *t = elf_tdata (abfd);\n  asection *sec;\n  unsigned int section_number, secn;\n  Elf_Internal_Shdr **i_shdrp;\n  struct bfd_elf_section_data *d;\n  bfd_boolean need_symtab;\n\n  section_number = 1;\n\n  _bfd_elf_strtab_clear_all_refs (elf_shstrtab (abfd));\n\n  /* SHT_GROUP sections are in relocatable files only.  */\n  if (link_info == NULL || link_info->relocatable)\n    {\n      /* Put SHT_GROUP sections first.  */\n      for (sec = abfd->sections; sec != NULL; sec = sec->next)\n\t{\n\t  d = elf_section_data (sec);\n\n\t  if (d->this_hdr.sh_type == SHT_GROUP)\n\t    {\n\t      if (sec->flags & SEC_LINKER_CREATED)\n\t\t{\n\t\t  /* Remove the linker created SHT_GROUP sections.  */\n\t\t  bfd_section_list_remove (abfd, sec);\n\t\t  abfd->section_count--;\n\t\t}\n\t      else\n\t\td->this_idx = section_number++;\n\t    }\n\t}\n    }\n\n  for (sec = abfd->sections; sec; sec = sec->next)\n    {\n      d = elf_section_data (sec);\n\n      if (d->this_hdr.sh_type != SHT_GROUP)\n\td->this_idx = section_number++;\n      _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->this_hdr.sh_name);\n      if (d->rel.hdr)\n\t{\n\t  d->rel.idx = section_number++;\n\t  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel.hdr->sh_name);\n\t}\n      else\n\td->rel.idx = 0;\n\n      if (d->rela.hdr)\n\t{\n\t  d->rela.idx = section_number++;\n\t  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rela.hdr->sh_name);\n\t}\n      else\n\td->rela.idx = 0;\n    }\n\n  elf_shstrtab_sec (abfd) = section_number++;\n  _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->shstrtab_hdr.sh_name);\n  elf_elfheader (abfd)->e_shstrndx = elf_shstrtab_sec (abfd);\n\n  need_symtab = (bfd_get_symcount (abfd) > 0\n\t\t|| (link_info == NULL\n\t\t    && ((abfd->flags & (EXEC_P | DYNAMIC | HAS_RELOC))\n\t\t\t== HAS_RELOC)));\n  if (need_symtab)\n    {\n      elf_onesymtab (abfd) = section_number++;\n      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->symtab_hdr.sh_name);\n      if (section_number > ((SHN_LORESERVE - 2) & 0xFFFF))\n\t{\n\t  elf_symtab_shndx (abfd) = section_number++;\n\t  t->symtab_shndx_hdr.sh_name\n\t    = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),\n\t\t\t\t\t\t  \".symtab_shndx\", FALSE);\n\t  if (t->symtab_shndx_hdr.sh_name == (unsigned int) -1)\n\t    return FALSE;\n\t}\n      elf_strtab_sec (abfd) = section_number++;\n      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);\n    }\n\n  if (section_number >= SHN_LORESERVE)\n    {\n      _bfd_error_handler (_(\"%B: too many sections: %u\"),\n\t\t\t  abfd, section_number);\n      return FALSE;\n    }\n\n  _bfd_elf_strtab_finalize (elf_shstrtab (abfd));\n  t->shstrtab_hdr.sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));\n\n  elf_numsections (abfd) = section_number;\n  elf_elfheader (abfd)->e_shnum = section_number;\n\n  /* Set up the list of section header pointers, in agreement with the\n     indices.  */\n  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc2 (abfd, section_number,\n                                                sizeof (Elf_Internal_Shdr *));\n  if (i_shdrp == NULL)\n    return FALSE;\n"
}