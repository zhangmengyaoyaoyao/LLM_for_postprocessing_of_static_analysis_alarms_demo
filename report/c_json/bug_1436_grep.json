{
    "Project": "grep",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "src/dfa.c",
    "message": "Offset: [0, 255] Size: 8 by call to `setbit`.",
    "warning_function_name": "lex",
    "warning_line": "setbit (c2, ccl);",
    "warning_context": "                          maxrep = MIN (RE_DUP_MAX + 1, maxrep * 10 + *p - '0');\n                      }\n                  }\n              }\n            if (! ((! backslash || (p != lim && *p++ == '\\\\'))\n                   && p != lim && *p++ == '}'\n                   && 0 <= minrep && (maxrep < 0 || minrep <= maxrep)))\n              {\n                if (syntax_bits & RE_INVALID_INTERVAL_ORD)\n                  goto normal_char;\n                dfaerror (_(\"invalid content of \\\\{\\\\}\"));\n              }\n            if (RE_DUP_MAX < maxrep)\n              dfaerror (_(\"regular expression too big\"));\n            lexptr = p;\n            lexleft = lim - p;\n          }\n          laststart = false;\n          return lasttok = REPMN;\n\n        case '|':\n          if (syntax_bits & RE_LIMITED_OPS)\n            goto normal_char;\n          if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))\n            goto normal_char;\n          laststart = true;\n          return lasttok = OR;\n\n        case '\\n':\n          if (syntax_bits & RE_LIMITED_OPS\n              || backslash || !(syntax_bits & RE_NEWLINE_ALT))\n            goto normal_char;\n          laststart = true;\n          return lasttok = OR;\n\n        case '(':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          ++parens;\n          laststart = true;\n          return lasttok = LPAREN;\n\n        case ')':\n          if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))\n            goto normal_char;\n          if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)\n            goto normal_char;\n          --parens;\n          laststart = false;\n          return lasttok = RPAREN;\n\n        case '.':\n          if (backslash)\n            goto normal_char;\n          if (dfa->multibyte)\n            {\n              /* In multibyte environment period must match with a single\n                 character not a byte.  So we use ANYCHAR.  */\n              laststart = false;\n              return lasttok = ANYCHAR;\n            }\n          zeroset (ccl);\n          notset (ccl);\n          if (!(syntax_bits & RE_DOT_NEWLINE))\n            clrbit (eolbyte, ccl);\n          if (syntax_bits & RE_DOT_NOT_NULL)\n            clrbit ('\\0', ccl);\n          laststart = false;\n          return lasttok = CSET + charclass_index (ccl);\n\n        case 's':\n        case 'S':\n          if (!backslash || (syntax_bits & RE_NO_GNU_OPS))\n            goto normal_char;\n          if (!dfa->multibyte)\n            {\n              zeroset (ccl);\n              for (c2 = 0; c2 < NOTCHAR; ++c2)\n                if (isspace (c2))\n                  setbit (c2, ccl);\n              if (c == 'S')\n                notset (ccl);\n              laststart = false;\n              return lasttok = CSET + charclass_index (ccl);\n            }\n\n          /* FIXME: see if optimizing this, as is done with ANYCHAR and\n             add_utf8_anychar, makes sense.  */\n\n          /* \\s and \\S are documented to be equivalent to [[:space:]] and\n             [^[:space:]] respectively, so tell the lexer to process those\n             strings, each minus its \"already processed\" '['.  */\n          PUSH_LEX_STATE (c == 's' ? \"[:space:]]\" : \"^[:space:]]\");\n\n          lasttok = parse_bracket_exp ();\n\n          POP_LEX_STATE ();\n\n          laststart = false;\n          return lasttok;\n\n"
}