{
    "Project": "tiff",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `sect_buff` last assigned on line 7185 could be null and is dereferenced by call to `_TIFFmemset()` at line 7190, column 7.",
    "Code_line": "      _TIFFmemset(sect_buff, 0, sectsize);",
    "Code_function": "static int  createImageSection(uint32, unsigned char **);\nstatic int  extractImageSection(struct image_data *, struct pageseg *,\n                                unsigned char *, unsigned char *);\nstatic int  writeSingleSection(TIFF *, TIFF *, struct image_data *,\n                               struct dump_opts *, uint32, uint32,\n\t\t\t       double, double, unsigned char *);\nstatic int  writeImageSections(TIFF *, TIFF *, struct image_data *,\n                               struct pagedef *, struct pageseg *,\n                               struct dump_opts *, unsigned char *,\n                               unsigned char **);\n/* Whole image functions */\nstatic int  createCroppedImage(struct image_data *, struct crop_mask *,\n                               unsigned char **, unsigned char **);\nstatic int  writeCroppedImage(TIFF *, TIFF *, struct image_data *image,\n                              struct dump_opts * dump,\n                              uint32, uint32, unsigned char *, int, int);\n\n/* Image manipulation functions */\nstatic int rotateContigSamples8bits(uint16, uint16, uint16, uint32,\n                                    uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples16bits(uint16, uint16, uint16, uint32,\n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples24bits(uint16, uint16, uint16, uint32,\n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateContigSamples32bits(uint16, uint16, uint16, uint32,\n                                     uint32,   uint32, uint8 *, uint8 *);\nstatic int rotateImage(uint16, struct image_data *, uint32 *, uint32 *,\n \t\t       unsigned char **);\nstatic int mirrorImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *);\nstatic int invertImage(uint16, uint16, uint16, uint32, uint32,\n\t\t       unsigned char *);\n\n/* Functions to reverse the sequence of samples in a scanline */\nstatic int reverseSamples8bits  (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples16bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples24bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamples32bits (uint16, uint16, uint32, uint8 *, uint8 *);\nstatic int reverseSamplesBytes  (uint16, uint16, uint32, uint8 *, uint8 *);\n\n/* Functions for manipulating individual samples in an image */\nstatic int extractSeparateRegion(struct image_data *, struct crop_mask *,\n\t\t \t\t unsigned char *, unsigned char *, int);\nstatic int extractCompositeRegions(struct image_data *,  struct crop_mask *,\n\t\t\t\t   unsigned char *, unsigned char *);\nstatic int extractContigSamples8bits (uint8 *, uint8 *, uint32,\n \t                             tsample_t, uint16, uint16,\n                                     tsample_t, uint32, uint32);\nstatic int extractContigSamples16bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16,\n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamples24bits (uint8 *, uint8 *, uint32,\n \t                              tsample_t, uint16, uint16,\n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamples32bits (uint8 *, uint8 *, uint32,\n\t                              tsample_t, uint16, uint16,\n                                      tsample_t, uint32, uint32);\nstatic int extractContigSamplesBytes (uint8 *, uint8 *, uint32,\n                                      tsample_t, uint16, uint16,\n\t\t\t\t      tsample_t, uint32, uint32);\nstatic int extractContigSamplesShifted8bits (uint8 *, uint8 *, uint32,\n \t                                     tsample_t, uint16, uint16,\n                                             tsample_t, uint32, uint32,\n                                             int);\nstatic int extractContigSamplesShifted16bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16,\n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesShifted24bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16,\n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesShifted32bits (uint8 *, uint8 *, uint32,\n\t                                      tsample_t, uint16, uint16,\n\t\t\t\t              tsample_t, uint32, uint32,\n                                              int);\nstatic int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,\n  \t                                    uint32, uint32, tsample_t, uint16,\n\t\t\t\t\t    uint16, uint16, struct dump_opts *);\n\n/* Functions to combine separate planes into interleaved planes */\nstatic int combineSeparateSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                        uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\nstatic int combineSeparateSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t\t\tuint32, uint32, tsample_t, uint16,\n                                        FILE *, int, int);\n\nstatic int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                            uint32, uint32, uint16, uint16,\n                                            FILE *, int, int);\nstatic int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                             uint32, uint32, uint16, uint16,\n                                             FILE *, int, int);\nstatic int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,\n\t\t\t  \t\t    uint32, uint32, uint32, uint32,\n                                            tsample_t, uint16, FILE *, int, int);\n\n/* Dump functions for debugging */\nstatic void dump_info  (FILE *, int, char *, char *, ...);\nstatic int  dump_data  (FILE *, int, char *, unsigned char *, uint32);\nstatic int  dump_byte  (FILE *, int, char *, unsigned char);\nstatic int  dump_short (FILE *, int, char *, uint16);\nstatic int  dump_long  (FILE *, int, char *, uint32);\nstatic int  dump_wide  (FILE *, int, char *, uint64);\nstatic int  dump_buffer (FILE *, int, uint32, uint32, uint32, unsigned char *);\n\n/* End function declarations */\n/* Functions derived in whole or in part from tiffcp */\n/* The following functions are taken largely intact from tiffcp */\n\nstatic   char* usage_info[] = {\n\"usage: tiffcrop [options] source1 ... sourceN  destination\",\n\"where options are:\",\n\" -h\t\tPrint this syntax listing\",\n\" -v\t\tPrint tiffcrop version identifier and last revision date\",\n\" \",\n\" -a\t\tAppend to output instead of overwriting\",\n\" -d offset\tSet initial directory offset, counting first image as one, not zero\",\n\" -p contig\tPack samples contiguously (e.g. RGBRGB...)\",\n\" -p separate\tStore samples separately (e.g. RRR...GGG...BBB...)\",\n\" -s\t\tWrite output in strips\",\n\" -t\t\tWrite output in tiles\",\n\" -i\t\tIgnore read errors\",\n\" \",\n\" -r #\t\tMake each strip have no more than # rows\",\n\" -w #\t\tSet output tile width (pixels)\",\n\" -l #\t\tSet output tile length (pixels)\",\n\" \",\n\" -f lsb2msb\tForce lsb-to-msb FillOrder for output\",\n\" -f msb2lsb\tForce msb-to-lsb FillOrder for output\",\n\"\",\n\" -c lzw[:opts]\t Compress output with Lempel-Ziv & Welch encoding\",\n\" -c zip[:opts]\t Compress output with deflate encoding\",\n\" -c jpeg[:opts] Compress output with JPEG encoding\",\n\" -c packbits\t Compress output with packbits encoding\",\n\" -c g3[:opts]\t Compress output with CCITT Group 3 encoding\",\n\" -c g4\t\t Compress output with CCITT Group 4 encoding\",\n\" -c none\t Use no compression algorithm on output\",\n\" \",\n\"Group 3 options:\",\n\" 1d\t\tUse default CCITT Group 3 1D-encoding\",\n\" 2d\t\tUse optional CCITT Group 3 2D-encoding\",\n\" fill\t\tByte-align EOL codes\",\n\"For example, -c g3:2d:fill to get G3-2D-encoded data with byte-aligned EOLs\",\n\" \",\n\"JPEG options:\",\n\" #\t\tSet compression quality level (0-100, default 100)\",\n\" raw\t\tOutput color image as raw YCbCr\",\n\" rgb\t\tOutput color image as RGB\",\n\"For example, -c jpeg:rgb:50 to get JPEG-encoded RGB data with 50% comp. quality\",\n\" \",\n\"LZW and deflate options:\",\n\" #\t\tSet predictor value\",\n\"For example, -c lzw:2 to get LZW-encoded data with horizontal differencing\",\n\" \",\n\"Page and selection options:\",\n\" -N odd|even|#,#-#,#|last         sequences and ranges of images within file to process\",\n\"             The words odd or even may be used to specify all odd or even numbered images.\",\n\"             The word last may be used in place of a number in the sequence to indicate.\",\n\"             The final image in the file without knowing how many images there are.\",\n\"             Numbers are counted from one even though TIFF IFDs are counted from zero.\",\n\" \",\n\" -E t|l|r|b  edge to use as origin for width and length of crop region\",\n\" -U units    [in, cm, px ] inches, centimeters or pixels\",\n\" \",\n\" -m #,#,#,#  margins from edges for selection: top, left, bottom, right separated by commas\",\n\" -X #        horizontal dimension of region to extract expressed in current units\",\n\" -Y #        vertical dimension of region to extract expressed in current units\",\n\" -Z #:#,#:#  zones of the image designated as position X of Y,\",\n\"             eg 1:3 would be first of three equal portions measured from reference edge\",\n\" -z x1,y1,x2,y2:...:xN,yN,xN+1,yN+1\",\n\"             regions of the image designated by upper left and lower right coordinates\",\n\"\",\n\"Export grouping options:\",\n\" -e c|d|i|m|s    export mode for images and selections from input images.\",\n\"                 When exporting a composite image from multiple zones or regions\",\n\"                 (combined and image modes), the selections must have equal sizes\",\n\"                 for the axis perpendicular to the edge specified with -E.\",\n\"    c|combined   All images and selections are written to a single file (default).\",\n\"                 with multiple selections from one image combined into a single image.\",\n\"    d|divided    All images and selections are written to a single file\",\n\"                 with each selection from one image written to a new image.\",\n\"    i|image      Each input image is written to a new file (numeric filename sequence)\",\n\"                 with multiple selections from the image combined into one image.\",\n\"    m|multiple   Each input image is written to a new file (numeric filename sequence)\",\n\"                 with each selection from the image written to a new image.\",\n\"    s|separated  Individual selections from each image are written to separate files.\",\n\"\",\n\"Output options:\",\n\" -H #        Set horizontal resolution of output images to #\",\n\" -V #        Set vertical resolution of output images to #\",\n\" -J #        Set horizontal margin of output page to # expressed in current units\",\n\"             when sectioning image into columns x rows using the -S cols:rows option\",\n\" -K #        Set verticalal margin of output page to # expressed in current units\",\n\"             when sectioning image into columns x rows using the -S cols:rows option\",\n\" \",\n\" -O orient    orientation for output image, portrait, landscape, auto\",\n\" -P page      page size for output image segments, eg letter, legal, tabloid, etc\",\n\"              use #.#x#.# to specify a custom page size in the currently defined units\",\n\"              where #.# represents the width and length\",\n\" -S cols:rows Divide the image into equal sized segments using cols across and rows down.\",\n\" \",\n\" -F hor|vert|both\",\n\"             flip (mirror) image or region horizontally, vertically, or both\",\n\" -R #        [90,180,or 270] degrees clockwise rotation of image or extracted region\",\n\" -I [black|white|data|both]\",\n\"             invert color space, eg dark to light for bilevel and grayscale images\",\n\"             If argument is white or black, set the PHOTOMETRIC_INTERPRETATION \",\n\"             tag to MinIsBlack or MinIsWhite without altering the image data\",\n\"             If the argument is data or both, the image data are modified:\",\n\"             both inverts the data and the PHOTOMETRIC_INTERPRETATION tag,\",\n\"             data inverts the data but not the PHOTOMETRIC_INTERPRETATION tag\",\n\" \",\n\"-D opt1:value1,opt2:value2,opt3:value3:opt4:value4\",\n\"             Debug/dump program progress and/or data to non-TIFF files.\",\n\"             Options include the following and must be joined as a comma\",\n\"             separate list. The use of this option is generally limited to\",\n\"             program debugging and development of future options.\",\n\" \",\n\"   debug:N   Display limited program progress indicators where larger N\",\n\"             increase the level of detail. Note: Tiffcrop may be compiled with\",\n\"             -DDEVELMODE to enable additional very low level debug reporting.\",\n\"\",\n\"   Format:txt|raw  Format any logged data as ASCII text or raw binary \",\n\"             values. ASCII text dumps include strings of ones and zeroes\",\n\"             representing the binary values in the image data plus identifying headers.\",\n\" \",\n\"   level:N   Specify the level of detail presented in the dump files.\",\n\"             This can vary from dumps of the entire input or output image data to dumps\",\n\"             of data processed by specific functions. Current range of levels is 1 to 3.\",\n\" \",\n\"   input:full-path-to-directory/input-dumpname\",\n\" \",\n\"   output:full-path-to-directory/output-dumpnaem\",\n\" \",\n\"             When dump files are being written, each image will be written to a separate\",\n\"             file with the name built by adding a numeric sequence value to the dumpname\",\n\"             and an extension of .txt for ASCII dumps or .bin for binary dumps.\",\n\" \",\n\"             The four debug/dump options are independent, though it makes little sense to\",\n\"             specify a dump file without specifying a detail level.\",\n\" \",\nNULL\n};\n\n/* This function could be modified to pass starting sample offset\n * and number of samples as args to select fewer than spp\n * from input image. These would then be passed to individual\n * extractContigSampleXX routines.\n */\nstatic int readContigTilesIntoBuffer (TIFF* in, uint8* buf,\n                                      uint32 imagelength,\n                                      uint32 imagewidth,\n                                      uint32 tw, uint32 tl,\n                                      tsample_t spp, uint16 bps)\n  {\n  int status = 1;\n  tsample_t sample = 0;\n  tsample_t count = spp;\n  uint32 row, col, trow;\n  uint32 nrow, ncol;\n  uint32 dst_rowsize, shift_width;\n  uint32 bytes_per_sample, bytes_per_pixel;\n  uint32 trailing_bits, prev_trailing_bits;\n  uint32 tile_rowsize  = TIFFTileRowSize(in);\n  uint32 src_offset, dst_offset;\n  uint32 row_offset, col_offset;\n  uint8 *bufp = (uint8*) buf;\n  unsigned char *src = NULL;\n  unsigned char *dst = NULL;\n  tsize_t tbytes = 0, tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(in);\n  unsigned char *tilebuf = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n\n  if ((bps % 8) == 0)\n    shift_width = 0;\n  else\n    {\n    if (bytes_per_pixel < (bytes_per_sample + 1))\n      shift_width = bytes_per_pixel;\n    else\n      shift_width = bytes_per_sample + 1;\n    }\n\n  tile_buffsize = tilesize;\n\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"readContigTilesIntoBuffer\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    }\n\n  tilebuf = _TIFFmalloc(tile_buffsize);\n  if (tilebuf == 0)\n    return 0;\n\n  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);\n      if (tbytes < tilesize  && !ignore)\n        {\n\tTIFFError(TIFFFileName(in),\n\t\t  \"Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu\",\n\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,\n                  (unsigned long)tilesize);\n\t\t  status = 0;\n                  _TIFFfree(tilebuf);\n\t\t  return status;\n\t}\n\n      row_offset = row * dst_rowsize;\n      col_offset = ((col * bps * spp) + 7)/ 8;\n      bufp = buf + row_offset + col_offset;\n\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      /* Each tile scanline will start on a byte boundary but it\n       * has to be merged into the scanline for the entire\n       * image buffer and the previous segment may not have\n       * ended on a byte boundary\n       */\n      /* Optimization for common bit depths, all samples */\n      if (((bps % 8) == 0) && (count == spp))\n        {\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);\n          bufp += (imagewidth * bps * spp) / 8;\n\t  }\n        }\n      else\n        {\n\t/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */\n        prev_trailing_bits = trailing_bits = 0;\n        trailing_bits = (ncol * bps * spp) % 8;\n\n\t/*\tfor (trow = 0; tl < nrow; trow++) */\n\tfor (trow = 0; trow < nrow; trow++)\n          {\n\t  src_offset = trow * tile_rowsize;\n          src = tilebuf + src_offset;\n\t  dst_offset = (row + trow) * dst_rowsize;\n          dst = buf + dst_offset + col_offset;\n          switch (shift_width)\n            {\n            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,\n                                                   spp, bps, count, 0, ncol))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\",\n\t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 1: if (bps == 1)\n                      {\n                      if (extractContigSamplesShifted8bits (src, dst, ncol,\n                                                            sample, spp,\n                                                            bps, count,\n                                                            0, ncol,\n                                                            prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\",\n\t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t\t      break;\n\t\t      }\n                    else\n                      if (extractContigSamplesShifted16bits (src, dst, ncol,\n                                                             sample, spp,\n                                                             bps, count,\n                                                             0, ncol,\n                                                             prev_trailing_bits))\n                        {\n\t\t        TIFFError(\"readContigTilesIntoBuffer\",\n                                  \"Unable to extract row %d from tile %lu\",\n\t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\n\t\t        return 1;\n\t\t        }\n\t            break;\n            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\",\n\t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            case 3:\n            case 4:\n            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,\n                                                           sample, spp,\n                                                           bps, count,\n                                                           0, ncol,\n                                                           prev_trailing_bits))\n                      {\n\t\t      TIFFError(\"readContigTilesIntoBuffer\",\n                                \"Unable to extract row %d from tile %lu\",\n\t\t\t        row, (unsigned long)TIFFCurrentTile(in));\n\t\t      return 1;\n\t\t      }\n\t\t    break;\n            default: TIFFError(\"readContigTilesIntoBuffer\", \"Unsupported bit depth %d\", bps);\n\t\t     return 1;\n\t    }\n          }\n        prev_trailing_bits += trailing_bits;\n        if (prev_trailing_bits > 7)\n\t  prev_trailing_bits-= 8;\n\t}\n      }\n    }\n\n  _TIFFfree(tilebuf);\n  return status;\n  }\n\nstatic int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,\n\t\t\t\t\t uint32 imagelength, uint32 imagewidth,\n                                         uint32 tw, uint32 tl,\n                                         uint16 spp, uint16 bps)\n  {\n  int     i, status = 1, sample;\n  int     shift_width, bytes_per_pixel;\n  uint16  bytes_per_sample;\n  uint32  row, col;     /* Current row and col of image */\n  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n  uint32  row_offset, col_offset; /* Output buffer offsets */\n  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n  tsample_t s;\n  uint8*  bufp = (uint8*)obuf;\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *tbuff = NULL;\n\n  bytes_per_sample = (bps + 7) / 8;\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    srcbuffs[sample] = NULL;\n    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n    if (!tbuff)\n      {\n      TIFFError (\"readSeparateTilesIntoBuffer\",\n                 \"Unable to allocate tile read buffer for sample %d\", sample);\n      for (i = 0; i < sample; i++)\n        _TIFFfree (srcbuffs[i]);\n      return 0;\n      }\n    srcbuffs[sample] = tbuff;\n    }\n  /* Each tile contains only the data for a single plane\n   * arranged in scanlines of tw * bytes_per_sample bytes.\n   */\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      for (s = 0; s < spp; s++)\n        {  /* Read each plane of a tile set into srcbuffs[s] */\n\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n        if (tbytes < 0  && !ignore)\n          {\n\t  TIFFError(TIFFFileName(in),\n                 \"Error, can't read tile for row %lu col %lu, \"\n\t\t \"sample %lu\",\n\t\t (unsigned long) col, (unsigned long) row,\n\t\t (unsigned long) s);\n\t\t status = 0;\n          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n            {\n            tbuff = srcbuffs[sample];\n            if (tbuff != NULL)\n              _TIFFfree(tbuff);\n            }\n          return status;\n\t  }\n\t}\n     /* Tiles on the right edge may be padded out to tw\n      * which must be a multiple of 16.\n      * Ncol represents the visible (non padding) portion.\n      */\n      if (col + tw > imagewidth)\n        ncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n      col_offset = ((col * spp * bps) + 7) / 8;\n      bufp = obuf + row_offset + col_offset;\n\n      if ((bps % 8) == 0)\n        {\n        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n\t  {\n          status = 0;\n          break;\n      \t  }\n\t}\n      else\n        {\n        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n        if (bytes_per_pixel < (bytes_per_sample + 1))\n          shift_width = bytes_per_pixel;\n        else\n          shift_width = bytes_per_sample + 1;\n\n        switch (shift_width)\n          {\n          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps,\n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n      \t            }\n\t          break;\n          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps,\n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps,\n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n       \t            }\n                  break;\n          case 4:\n          case 5:\n          case 6:\n          case 7:\n          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n                                                       imagewidth, tw, spp, bps,\n\t\t\t\t\t\t       NULL, 0, 0))\n\t            {\n                    status = 0;\n                    break;\n\t\t    }\n\t          break;\n          default: TIFFError (\"readSeparateTilesIntoBuffer\", \"Unsupported bit depth: %d\", bps);\n                  status = 0;\n                  break;\n          }\n        }\n      }\n    }\n\n  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n    {\n    tbuff = srcbuffs[sample];\n    if (tbuff != NULL)\n      _TIFFfree(tbuff);\n    }\n\n  return status;\n  }\n\nstatic int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)\n  {\n  uint32 row, nrows, rowsperstrip;\n  tstrip_t strip = 0;\n  tsize_t stripsize;\n\n  TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  for (row = 0; row < imagelength; row += rowsperstrip)\n    {\n    nrows = (row + rowsperstrip > imagelength) ?\n\t     imagelength - row : rowsperstrip;\n    stripsize = TIFFVStripSize(out, nrows);\n    if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)\n      {\n      TIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n      return 1;\n      }\n    buf += stripsize;\n    }\n\n  return 0;\n  }\n\n/* Abandon plans to modify code so that plannar orientation separate images\n * do not have all samples for each channel written before all samples\n * for the next channel have been abandoned.\n * Libtiff internals seem to depend on all data for a given sample\n * being contiguous within a strip or tile when PLANAR_CONFIG is\n * separate. All strips or tiles of a given plane are written\n * before any strips or tiles of a different plane are stored.\n */\nstatic int\nwriteBufferToSeparateStrips (TIFF* out, uint8* buf,\n\t\t\t     uint32 length, uint32 width, uint16 spp,\n\t\t\t     struct dump_opts *dump)\n  {\n  uint8   *src;\n  uint16   bps;\n  uint32   row, nrows, rowsize, rowsperstrip;\n  uint32   bytes_per_sample;\n  tsample_t s;\n  tstrip_t strip = 0;\n  tsize_t  stripsize = TIFFStripSize(out);\n  tsize_t  rowstripsize,  scanlinesize = TIFFScanlineSize(out);\n  tsize_t  total_bytes = 0;\n  tdata_t  obuf;\n\n  (void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n  (void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n  bytes_per_sample = (bps + 7) / 8;\n  rowsize = ((bps * spp * width) + 7) / 8; /* source has interleaved samples */\n  rowstripsize = rowsperstrip * bytes_per_sample * (width + 1);\n\n  obuf = _TIFFmalloc (rowstripsize);\n  if (obuf == NULL)\n    return 1;\n\n  for (s = 0; s < spp; s++)\n    {\n    for (row = 0; row < length; row += rowsperstrip)\n      {\n      nrows = (row + rowsperstrip > length) ? length - row : rowsperstrip;\n\n      stripsize = TIFFVStripSize(out, nrows);\n      src = buf + (row * rowsize);\n      total_bytes += stripsize;\n      memset (obuf, '\\0', rowstripsize);\n      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n        {\n        _TIFFfree(obuf);\n        return 1;\n\t}\n      if ((dump->outfile != NULL) && (dump->level == 1))\n        {\n        dump_info(dump->outfile, dump->format,\"\",\n                  \"Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d\",\n                  s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);\n        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);\n\t}\n\n      if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)\n        {\n\tTIFFError(TIFFFileName(out), \"Error, can't write strip %u\", strip - 1);\n\t_TIFFfree(obuf);\n\treturn 1;\n\t}\n      }\n    }\n\n  _TIFFfree(obuf);\n  return 0;\n}\n\n/* Extract all planes from contiguous buffer into a single tile buffer\n * to be written out as a tile.\n */\nstatic int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp,\n                                       struct dump_opts* dump)\n  {\n  uint16 bps;\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint32 tile_rowsize  = TIFFTileRowSize(out);\n  uint8* bufp = (uint8*) buf;\n  tsize_t tile_buffsize = 0;\n  tsize_t tilesize = TIFFTileSize(out);\n  unsigned char *tilebuf = NULL;\n\n  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n\n  tile_buffsize = tilesize;\n  if (tilesize < (tsize_t)(tl * tile_rowsize))\n    {\n#ifdef DEBUG2\n    TIFFError(\"writeBufferToContigTiles\",\n\t      \"Tilesize %lu is too small, using alternate calculation %u\",\n              tilesize, tl * tile_rowsize);\n#endif\n    tile_buffsize = tl * tile_rowsize;\n    }\n\n  tilebuf = _TIFFmalloc(tile_buffsize);\n  if (tilebuf == 0)\n    return 1;\n\n  src_rowsize = ((imagewidth * spp * bps) + 7) / 8;\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\",\n                  \"Unable to extract data to tile for row %lu, col %lu\",\n                  (unsigned long) row, (unsigned long)col);\n\t_TIFFfree(tilebuf);\n\treturn 1;\n        }\n\n      if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)\n        {\n\tTIFFError(\"writeBufferToContigTiles\",\n\t          \"Cannot write tile at %lu %lu\",\n\t          (unsigned long) col, (unsigned long) row);\n\t _TIFFfree(tilebuf);\n\treturn 1;\n\t}\n      }\n    }\n  _TIFFfree(tilebuf);\n\n  return 0;\n  } /* end writeBufferToContigTiles */\n\n/* Extract each plane from contiguous buffer into a single tile buffer\n * to be written out as a tile.\n */\nstatic int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,\n\t\t\t\t       uint32 imagewidth, tsample_t spp,\n                                       struct dump_opts * dump)\n  {\n  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n  uint32 tl, tw;\n  uint32 row, col, nrow, ncol;\n  uint32 src_rowsize, col_offset;\n  uint16 bps;\n  tsample_t s;\n  uint8* bufp = (uint8*) buf;\n\n  if (obuf == NULL)\n    return 1;\n\n  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n  src_rowsize = ((imagewidth * spp * bps) + 7) / 8;\n\n  for (row = 0; row < imagelength; row += tl)\n    {\n    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n    for (col = 0; col < imagewidth; col += tw)\n      {\n      /* Calculate visible portion of tile. */\n      if (col + tw > imagewidth)\n\tncol = imagewidth - col;\n      else\n        ncol = tw;\n\n      col_offset = (((col * bps * spp) + 7) / 8);\n      bufp = buf + (row * src_rowsize) + col_offset;\n\n      for (s = 0; s < spp; s++)\n        {\n\tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,\n\t\t\t\t\t     tw, s"
}