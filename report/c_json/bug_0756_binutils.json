{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Message": "Offset: [-1+max(2, `rel->r_offset`), `rel->r_offset` - 1] (â‡ [max(2, `rel->r_offset`), `rel->r_offset`] + -1) Size: [1, +oo].",
    "Code_line": "      val = bfd_get_8 (abfd, contents + offset - 1);",
    "Code_function": "elf_i386_check_tls_transition (bfd *abfd, asection *sec,\n\t\t\t       bfd_byte *contents,\n\t\t\t       Elf_Internal_Shdr *symtab_hdr,\n\t\t\t       struct elf_link_hash_entry **sym_hashes,\n\t\t\t       unsigned int r_type,\n\t\t\t       const Elf_Internal_Rela *rel,\n\t\t\t       const Elf_Internal_Rela *relend)\n{\n  unsigned int val, type;\n  unsigned long r_symndx;\n  struct elf_link_hash_entry *h;\n  bfd_vma offset;\n\n  /* Get the section contents.  */\n  if (contents == NULL)\n    {\n      if (elf_section_data (sec)->this_hdr.contents != NULL)\n\tcontents = elf_section_data (sec)->this_hdr.contents;\n      else\n\t{\n\t  /* FIXME: How to better handle error condition?  */\n\t  if (!bfd_malloc_and_get_section (abfd, sec, &contents))\n\t    return FALSE;\n\n\t  /* Cache the section contents for elf_link_input_bfd.  */\n\t  elf_section_data (sec)->this_hdr.contents = contents;\n\t}\n    }\n\n  offset = rel->r_offset;\n  switch (r_type)\n    {\n    case R_386_TLS_GD:\n    case R_386_TLS_LDM:\n      if (offset < 2 || (rel + 1) >= relend)\n\treturn FALSE;\n\n      type = bfd_get_8 (abfd, contents + offset - 2);\n      if (r_type == R_386_TLS_GD)\n\t{\n\t  /* Check transition from GD access model.  Only\n\t\tleal foo@tlsgd(,%reg,1), %eax; call ___tls_get_addr\n\t\tleal foo@tlsgd(%reg), %eax; call ___tls_get_addr; nop\n\t     can transit to different access model.  */\n\t  if ((offset + 10) > sec->size ||\n\t      (type != 0x8d && type != 0x04))\n\t    return FALSE;\n\n\t  val = bfd_get_8 (abfd, contents + offset - 1);\n\t  if (type == 0x04)\n\t    {\n\t      /* leal foo@tlsgd(,%reg,1), %eax; call ___tls_get_addr */\n\t      if (offset < 3)\n\t\treturn FALSE;\n\n\t      if (bfd_get_8 (abfd, contents + offset - 3) != 0x8d)\n\t\treturn FALSE;\n\n\t      if ((val & 0xc7) != 0x05 || val == (4 << 3))\n\t\treturn FALSE;\n\t    }\n\t  else\n\t    {\n\t      /* leal foo@tlsgd(%reg), %eax; call ___tls_get_addr; nop  */\n\t      if ((val & 0xf8) != 0x80 || (val & 7) == 4)\n\t\treturn FALSE;\n\n\t      if (bfd_get_8 (abfd, contents + offset + 9) != 0x90)\n\t\treturn FALSE;\n\t    }\n\t}\n      else\n\t{\n\t  /* Check transition from LD access model.  Only\n\t\tleal foo@tlsgd(%reg), %eax; call ___tls_get_addr\n\t     can transit to different access model.  */\n\t  if (type != 0x8d || (offset + 9) > sec->size)\n\t    return FALSE;\n\n\t  val = bfd_get_8 (abfd, contents + offset - 1);\n\t  if ((val & 0xf8) != 0x80 || (val & 7) == 4)\n\t    return FALSE;\n\t}\n\n      if (bfd_get_8 (abfd, contents + offset + 4) != 0xe8)\n\treturn FALSE;\n\n      r_symndx = ELF32_R_SYM (rel[1].r_info);\n      if (r_symndx < symtab_hdr->sh_info)\n\treturn FALSE;\n\n      h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n      /* Use strncmp to check ___tls_get_addr since ___tls_get_addr\n\t may be versioned.  */\n      return (h != NULL\n\t      && h->root.root.string != NULL\n\t      && (ELF32_R_TYPE (rel[1].r_info) == R_386_PC32\n\t\t  || ELF32_R_TYPE (rel[1].r_info) == R_386_PLT32)\n\t      && (strncmp (h->root.root.string, \"___tls_get_addr\",\n\t\t\t   15) == 0));\n\n    case R_386_TLS_IE:\n      /* Check transition from IE access model:\n\t\tmovl foo@indntpoff(%rip), %eax\n\t\tmovl foo@indntpoff(%rip), %reg\n\t\taddl foo@indntpoff(%rip), %reg\n       */\n\n      if (offset < 1 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      /* Check \"movl foo@tpoff(%rip), %eax\" first.  */\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      if (val == 0xa1)\n\treturn TRUE;\n\n      if (offset < 2)\n\treturn FALSE;\n\n      /* Check movl|addl foo@tpoff(%rip), %reg.   */\n      type = bfd_get_8 (abfd, contents + offset - 2);\n      return ((type == 0x8b || type == 0x03)\n\t      && (val & 0xc7) == 0x05);\n\n    case R_386_TLS_GOTIE:\n    case R_386_TLS_IE_32:\n      /* Check transition from {IE_32,GOTIE} access model:\n\t\tsubl foo@{tpoff,gontoff}(%reg1), %reg2\n\t\tmovl foo@{tpoff,gontoff}(%reg1), %reg2\n\t\taddl foo@{tpoff,gontoff}(%reg1), %reg2\n       */\n\n      if (offset < 2 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      if ((val & 0xc0) != 0x80 || (val & 7) == 4)\n\treturn FALSE;\n\n      type = bfd_get_8 (abfd, contents + offset - 2);\n      return type == 0x8b || type == 0x2b || type == 0x03;\n\n    case R_386_TLS_GOTDESC:\n      /* Check transition from GDesc access model:\n\t\tleal x@tlsdesc(%ebx), %eax\n\n\t Make sure it's a leal adding ebx to a 32-bit offset\n\t into any register, although it's probably almost always\n\t going to be eax.  */\n\n      if (offset < 2 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      if (bfd_get_8 (abfd, contents + offset - 2) != 0x8d)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      return (val & 0xc7) == 0x83;\n\n    case R_386_TLS_DESC_CALL:\n      /* Check transition from GDesc access model:\n\t\tcall *x@tlsdesc(%rax)\n       */\n      if (offset + 2 <= sec->size)\n\t{\n\t  /* Make sure that it's a call *x@tlsdesc(%rax).  */\n\t  static const unsigned char call[] = { 0xff, 0x10 };\n\t  return memcmp (contents + offset, call, 2) == 0;\n\t}\n\n      return FALSE;\n\n    default:\n      abort ();\n    }\n}"
}