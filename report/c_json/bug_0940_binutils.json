{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "opcodes/i386-dis.c",
    "message": "Offset: [-1, +oo] (â‡ [-1, +oo] + [0, +oo]) Size: 30 by call to `print_displacement`.",
    "warning_function_name": "OP_E_memory",
    "warning_line": "print_displacement (scratchbuf, disp);",
    "warning_context": "\t\t{\n\t\t  if (!vex.v)\n\t\t    vindex += 16;\n\t\t}\n\n\t      haveindex = 1;\n\t      switch (vex.length)\n\t\t{\n\t\tcase 128:\n\t\t  indexes64 = indexes32 = names_xmm;\n\t\t  break;\n\t\tcase 256:\n\t\t  if (!vex.w\n\t\t      || bytemode == vex_vsib_q_w_dq_mode\n\t\t      || bytemode == vex_vsib_q_w_d_mode)\n\t\t    indexes64 = indexes32 = names_ymm;\n\t\t  else\n\t\t    indexes64 = indexes32 = names_xmm;\n\t\t  break;\n\t\tcase 512:\n\t\t  if (!vex.w\n\t\t      || bytemode == vex_vsib_q_w_dq_mode\n\t\t      || bytemode == vex_vsib_q_w_d_mode)\n\t\t    indexes64 = indexes32 = names_zmm;\n\t\t  else\n\t\t    indexes64 = indexes32 = names_ymm;\n\t\t  break;\n\t\tdefault:\n\t\t  abort ();\n\t\t}\n\t      break;\n\t    default:\n\t      haveindex = vindex != 4;\n\t      break;\n\t    }\n\t  scale = sib.scale;\n\t  base = sib.base;\n\t  codep++;\n\t}\n      rbase = base + add;\n\n      switch (modrm.mod)\n\t{\n\tcase 0:\n\t  if (base == 5)\n\t    {\n\t      havebase = 0;\n\t      if (address_mode == mode_64bit && !havesib)\n\t\triprel = 1;\n\t      disp = get32s ();\n\t    }\n\t  break;\n\tcase 1:\n\t  FETCH_DATA (the_info, codep + 1);\n\t  disp = *codep++;\n\t  if ((disp & 0x80) != 0)\n\t    disp -= 0x100;\n\t  if (vex.evex && shift > 0)\n\t    disp <<= shift;\n\t  break;\n\tcase 2:\n\t  disp = get32s ();\n\t  break;\n\t}\n\n      /* In 32bit mode, we need index register to tell [offset] from\n\t [eiz*1 + offset].  */\n      needindex = (havesib\n\t\t   && !havebase\n\t\t   && !haveindex\n\t\t   && address_mode == mode_32bit);\n      havedisp = (havebase\n\t\t  || needindex\n\t\t  || (havesib && (haveindex || scale != 0)));\n\n      if (!intel_syntax)\n\tif (modrm.mod != 0 || base == 5)\n\t  {\n\t    if (havedisp || riprel)\n\t      print_displacement (scratchbuf, disp);\n\t    else\n\t      print_operand_value (scratchbuf, 1, disp);\n\t    oappend (scratchbuf);\n\t    if (riprel)\n\t      {\n\t\tset_op (disp, 1);\n\t\toappend (sizeflag & AFLAG ? \"(%rip)\" : \"(%eip)\");\n\t      }\n\t  }\n\n      if ((havebase || haveindex || riprel)\n\t  && (bytemode != v_bnd_mode)\n\t  && (bytemode != bnd_mode))\n\tused_prefixes |= PREFIX_ADDR;\n\n      if (havedisp || (intel_syntax && riprel))\n\t{\n\t  *obufp++ = open_char;\n\t  if (intel_syntax && riprel)\n\t    {\n\t      set_op (disp, 1);\n"
}