{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [1, +oo] Size: [0, +oo] by call to `make_regexp`.",
    "Code_line": "\t\t\tFS_re_no_case = make_regexp(buf, strlen(buf), true, true, true);",
    "Code_function": "set_FS()\n{\n\tchar buf[10];\n\tNODE *fs;\n\tstatic NODE *save_fs = NULL;\n\tstatic NODE *save_rs = NULL;\n\tbool remake_re = true;\n\n\t/*\n\t * If changing the way fields are split, obey least-surprise\n\t * semantics, and force $0 to be split totally.\n\t */\n\tif (fields_arr != NULL)\n\t\t(void) get_field(UNLIMITED - 1, 0);\n\n\t/* It's possible that only IGNORECASE changed, or FS = FS */\n\t/*\n\t * This comparison can't use cmp_nodes(), which pays attention\n\t * to IGNORECASE, and that's not what we want.\n\t */\n\tif (save_fs\n\t\t&& FS_node->var_value->stlen == save_fs->stlen\n\t\t&& memcmp(FS_node->var_value->stptr, save_fs->stptr, save_fs->stlen) == 0\n\t\t&& save_rs\n\t\t&& RS_node->var_value->stlen == save_rs->stlen\n\t\t&& memcmp(RS_node->var_value->stptr, save_rs->stptr, save_rs->stlen) == 0) {\n\t\tif (FS_regexp != NULL)\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\n\t\t/* FS = FS */\n\t\tif (current_field_sep() == Using_FS) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tremake_re = false;\n\t\t\tgoto choose_fs_function;\n\t\t}\n\t}\n\n\tunref(save_fs);\n\tsave_fs = dupnode(FS_node->var_value);\n\tunref(save_rs);\n\tsave_rs = dupnode(RS_node->var_value);\n\tresave_fs = true;\n\n\t/* If FS_re_no_case assignment is fatal (make_regexp in remake_re)\n\t * FS_regexp will be NULL with a non-null FS_re_yes_case.\n\t * refree() handles null argument; no need for `if (FS_regexp != NULL)' below.\n\t * Please do not remerge.\n\t */\n\trefree(FS_re_yes_case);\n\trefree(FS_re_no_case);\n\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\n\nchoose_fs_function:\n\tbuf[0] = '\\0';\n\tdefault_FS = false;\n\tfs = force_string(FS_node->var_value);\n\n\tif (! do_traditional && fs->stlen == 0) {\n\t\tstatic bool warned = false;\n\n\t\tparse_field = null_parse_field;\n\n\t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn(_(\"null string for `FS' is a gawk extension\"));\n\t\t}\n\t} else if (fs->stlen > 1) {\n\t\tif (do_lint_old)\n\t\t\twarning(_(\"old awk does not support regexps as value of `FS'\"));\n\t\tparse_field = re_parse_field;\n\t} else if (RS_is_null) {\n\t\t/* we know that fs->stlen <= 1 */\n\t\tparse_field = sc_parse_field;\n\t\tif (fs->stlen == 1) {\n\t\t\tif (fs->stptr[0] == ' ') {\n\t\t\t\tdefault_FS = true;\n\t\t\t\tstrcpy(buf, \"[ \\t\\n]+\");\n\t\t\t} else if (fs->stptr[0] == '\\\\') {\n\t\t\t\t/* yet another special case */\n\t\t\t\tstrcpy(buf, \"[\\\\\\\\\\n]\");\n\t\t\t} else if (fs->stptr[0] != '\\n')\n\t\t\t\tsprintf(buf, \"[%c\\n]\", fs->stptr[0]);\n\t\t}\n\t} else {\n\t\tif (do_posix)\n\t\t\tparse_field = posix_def_parse_field;\n\t\telse\n\t\t\tparse_field = def_parse_field;\n\n\t\tif (fs->stlen == 1) {\n\t\t\tif (fs->stptr[0] == ' ')\n\t\t\t\tdefault_FS = true;\n\t\t\telse if (fs->stptr[0] == '\\\\')\n\t\t\t\t/* same special case */\n\t\t\t\tstrcpy(buf, \"[\\\\\\\\]\");\n\t\t\telse\n\t\t\t\tparse_field = sc_parse_field;\n\t\t}\n\t}\n\tif (remake_re) {\n\t\trefree(FS_re_yes_case);\n\t\trefree(FS_re_no_case);\n\t\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\n\t\tif (buf[0] != '\\0') {\n\t\t\tFS_re_yes_case = make_regexp(buf, strlen(buf), false, true, true);\n\t\t\tFS_re_no_case = make_regexp(buf, strlen(buf), true, true, true);\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\t\t\tparse_field = re_parse_field;\n\t\t} else if (parse_field == re_parse_field) {\n\t\t\tFS_re_yes_case = make_regexp(fs->stptr, fs->stlen, false, true, true);\n\t\t\tFS_re_no_case = make_regexp(fs->stptr, fs->stlen, true, true, true);\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\t\t} else\n\t\t\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\t}\n\n\t/*\n\t * For FS = \"c\", we don't use IGNORECASE. But we must use\n\t * re_parse_field to get the character and the newline as\n\t * field separators.\n\t */\n\tif (fs->stlen == 1 && parse_field == re_parse_field)\n\t\tFS_regexp = FS_re_yes_case;\n\n\tupdate_PROCINFO_str(\"FS\", \"FS\");\n}"
}