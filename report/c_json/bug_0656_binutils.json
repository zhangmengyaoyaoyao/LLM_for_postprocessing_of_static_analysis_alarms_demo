{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `p` last assigned on line 422 could be null and is dereferenced at line 422, column 4.",
    "Code_line": "\t  *p++ = '\\0';",
    "Code_function": "linux_tally_symbols (struct linux_link_hash_entry *h, void * data)\n{\n  struct bfd_link_info *info = (struct bfd_link_info *) data;\n  struct fixup *f, *f1;\n  int is_plt;\n  struct linux_link_hash_entry *h1, *h2;\n  bfd_boolean exists;\n\n  if (h->root.root.type == bfd_link_hash_undefined\n      && CONST_STRNEQ (h->root.root.root.string, NEEDS_SHRLIB))\n    {\n      const char *name;\n      char *p;\n      char *alloc = NULL;\n\n      name = h->root.root.root.string + sizeof NEEDS_SHRLIB - 1;\n      p = strrchr (name, '_');\n      if (p != NULL)\n\talloc = (char *) bfd_malloc ((bfd_size_type) strlen (name) + 1);\n\n      if (p == NULL || alloc == NULL)\n\t(*_bfd_error_handler) (_(\"Output file requires shared library `%s'\\n\"),\n\t\t\t       name);\n      else\n\t{\n\t  strcpy (alloc, name);\n\t  p = strrchr (alloc, '_');\n\t  *p++ = '\\0';\n\t  (*_bfd_error_handler)\n\t    (_(\"Output file requires shared library `%s.so.%s'\\n\"),\n\t     alloc, p);\n\t  free (alloc);\n\t}\n\n      abort ();\n    }\n\n  /* If this symbol is not a PLT/GOT, we do not even need to look at it */\n  is_plt = IS_PLT_SYM (h->root.root.root.string);\n\n  if (is_plt || IS_GOT_SYM (h->root.root.root.string))\n    {\n      /* Look up this symbol twice.  Once just as a regular lookup,\n\t and then again following all of the indirect links until we\n\t reach a real symbol.  */\n      h1 = linux_link_hash_lookup (linux_hash_table (info),\n\t\t\t\t   (h->root.root.root.string\n\t\t\t\t    + sizeof PLT_REF_PREFIX - 1),\n\t\t\t\t   FALSE, FALSE, TRUE);\n      /* h2 does not follow indirect symbols. */\n      h2 = linux_link_hash_lookup (linux_hash_table (info),\n\t\t\t\t   (h->root.root.root.string\n\t\t\t\t    + sizeof PLT_REF_PREFIX - 1),\n\t\t\t\t   FALSE, FALSE, FALSE);\n\n      /* The real symbol must exist but if it is also an ABS symbol,\n\t there is no need to have a fixup.  This is because they both\n\t came from the same library.  If on the other hand, we had to\n\t use an indirect symbol to get to the real symbol, we add the\n\t fixup anyway, since there are cases where these symbols come\n\t from different shared libraries */\n      if (h1 != NULL\n\t  && (((h1->root.root.type == bfd_link_hash_defined\n\t\t|| h1->root.root.type == bfd_link_hash_defweak)\n\t       && ! bfd_is_abs_section (h1->root.root.u.def.section))\n\t      || h2->root.root.type == bfd_link_hash_indirect))\n\t{\n\t  /* See if there is a \"builtin\" fixup already present\n\t     involving this symbol.  If so, convert it to a regular\n\t     fixup.  In the end, this relaxes some of the requirements\n\t     about the order of performing fixups.  */\n\t  exists = FALSE;\n\t  for (f1 = linux_hash_table (info)->fixup_list;\n\t       f1 != NULL;\n\t       f1 = f1->next)\n\t    {\n\t      if ((f1->h != h && f1->h != h1)\n\t\t  || (! f1->builtin && ! f1->jump))\n\t\tcontinue;\n\t      if (f1->h == h1)\n\t\texists = TRUE;\n\t      if (! exists\n\t\t  && bfd_is_abs_section (h->root.root.u.def.section))\n\t\t{\n\t\t  f = new_fixup (info, h1, f1->h->root.root.u.def.value, 0);\n\t\t  f->jump = is_plt;\n\t\t}\n\t      f1->h = h1;\n\t      f1->jump = is_plt;\n\t      f1->builtin = 0;\n\t      exists = TRUE;\n\t    }\n\t  if (! exists\n\t      && bfd_is_abs_section (h->root.root.u.def.section))\n\t    {\n\t      f = new_fixup (info, h1, h->root.root.u.def.value, 0);\n\t      if (f == NULL)\n\t\t{\n\t\t  /* FIXME: No way to return error.  */\n\t\t  abort ();\n\t\t}\n\t      f->jump = is_plt;\n\t    }\n\t}\n\n      /* Quick and dirty way of stripping these symbols from the\n\t symtab. */\n      if (bfd_is_abs_section (h->root.root.u.def.section))\n\th->root.written = TRUE;\n    }\n\n  return TRUE;\n}"
}