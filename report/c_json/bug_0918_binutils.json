{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset added: [12, +oo] (⇐ [0, +oo] + 12) Size: [0, +oo] by call to `elf_link_input_bfd`.",
    "warning_function_name": "bfd_elf_final_link",
    "warning_line": "if (! elf_link_input_bfd (&flinfo, sub))",
    "warning_context": "\n  if (max_sym_shndx_count != 0)\n    {\n      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);\n      flinfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);\n      if (flinfo.locsym_shndx == NULL)\n\tgoto error_return;\n    }\n\n  if (elf_hash_table (info)->tls_sec)\n    {\n      bfd_vma base, end = 0;\n      asection *sec;\n\n      for (sec = elf_hash_table (info)->tls_sec;\n\t   sec && (sec->flags & SEC_THREAD_LOCAL);\n\t   sec = sec->next)\n\t{\n\t  bfd_size_type size = sec->size;\n\n\t  if (size == 0\n\t      && (sec->flags & SEC_HAS_CONTENTS) == 0)\n\t    {\n\t      struct bfd_link_order *ord = sec->map_tail.link_order;\n\n\t      if (ord != NULL)\n\t\tsize = ord->offset + ord->size;\n\t    }\n\t  end = sec->vma + size;\n\t}\n      base = elf_hash_table (info)->tls_sec->vma;\n      /* Only align end of TLS section if static TLS doesn't have special\n\t alignment requirements.  */\n      if (bed->static_tls_alignment == 1)\n\tend = align_power (end,\n\t\t\t   elf_hash_table (info)->tls_sec->alignment_power);\n      elf_hash_table (info)->tls_size = end - base;\n    }\n\n  /* Reorder SHF_LINK_ORDER sections.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      if (!elf_fixup_link_order (abfd, o))\n\treturn FALSE;\n    }\n\n  /* Since ELF permits relocations to be against local symbols, we\n     must have the local symbols available when we do the relocations.\n     Since we would rather only read the local symbols once, and we\n     would rather not keep them in memory, we handle all the\n     relocations for a single input file at the same time.\n\n     Unfortunately, there is no way to know the total number of local\n     symbols until we have seen all of them, and the local symbol\n     indices precede the global symbol indices.  This means that when\n     we are generating relocatable output, and we see a reloc against\n     a global symbol, we can not know the symbol index until we have\n     finished examining all the local symbols to see which ones we are\n     going to output.  To deal with this, we keep the relocations in\n     memory, and don't output them until the end of the link.  This is\n     an unfortunate waste of memory, but I don't see a good way around\n     it.  Fortunately, it only happens when performing a relocatable\n     link, which is not the common case.  FIXME: If keep_memory is set\n     we could write the relocs out and then read them again; I don't\n     know how bad the memory loss will be.  */\n\n  for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n    sub->output_has_begun = FALSE;\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  if (p->type == bfd_indirect_link_order\n\t      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))\n\t\t  == bfd_target_elf_flavour)\n\t      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)\n\t    {\n\t      if (! sub->output_has_begun)\n\t\t{\n\t\t  if (! elf_link_input_bfd (&flinfo, sub))\n\t\t    goto error_return;\n\t\t  sub->output_has_begun = TRUE;\n\t\t}\n\t    }\n\t  else if (p->type == bfd_section_reloc_link_order\n\t\t   || p->type == bfd_symbol_reloc_link_order)\n\t    {\n\t      if (! elf_reloc_link_order (abfd, info, o, p))\n\t\tgoto error_return;\n\t    }\n\t  else\n\t    {\n\t      if (! _bfd_default_link_order (abfd, info, o, p))\n\t\t{\n\t\t  if (p->type == bfd_indirect_link_order\n\t\t      && (bfd_get_flavour (sub)\n\t\t\t  == bfd_target_elf_flavour)\n\t\t      && (elf_elfheader (sub)->e_ident[EI_CLASS]\n\t\t\t  != bed->s->elfclass))\n\t\t    {\n\t\t      const char *iclass, *oclass;\n"
}