{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/app.c",
    "message": "The value read from fromlen was never initialized.",
    "warning_function_name": "process_escape",
    "warning_line": "ch = GET ();",
    "warning_context": "\t  else\n\t    {\n\t      /* We've read the entire pseudo-op.  If this is the end\n\t\t of the line, go back to the beginning.  */\n\t      if (IS_NEWLINE (ch))\n\t\tsymver_state = NULL;\n\t    }\n\t}\n#endif /* TC_ARM && OBJ_ELF */\n\n#ifdef TC_M68K\n      /* We want to have pseudo-ops which control whether we are in\n\t MRI mode or not.  Unfortunately, since m68k MRI mode affects\n\t the scrubber, that means that we need a special purpose\n\t recognizer here.  */\n      if (mri_state == NULL)\n\t{\n\t  if ((state == 0 || state == 1)\n\t      && ch == mri_pseudo[0])\n\t    mri_state = mri_pseudo + 1;\n\t}\n      else\n\t{\n\t  /* We advance to the next state if we find the right\n\t     character, or if we need a space character and we get any\n\t     whitespace character, or if we need a '0' and we get a\n\t     '1' (this is so that we only need one state to handle\n\t     ``.mri 0'' and ``.mri 1'').  */\n\t  if (ch != '\\0'\n\t      && (*mri_state == ch\n\t\t  || (*mri_state == ' '\n\t\t      && lex[ch] == LEX_IS_WHITESPACE)\n\t\t  || (*mri_state == '0'\n\t\t      && ch == '1')))\n\t    {\n\t      mri_last_ch = ch;\n\t      ++mri_state;\n\t    }\n\t  else if (*mri_state != '\\0'\n\t\t   || (lex[ch] != LEX_IS_WHITESPACE\n\t\t       && lex[ch] != LEX_IS_NEWLINE))\n\t    {\n\t      /* We did not get the expected character, or we didn't\n\t\t get a valid terminating character after seeing the\n\t\t entire pseudo-op, so we must go back to the\n\t\t beginning.  */\n\t      mri_state = NULL;\n\t    }\n\t  else\n\t    {\n\t      /* We've read the entire pseudo-op.  mips_last_ch is\n\t\t either '0' or '1' indicating whether to enter or\n\t\t leave MRI mode.  */\n\t      do_scrub_begin (mri_last_ch == '1');\n\t      mri_state = NULL;\n\n\t      /* We continue handling the character as usual.  The\n\t\t main gas reader must also handle the .mri pseudo-op\n\t\t to control expression parsing and the like.  */\n\t    }\n\t}\n#endif\n\n      if (ch == EOF)\n\t{\n\t  if (state != 0)\n\t    {\n\t      as_warn (_(\"end of file not at end of a line; newline inserted\"));\n\t      state = 0;\n\t      PUT ('\\n');\n\t    }\n\t  goto fromeof;\n\t}\n\n      switch (lex[ch])\n\t{\n\tcase LEX_IS_WHITESPACE:\n\t  do\n\t    {\n\t      ch = GET ();\n\t    }\n\t  while (ch != EOF && IS_WHITESPACE (ch));\n\t  if (ch == EOF)\n\t    goto fromeof;\n\n\t  if (state == 0)\n\t    {\n\t      /* Preserve a single whitespace character at the\n\t\t beginning of a line.  */\n\t      state = 1;\n\t      UNGET (ch);\n\t      PUT (' ');\n\t      break;\n\t    }\n\n#ifdef KEEP_WHITE_AROUND_COLON\n\t  if (lex[ch] == LEX_IS_COLON)\n\t    {\n\t      /* Only keep this white if there's no white *after* the\n\t\t colon.  */\n\t      ch2 = GET ();\n"
}