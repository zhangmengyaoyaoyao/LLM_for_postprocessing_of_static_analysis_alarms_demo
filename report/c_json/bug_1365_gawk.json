{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "builtin.c",
    "message": "Dereference of null pointer",
    "warning_function_name": "do_sub",
    "warning_line": "*bp++ = *scan;",
    "warning_context": "\t * code to check for `repllen == 0'.  This can occur for\n\t * something like:\n\t * \tsub(/foo/, \"\", mystring)\n\t * for example.\n\t */\n\tif (gawk_mb_cur_max > 1 && repllen > 0) {\n\t\temalloc(mb_indices, char *, repllen * sizeof(char), \"do_sub\");\n\t\tindex_multibyte_buffer(repl, mb_indices, repllen);\n\t}\n\n\tfor (scan = repl; scan < replend; scan++) {\n\t\tif ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))\n\t\t    && (*scan == '&')) {\n\t\t\trepllen--;\n\t\t\tampersands++;\n\t\t} else if (*scan == '\\\\') {\n\t\t\tif ((flags & GENSUB) != 0) {\t/* gensub, behave sanely */\n\t\t\t\tif (isdigit((unsigned char) scan[1])) {\n\t\t\t\t\tampersands++;\n\t\t\t\t\tscan++;\n\t\t\t\t} else {\t/* \\q for any q --> q */\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t}\n\t\t\t} else if (do_posix) {\n\t\t\t\t/* \\& --> &, \\\\ --> \\ */\n\t\t\t\tif (scan[1] == '&' || scan[1] == '\\\\') {\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t} /* else\n\t\t\t\t\tleave alone, it goes into the output */\n\t\t\t} else {\n\t\t\t\t/* gawk default behavior since 1996 */\n\t\t\t\tif (strncmp(scan, \"\\\\\\\\\\\\&\", 4) == 0) {\n\t\t\t\t\t/* \\\\\\& --> \\& */\n\t\t\t\t\trepllen -= 2;\n\t\t\t\t\tscan += 3;\n\t\t\t\t} else if (strncmp(scan, \"\\\\\\\\&\", 3) == 0) {\n\t\t\t\t\t/* \\\\& --> \\<string> */\n\t\t\t\t\tampersands++;\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan += 2;\n\t\t\t\t} else if (scan[1] == '&') {\n\t\t\t\t\t/* \\& --> & */\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t} /* else\n\t\t\t\t\tleave alone, it goes into the output */\n\t\t\t}\n\t\t}\n\t}\n\n\tlastmatchnonzero = false;\n\n\t/* guesstimate how much room to allocate; +2 forces > 0 */\n\tbuflen = textlen + (ampersands + 1) * repllen + 2;\n\temalloc(buf, char *, buflen + 2, \"do_sub\");\n\tbuf[buflen] = '\\0';\n\tbuf[buflen + 1] = '\\0';\n\n\tbp = buf;\n\tfor (current = 1;; current++) {\n\t\tmatches++;\n\t\tmatchstart = t->stptr + RESTART(rp, t->stptr);\n\t\tmatchend = t->stptr + REEND(rp, t->stptr);\n\n\t\t/*\n\t\t * create the result, copying in parts of the original\n\t\t * string \n\t\t */\n\t\tlen = matchstart - text + repllen\n\t\t      + ampersands * (matchend - matchstart);\n\t\tsofar = bp - buf;\n\t\twhile (buflen < (sofar + len + 1)) {\n\t\t\tbuflen *= 2;\n\t\t\terealloc(buf, char *, buflen, \"sub_common\");\n\t\t\tbp = buf + sofar;\n\t\t}\n\t\tfor (scan = text; scan < matchstart; scan++)\n\t\t\t*bp++ = *scan;\n\t\tif (global || current == how_many) {\n\t\t\t/*\n\t\t\t * If the current match matched the null string,\n\t\t\t * and the last match didn't and did a replacement,\n\t\t\t * and the match of the null string is at the front of\n\t\t\t * the text (meaning right after end of the previous\n\t\t\t * replacement), then skip this one.\n\t\t\t */\n\t\t\tif (matchstart == matchend\n\t\t\t    && lastmatchnonzero\n\t\t\t    && matchstart == text) {\n\t\t\t\tlastmatchnonzero = false;\n\t\t\t\tmatches--;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If replacing all occurrences, or this is the\n\t\t\t * match we want, copy in the replacement text,\n\t\t\t * making substitutions as we go.\n\t\t\t */\n\t\t\tfor (scan = repl; scan < replend; scan++)\n"
}