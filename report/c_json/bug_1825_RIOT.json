{
    "project": "RIOT",
    "tool": "Cppcheck",
    "category": "arrayIndexOutOfBoundsCond",
    "file": "cpu/atmega_common/periph/gpio.c",
    "message": "Either the condition 'int_num<4' is redundant or the array 'config[2]' is accessed at index 4, which is out of bounds.",
    "warning_function_name": "pio_init_int(",
    "warning_line": "config[int_num].cb = cb;",
    "warning_context": "int gpio_init_int(gpio_t pin, gpio_mode_t mode, gpio_flank_t flank,\n                  gpio_cb_t cb, void *arg)\n{\n    int8_t int_num = _int_num(pin);\n\n    /* mode not supported */\n    if ((mode != GPIO_IN) && (mode != GPIO_IN_PU)) {\n        return -1;\n    }\n\n    /* not a valid interrupt pin. Set as pcint instead if pcints are enabled */\n    if (int_num < 0) {\n#ifdef ENABLE_PCINT\n        /* If pin change interrupts are enabled, enable mask and interrupt */\n        return pcint_init_int(pin, mode, flank, cb, arg);\n#else\n        return -1;\n#endif /* ENABLE_PCINT */\n    }\n\n    /* flank not supported */\n    if (flank > GPIO_RISING) {\n        return -1;\n    }\n\n    gpio_init(pin, mode);\n\n    /* clear global interrupt flag */\n    cli();\n\n    /* enable interrupt number int_num */\n    EIFR |= (1 << int_num);\n    EIMSK |= (1 << int_num);\n\n    /* apply flank to interrupt number int_num */\n    if (int_num < 4) {\n        EICRA &= ~(0x3 << (int_num * 2));\n        EICRA |= (flank << (int_num * 2));\n    }\n    #if defined(EICRB)\n    else {\n        EICRB &= ~(0x3 << ((int_num % 4) * 2));\n        EICRB |= (flank << ((int_num % 4) * 2));\n    }\n    #endif\n\n    /* set callback */\n    config[int_num].cb = cb;\n    config[int_num].arg = arg;\n\n    /* set global interrupt flag */\n    sei();\n\n    return 0;\n}\n"
}