{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t  ADVANCE_CHAR (string, slen, i);",
    "Code_function": "extract_dollar_brace_string (string, sindex, quoted, flags)\n     char *string;\n     int *sindex, quoted, flags;\n{\n  register int i, c;\n  size_t slen;\n  int pass_character, nesting_level, si, dolbrace_state;\n  char *result, *t;\n  DECLARE_MBSTATE;\n\n  pass_character = 0;\n  nesting_level = 1;\n  slen = strlen (string + *sindex) + *sindex;\n\n  /* The handling of dolbrace_state needs to agree with the code in parse.y:\n     parse_matched_pair().  The different initial value is to handle the\n     case where this function is called to parse the word in\n     ${param op word} (SX_WORD). */\n  dolbrace_state = (flags & SX_WORD) ? DOLBRACE_WORD : DOLBRACE_PARAM;\n  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && (flags & SX_POSIXEXP))\n    dolbrace_state = DOLBRACE_QUOTE;\n\n  i = *sindex;\n  while (c = string[i])\n    {\n      if (pass_character)\n\t{\n\t  pass_character = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n\n      /* CTLESCs and backslashes quote the next character. */\n      if (c == CTLESC || c == '\\\\')\n\t{\n\t  pass_character++;\n\t  i++;\n\t  continue;\n\t}\n\n      if (string[i] == '$' && string[i+1] == LBRACE)\n\t{\n\t  nesting_level++;\n\t  i += 2;\n\t  continue;\n\t}\n\n      if (c == RBRACE)\n\t{\n\t  nesting_level--;\n\t  if (nesting_level == 0)\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Pass the contents of old-style command substitutions through\n\t verbatim. */\n      if (c == '`')\n\t{\n\t  si = i + 1;\n\t  t = string_extract (string, &si, \"`\", flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* Pass the contents of new-style command substitutions and\n\t arithmetic substitutions through verbatim. */\n      if (string[i] == '$' && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  t = extract_command_subst (string, &si, flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* Pass the contents of double-quoted strings through verbatim. */\n      if (c == '\"')\n\t{\n\t  si = i + 1;\n\t  i = skip_double_quoted (string, slen, si);\n\t  /* skip_XXX_quoted leaves index one past close quote */\n\t  continue;\n\t}\n\n      if (c == '\\'')\n\t{\n/*itrace(\"extract_dollar_brace_string: c == single quote flags = %d quoted = %d dolbrace_state = %d\", flags, quoted, dolbrace_state);*/\n\t  if (posixly_correct && shell_compatibility_level > 42 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t    ADVANCE_CHAR (string, slen, i);\n\t  else\n\t    {\n\t      si = i + 1;\n\t      i = skip_single_quoted (string, slen, si);\n\t    }\n\n          continue;\n\t}\n\n      /* move past this character, which was not special. */\n      ADVANCE_CHAR (string, slen, i);\n\n      /* This logic must agree with parse.y:parse_matched_pair, since they\n\t share the same defines. */\n      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)\n\tdolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE2;\t/* XXX */\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && strchr (\"#%^,~:-=?+/\", c) != 0)\n\tdolbrace_state = DOLBRACE_OP;\n      else if (dolbrace_state == DOLBRACE_OP && strchr (\"#%^,~:-=?+/\", c) == 0)\n\tdolbrace_state = DOLBRACE_WORD;\n    }\n\n  if (c == 0 && nesting_level)\n    {\n      if (no_longjmp_on_fatal_error == 0)\n\t{\t\t\t/* { */\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  report_error (_(\"bad substitution: no closing `%s' in %s\"), \"}\", string);\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n      else\n\t{\n\t  *sindex = i;\n\t  return ((char *)NULL);\n\t}\n    }\n\n  result = (flags & SX_NOALLOC) ? (char *)NULL : substring (string, *sindex, i);\n  *sindex = i;\n\n  return (result);\n}"
}