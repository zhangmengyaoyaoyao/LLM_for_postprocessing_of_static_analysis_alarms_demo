{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/input.c",
    "message": "The value read from input was never initialized.",
    "warning_function_name": "rl_gather_tyi",
    "warning_line": "rl_stuff_char (input);",
    "warning_context": "static int\nrl_gather_tyi ()\n{\n  int tty;\n  register int tem, result;\n  int chars_avail, k;\n  char input;\n#if defined(HAVE_SELECT)\n  fd_set readfds, exceptfds;\n  struct timeval timeout;\n#endif\n\n  chars_avail = 0;\n  tty = fileno (rl_instream);\n\n#if defined (HAVE_SELECT)\n  FD_ZERO (&readfds);\n  FD_ZERO (&exceptfds);\n  FD_SET (tty, &readfds);\n  FD_SET (tty, &exceptfds);\n  USEC_TO_TIMEVAL (_keyboard_input_timeout, timeout);\n  result = select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);\n  if (result <= 0)\n    return 0;\t/* Nothing to read. */\n#endif\n\n  result = -1;\n#if defined (FIONREAD)\n  errno = 0;\n  result = ioctl (tty, FIONREAD, &chars_avail);\n  if (result == -1 && errno == EIO)\n    return -1;\n#endif\n\n#if defined (O_NDELAY)\n  if (result == -1)\n    {\n      tem = fcntl (tty, F_GETFL, 0);\n\n      fcntl (tty, F_SETFL, (tem | O_NDELAY));\n      chars_avail = read (tty, &input, 1);\n\n      fcntl (tty, F_SETFL, tem);\n      if (chars_avail == -1 && errno == EAGAIN)\n\treturn 0;\n      if (chars_avail == 0)\t/* EOF */\n\t{\n\t  rl_stuff_char (EOF);\n\t  return (0);\n\t}\n    }\n#endif /* O_NDELAY */\n\n#if defined (__MINGW32__)\n  /* Use getch/_kbhit to check for available console input, in the same way\n     that we read it normally. */\n   chars_avail = isatty (tty) ? _kbhit () : 0;\n   result = 0;\n#endif\n\n  /* If there's nothing available, don't waste time trying to read\n     something. */\n  if (chars_avail <= 0)\n    return 0;\n\n  tem = ibuffer_space ();\n\n  if (chars_avail > tem)\n    chars_avail = tem;\n\n  /* One cannot read all of the available input.  I can only read a single\n     character at a time, or else programs which require input can be\n     thwarted.  If the buffer is larger than one character, I lose.\n     Damn! */\n  if (tem < ibuffer_len)\n    chars_avail = 0;\n\n  if (result != -1)\n    {\n      while (chars_avail--)\n\t{\n\t  RL_CHECK_SIGNALS ();\n\t  k = (*rl_getc_function) (rl_instream);\n\t  if (rl_stuff_char (k) == 0)\n\t    break;\t\t\t/* some problem; no more room */\n\t  if (k == NEWLINE || k == RETURN)\n\t    break;\n\t}\n    }\n  else\n    {\n      if (chars_avail)\n\trl_stuff_char (input);\n    }\n\n  return 1;\n}\n"
}