{
    "Project": "apr",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from words[_] was never initialized.",
    "Code_line": "        tp += apr_snprintf(tp, sizeof tmp - (tp - tmp), \"%x\", words[i]);",
    "Code_function": "inet_ntop6(const unsigned char *src, char *dst, apr_size_t size)\n{\n    /*\n     * Note that int32_t and int16_t need only be \"at least\" large enough\n     * to contain a value of the specified size.  On some systems, like\n     * Crays, there is no such thing as an integer variable with 16 bits.\n     * Keep this in mind if you think this function should have been coded\n     * to use pointer overlays.  All the world's not a VAX.\n     */\n    char tmp[sizeof \"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"], *tp;\n    struct { int base, len; } best = {-1, 0}, cur = {-1, 0};\n    unsigned int words[IN6ADDRSZ / INT16SZ];\n    int i;\n    const unsigned char *next_src, *src_end;\n    unsigned int *next_dest;\n\n    /*\n     * Preprocess:\n     *\tCopy the input (bytewise) array into a wordwise array.\n     *\tFind the longest run of 0x00's in src[] for :: shorthanding.\n     */\n    next_src = src;\n    src_end = src + IN6ADDRSZ;\n    next_dest = words;\n    i = 0;\n    do {\n        unsigned int next_word = (unsigned int)*next_src++;\n        next_word <<= 8;\n        next_word |= (unsigned int)*next_src++;\n        *next_dest++ = next_word;\n\n        if (next_word == 0) {\n            if (cur.base == -1) {\n                cur.base = i;\n                cur.len = 1;\n            }\n            else {\n                cur.len++;\n            }\n        } else {\n            if (cur.base != -1) {\n                if (best.base == -1 || cur.len > best.len) {\n                    best = cur;\n                }\n                cur.base = -1;\n            }\n        }\n\n        i++;\n    } while (next_src < src_end);\n\n    if (cur.base != -1) {\n        if (best.base == -1 || cur.len > best.len) {\n            best = cur;\n        }\n    }\n    if (best.base != -1 && best.len < 2) {\n        best.base = -1;\n    }\n\n    /*\n     * Format the result.\n     */\n    tp = tmp;\n    for (i = 0; i < (IN6ADDRSZ / INT16SZ);) {\n        /* Are we inside the best run of 0x00's? */\n        if (i == best.base) {\n            *tp++ = ':';\n            i += best.len;\n            continue;\n        }\n        /* Are we following an initial run of 0x00s or any real hex? */\n        if (i != 0) {\n            *tp++ = ':';\n        }\n        /* Is this address an encapsulated IPv4? */\n        if (i == 6 && best.base == 0 &&\n            (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {\n            if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp))) {\n                return (NULL);\n            }\n            tp += strlen(tp);\n            break;\n        }\n        tp += apr_snprintf(tp, sizeof tmp - (tp - tmp), \"%x\", words[i]);\n        i++;\n    }\n    /* Was it a trailing run of 0x00's? */\n    if (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ)) {\n        *tp++ = ':';\n    }\n    *tp++ = '\\0';\n\n    /*\n     * Check for overflow, copy, and we're done.\n     */\n    if ((apr_size_t)(tp - tmp) > size) {\n        errno = ENOSPC;\n        return (NULL);\n    }\n    strcpy(dst, tmp);\n    return (dst);\n}"
}