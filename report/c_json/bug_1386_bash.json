{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "      igncase = RL_BOOLEAN_VARIABLE_VALUE (temp);",
    "Code_function": "command_word_completion_function (hint_text, state)\n     const char *hint_text;\n     int state;\n{\n  static char *hint = (char *)NULL;\n  static char *path = (char *)NULL;\n  static char *val = (char *)NULL;\n  static char *filename_hint = (char *)NULL;\n  static char *fnhint = (char *)NULL;\n  static char *dequoted_hint = (char *)NULL;\n  static char *directory_part = (char *)NULL;\n  static char **glob_matches = (char **)NULL;\n  static int path_index, hint_len, dequoted_len, istate, igncase;\n  static int mapping_over, local_index, searching_path, hint_is_dir;\n  static int old_glob_ignore_case, globpat;\n  static SHELL_VAR **varlist = (SHELL_VAR **)NULL;\n#if defined (ALIAS)\n  static alias_t **alias_list = (alias_t **)NULL;\n#endif /* ALIAS */\n  char *temp, *cval;\n\n  /* We have to map over the possibilities for command words.  If we have\n     no state, then make one just for that purpose. */\n  if (state == 0)\n    {\n      rl_filename_stat_hook = bash_command_name_stat_hook;\n\n      if (dequoted_hint && dequoted_hint != hint)\n\tfree (dequoted_hint);\n      if (hint)\n\tfree (hint);\n\n      mapping_over = searching_path = 0;\n      hint_is_dir = CMD_IS_DIR (hint_text);\n      val = (char *)NULL;\n\n      temp = rl_variable_value (\"completion-ignore-case\");\n      igncase = RL_BOOLEAN_VARIABLE_VALUE (temp);\n\n      if (glob_matches)\n\t{\n\t  free (glob_matches);\n\t  glob_matches = (char **)NULL;\n\t}\n\n      globpat = glob_pattern_p (hint_text);\n\n      /* If this is an absolute program name, do not check it against\n\t aliases, reserved words, functions or builtins.  We must check\n\t whether or not it is unique, and, if so, whether that filename\n\t is executable. */\n      if (globpat || absolute_program (hint_text))\n\t{\n\t  /* Perform tilde expansion on what's passed, so we don't end up\n\t     passing filenames with tildes directly to stat(). */\n\t  if (*hint_text == '~')\n\t    {\n\t      hint = bash_tilde_expand (hint_text, 0);\n\t      directory_part = savestring (hint_text);\n\t      temp = strchr (directory_part, '/');\n\t      if (temp)\n\t\t*temp = 0;\n\t      else\n\t\t{\n\t\t  free (directory_part);\n\t\t  directory_part = (char *)NULL;\n\t\t}\n\t    }\n\t  else\n\t    hint = savestring (hint_text);\n\n\t  dequoted_hint = hint;\n\t  /* If readline's completer found a quote character somewhere, but\n\t     didn't set the quote character, there must have been a quote\n\t     character embedded in the filename.  It can't be at the start of\n\t     the filename, so we need to dequote the filename before we look\n\t     in the file system for it. */\n\t  if (rl_completion_found_quote && rl_completion_quote_character == 0)\n\t    {\n\t      dequoted_hint = bash_dequote_filename (hint, 0);\n\t      free (hint);\n\t      hint = dequoted_hint;\n\t    }\n\t  dequoted_len = hint_len = strlen (hint);\n\n\t  if (filename_hint)\n\t    free (filename_hint);\n\n\t  fnhint = filename_hint = savestring (hint);\n\n\t  istate = 0;\n\n\t  if (globpat)\n\t    {\n\t      mapping_over = 5;\n\t      goto globword;\n\t    }\n\t  else\n\t    {\n\t     if (dircomplete_expand && path_dot_or_dotdot (filename_hint))\n\t\t{\n\t\t  dircomplete_expand = 0;\n\t\t  set_directory_hook ();\n\t\t  dircomplete_expand = 1;\n\t\t}\n\t      mapping_over = 4;\n\t      goto inner;\n\t    }\n\t}\n\n      dequoted_hint = hint = savestring (hint_text);\n      dequoted_len = hint_len = strlen (hint);\n\n      if (rl_completion_found_quote && rl_completion_quote_character == 0)\n\t{\n\t  dequoted_hint = bash_dequote_filename (hint, 0);\n\t  dequoted_len = strlen (dequoted_hint);\n\t}\n\n      path = get_string_value (\"PATH\");\n      path_index = dot_in_path = 0;\n\n      /* Initialize the variables for each type of command word. */\n      local_index = 0;\n\n      if (varlist)\n\tfree (varlist);\n\n      varlist = all_visible_functions ();\n\n#if defined (ALIAS)\n      if (alias_list)\n\tfree (alias_list);\n\n      alias_list = all_aliases ();\n#endif /* ALIAS */\n    }\n\n  /* mapping_over says what we are currently hacking.  Note that every case\n     in this list must fall through when there are no more possibilities. */\n\n  switch (mapping_over)\n    {\n    case 0:\t\t\t/* Aliases come first. */\n#if defined (ALIAS)\n      while (alias_list && alias_list[local_index])\n\t{\n\t  register char *alias;\n\n\t  alias = alias_list[local_index++]->name;\n\n\t  if (STREQN (alias, hint, hint_len))\n\t    return (savestring (alias));\n\t}\n#endif /* ALIAS */\n      local_index = 0;\n      mapping_over++;\n\n    case 1:\t\t\t/* Then shell reserved words. */\n      {\n\twhile (word_token_alist[local_index].word)\n\t  {\n\t    register char *reserved_word;\n\n\t    reserved_word = word_token_alist[local_index++].word;\n\n\t    if (STREQN (reserved_word, hint, hint_len))\n\t      return (savestring (reserved_word));\n\t  }\n\tlocal_index = 0;\n\tmapping_over++;\n      }\n\n    case 2:\t\t\t/* Then function names. */\n      while (varlist && varlist[local_index])\n\t{\n\t  register char *varname;\n\n\t  varname = varlist[local_index++]->name;\n\n\t  if (STREQN (varname, hint, hint_len))\n\t    return (savestring (varname));\n\t}\n      local_index = 0;\n      mapping_over++;\n\n    case 3:\t\t\t/* Then shell builtins. */\n      for (; local_index < num_shell_builtins; local_index++)\n\t{\n\t  /* Ignore it if it doesn't have a function pointer or if it\n\t     is not currently enabled. */\n\t  if (!shell_builtins[local_index].function ||\n\t      (shell_builtins[local_index].flags & BUILTIN_ENABLED) == 0)\n\t    continue;\n\n\t  if (STREQN (shell_builtins[local_index].name, hint, hint_len))\n\t    {\n\t      int i = local_index++;\n\n\t      return (savestring (shell_builtins[i].name));\n\t    }\n\t}\n      local_index = 0;\n      mapping_over++;\n    }\n\nglobword:\n  /* Limited support for completing command words with globbing chars.  Only\n     a single match (multiple matches that end up reducing the number of\n     characters in the common prefix are bad) will ever be returned on\n     regular completion. */\n  if (globpat)\n    {\n      if (state == 0)\n\t{\n\t  glob_ignore_case = igncase;\n\t  glob_matches = shell_glob_filename (hint);\n\t  glob_ignore_case = old_glob_ignore_case;\n\n\t  if (GLOB_FAILED (glob_matches) || glob_matches == 0)\n\t    {\n\t      glob_matches = (char **)NULL;\n\t      return ((char *)NULL);\n\t    }\n\n\t  local_index = 0;\n\n\t  if (glob_matches[1] && rl_completion_type == TAB)\t/* multiple matches are bad */\n\t    return ((char *)NULL);\n\t}\n\n      while (val = glob_matches[local_index++])\n        {\n\t  if (executable_or_directory (val))\n\t    {\n\t      if (*hint_text == '~' && directory_part)\n\t\t{\n\t\t  temp = maybe_restore_tilde (val, directory_part);\n\t\t  free (val);\n\t\t  val = temp;\n\t\t}\n\t      return (val);\n\t    }\n\t  free (val);\n        }\n\n      glob_ignore_case = old_glob_ignore_case;\n      return ((char *)NULL);\n    }\n\n  /* If the text passed is a directory in the current directory, return it\n     as a possible match.  Executables in directories in the current\n     directory can be specified using relative pathnames and successfully\n     executed even when `.' is not in $PATH. */\n  if (hint_is_dir)\n    {\n      hint_is_dir = 0;\t/* only return the hint text once */\n      return (savestring (hint_text));\n    }\n\n  /* Repeatedly call filename_completion_function while we have\n     members of PATH left.  Question:  should we stat each file?\n     Answer: we call executable_file () on each file. */\n outer:\n\n  istate = (val != (char *)NULL);\n\n  if (istate == 0)\n    {\n      char *current_path;\n\n      /* Get the next directory from the path.  If there is none, then we\n\t are all done. */\n      if (path == 0 || path[path_index] == 0 ||\n\t  (current_path = extract_colon_unit (path, &path_index)) == 0)\n\treturn ((char *)NULL);\n\n      searching_path = 1;\n      if (*current_path == 0)\n\t{\n\t  free (current_path);\n\t  current_path = savestring (\".\");\n\t}\n\n      if (*current_path == '~')\n\t{\n\t  char *t;\n\n\t  t = bash_tilde_expand (current_path, 0);\n\t  free (current_path);\n\t  current_path = t;\n\t}\n\n      if (current_path[0] == '.' && current_path[1] == '\\0')\n\tdot_in_path = 1;\n\n      if (fnhint && fnhint != filename_hint)\n\tfree (fnhint);\n      if (filename_hint)\n\tfree (filename_hint);\n\n      filename_hint = sh_makepath (current_path, hint, 0);\n      /* Need a quoted version (though it doesn't matter much in most\n\t cases) because rl_filename_completion_function dequotes the\n\t filename it gets, assuming that it's been quoted as part of\n\t the input line buffer. */\n      if (strpbrk (filename_hint, \"\\\"'\\\\\"))\n\tfnhint = sh_backslash_quote (filename_hint, filename_bstab, 0);\n      else\n\tfnhint = filename_hint;\n      free (current_path);\t\t/* XXX */\n    }\n\n inner:\n  val = rl_filename_completion_function (fnhint, istate);\n  if (mapping_over == 4 && dircomplete_expand)\n    set_directory_hook ();\n\n  istate = 1;\n\n  if (val == 0)\n    {\n      /* If the hint text is an absolute program, then don't bother\n\t searching through PATH. */\n      if (absolute_program (hint))\n\treturn ((char *)NULL);\n\n      goto outer;\n    }\n  else\n    {\n      int match, freetemp;\n\n      if (absolute_program (hint))\n\t{\n\t  if (igncase == 0)\n\t    match = strncmp (val, hint, hint_len) == 0;\n\t  else\n\t    match = strncasecmp (val, hint, hint_len) == 0;\n\n\t  /* If we performed tilde expansion, restore the original\n\t     filename. */\n\t  if (*hint_text == '~')\n\t    temp = maybe_restore_tilde (val, directory_part);\n\t  else\n\t    temp = savestring (val);\n\t  freetemp = 1;\n\t}\n      else\n\t{\n\t  temp = strrchr (val, '/');\n\n\t  if (temp)\n\t    {\n\t      temp++;\n\t      if (igncase == 0)\n\t\tfreetemp = match = strncmp (temp, hint, hint_len) == 0;\n\t      else\n\t\tfreetemp = match = strncasecmp (temp, hint, hint_len) == 0;\n\t      if (match)\n\t\ttemp = savestring (temp);\n\t    }\n\t  else\n\t    freetemp = match = 0;\n\t}\n\n      /* If we have found a match, and it is an executable file, return it.\n\t We don't return directory names when searching $PATH, since the\n\t bash execution code won't find executables in directories which\n\t appear in directories in $PATH when they're specified using\n\t relative pathnames.  */\n#if 0\n      /* If we're not searching $PATH and we have a relative pathname, we\n\t need to re-canonicalize it before testing whether or not it's an\n\t executable or a directory so the shell treats .. relative to $PWD\n\t according to the physical/logical option.  The shell already\n\t canonicalizes the directory name in order to tell readline where\n\t to look, so not doing it here will be inconsistent. */\n      /* XXX -- currently not used -- will introduce more inconsistency,\n\t since shell does not canonicalize ../foo before passing it to\n\t shell_execve().  */\n      if (match && searching_path == 0 && *val == '.')\n\t{\n\t  char *t, *t1;\n\n\t  t = get_working_directory (\"command-word-completion\");\n\t  t1 = make_absolute (val, t);\n\t  free (t);\n\t  cval = sh_canonpath (t1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\t}\n      else\n#endif\n\tcval = val;\n\n      if (match && executable_completion ((searching_path ? val : cval), searching_path))\n\t{\n\t  if (cval != val)\n\t    free (cval);\n\t  free (val);\n\t  val = \"\";\t\t/* So it won't be NULL. */\n\t  return (temp);\n\t}\n      else\n\t{\n\t  if (freetemp)\n\t    free (temp);\n\t  if (cval != val)\n\t    free (cval);\n\t  free (val);\n\t  goto inner;\n\t}\n    }\n}"
}