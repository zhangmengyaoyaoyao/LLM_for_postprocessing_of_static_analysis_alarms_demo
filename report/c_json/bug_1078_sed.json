{
    "Project": "sed",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Code_line": "\t      strcpy (in_place_extension + 1, optarg);",
    "Code_function": "main(argc, argv)\n  int argc;\n  char **argv;\n{\n#ifdef REG_PERL\n#define SHORTOPTS \"bsnrRuEe:f:l:i::V:\"\n#else\n#define SHORTOPTS \"bsnruEe:f:l:i::V:\"\n#endif\n\n  static struct option longopts[] = {\n    {\"binary\", 0, NULL, 'b'},\n    {\"regexp-extended\", 0, NULL, 'r'},\n#ifdef REG_PERL\n    {\"regexp-perl\", 0, NULL, 'R'},\n#endif\n    {\"expression\", 1, NULL, 'e'},\n    {\"file\", 1, NULL, 'f'},\n    {\"in-place\", 2, NULL, 'i'},\n    {\"line-length\", 1, NULL, 'l'},\n    {\"quiet\", 0, NULL, 'n'},\n    {\"posix\", 0, NULL, 'p'},\n    {\"silent\", 0, NULL, 'n'},\n    {\"separate\", 0, NULL, 's'},\n    {\"unbuffered\", 0, NULL, 'u'},\n    {\"version\", 0, NULL, 'v'},\n    {\"help\", 0, NULL, 'h'},\n#ifdef ENABLE_FOLLOW_SYMLINKS\n    {\"follow-symlinks\", 0, NULL, 'F'},\n#endif\n    {NULL, 0, NULL, 0}\n  };\n\n  int opt;\n  int return_code;\n  const char *cols = getenv(\"COLS\");\n\n  program_name = argv[0];\n  initialize_main (&argc, &argv);\n#if HAVE_SETLOCALE\n  /* Set locale according to user's wishes.  */\n  setlocale (LC_ALL, \"\");\n#endif\n  initialize_mbcs ();\n\n#if ENABLE_NLS\n\n  /* Tell program which translations to use and where to find.  */\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  if (getenv(\"POSIXLY_CORRECT\") != NULL)\n    posixicity = POSIXLY_CORRECT;\n  else\n    posixicity = POSIXLY_EXTENDED;\n\n  /* If environment variable `COLS' is set, use its value for\n     the baseline setting of `lcmd_out_line_len'.  The \"-1\"\n     is to avoid gratuitous auto-line-wrap on ttys.\n   */\n  if (cols)\n    {\n      countT t = ATOI(cols);\n      if (t > 1)\n\tlcmd_out_line_len = t-1;\n    }\n\n  myname = *argv;\n  while ((opt = getopt_long(argc, argv, SHORTOPTS, longopts, NULL)) != EOF)\n    {\n      switch (opt)\n\t{\n\tcase 'n':\n\t  no_default_output = true;\n\t  break;\n\tcase 'e':\n\t  the_program = compile_string(the_program, optarg, strlen(optarg));\n\t  break;\n\tcase 'f':\n\t  the_program = compile_file(the_program, optarg);\n\t  break;\n\n\tcase 'F':\n\t  follow_symlinks = true;\n\t  break;\n\n\tcase 'i':\n\t  separate_files = true;\n\t  if (optarg == NULL)\n\t    /* use no backups */\n\t    in_place_extension = ck_strdup (\"*\");\n\n\t  else if (strchr(optarg, '*') != NULL)\n\t    in_place_extension = ck_strdup(optarg);\n\n\t  else\n\t    {\n\t      in_place_extension = MALLOC (strlen(optarg) + 2, char);\n\t      in_place_extension[0] = '*';\n\t      strcpy (in_place_extension + 1, optarg);\n\t    }\n\n\t  break;\n\n\tcase 'l':\n\t  lcmd_out_line_len = ATOI(optarg);\n\t  break;\n\n\tcase 'p':\n\t  posixicity = POSIXLY_BASIC;\n\t  break;\n\n        case 'b':\n\t  read_mode = \"rb\";\n\t  break;\n\n\t/* Undocumented, for compatibility with BSD sed.  */\n\tcase 'E':\n\tcase 'r':\n\t  if (extended_regexp_flags)\n\t    usage(4);\n\t  extended_regexp_flags = REG_EXTENDED;\n\t  break;\n\n#ifdef REG_PERL\n\tcase 'R':\n\t  if (extended_regexp_flags)\n\t    usage(4);\n\t  extended_regexp_flags = REG_PERL;\n\t  break;\n#endif\n\n\tcase 's':\n\t  separate_files = true;\n\t  break;\n\n\tcase 'u':\n\t  unbuffered_output = true;\n\t  break;\n\n\tcase 'v':\n#ifdef REG_PERL\n\t  fprintf(stdout, _(\"super-sed version %s\\n\"), VERSION);\n\t  fprintf(stdout, _(\"based on GNU sed version %s\\n\\n\"), SED_FEATURE_VERSION);\n#else\n\t  fprintf(stdout, _(\"GNU sed version %s\\n\"), VERSION);\n#endif\n\t  fprintf(stdout, _(\"%s\\n\\\nThis is free software; see the source for copying conditions.  There is NO\\n\\\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE,\\n\\\nto the extent permitted by law.\\n\\\n\"), COPYRIGHT_NOTICE);\n\t  fputc('\\n', stdout);\n\t  contact(false);\n\n\t  ck_fclose (NULL);\n\t  exit (0);\n\tcase 'h':\n\t  usage(0);\n\tdefault:\n\t  usage(4);\n\t}\n    }\n\n  if (!the_program)\n    {\n      if (optind < argc)\n\t{\n\t  char *arg = argv[optind++];\n\t  the_program = compile_string(the_program, arg, strlen(arg));\n\t}\n      else\n\tusage(4);\n    }\n  check_final_program(the_program);\n\n  return_code = process_files(the_program, argv+optind);\n\n  finish_program(the_program);\n  ck_fclose(NULL);\n\n  return return_code;\n}"
}