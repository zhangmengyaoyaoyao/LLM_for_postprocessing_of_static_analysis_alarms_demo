{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "braces.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "ADVANCE_CHAR (amble, alen, j);",
    "warning_context": "\t      break;\n\t    }\n\t}\n      else\n\tbreak;\n    }\n  while (c);\n#endif /* !CSH_BRACE_COMPAT */\n\n  preamble = (char *)xmalloc (i + 1);\n  if (i > 0)\n    strncpy (preamble, text, i);\n  preamble[i] = '\\0';\n\n  result = (char **)xmalloc (2 * sizeof (char *));\n  result[0] = preamble;\n  result[1] = (char *)NULL;\n\n  /* Special case.  If we never found an exciting character, then\n     the preamble is all of the text, so just return that. */\n  if (c != '{')\n    return (result);\n\n  /* Find the amble.  This is the stuff inside this set of braces. */\n  start = ++i;\n  c = brace_gobbler (text, tlen, &i, '}');\n\n  /* What if there isn't a matching close brace? */\n  if (c == 0)\n    {\n#if defined (NOTDEF)\n      /* Well, if we found an unquoted BRACE_ARG_SEPARATOR between START\n\t and I, then this should be an error.  Otherwise, it isn't. */\n      j = start;\n      while (j < i)\n\t{\n\t  if (text[j] == '\\\\')\n\t    {\n\t      j++;\n\t      ADVANCE_CHAR (text, tlen, j);\n\t      continue;\n\t    }\n\n\t  if (text[j] == brace_arg_separator)\n\t    {\t/* { */\n\t      strvec_dispose (result);\n\t      last_command_exit_value = 1;\n\t      report_error (\"no closing `%c' in %s\", '}', text);\n\t      throw_to_top_level ();\n\t    }\n\t  ADVANCE_CHAR (text, tlen, j);\n\t}\n#endif\n      free (preamble);\t\t/* Same as result[0]; see initialization. */\n      result[0] = savestring (text);\n      return (result);\n    }\n\n#if defined (SHELL)\n  amble = substring (text, start, i);\n  alen = i - start;\n#else\n  amble = (char *)xmalloc (1 + (i - start));\n  strncpy (amble, &text[start], (i - start));\n  alen = i - start;\n  amble[alen] = '\\0';\n#endif\n\n#if defined (SHELL)\n  INITIALIZE_MBSTATE;\n\n  /* If the amble does not contain an unquoted BRACE_ARG_SEPARATOR, then\n     just return without doing any expansion.  */\n  j = 0;\n  while (amble[j])\n    {\n      if (amble[j] == '\\\\')\n\t{\n\t  j++;\n\t  ADVANCE_CHAR (amble, alen, j);\n\t  continue;\n\t}\n\n      if (amble[j] == brace_arg_separator)\n\tbreak;\n\n      ADVANCE_CHAR (amble, alen, j);\n    }\n\n  if (amble[j] == 0)\n    {\n      tack = expand_seqterm (amble, alen);\n      if (tack)\n\tgoto add_tack;\n      else if (text[i + 1])\n\t{\n\t  /* If the sequence expansion fails (e.g., because the integers\n\t     overflow), but there is more in the string, try and process\n\t     the rest of the string, which may contain additional brace\n\t     expansions.  Treat the unexpanded sequence term as a simple\n\t     string (including the braces). */\n"
}