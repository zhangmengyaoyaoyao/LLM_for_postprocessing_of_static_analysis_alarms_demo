{
    "Project": "sed",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "lib/localcharset.c",
    "message": "Offset: [1, +oo] (‚áê [0, +oo] + 1) Size: 1.",
    "warning_function_name": "locale_charset",
    "warning_line": "|| (aliases[0] == '*' && aliases[1] == '\\0'))",
    "warning_context": "  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WIN32_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* Woe32 has a function returning the locale's codepage as a number.  */\n  sprintf (buf, \"CP%u\", GetACP ());\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n\tlocale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n\t{\n\t  const char *modifier;\n\n\t  dot++;\n\t  /* Look for the possible @... trailer and remove it, if any.  */\n\t  modifier = strchr (dot, '@');\n\t  if (modifier == NULL)\n\t    return dot;\n\t  if (modifier - dot < sizeof (buf))\n\t    {\n\t      memcpy (buf, dot, modifier - dot);\n\t      buf [modifier - dot] = '\\0';\n\t      return buf;\n\t    }\n\t}\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n\tcodeset = \"\";\n      else\n\t{\n\t  sprintf (buf, \"CP%u\", cp[0]);\n\t  codeset = buf;\n\t}\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n\t|| (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n\tcodeset = aliases + strlen (aliases) + 1;\n\tbreak;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n  return codeset;\n}\n"
}