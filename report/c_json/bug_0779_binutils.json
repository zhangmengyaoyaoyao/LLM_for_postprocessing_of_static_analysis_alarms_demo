{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/expr.c",
    "message": "The value read from seg_left was never initialized.",
    "warning_function_name": "resolve_expression",
    "warning_line": "if (seg_left == absolute_section)",
    "warning_context": "\t      break;\n\t    }\n\t  else if ((op == O_multiply || op == O_divide)\n\t\t   && seg_right == absolute_section && right == 1)\n\t    {\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t  else if (!(left == right\n\t\t     && ((seg_left == reg_section && seg_right == reg_section)\n\t\t\t || (seg_left == undefined_section\n\t\t\t     && seg_right == undefined_section\n\t\t\t     && add_symbol == op_symbol))))\n\t    return 0;\n\t  else if (op == O_bit_and || op == O_bit_inclusive_or)\n\t    {\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t  else if (op != O_bit_exclusive_or && op != O_bit_or_not)\n\t    return 0;\n\t}\n\n      right += frag_off / OCTETS_PER_BYTE;\n      switch (op)\n\t{\n\tcase O_add:\t\t\tleft += right; break;\n\tcase O_subtract:\t\tleft -= right; break;\n\tcase O_multiply:\t\tleft *= right; break;\n\tcase O_divide:\n\t  if (right == 0)\n\t    return 0;\n\t  left = (offsetT) left / (offsetT) right;\n\t  break;\n\tcase O_modulus:\n\t  if (right == 0)\n\t    return 0;\n\t  left = (offsetT) left % (offsetT) right;\n\t  break;\n\tcase O_left_shift:\t\tleft <<= right; break;\n\tcase O_right_shift:\t\tleft >>= right; break;\n\tcase O_bit_inclusive_or:\tleft |= right; break;\n\tcase O_bit_or_not:\t\tleft |= ~right; break;\n\tcase O_bit_exclusive_or:\tleft ^= right; break;\n\tcase O_bit_and:\t\t\tleft &= right; break;\n\tcase O_eq:\n\tcase O_ne:\n\t  left = (left == right\n\t\t  && seg_left == seg_right\n\t\t  && (finalize_syms || frag_left == frag_right)\n\t\t  && (seg_left != undefined_section\n\t\t      || add_symbol == op_symbol)\n\t\t  ? ~ (valueT) 0 : 0);\n\t  if (op == O_ne)\n\t    left = ~left;\n\t  break;\n\tcase O_lt:\n\t  left = (offsetT) left <  (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_le:\n\t  left = (offsetT) left <= (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_ge:\n\t  left = (offsetT) left >= (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_gt:\n\t  left = (offsetT) left >  (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_logical_and:\tleft = left && right; break;\n\tcase O_logical_or:\tleft = left || right; break;\n\tdefault:\t\tabort ();\n\t}\n\n      op = O_constant;\n      break;\n    }\n\n  if (op == O_symbol)\n    {\n      if (seg_left == absolute_section)\n\top = O_constant;\n      else if (seg_left == reg_section && final_val == 0)\n\top = O_register;\n      else if (!symbol_same_p (add_symbol, orig_add_symbol))\n\tfinal_val += left;\n      expressionP->X_add_symbol = add_symbol;\n    }\n  expressionP->X_op = op;\n\n  if (op == O_constant || op == O_register)\n    final_val += left;\n  expressionP->X_add_number = final_val;\n\n  return 1;\n}\n\n/* This lives here because it belongs equally in expr.c & read.c.\n   expr.c is just a branch office read.c anyway, and putting it\n   here lessens the crowd at read.c.\n\n   Assume input_line_pointer is at start of symbol name.\n"
}