{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "subst.c",
    "message": "Access to field 'word' results in a dereference of a null pointer (loaded from field 'word')",
    "warning_function_name": "param_expand",
    "warning_line": "temp = savestring (list->word->word);",
    "warning_context": "\t      temp_has_dollar_at = 0;\t/* XXX */\n\t      /* Need to get W_HASQUOTEDNULL flag through this function. */\n\t      list = expand_word_internal (tword, Q_DOUBLE_QUOTES, 0, &temp_has_dollar_at, (int *)NULL);\n\t      has_dollar_at += temp_has_dollar_at;\n\n\t      if (list == &expand_word_error || list == &expand_word_fatal)\n\t\t{\n\t\t  free (istring);\n\t\t  free (string);\n\t\t  /* expand_word_internal has already freed temp_word->word\n\t\t     for us because of the way it prints error messages. */\n\t\t  tword->word = (char *)NULL;\n\t\t  dispose_word (tword);\n\t\t  return list;\n\t\t}\n\n\t      dispose_word (tword);\n\n\t      /* \"$@\" (a double-quoted dollar-at) expands into nothing,\n\t\t not even a NULL word, when there are no positional\n\t\t parameters. */\n\t      if (list == 0 && has_dollar_at)\n\t\t{\n\t\t  quoted_dollar_at++;\n\t\t  break;\n\t\t}\n\n\t      /* If we get \"$@\", we know we have expanded something, so we\n\t\t need to remember it for the final split on $IFS.  This is\n\t\t a special case; it's the only case where a quoted string\n\t\t can expand into more than one word.  It's going to come back\n\t\t from the above call to expand_word_internal as a list with\n\t\t a single word, in which all characters are quoted and\n\t\t separated by blanks.  What we want to do is to turn it back\n\t\t into a list for the next piece of code. */\n\t      if (list)\n\t\tdequote_list (list);\n\n\t      if (list && list->word && (list->word->flags & W_HASQUOTEDNULL))\n\t\thad_quoted_null = 1;\t\t/* XXX */\n\n\t      if (has_dollar_at)\n\t\t{\n\t\t  quoted_dollar_at++;\n\t\t  if (contains_dollar_at)\n\t\t    *contains_dollar_at = 1;\n\t\t  if (expanded_something)\n\t\t    *expanded_something = 1;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* What we have is \"\".  This is a minor optimization. */\n\t      FREE (temp);\n\t      list = (WORD_LIST *)NULL;\n\t    }\n\n\t  /* The code above *might* return a list (consider the case of \"$@\",\n\t     where it returns \"$1\", \"$2\", etc.).  We can't throw away the\n\t     rest of the list, and we have to make sure each word gets added\n\t     as quoted.  We test on tresult->next:  if it is non-NULL, we\n\t     quote the whole list, save it to a string with string_list, and\n\t     add that string. We don't need to quote the results of this\n\t     (and it would be wrong, since that would quote the separators\n\t     as well), so we go directly to add_string. */\n\t  if (list)\n\t    {\n\t      if (list->next)\n\t\t{\n\t\t  /* Testing quoted_dollar_at makes sure that \"$@\" is\n\t\t     split correctly when $IFS does not contain a space. */\n\t\t  temp = quoted_dollar_at\n\t\t\t\t? string_list_dollar_at (list, Q_DOUBLE_QUOTES)\n\t\t\t\t: string_list (quote_list (list));\n\t\t  dispose_words (list);\n\t\t  goto add_string;\n\t\t}\n\t      else\n\t\t{\n\t\t  temp = savestring (list->word->word);\n\t\t  tflag = list->word->flags;\n\t\t  dispose_words (list);\n\n\t\t  /* If the string is not a quoted null string, we want\n\t\t     to remove any embedded unquoted CTLNUL characters.\n\t\t     We do not want to turn quoted null strings back into\n\t\t     the empty string, though.  We do this because we\n\t\t     want to remove any quoted nulls from expansions that\n\t\t     contain other characters.  For example, if we have\n\t\t     x\"$*\"y or \"x$*y\" and there are no positional parameters,\n\t\t     the $* should expand into nothing. */\n\t\t  /* We use the W_HASQUOTEDNULL flag to differentiate the\n\t\t     cases:  a quoted null character as above and when\n\t\t     CTLNUL is contained in the (non-null) expansion\n\t\t     of some variable.  We use the had_quoted_null flag to\n\t\t     pass the value through this function to its caller. */\n\t\t  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)\n\t\t    remove_quoted_nulls (temp);\t/* XXX */\n\t\t}\n\t    }\n\t  else\n"
}