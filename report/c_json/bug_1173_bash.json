{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "  signal_names[NSIG+2] = \"RETURN\";",
    "Code_function": "initialize_signames ()\n{\n  register int i;\n#if defined (SIGRTMAX) || defined (SIGRTMIN)\n  int rtmin, rtmax, rtcnt;\n#endif\n\n  for (i = 1; i < signal_names_size; i++)\n    signal_names[i] = (char *)NULL;\n\n  /* `signal' 0 is what we do on exit. */\n  signal_names[0] = \"EXIT\";\n\n  /* Place signal names which can be aliases for more common signal\n     names first.  This allows (for example) SIGABRT to overwrite SIGLOST. */\n\n  /* POSIX 1003.1b-1993 real time signals, but take care of incomplete\n     implementations. Acoording to the standard, both, SIGRTMIN and\n     SIGRTMAX must be defined, SIGRTMIN must be strictly less than\n     SIGRTMAX, and the difference must be at least 7, that is, there\n     must be at least eight distinct real time signals. */\n\n  /* The generated signal names are SIGRTMIN, SIGRTMIN+1, ...,\n     SIGRTMIN+x, SIGRTMAX-x, ..., SIGRTMAX-1, SIGRTMAX. If the number\n     of RT signals is odd, there is an extra SIGRTMIN+(x+1).\n     These names are the ones used by ksh and /usr/xpg4/bin/sh on SunOS5. */\n\n#if defined (SIGRTMIN)\n  rtmin = SIGRTMIN;\n  signal_names[rtmin] = \"SIGRTMIN\";\n#endif\n\n#if defined (SIGRTMAX)\n  rtmax = SIGRTMAX;\n  signal_names[rtmax] = \"SIGRTMAX\";\n#endif\n\n#if defined (SIGRTMAX) && defined (SIGRTMIN)\n  if (rtmax > rtmin)\n    {\n      rtcnt = (rtmax - rtmin - 1) / 2;\n      /* croak if there are too many RT signals */\n      if (rtcnt >= RTLIM/2)\n\t{\n\t  rtcnt = RTLIM/2-1;\n#ifdef BUILDTOOL\n\t  fprintf(stderr, \"%s: error: more than %d real time signals, fix `%s'\\n\",\n\t\t  progname, RTLIM, progname);\n#endif\n\t}\n\n      for (i = 1; i <= rtcnt; i++)\n\t{\n\t  signal_names[rtmin+i] = (char *)malloc(RTLEN);\n\t  if (signal_names[rtmin+i])\n\t    sprintf (signal_names[rtmin+i], \"SIGRTMIN+%d\", i);\n\t  signal_names[rtmax-i] = (char *)malloc(RTLEN);\n\t  if (signal_names[rtmax-i])\n\t    sprintf (signal_names[rtmax-i], \"SIGRTMAX-%d\", i);\n\t}\n\n      if (rtcnt < RTLIM/2-1 && rtcnt != (rtmax-rtmin)/2)\n\t{\n\t  /* Need an extra RTMIN signal */\n\t  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);\n\t  if (signal_names[rtmin+rtcnt+1])\n\t    sprintf (signal_names[rtmin+rtcnt+1], \"SIGRTMIN+%d\", rtcnt+1);\n\t}\n    }\n#endif /* SIGRTMIN && SIGRTMAX */\n\n#if defined (SIGLOST)\t/* resource lost (eg, record-lock lost) */\n  signal_names[SIGLOST] = \"SIGLOST\";\n#endif\n\n/* AIX */\n#if defined (SIGMSG)\t/* HFT input data pending */\n  signal_names[SIGMSG] = \"SIGMSG\";\n#endif\n\n#if defined (SIGDANGER)\t/* system crash imminent */\n  signal_names[SIGDANGER] = \"SIGDANGER\";\n#endif\n\n#if defined (SIGMIGRATE) /* migrate process to another CPU */\n  signal_names[SIGMIGRATE] = \"SIGMIGRATE\";\n#endif\n\n#if defined (SIGPRE)\t/* programming error */\n  signal_names[SIGPRE] = \"SIGPRE\";\n#endif\n\n#if defined (SIGVIRT)\t/* AIX virtual time alarm */\n  signal_names[SIGVIRT] = \"SIGVIRT\";\n#endif\n\n#if defined (SIGALRM1)\t/* m:n condition variables */\n  signal_names[SIGALRM1] = \"SIGALRM1\";\n#endif\n\n#if defined (SIGWAITING)\t/* m:n scheduling */\n  signal_names[SIGWAITING] = \"SIGWAITING\";\n#endif\n\n#if defined (SIGGRANT)\t/* HFT monitor mode granted */\n  signal_names[SIGGRANT] = \"SIGGRANT\";\n#endif\n\n#if defined (SIGKAP)\t/* keep alive poll from native keyboard */\n  signal_names[SIGKAP] = \"SIGKAP\";\n#endif\n\n#if defined (SIGRETRACT) /* HFT monitor mode retracted */\n  signal_names[SIGRETRACT] = \"SIGRETRACT\";\n#endif\n\n#if defined (SIGSOUND)\t/* HFT sound sequence has completed */\n  signal_names[SIGSOUND] = \"SIGSOUND\";\n#endif\n\n#if defined (SIGSAK)\t/* Secure Attention Key */\n  signal_names[SIGSAK] = \"SIGSAK\";\n#endif\n\n/* SunOS5 */\n#if defined (SIGLWP)\t/* Solaris: special signal used by thread library */\n  signal_names[SIGLWP] = \"SIGLWP\";\n#endif\n\n#if defined (SIGFREEZE)\t/* Solaris: special signal used by CPR */\n  signal_names[SIGFREEZE] = \"SIGFREEZE\";\n#endif\n\n#if defined (SIGTHAW)\t/* Solaris: special signal used by CPR */\n  signal_names[SIGTHAW] = \"SIGTHAW\";\n#endif\n\n#if defined (SIGCANCEL)\t/* Solaris: thread cancellation signal used by libthread */\n  signal_names[SIGCANCEL] = \"SIGCANCEL\";\n#endif\n\n#if defined (SIGXRES)\t/* Solaris: resource control exceeded */\n  signal_names[SIGXRES] = \"SIGXRES\";\n#endif\n\n#if defined (SIGJVM1)\t/* Solaris: Java Virtual Machine 1 */\n  signal_names[SIGJVM1] = \"SIGJVM1\";\n#endif\n\n#if defined (SIGJVM2)\t/* Solaris: Java Virtual Machine 2 */\n  signal_names[SIGJVM2] = \"SIGJVM2\";\n#endif\n\n/* HP-UX */\n#if defined (SIGDIL)\t/* DIL signal (?) */\n  signal_names[SIGDIL] = \"SIGDIL\";\n#endif\n\n/* System V */\n#if defined (SIGCLD)\t/* Like SIGCHLD.  */\n  signal_names[SIGCLD] = \"SIGCLD\";\n#endif\n\n#if defined (SIGPWR)\t/* power state indication */\n  signal_names[SIGPWR] = \"SIGPWR\";\n#endif\n\n#if defined (SIGPOLL)\t/* Pollable event (for streams)  */\n  signal_names[SIGPOLL] = \"SIGPOLL\";\n#endif\n\n/* Unknown */\n#if defined (SIGWINDOW)\n  signal_names[SIGWINDOW] = \"SIGWINDOW\";\n#endif\n\n/* Linux */\n#if defined (SIGSTKFLT)\n  signal_names[SIGSTKFLT] = \"SIGSTKFLT\";\n#endif\n\n/* FreeBSD */\n#if defined (SIGTHR)\t/* thread interrupt */\n  signal_names[SIGTHR] = \"SIGTHR\";\n#endif\n\n/* Common */\n#if defined (SIGHUP)\t/* hangup */\n  signal_names[SIGHUP] = \"SIGHUP\";\n#endif\n\n#if defined (SIGINT)\t/* interrupt */\n  signal_names[SIGINT] = \"SIGINT\";\n#endif\n\n#if defined (SIGQUIT)\t/* quit */\n  signal_names[SIGQUIT] = \"SIGQUIT\";\n#endif\n\n#if defined (SIGILL)\t/* illegal instruction (not reset when caught) */\n  signal_names[SIGILL] = \"SIGILL\";\n#endif\n\n#if defined (SIGTRAP)\t/* trace trap (not reset when caught) */\n  signal_names[SIGTRAP] = \"SIGTRAP\";\n#endif\n\n#if defined (SIGIOT)\t/* IOT instruction */\n  signal_names[SIGIOT] = \"SIGIOT\";\n#endif\n\n#if defined (SIGABRT)\t/* Cause current process to dump core. */\n  signal_names[SIGABRT] = \"SIGABRT\";\n#endif\n\n#if defined (SIGEMT)\t/* EMT instruction */\n  signal_names[SIGEMT] = \"SIGEMT\";\n#endif\n\n#if defined (SIGFPE)\t/* floating point exception */\n  signal_names[SIGFPE] = \"SIGFPE\";\n#endif\n\n#if defined (SIGKILL)\t/* kill (cannot be caught or ignored) */\n  signal_names[SIGKILL] = \"SIGKILL\";\n#endif\n\n#if defined (SIGBUS)\t/* bus error */\n  signal_names[SIGBUS] = \"SIGBUS\";\n#endif\n\n#if defined (SIGSEGV)\t/* segmentation violation */\n  signal_names[SIGSEGV] = \"SIGSEGV\";\n#endif\n\n#if defined (SIGSYS)\t/* bad argument to system call */\n  signal_names[SIGSYS] = \"SIGSYS\";\n#endif\n\n#if defined (SIGPIPE)\t/* write on a pipe with no one to read it */\n  signal_names[SIGPIPE] = \"SIGPIPE\";\n#endif\n\n#if defined (SIGALRM)\t/* alarm clock */\n  signal_names[SIGALRM] = \"SIGALRM\";\n#endif\n\n#if defined (SIGTERM)\t/* software termination signal from kill */\n  signal_names[SIGTERM] = \"SIGTERM\";\n#endif\n\n#if defined (SIGURG)\t/* urgent condition on IO channel */\n  signal_names[SIGURG] = \"SIGURG\";\n#endif\n\n#if defined (SIGSTOP)\t/* sendable stop signal not from tty */\n  signal_names[SIGSTOP] = \"SIGSTOP\";\n#endif\n\n#if defined (SIGTSTP)\t/* stop signal from tty */\n  signal_names[SIGTSTP] = \"SIGTSTP\";\n#endif\n\n#if defined (SIGCONT)\t/* continue a stopped process */\n  signal_names[SIGCONT] = \"SIGCONT\";\n#endif\n\n#if defined (SIGCHLD)\t/* to parent on child stop or exit */\n  signal_names[SIGCHLD] = \"SIGCHLD\";\n#endif\n\n#if defined (SIGTTIN)\t/* to readers pgrp upon background tty read */\n  signal_names[SIGTTIN] = \"SIGTTIN\";\n#endif\n\n#if defined (SIGTTOU)\t/* like TTIN for output if (tp->t_local&LTOSTOP) */\n  signal_names[SIGTTOU] = \"SIGTTOU\";\n#endif\n\n#if defined (SIGIO)\t/* input/output possible signal */\n  signal_names[SIGIO] = \"SIGIO\";\n#endif\n\n#if defined (SIGXCPU)\t/* exceeded CPU time limit */\n  signal_names[SIGXCPU] = \"SIGXCPU\";\n#endif\n\n#if defined (SIGXFSZ)\t/* exceeded file size limit */\n  signal_names[SIGXFSZ] = \"SIGXFSZ\";\n#endif\n\n#if defined (SIGVTALRM)\t/* virtual time alarm */\n  signal_names[SIGVTALRM] = \"SIGVTALRM\";\n#endif\n\n#if defined (SIGPROF)\t/* profiling time alarm */\n  signal_names[SIGPROF] = \"SIGPROF\";\n#endif\n\n#if defined (SIGWINCH)\t/* window changed */\n  signal_names[SIGWINCH] = \"SIGWINCH\";\n#endif\n\n/* 4.4 BSD */\n#if defined (SIGINFO) && !defined (_SEQUENT_)\t/* information request */\n  signal_names[SIGINFO] = \"SIGINFO\";\n#endif\n\n#if defined (SIGUSR1)\t/* user defined signal 1 */\n  signal_names[SIGUSR1] = \"SIGUSR1\";\n#endif\n\n#if defined (SIGUSR2)\t/* user defined signal 2 */\n  signal_names[SIGUSR2] = \"SIGUSR2\";\n#endif\n\n#if defined (SIGKILLTHR)\t/* BeOS: Kill Thread */\n  signal_names[SIGKILLTHR] = \"SIGKILLTHR\";\n#endif\n\n  for (i = 0; i < NSIG; i++)\n    if (signal_names[i] == (char *)NULL)\n      {\n\tsignal_names[i] = (char *)malloc (18);\n\tif (signal_names[i])\n\t  sprintf (signal_names[i], \"SIGJUNK(%d)\", i);\n      }\n\n  signal_names[NSIG] = \"DEBUG\";\n  signal_names[NSIG+1] = \"ERR\";\n  signal_names[NSIG+2] = \"RETURN\";\n}"
}