{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      ADVANCE_CHAR (string, slen, i);",
    "Code_function": "string_extract_verbatim (string, slen, sindex, charlist, flags)\n     char *string;\n     size_t slen;\n     int *sindex;\n     char *charlist;\n     int flags;\n{\n  register int i;\n#if defined (HANDLE_MULTIBYTE)\n  size_t clen;\n  wchar_t *wcharlist;\n#endif\n  int c;\n  char *temp;\n  DECLARE_MBSTATE;\n\n  if (charlist[0] == '\\'' && charlist[1] == '\\0')\n    {\n      temp = string_extract_single_quoted (string, sindex);\n      --*sindex;\t/* leave *sindex at separator character */\n      return temp;\n    }\n\n  i = *sindex;\n#if 0\n  /* See how the MBLEN and ADVANCE_CHAR macros work to understand why we need\n     this only if MB_CUR_MAX > 1. */\n  slen = (MB_CUR_MAX > 1) ? strlen (string + *sindex) + *sindex : 1;\n#endif\n#if defined (HANDLE_MULTIBYTE)\n  clen = strlen (charlist);\n  wcharlist = 0;\n#endif\n  while (c = string[i])\n    {\n#if defined (HANDLE_MULTIBYTE)\n      size_t mblength;\n#endif\n      if ((flags & SX_NOCTLESC) == 0 && c == CTLESC)\n\t{\n\t  i += 2;\n\t  continue;\n\t}\n      /* Even if flags contains SX_NOCTLESC, we let CTLESC quoting CTLNUL\n\t through, to protect the CTLNULs from later calls to\n\t remove_quoted_nulls. */\n      else if ((flags & SX_NOESCCTLNUL) == 0 && c == CTLESC && string[i+1] == CTLNUL)\n\t{\n\t  i += 2;\n\t  continue;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      mblength = MBLEN (string + i, slen - i);\n      if (mblength > 1)\n\t{\n\t  wchar_t wc;\n\t  mblength = mbtowc (&wc, string + i, slen - i);\n\t  if (MB_INVALIDCH (mblength))\n\t    {\n\t      if (MEMBER (c, charlist))\n\t\tbreak;\n\t    }\n\t  else\n\t    {\n\t      if (wcharlist == 0)\n\t\t{\n\t\t  size_t len;\n\t\t  len = mbstowcs (wcharlist, charlist, 0);\n\t\t  if (len == -1)\n\t\t    len = 0;\n\t\t  wcharlist = (wchar_t *)xmalloc (sizeof (wchar_t) * (len + 1));\n\t\t  mbstowcs (wcharlist, charlist, len + 1);\n\t\t}\n\n\t      if (wcschr (wcharlist, wc))\n\t\tbreak;\n\t    }\n\t}\n      else\n#endif\n      if (MEMBER (c, charlist))\n\tbreak;\n\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  FREE (wcharlist);\n#endif\n\n  temp = substring (string, *sindex, i);\n  *sindex = i;\n\n  return (temp);\n}"
}