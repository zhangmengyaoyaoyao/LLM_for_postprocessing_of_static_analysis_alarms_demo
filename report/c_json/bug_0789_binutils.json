{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "libiberty/regex.c",
    "message": "Offset: [0, 128] Size: 128.",
    "warning_function_name": "PREFIX",
    "warning_line": "str[c1] = '\\0';",
    "warning_context": "\n\t\t\t    /* Throw away the ] at the end of the equivalence\n\t\t\t       class.  */\n\t\t\t    PATFETCH (c);\n\n\t\t\t    /* Now we have to go through the whole table\n\t\t\t       and find all characters which have the same\n\t\t\t       first level weight.\n\n\t\t\t       XXX Note that this is not entirely correct.\n\t\t\t       we would have to match multibyte sequences\n\t\t\t       but this is not possible with the current\n\t\t\t       implementation.  */\n\t\t\t    for (ch = 1; ch < 256; ++ch)\n\t\t\t      /* XXX This test would have to be changed if we\n\t\t\t\t would allow matching multibyte sequences.  */\n\t\t\t      if (table[ch] > 0)\n\t\t\t\t{\n\t\t\t\t  int32_t idx2 = table[ch];\n\t\t\t\t  size_t len = weights[idx2];\n\n\t\t\t\t  /* Test whether the lenghts match.  */\n\t\t\t\t  if (weights[idx] == len)\n\t\t\t\t    {\n\t\t\t\t      /* They do.  New compare the bytes of\n\t\t\t\t\t the weight.  */\n\t\t\t\t      size_t cnt = 0;\n\n\t\t\t\t      while (cnt < len\n\t\t\t\t\t     && (weights[idx + 1 + cnt]\n\t\t\t\t\t\t == weights[idx2 + 1 + cnt]))\n\t\t\t\t\t++cnt;\n\n\t\t\t\t      if (cnt == len)\n\t\t\t\t\t/* They match.  Mark the character as\n\t\t\t\t\t   acceptable.  */\n\t\t\t\t\tSET_LIST_BIT (ch);\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t  }\n# endif\n\t\t\thad_char_class = true;\n\t\t      }\n                    else\n                      {\n                        c1++;\n                        while (c1--)\n                          PATUNFETCH;\n                        SET_LIST_BIT ('[');\n                        SET_LIST_BIT ('=');\n\t\t\trange_start = '=';\n                        had_char_class = false;\n                      }\n\t\t  }\n                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == '.')\n\t\t  {\n\t\t    unsigned char str[128];\t/* Should be large enough.  */\n# ifdef _LIBC\n\t\t    uint32_t nrules =\n\t\t      _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n# endif\n\n\t\t    PATFETCH (c);\n\t\t    c1 = 0;\n\n\t\t    /* If pattern is `[[.'.  */\n\t\t    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);\n\n\t\t    for (;;)\n\t\t      {\n\t\t\tPATFETCH (c);\n\t\t\tif ((c == '.' && *p == ']') || p == pend)\n\t\t\t  break;\n\t\t\tif (c1 < sizeof (str))\n\t\t\t  str[c1++] = c;\n\t\t\telse\n\t\t\t  /* This is in any case an invalid class name.  */\n\t\t\t  str[0] = '\\0';\n                      }\n\t\t    str[c1] = '\\0';\n\n\t\t    if (c == '.' && *p == ']' && str[0] != '\\0')\n\t\t      {\n\t\t\t/* If we have no collation data we use the default\n\t\t\t   collation in which each character is the name\n\t\t\t   for its own class which contains only the one\n\t\t\t   character.  It also means that ASCII is the\n\t\t\t   character set and therefore we cannot have character\n\t\t\t   with more than one byte in the multibyte\n\t\t\t   representation.  */\n# ifdef _LIBC\n\t\t\tif (nrules == 0)\n# endif\n\t\t\t  {\n\t\t\t    if (c1 != 1)\n\t\t\t      FREE_STACK_RETURN (REG_ECOLLATE);\n\n\t\t\t    /* Throw away the ] at the end of the equivalence\n\t\t\t       class.  */\n\t\t\t    PATFETCH (c);\n\n"
}