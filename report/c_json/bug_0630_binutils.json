{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset: 1 Size: [0, +oo] by call to `_bfd_elf_strtab_add`.",
    "warning_function_name": "bfd_elf_link_record_local_dynamic_symbol",
    "warning_line": "dynstr_index = _bfd_elf_strtab_add (dynstr, name, FALSE);",
    "warning_context": "int\nbfd_elf_link_record_local_dynamic_symbol (struct bfd_link_info *info,\n\t\t\t\t\t  bfd *input_bfd,\n\t\t\t\t\t  long input_indx)\n{\n  bfd_size_type amt;\n  struct elf_link_local_dynamic_entry *entry;\n  struct elf_link_hash_table *eht;\n  struct elf_strtab_hash *dynstr;\n  unsigned long dynstr_index;\n  char *name;\n  Elf_External_Sym_Shndx eshndx;\n  char esym[sizeof (Elf64_External_Sym)];\n\n  if (! is_elf_hash_table (info->hash))\n    return 0;\n\n  /* See if the entry exists already.  */\n  for (entry = elf_hash_table (info)->dynlocal; entry ; entry = entry->next)\n    if (entry->input_bfd == input_bfd && entry->input_indx == input_indx)\n      return 1;\n\n  amt = sizeof (*entry);\n  entry = (struct elf_link_local_dynamic_entry *) bfd_alloc (input_bfd, amt);\n  if (entry == NULL)\n    return 0;\n\n  /* Go find the symbol, so that we can find it's name.  */\n  if (!bfd_elf_get_elf_syms (input_bfd, &elf_tdata (input_bfd)->symtab_hdr,\n\t\t\t     1, input_indx, &entry->isym, esym, &eshndx))\n    {\n      bfd_release (input_bfd, entry);\n      return 0;\n    }\n\n  if (entry->isym.st_shndx != SHN_UNDEF\n      && entry->isym.st_shndx < SHN_LORESERVE)\n    {\n      asection *s;\n\n      s = bfd_section_from_elf_index (input_bfd, entry->isym.st_shndx);\n      if (s == NULL || bfd_is_abs_section (s->output_section))\n\t{\n\t  /* We can still bfd_release here as nothing has done another\n\t     bfd_alloc.  We can't do this later in this function.  */\n\t  bfd_release (input_bfd, entry);\n\t  return 2;\n\t}\n    }\n\n  name = (bfd_elf_string_from_elf_section\n\t  (input_bfd, elf_tdata (input_bfd)->symtab_hdr.sh_link,\n\t   entry->isym.st_name));\n\n  dynstr = elf_hash_table (info)->dynstr;\n  if (dynstr == NULL)\n    {\n      /* Create a strtab to hold the dynamic symbol names.  */\n      elf_hash_table (info)->dynstr = dynstr = _bfd_elf_strtab_init ();\n      if (dynstr == NULL)\n\treturn 0;\n    }\n\n  dynstr_index = _bfd_elf_strtab_add (dynstr, name, FALSE);\n  if (dynstr_index == (unsigned long) -1)\n    return 0;\n  entry->isym.st_name = dynstr_index;\n\n  eht = elf_hash_table (info);\n\n  entry->next = eht->dynlocal;\n  eht->dynlocal = entry;\n  entry->input_bfd = input_bfd;\n  entry->input_indx = input_indx;\n  eht->dynsymcount++;\n\n  /* Whatever binding the symbol had before, it's now local.  */\n  entry->isym.st_info\n    = ELF_ST_INFO (STB_LOCAL, ELF_ST_TYPE (entry->isym.st_info));\n\n  /* The dynindx will be set at the end of size_dynamic_sections.  */\n\n  return 1;\n}\n"
}