{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-20, 475] (⇐ [-236, 259] + 216) Size: 4064 by call to `bfd_zalloc`.",
    "Code_line": "\t\t  secdata = bfd_zalloc (abfd, sizeof *secdata);",
    "Code_function": "nacl_modify_segment_map (bfd *abfd, struct bfd_link_info *info)\n{\n  const struct elf_backend_data *const bed = get_elf_backend_data (abfd);\n  struct elf_segment_map **m = &elf_seg_map (abfd);\n  struct elf_segment_map **first_load = NULL;\n  struct elf_segment_map **last_load = NULL;\n  bfd_boolean moved_headers = FALSE;\n  int sizeof_headers;\n\n  if (info != NULL && info->user_phdrs)\n    /* The linker script used PHDRS explicitly, so don't change what the\n       user asked for.  */\n    return TRUE;\n\n  if (info != NULL)\n    /* We're doing linking, so evalute SIZEOF_HEADERS as in a linker script.  */\n    sizeof_headers = bfd_sizeof_headers (abfd, info);\n  else\n    {\n      /* We're not doing linking, so this is objcopy or suchlike.\n\t We just need to collect the size of the existing headers.  */\n      struct elf_segment_map *seg;\n      sizeof_headers = bed->s->sizeof_ehdr;\n      for (seg = *m; seg != NULL; seg = seg->next)\n\tsizeof_headers += bed->s->sizeof_phdr;\n    }\n\n  while (*m != NULL)\n    {\n      struct elf_segment_map *seg = *m;\n\n      if (seg->p_type == PT_LOAD)\n\t{\n\t  bfd_boolean executable = segment_executable (seg);\n\n\t  if (executable\n\t      && seg->count > 0\n\t      && seg->sections[0]->vma % bed->minpagesize == 0)\n\t    {\n\t      asection *lastsec = seg->sections[seg->count - 1];\n\t      bfd_vma end = lastsec->vma + lastsec->size;\n\t      if (end % bed->minpagesize != 0)\n\t\t{\n\t\t  /* This is an executable segment that starts on a page\n\t\t     boundary but does not end on a page boundary.  Fill\n\t\t     it out to a whole page with code fill (the tail of\n\t\t     the segment will not be within any section).  Thus\n\t\t     the entire code segment can be mapped from the file\n\t\t     as whole pages and that mapping will contain only\n\t\t     valid instructions.\n\n\t\t     To accomplish this, we must fake out the code in\n\t\t     assign_file_positions_for_load_sections (elf.c) so\n\t\t     that it advances past the rest of the final page,\n\t\t     rather than trying to put the next (unaligned, or\n\t\t     unallocated) section.  We do this by appending a\n\t\t     dummy section record to this element in the segment\n\t\t     map.  No such output section ever actually exists,\n\t\t     but this gets the layout logic to advance the file\n\t\t     positions past this partial page.  Since we are\n\t\t     lying to BFD like this, nothing will ever know to\n\t\t     write the section contents.  So we do that by hand\n\t\t     after the fact, in nacl_final_write_processing, below.  */\n\n\t\t  struct elf_segment_map *newseg;\n\t\t  asection *sec;\n\t\t  struct bfd_elf_section_data *secdata;\n\n\t\t  BFD_ASSERT (!seg->p_size_valid);\n\n\t\t  secdata = bfd_zalloc (abfd, sizeof *secdata);\n\t\t  if (secdata == NULL)\n\t\t    return FALSE;\n\n\t\t  sec = bfd_zalloc (abfd, sizeof *sec);\n\t\t  if (sec == NULL)\n\t\t    return FALSE;\n\n\t\t  /* Fill in only the fields that actually affect the logic\n\t\t     in assign_file_positions_for_load_sections.  */\n\t\t  sec->vma = end;\n\t\t  sec->lma = lastsec->lma + lastsec->size;\n\t\t  sec->size = bed->minpagesize - (end % bed->minpagesize);\n\t\t  sec->flags = (SEC_ALLOC | SEC_LOAD\n\t\t\t\t| SEC_READONLY | SEC_CODE | SEC_LINKER_CREATED);\n\t\t  sec->used_by_bfd = secdata;\n\n\t\t  secdata->this_hdr.sh_type = SHT_PROGBITS;\n\t\t  secdata->this_hdr.sh_flags = SHF_ALLOC | SHF_EXECINSTR;\n\t\t  secdata->this_hdr.sh_addr = sec->vma;\n\t\t  secdata->this_hdr.sh_size = sec->size;\n\n\t\t  newseg = bfd_alloc (abfd,\n\t\t\t\t      sizeof *newseg + ((seg->count + 1)\n\t\t\t\t\t\t\t* sizeof (asection *)));\n\t\t  if (newseg == NULL)\n\t\t    return FALSE;\n\t\t  memcpy (newseg, seg,\n\t\t\t  sizeof *newseg + (seg->count * sizeof (asection *)));\n\t\t  newseg->sections[newseg->count++] = sec;\n\t\t  *m = seg = newseg;\n\t\t}\n\t    }\n\n\t  /* First, we're just finding the earliest PT_LOAD.\n\t     By the normal rules, this will be the lowest-addressed one.\n\t     We only have anything interesting to do if it's executable.  */\n\t  last_load = m;\n\t  if (first_load == NULL)\n\t    {\n\t      if (!executable)\n\t\tgoto next;\n\t      first_load = m;\n\t    }\n\t  /* Now that we've noted the first PT_LOAD, we're looking for\n\t     the first non-executable PT_LOAD with a nonempty p_filesz.  */\n\t  else if (!moved_headers\n\t\t   && segment_eligible_for_headers (seg, bed->minpagesize,\n\t\t\t\t\t\t    sizeof_headers))\n\t    {\n\t      /* This is the one we were looking for!\n\n\t\t First, clear the flags on previous segments that\n\t\t say they include the file header and phdrs.  */\n\t      struct elf_segment_map *prevseg;\n\t      for (prevseg = *first_load;\n\t\t   prevseg != seg;\n\t\t   prevseg = prevseg->next)\n\t\tif (prevseg->p_type == PT_LOAD)\n\t\t  {\n\t\t    prevseg->includes_filehdr = 0;\n\t\t    prevseg->includes_phdrs = 0;\n\t\t  }\n\n\t      /* This segment will include those headers instead.  */\n\t      seg->includes_filehdr = 1;\n\t      seg->includes_phdrs = 1;\n\n\t      moved_headers = TRUE;\n\t    }\n\t}\n\n    next:\n      m = &seg->next;\n    }\n\n  if (first_load != last_load && moved_headers)\n    {\n      /* Now swap the first and last PT_LOAD segments'\n\t positions in segment_map.  */\n      struct elf_segment_map *first = *first_load;\n      struct elf_segment_map *last = *last_load;\n      *first_load = first->next;\n      first->next = last->next;\n      last->next = first;\n    }\n\n  return TRUE;\n}"
}