{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "dfa.c",
    "message": "Access to field 'chars' results in a dereference of a null pointer (loaded from variable 'work_mbc')",
    "warning_function_name": "parse_bracket_exp",
    "warning_line": NaN,
    "warning_context": "                {\n                  /* When case folding map a range, say [m-z] (or even [M-z])\n                     to the pair of ranges, [m-z] [M-Z].  Although this code\n                     is wrong in multiple ways, it's never used in practice.\n                     FIXME: Remove this (and related) unused code.  */\n                  if (wc != WEOF && wc2 != WEOF)\n                    {\n                      work_mbc->ranges\n                        = maybe_realloc (work_mbc->ranges,\n                                         work_mbc->nranges + 2,\n                                         &ranges_al, sizeof *work_mbc->ranges);\n                      work_mbc->ranges[work_mbc->nranges].beg\n                        = case_fold ? towlower (wc) : wc;\n                      work_mbc->ranges[work_mbc->nranges++].end\n                        = case_fold ? towlower (wc2) : wc2;\n\n                      if (case_fold && (iswalpha (wc) || iswalpha (wc2)))\n                        {\n                          work_mbc->ranges[work_mbc->nranges].beg\n                            = towupper (wc);\n                          work_mbc->ranges[work_mbc->nranges++].end\n                            = towupper (wc2);\n                        }\n                    }\n                }\n              else if (using_simple_locale ())\n                {\n                  for (c1 = c; c1 <= c2; c1++)\n                    setbit (c1, ccl);\n                  if (case_fold)\n                    {\n                      int uc = toupper (c);\n                      int uc2 = toupper (c2);\n                      for (c1 = 0; c1 < NOTCHAR; c1++)\n                        {\n                          int uc1 = toupper (c1);\n                          if (uc <= uc1 && uc1 <= uc2)\n                            setbit (c1, ccl);\n                        }\n                    }\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* In the case [x-], the - is an ordinary hyphen,\n             which is left in c1, the lookahead character.  */\n          lexptr -= cur_mb_len;\n          lexleft += cur_mb_len;\n        }\n\n      colon_warning_state |= (c == ':') ? 2 : 4;\n\n      if (!dfa->multibyte)\n        {\n          if (case_fold)\n            setbit_case_fold_c (c, ccl);\n          else\n            setbit (c, ccl);\n          continue;\n        }\n\n      if (wc == WEOF)\n        known_bracket_exp = false;\n      else\n        {\n          wchar_t folded[CASE_FOLDED_BUFSIZE + 1];\n          int i;\n          int n = (case_fold ? case_folded_counterparts (wc, folded + 1) + 1\n                   : 1);\n          folded[0] = wc;\n          for (i = 0; i < n; i++)\n            if (!setbit_wc (folded[i], ccl))\n              {\n                work_mbc->chars\n                  = maybe_realloc (work_mbc->chars, work_mbc->nchars,\n                                   &chars_al, sizeof *work_mbc->chars);\n                work_mbc->chars[work_mbc->nchars++] = folded[i];\n              }\n        }\n    }\n  while ((wc = wc1, (c = c1) != ']'));\n\n  if (colon_warning_state == 7)\n    dfawarn (_(\"character class syntax is [[:space:]], not [:space:]\"));\n\n  if (! known_bracket_exp)\n    return BACKREF;\n\n  if (dfa->multibyte)\n    {\n      static charclass zeroclass;\n      work_mbc->invert = invert;\n      work_mbc->cset = equal (ccl, zeroclass) ? -1 : charclass_index (ccl);\n      return MBCSET;\n    }\n\n"
}