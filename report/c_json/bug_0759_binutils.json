{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "ld/ldlang.c",
    "message": "Offset: [1, 2] (⇐ [0, 1] + 1) Size: 2 by call to `exp_nameop`.",
    "warning_function_name": "lang_insert_orphan",
    "warning_line": "exp_nameop (NAME, \".\"),",
    "warning_context": "lang_output_section_statement_type *\nlang_insert_orphan (asection *s,\n\t\t    const char *secname,\n\t\t    int constraint,\n\t\t    lang_output_section_statement_type *after,\n\t\t    struct orphan_save *place,\n\t\t    etree_type *address,\n\t\t    lang_statement_list_type *add_child)\n{\n  lang_statement_list_type add;\n  const char *ps;\n  lang_output_section_statement_type *os;\n  lang_output_section_statement_type **os_tail;\n\n  /* If we have found an appropriate place for the output section\n     statements for this orphan, add them to our own private list,\n     inserting them later into the global statement list.  */\n  if (after != NULL)\n    {\n      lang_list_init (&add);\n      push_stat_ptr (&add);\n    }\n\n  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)\n    address = exp_intop (0);\n\n  os_tail = ((lang_output_section_statement_type **)\n\t     lang_output_section_statement.tail);\n  os = lang_enter_output_section_statement (secname, address, normal_section,\n\t\t\t\t\t    NULL, NULL, NULL, constraint, 0);\n\n  ps = NULL;\n  if (config.build_constructors && *os_tail == os)\n    {\n      /* If the name of the section is representable in C, then create\n\t symbols to mark the start and the end of the section.  */\n      for (ps = secname; *ps != '\\0'; ps++)\n\tif (! ISALNUM ((unsigned char) *ps) && *ps != '_')\n\t  break;\n      if (*ps == '\\0')\n\t{\n\t  char *symname;\n\n\t  symname = (char *) xmalloc (ps - secname + sizeof \"__start_\" + 1);\n\t  symname[0] = bfd_get_symbol_leading_char (link_info.output_bfd);\n\t  sprintf (symname + (symname[0] != 0), \"__start_%s\", secname);\n\t  lang_add_assignment (exp_provide (symname,\n\t\t\t\t\t    exp_nameop (NAME, \".\"),\n\t\t\t\t\t    FALSE));\n\t}\n    }\n\n  if (add_child == NULL)\n    add_child = &os->children;\n  lang_add_section (add_child, s, NULL, os);\n\n  if (after && (s->flags & (SEC_LOAD | SEC_ALLOC)) != 0)\n    {\n      const char *region = (after->region\n\t\t\t    ? after->region->name_list.name\n\t\t\t    : DEFAULT_MEMORY_REGION);\n      const char *lma_region = (after->lma_region\n\t\t\t\t? after->lma_region->name_list.name\n\t\t\t\t: NULL);\n      lang_leave_output_section_statement (NULL, region, after->phdrs,\n\t\t\t\t\t   lma_region);\n    }\n  else\n    lang_leave_output_section_statement (NULL, DEFAULT_MEMORY_REGION, NULL,\n\t\t\t\t\t NULL);\n\n  if (ps != NULL && *ps == '\\0')\n    {\n      char *symname;\n\n      symname = (char *) xmalloc (ps - secname + sizeof \"__stop_\" + 1);\n      symname[0] = bfd_get_symbol_leading_char (link_info.output_bfd);\n      sprintf (symname + (symname[0] != 0), \"__stop_%s\", secname);\n      lang_add_assignment (exp_provide (symname,\n\t\t\t\t\texp_nameop (NAME, \".\"),\n\t\t\t\t\tFALSE));\n    }\n\n  /* Restore the global list pointer.  */\n  if (after != NULL)\n    pop_stat_ptr ();\n\n  if (after != NULL && os->bfd_section != NULL)\n    {\n      asection *snew, *as;\n\n      snew = os->bfd_section;\n\n      /* Shuffle the bfd section list to make the output file look\n\t neater.  This is really only cosmetic.  */\n      if (place->section == NULL\n\t  && after != (&lang_output_section_statement.head\n\t\t       ->output_section_statement))\n\t{\n\t  asection *bfd_section = after->bfd_section;\n\n"
}