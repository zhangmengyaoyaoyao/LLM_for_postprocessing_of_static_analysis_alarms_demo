{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "braces.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "ADVANCE_CHAR (text, tlen, i);",
    "warning_context": "add_tack:\n  result = array_concat (result, tack);\n  free (amble);\n  if (tack != result)\n    strvec_dispose (tack);\n\n  postamble = text + i + 1;\n\n  if (postamble && *postamble)\n    {\n      tack = brace_expand (postamble);\n      result = array_concat (result, tack);\n      if (tack != result)\n\tstrvec_dispose (tack);\n    }\n\n  return (result);\n}\n\n/* Expand the text found inside of braces.  We simply try to split the\n   text at BRACE_ARG_SEPARATORs into separate strings.  We then brace\n   expand each slot which needs it, until there are no more slots which\n   need it. */\nstatic char **\nexpand_amble (text, tlen, flags)\n     char *text;\n     size_t tlen;\n     int flags;\n{\n  char **result, **partial, **tresult;\n  char *tem;\n  int start, i, c;\n\n  DECLARE_MBSTATE;\n\n  result = (char **)NULL;\n\n  start = i = 0;\n  c = 1;\n  while (c)\n    {\n      c = brace_gobbler (text, tlen, &i, brace_arg_separator);\n#if defined (SHELL)\n      tem = substring (text, start, i);\n#else\n      tem = (char *)xmalloc (1 + (i - start));\n      strncpy (tem, &text[start], (i - start));\n      tem[i- start] = '\\0';\n#endif\n\n      partial = brace_expand (tem);\n\n      if (!result)\n\tresult = partial;\n      else\n\t{\n\t  register int lr, lp, j;\n\n\t  lr = strvec_len (result);\n\t  lp = strvec_len (partial);\n\n\t  tresult = strvec_mresize (result, lp + lr + 1);\n\t  if (tresult == 0)\n\t    {\n\t      internal_error (_(\"brace expansion: cannot allocate memory for %s\"), tem);\n\t      strvec_dispose (result);\n\t      result = (char **)NULL;\n\t      return result;\n\t    }\n\t  else\n\t    result = tresult;\n\n\t  for (j = 0; j < lp; j++)\n\t    result[lr + j] = partial[j];\n\n\t  result[lr + j] = (char *)NULL;\n\t  free (partial);\n\t}\n      free (tem);\n      ADVANCE_CHAR (text, tlen, i);\n      start = i;\n    }\n  return (result);\n}\n\n#define ST_BAD\t0\n#define ST_INT\t1\n#define ST_CHAR\t2\n#define ST_ZINT\t3\n\n#ifndef sh_imaxabs\n#  define sh_imaxabs(x)\t(((x) >= 0) ? (x) : -(x))\n#endif\n\n/* Handle signed arithmetic overflow and underflow.  Have to do it this way\n   to avoid compilers optimizing out simpler overflow checks. */\n\n/* Make sure that a+b does not exceed MAXV or is smaller than MINV (if b < 0).\n   Assumes that b > 0 if a > 0 and b < 0 if a < 0 */\n#define ADDOVERFLOW(a,b,minv,maxv) \\\n\t((((a) > 0) && ((b) > ((maxv) - (a)))) || \\\n"
}