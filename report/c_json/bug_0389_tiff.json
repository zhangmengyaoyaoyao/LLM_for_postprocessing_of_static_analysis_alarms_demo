{
    "Project": "tiff",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [1, +oo] Size: [0, +oo] by call to `TIFFWriteRationalArray`.",
    "Code_line": "\t\t\tWriteRationalPair(TIFF_RATIONAL,",
    "Code_function": "_TIFFWriteDirectory(TIFF* tif, int done)\n{\n\tuint16 dircount;\n\ttoff_t diroff;\n\tttag_t tag;\n\tuint32 nfields;\n\ttsize_t dirsize;\n\tchar* data;\n\tTIFFDirEntry* dir;\n\tTIFFDirectory* td;\n\tunsigned long b, fields[FIELD_SETLONGS];\n\tint fi, nfi;\n\n\tif (tif->tif_mode == O_RDONLY)\n\t\treturn (1);\n\t/*\n\t * Clear write state so that subsequent images with\n\t * different characteristics get the right buffers\n\t * setup for them.\n\t */\n\tif (done)\n\t{\n\t\tif (tif->tif_flags & TIFF_POSTENCODE) {\n\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\t\tif (!(*tif->tif_postencode)(tif)) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,\n\t\t\t\t\t     tif->tif_name,\n\t\t\t\t\"Error post-encoding before directory write\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t(*tif->tif_close)(tif);\t\t/* shutdown encoder */\n\t\t/*\n\t\t * Flush any data that might have been written\n \t\t * by the compression close+cleanup routines.\n\t\t */\n\t\tif (tif->tif_rawcc > 0\n                    && (tif->tif_flags & TIFF_BEENWRITING) != 0\n                    && !TIFFFlushData1(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t    \"Error flushing data before directory write\");\n\t\t\treturn (0);\n\t\t}\n\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_rawdata = NULL;\n\t\t\ttif->tif_rawcc = 0;\n\t\t\ttif->tif_rawdatasize = 0;\n\t\t}\n\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\n\t}\n\n\ttd = &tif->tif_dir;\n\t/*\n\t * Size the directory so that we can calculate\n\t * offsets for the data items that aren't kept\n\t * in-place in each field.\n\t */\n\tnfields = 0;\n\tfor (b = 0; b <= FIELD_LAST; b++)\n\t\tif (TIFFFieldSet(tif, b) && b != FIELD_CUSTOM)\n\t\t\tnfields += (b < FIELD_SUBFILETYPE ? 2 : 1);\n\tnfields += td->td_customValueCount;\n\tdirsize = nfields * sizeof (TIFFDirEntry);\n\tdata = (char*) _TIFFmalloc(dirsize);\n\tif (data == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Cannot write directory, out of space\");\n\t\treturn (0);\n\t}\n\t/*\n\t * Directory hasn't been placed yet, put\n\t * it at the end of the file and link it\n\t * into the existing directory structure.\n\t */\n\tif (tif->tif_diroff == 0 && !TIFFLinkDirectory(tif))\n\t\tgoto bad;\n\ttif->tif_dataoff = (toff_t)(\n\t    tif->tif_diroff + sizeof (uint16) + dirsize + sizeof (toff_t));\n\tif (tif->tif_dataoff & 1)\n\t\ttif->tif_dataoff++;\n\t(void) TIFFSeekFile(tif, tif->tif_dataoff, SEEK_SET);\n\ttif->tif_curdir++;\n\tdir = (TIFFDirEntry*) data;\n\t/*\n\t * Setup external form of directory\n\t * entries and write data items.\n\t */\n\t_TIFFmemcpy(fields, td->td_fieldsset, sizeof (fields));\n\t/*\n\t * Write out ExtraSamples tag only if\n\t * extra samples are present in the data.\n\t */\n\tif (FieldSet(fields, FIELD_EXTRASAMPLES) && !td->td_extrasamples) {\n\t\tResetFieldBit(fields, FIELD_EXTRASAMPLES);\n\t\tnfields--;\n\t\tdirsize -= sizeof (TIFFDirEntry);\n\t}\t\t\t\t\t\t\t\t/*XXX*/\n\tfor (fi = 0, nfi = tif->tif_nfields; nfi > 0; nfi--, fi++) {\n\t\tconst TIFFFieldInfo* fip = tif->tif_fieldinfo[fi];\n\n\t\t/*\n\t\t * For custom fields, we test to see if the custom field\n\t\t * is set or not.  For normal fields, we just use the\n\t\t * FieldSet test.\n\t\t*/\n\t\tif( fip->field_bit == FIELD_CUSTOM )\n\t\t{\n\t\t\tint ci, is_set = FALSE;\n\n\t\t\tfor( ci = 0; ci < td->td_customValueCount; ci++ )\n\t\t\t\tis_set |= (td->td_customValues[ci].info == fip);\n\n\t\t\tif( !is_set )\n\t\t\t\tcontinue;\n\t\t}\n\t\telse if (!FieldSet(fields, fip->field_bit))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Handle other fields.\n\t\t */\n\t\tswitch (fip->field_bit)\n\t\t{\n\t\tcase FIELD_STRIPOFFSETS:\n\t\t\t/*\n\t\t\t * We use one field bit for both strip and tile\n\n\t\t\t * offsets, and so must be careful in selecting\n\t\t\t * the appropriate field descriptor (so that tags\n\t\t\t * are written in sorted order).\n\t\t\t */\n\t\t\ttag = isTiled(tif) ?\n\t\t\t    TIFFTAG_TILEOFFSETS : TIFFTAG_STRIPOFFSETS;\n\t\t\tif (tag != fip->field_tag)\n\t\t\t\tcontinue;\n\n\t\t\tdir->tdir_tag = (uint16) tag;\n\t\t\tdir->tdir_type = (uint16) TIFF_LONG;\n\t\t\tdir->tdir_count = (uint32) td->td_nstrips;\n\t\t\tif (!TIFFWriteLongArray(tif, dir, td->td_stripoffset))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_STRIPBYTECOUNTS:\n\t\t\t/*\n\t\t\t * We use one field bit for both strip and tile\n\t\t\t * byte counts, and so must be careful in selecting\n\t\t\t * the appropriate field descriptor (so that tags\n\t\t\t * are written in sorted order).\n\t\t\t */\n\t\t\ttag = isTiled(tif) ?\n\t\t\t    TIFFTAG_TILEBYTECOUNTS : TIFFTAG_STRIPBYTECOUNTS;\n\t\t\tif (tag != fip->field_tag)\n\t\t\t\tcontinue;\n\n\t\t\tdir->tdir_tag = (uint16) tag;\n\t\t\tdir->tdir_type = (uint16) TIFF_LONG;\n\t\t\tdir->tdir_count = (uint32) td->td_nstrips;\n\t\t\tif (!TIFFWriteLongArray(tif, dir, td->td_stripbytecount))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_ROWSPERSTRIP:\n\t\t\tTIFFSetupShortLong(tif, TIFFTAG_ROWSPERSTRIP,\n\t\t\t    dir, td->td_rowsperstrip);\n\t\t\tbreak;\n\t\tcase FIELD_COLORMAP:\n\t\t\tif (!TIFFWriteShortTable(tif, TIFFTAG_COLORMAP, dir,\n\t\t\t    3, td->td_colormap))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_IMAGEDIMENSIONS:\n\t\t\tTIFFSetupShortLong(tif, TIFFTAG_IMAGEWIDTH,\n\t\t\t    dir++, td->td_imagewidth);\n\t\t\tTIFFSetupShortLong(tif, TIFFTAG_IMAGELENGTH,\n\t\t\t    dir, td->td_imagelength);\n\t\t\tbreak;\n\t\tcase FIELD_TILEDIMENSIONS:\n\t\t\tTIFFSetupShortLong(tif, TIFFTAG_TILEWIDTH,\n\t\t\t    dir++, td->td_tilewidth);\n\t\t\tTIFFSetupShortLong(tif, TIFFTAG_TILELENGTH,\n\t\t\t    dir, td->td_tilelength);\n\t\t\tbreak;\n\t\tcase FIELD_COMPRESSION:\n\t\t\tTIFFSetupShort(tif, TIFFTAG_COMPRESSION,\n\t\t\t    dir, td->td_compression);\n\t\t\tbreak;\n\t\tcase FIELD_PHOTOMETRIC:\n\t\t\tTIFFSetupShort(tif, TIFFTAG_PHOTOMETRIC,\n\t\t\t    dir, td->td_photometric);\n\t\t\tbreak;\n\t\tcase FIELD_POSITION:\n\t\t\tWriteRationalPair(TIFF_RATIONAL,\n\t\t\t    TIFFTAG_XPOSITION, td->td_xposition,\n\t\t\t    TIFFTAG_YPOSITION, td->td_yposition);\n\t\t\tbreak;\n\t\tcase FIELD_RESOLUTION:\n\t\t\tWriteRationalPair(TIFF_RATIONAL,\n\t\t\t    TIFFTAG_XRESOLUTION, td->td_xresolution,\n\t\t\t    TIFFTAG_YRESOLUTION, td->td_yresolution);\n\t\t\tbreak;\n\t\tcase FIELD_BITSPERSAMPLE:\n\t\tcase FIELD_MINSAMPLEVALUE:\n\t\tcase FIELD_MAXSAMPLEVALUE:\n\t\tcase FIELD_SAMPLEFORMAT:\n\t\t\tif (!TIFFWritePerSampleShorts(tif, fip->field_tag, dir))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_SMINSAMPLEVALUE:\n\t\tcase FIELD_SMAXSAMPLEVALUE:\n\t\t\tif (!TIFFWritePerSampleAnys(tif,\n\t\t\t    _TIFFSampleToTagType(tif), fip->field_tag, dir))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_INKNAMES:\n\t\t\tif (!TIFFWriteInkNames(tif, dir))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_TRANSFERFUNCTION:\n\t\t\tif (!TIFFWriteTransferFunction(tif, dir))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase FIELD_SUBIFD:\n\t\t\t/*\n\t\t\t * XXX: Always write this field using LONG type\n\t\t\t * for backward compatibility.\n\t\t\t */\n\t\t\tdir->tdir_tag = (uint16) fip->field_tag;\n\t\t\tdir->tdir_type = (uint16) TIFF_LONG;\n\t\t\tdir->tdir_count = (uint32) td->td_nsubifd;\n\t\t\tif (!TIFFWriteLongArray(tif, dir, td->td_subifd))\n\t\t\t\tgoto bad;\n\t\t\t/*\n\t\t\t * Total hack: if this directory includes a SubIFD\n\t\t\t * tag then force the next <n> directories to be\n\t\t\t * written as ``sub directories'' of this one.  This\n\t\t\t * is used to write things like thumbnails and\n\t\t\t * image masks that one wants to keep out of the\n\t\t\t * normal directory linkage access mechanism.\n\t\t\t */\n\t\t\tif (dir->tdir_count > 0) {\n\t\t\t\ttif->tif_flags |= TIFF_INSUBIFD;\n\t\t\t\ttif->tif_nsubifd = (uint16) dir->tdir_count;\n\t\t\t\tif (dir->tdir_count > 1)\n\t\t\t\t\ttif->tif_subifdoff = dir->tdir_offset;\n\t\t\t\telse\n\t\t\t\t\ttif->tif_subifdoff = (uint32)(\n\t\t\t\t\t      tif->tif_diroff\n\t\t\t\t\t    + sizeof (uint16)\n\t\t\t\t\t    + ((char*)&dir->tdir_offset-data));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX: Should be fixed and removed. See comments\n\t\t\t * related to these tags in tif_dir.c.\n\t\t\t */\n\t\t\tif (fip->field_tag == TIFFTAG_PAGENUMBER\n\t\t\t    || fip->field_tag == TIFFTAG_HALFTONEHINTS\n\t\t\t    || fip->field_tag == TIFFTAG_YCBCRSUBSAMPLING\n\t\t\t    || fip->field_tag == TIFFTAG_DOTRANGE) {\n\t\t\t\tif (fip->field_type == TIFF_BYTE) {\n\t\t\t\t\tif (!TIFFSetupBytePair(tif, fip->field_tag, dir))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t} else if (fip->field_type == TIFF_SHORT) {\n\t\t\t\t\tif (!TIFFSetupShortPair(tif, fip->field_tag, dir))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t} else if (!TIFFWriteNormalTag(tif, dir, fip))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\t}\n\t\tdir++;\n\n\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\tResetFieldBit(fields, fip->field_bit);\n\t}\n\n\t/*\n\t * Write directory.\n\t */\n\tdircount = (uint16) nfields;\n\tdiroff = (uint32) tif->tif_nextdiroff;\n\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t/*\n\t\t * The file's byte order is opposite to the\n\t\t * native machine architecture.  We overwrite\n\t\t * the directory information with impunity\n\t\t * because it'll be released below after we\n\t\t * write it to the file.  Note that all the\n\t\t * other tag construction routines assume that\n\t\t * we do this byte-swapping; i.e. they only\n\t\t * byte-swap indirect data.\n\t\t */\n\t\tfor (dir = (TIFFDirEntry*) data; dircount; dir++, dircount--) {\n\t\t\tTIFFSwabArrayOfShort(&dir->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dir->tdir_count, 2);\n\t\t}\n\t\tdircount = (uint16) nfields;\n\t\tTIFFSwabShort(&dircount);\n\t\tTIFFSwabLong(&diroff);\n\t}\n\t(void) TIFFSeekFile(tif, tif->tif_diroff, SEEK_SET);\n\tif (!WriteOK(tif, &dircount, sizeof (dircount))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Error writing directory count\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif, data, dirsize)) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Error writing directory contents\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif, &diroff, sizeof (uint32))) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Error writing directory link\");\n\t\tgoto bad;\n\t}\n\tif (done) {\n\t\tTIFFFreeDirectory(tif);\n\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\t\t(*tif->tif_cleanup)(tif);\n\n\t\t/*\n\t\t* Reset directory-related state for subsequent\n\t\t* directories.\n\t\t*/\n\t\tTIFFCreateDirectory(tif);\n\t}\n\t_TIFFfree(data);\n\treturn (1);\nbad:\n\t_TIFFfree(data);\n\treturn (0);\n}"
}