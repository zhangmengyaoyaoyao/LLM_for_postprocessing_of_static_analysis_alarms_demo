{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "binutils/stabs.c",
    "message": "Offset: [2, 13] Size: 3.",
    "warning_function_name": "parse_stab_argtypes",
    "warning_line": "strcpy (physname + 3, opname);",
    "warning_context": "static debug_type\nparse_stab_argtypes (void *dhandle, struct stab_handle *info,\n\t\t     debug_type class_type, const char *fieldname,\n\t\t     const char *tagname, debug_type return_type,\n\t\t     const char *argtypes, bfd_boolean constp,\n\t\t     bfd_boolean volatilep, const char **pphysname)\n{\n  bfd_boolean is_full_physname_constructor;\n  bfd_boolean is_constructor;\n  bfd_boolean is_destructor;\n  bfd_boolean is_v3;\n  debug_type *args;\n  bfd_boolean varargs;\n  unsigned int physname_len = 0;\n\n  /* Constructors are sometimes handled specially.  */\n  is_full_physname_constructor = ((argtypes[0] == '_'\n\t\t\t\t   && argtypes[1] == '_'\n\t\t\t\t   && (ISDIGIT (argtypes[2])\n\t\t\t\t       || argtypes[2] == 'Q'\n\t\t\t\t       || argtypes[2] == 't'))\n\t\t\t\t  || CONST_STRNEQ (argtypes, \"__ct\"));\n\n  is_constructor = (is_full_physname_constructor\n\t\t    || (tagname != NULL\n\t\t\t&& strcmp (fieldname, tagname) == 0));\n  is_destructor = ((argtypes[0] == '_'\n\t\t    && (argtypes[1] == '$' || argtypes[1] == '.')\n\t\t    && argtypes[2] == '_')\n\t\t   || CONST_STRNEQ (argtypes, \"__dt\"));\n  is_v3 = argtypes[0] == '_' && argtypes[1] == 'Z';\n\n  if (!(is_destructor || is_full_physname_constructor || is_v3))\n    {\n      unsigned int len;\n      const char *const_prefix;\n      const char *volatile_prefix;\n      char buf[20];\n      unsigned int mangled_name_len;\n      char *physname;\n\n      len = tagname == NULL ? 0 : strlen (tagname);\n      const_prefix = constp ? \"C\" : \"\";\n      volatile_prefix = volatilep ? \"V\" : \"\";\n\n      if (len == 0)\n\tsprintf (buf, \"__%s%s\", const_prefix, volatile_prefix);\n      else if (tagname != NULL && strchr (tagname, '<') != NULL)\n\t{\n\t  /* Template methods are fully mangled.  */\n\t  sprintf (buf, \"__%s%s\", const_prefix, volatile_prefix);\n\t  tagname = NULL;\n\t  len = 0;\n\t}\n      else\n\tsprintf (buf, \"__%s%s%d\", const_prefix, volatile_prefix, len);\n\n      mangled_name_len = ((is_constructor ? 0 : strlen (fieldname))\n\t\t\t  + strlen (buf)\n\t\t\t  + len\n\t\t\t  + strlen (argtypes)\n\t\t\t  + 1);\n\n      if (fieldname[0] == 'o'\n\t  && fieldname[1] == 'p'\n\t  && (fieldname[2] == '$' || fieldname[2] == '.'))\n\t{\n\t  const char *opname;\n\n\t  opname = cplus_mangle_opname (fieldname + 3, 0);\n\t  if (opname == NULL)\n\t    {\n\t      fprintf (stderr, _(\"No mangling for \\\"%s\\\"\\n\"), fieldname);\n\t      return DEBUG_TYPE_NULL;\n\t    }\n\t  mangled_name_len += strlen (opname);\n\t  physname = (char *) xmalloc (mangled_name_len);\n\t  strncpy (physname, fieldname, 3);\n\t  strcpy (physname + 3, opname);\n\t}\n      else\n\t{\n\t  physname = (char *) xmalloc (mangled_name_len);\n\t  if (is_constructor)\n\t    physname[0] = '\\0';\n\t  else\n\t    strcpy (physname, fieldname);\n\t}\n\n      physname_len = strlen (physname);\n      strcat (physname, buf);\n      if (tagname != NULL)\n\tstrcat (physname, tagname);\n      strcat (physname, argtypes);\n\n      *pphysname = physname;\n    }\n\n  if (*argtypes == '\\0' || is_destructor)\n    {\n      args = (debug_type *) xmalloc (sizeof *args);\n"
}