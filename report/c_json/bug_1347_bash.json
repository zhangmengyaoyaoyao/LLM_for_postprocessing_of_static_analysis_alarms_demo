{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from state_bak.__count was never initialized.",
    "Code_line": "\t\tADVANCE_CHAR (rl_line_buffer, slen, p);",
    "Code_function": "bash_forward_shellword (count, key)\n     int count, key;\n{\n  size_t slen;\n  int sindex, c, p;\n  DECLARE_MBSTATE;\n\n  if (count < 0)\n    return (bash_backward_shellword (-count, key));\n\n  /* The tricky part of this is deciding whether or not the first character\n     we're on is an unquoted metacharacter.  Not completely handled yet. */\n  /* XXX - need to test this stuff with backslash-escaped shell\n     metacharacters and unclosed single- and double-quoted strings. */\n\n  p = rl_point;\n  slen = rl_end;\n\n  while (count)\n    {\n      if (p == rl_end)\n\t{\n\t  rl_point = rl_end;\n\t  return 0;\n\t}\n\n      /* Are we in a quoted string?  If we are, move to the end of the quoted\n         string and continue the outer loop. We only want quoted strings, not\n         backslash-escaped characters, but char_is_quoted doesn't\n         differentiate. */\n      if (char_is_quoted (rl_line_buffer, p) && p > 0 && rl_line_buffer[p-1] != '\\\\')\n\t{\n\t  do\n\t    ADVANCE_CHAR (rl_line_buffer, slen, p);\n\t  while (p < rl_end && char_is_quoted (rl_line_buffer, p));\n\t  count--;\n\t  continue;\n\t}\n\n      /* Rest of code assumes we are not in a quoted string. */\n      /* Move forward until we hit a non-metacharacter. */\n      while (p < rl_end && (c = rl_line_buffer[p]) && WORDDELIM (c))\n\t{\n\t  switch (c)\n\t    {\n\t    default:\n\t      ADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      continue;\t\t/* straight back to loop, don't increment p */\n\t    case '\\\\':\n\t      if (p < rl_end && rl_line_buffer[p])\n\t\tADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      break;\n\t    case '\\'':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"'\", SD_NOJMP);\n\t      break;\n\t    case '\"':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"\\\"\", SD_NOJMP);\n\t      break;\n\t    }\n\n\t  if (p < rl_end)\n\t    p++;\n\t}\n\n      if (rl_line_buffer[p] == 0 || p == rl_end)\n        {\n\t  rl_point = rl_end;\n\t  rl_ding ();\n\t  return 0;\n        }\n\n      /* Now move forward until we hit a non-quoted metacharacter or EOL */\n      while (p < rl_end && (c = rl_line_buffer[p]) && WORDDELIM (c) == 0)\n\t{\n\t  switch (c)\n\t    {\n\t    default:\n\t      ADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      continue;\t\t/* straight back to loop, don't increment p */\n\t    case '\\\\':\n\t      if (p < rl_end && rl_line_buffer[p])\n\t\tADVANCE_CHAR (rl_line_buffer, slen, p);\n\t      break;\n\t    case '\\'':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"'\", SD_NOJMP);\n\t      break;\n\t    case '\"':\n\t      p = skip_to_delim (rl_line_buffer, ++p, \"\\\"\", SD_NOJMP);\n\t      break;\n\t    }\n\n\t  if (p < rl_end)\n\t    p++;\n\t}\n\n      if (p == rl_end || rl_line_buffer[p] == 0)\n\t{\n\t  rl_point = rl_end;\n\t  return (0);\n\t}\n\n      count--;\n    }\n\n  rl_point = p;\n  return (0);\n}"
}