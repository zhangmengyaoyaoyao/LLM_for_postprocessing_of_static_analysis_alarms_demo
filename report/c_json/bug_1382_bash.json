{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "\t  temp = extract_delimited_string (string, &si, open, \"(\", \")\", SX_NOALLOC); /* ) */",
    "Code_function": "skip_to_delim (string, start, delims, flags)\n     char *string;\n     int start;\n     char *delims;\n     int flags;\n{\n  int i, pass_next, backq, si, c, invert, skipquote, skipcmd;\n  size_t slen;\n  char *temp, open[3];\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + start) + start;\n  if (flags & SD_NOJMP)\n    no_longjmp_on_fatal_error = 1;\n  invert = (flags & SD_INVERT);\n  skipcmd = (flags & SD_NOSKIPCMD) == 0;\n\n  i = start;\n  pass_next = backq = 0;\n  while (c = string[i])\n    {\n      /* If this is non-zero, we should not let quote characters be delimiters\n\t and the current character is a single or double quote.  We should not\n\t test whether or not it's a delimiter until after we skip single- or\n\t double-quoted strings. */\n      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\\'' || c =='\"'));\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (c == 0)\n\t    CQ_RETURN(i);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq)\n\t{\n\t  if (c == '`')\n\t    backq = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '`')\n\t{\n\t  backq = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (skipquote == 0 && invert == 0 && member (c, delims))\n\tbreak;\n      else if (c == '\\'' || c == '\"')\n\t{\n\t  i = (c == '\\'') ? skip_single_quoted (string, slen, ++i)\n\t\t\t  : skip_double_quoted (string, slen, ++i);\n\t  /* no increment, the skip functions increment past the closing quote. */\n\t}\n      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  if (string[i+1] == LPAREN)\n\t    temp = extract_delimited_string (string, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND); /* ) */\n\t  else\n\t    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#if defined (PROCESS_SUBSTITUTION)\n      else if (skipcmd && (c == '<' || c == '>') && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\t  temp = extract_process_subst (string, (c == '<') ? \"<(\" : \">(\", &si);\n\t  free (temp);\t\t/* no SX_ALLOC here */\n\t  i = si;\n\t  if (string[i] == '\\0')\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif /* PROCESS_SUBSTITUTION */\n#if defined (EXTENDED_GLOB)\n      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, \"?*+!@\"))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  open[0] = c;\n\t  open[1] = LPAREN;\n\t  open[2] = '\\0';\n\t  temp = extract_delimited_string (string, &si, open, \"(\", \")\", SX_NOALLOC); /* ) */\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif\n      else if ((flags & SD_GLOB) && c == LBRACK)\n\t{\n\t  si = i + 1;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  temp = extract_delimited_string (string, &si, \"[\", \"[\", \"]\", SX_NOALLOC); /* ] */\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else if ((skipquote || invert) && (member (c, delims) == 0))\n\tbreak;\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(i);\n}"
}