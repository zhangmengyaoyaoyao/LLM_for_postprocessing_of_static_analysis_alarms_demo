{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from recm.rt_len was never initialized.",
    "Code_line": "\t\t\t\trtval->stlen = recm.rt_len;",
    "Code_function": "get_a_record(char **out,        /* pointer to pointer to data */\n        IOBUF *iop,             /* input IOP */\n        int *errcode)           /* pointer to error variable */\n{\n\tstruct recmatch recm;\n\tSCANSTATE state;\n\tRECVALUE ret;\n\tint retval;\n\tNODE *rtval = NULL;\n\tstatic RECVALUE (*lastmatchrec)(IOBUF *iop, struct recmatch *recm, SCANSTATE *state) = NULL;\n\n\tif (at_eof(iop) && no_data_left(iop))\n\t\treturn EOF;\n\n\tif (read_can_timeout)\n\t\tread_timeout = get_read_timeout(iop);\n\n\tif (iop->public.get_record != NULL) {\n\t\tchar *rt_start;\n\t\tsize_t rt_len;\n\t\tint rc = iop->public.get_record(out, &iop->public, errcode,\n\t\t\t\t\t\t&rt_start, &rt_len);\n\t\tif (rc == EOF)\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\telse {\n\t\t\tif (rt_len != 0)\n\t\t\t\tset_RT(rt_start, rt_len);\n\t\t\telse\n\t\t\t\tset_RT_to_null();\n\t\t}\n\t\treturn rc;\n\t}\n\n        /* fill initial buffer */\n\tif (has_no_data(iop) || no_data_left(iop)) {\n\t\tiop->count = iop->public.read_func(iop->public.fd, iop->buf, iop->readsize);\n\t\tif (iop->count == 0) {\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\treturn EOF;\n\t\t} else if (iop->count == -1) {\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\t*errcode = errno;\n\t\t\treturn EOF;\n\t\t} else {\n\t\t\tiop->dataend = iop->buf + iop->count;\n\t\t\tiop->off = iop->buf;\n\t\t}\n\t}\n\n\t/* loop through file to find a record */\n\tstate = NOSTATE;\n\tfor (;;) {\n\t\tsize_t dataend_off;\n\t\tsize_t room_left;\n\t\tsize_t amt_to_read;\n\n\t\tret = (*matchrec)(iop, & recm, & state);\n\t\tiop->flag &= ~IOP_AT_START;\n\t\t/* found the record, we're done, break the loop */\n\t\tif (ret == REC_OK)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Likely found the record; if there's no more data\n\t\t * to be had (like from a tiny regular file), break the\n\t\t * loop. Otherwise, see if we can read more.\n\t\t */\n\t\tif (ret == TERMNEAREND && buffer_has_all_data(iop))\n\t\t\tbreak;\n\n\t\t/* need to add more data to buffer */\n\t\t/* shift data down in buffer */\n\t\tdataend_off = iop->dataend - iop->off;\n\t\tmemmove(iop->buf, iop->off, dataend_off);\n\t\tiop->off = iop->buf;\n\t\tiop->dataend = iop->buf + dataend_off;\n\n\t\t/* adjust recm contents */\n\t\trecm.start = iop->off;\n\t\tif (recm.rt_start != NULL)\n\t\t\trecm.rt_start = iop->off + recm.len;\n\n\t\t/* read more data, break if EOF */\n#ifndef MIN\n#define MIN(x, y) (x < y ? x : y)\n#endif\n\t\t/* subtract one in read count to leave room for sentinel */\n\t\troom_left = iop->end - iop->dataend - 1;\n\t\tamt_to_read = MIN(iop->readsize, room_left);\n\n\t\tif (amt_to_read < iop->readsize) {\n\t\t\tgrow_iop_buffer(iop);\n\t\t\t/* adjust recm contents */\n\t\t\trecm.start = iop->off;\n\t\t\tif (recm.rt_start != NULL)\n\t\t\t\trecm.rt_start = iop->off + recm.len;\n\n\t\t\t/* recalculate amt_to_read */\n\t\t\troom_left = iop->end - iop->dataend - 1;\n\t\t\tamt_to_read = MIN(iop->readsize, room_left);\n\t\t}\n\t\twhile (amt_to_read + iop->readsize < room_left)\n\t\t\tamt_to_read += iop->readsize;\n\n#ifdef SSIZE_MAX\n\t\t/*\n\t\t * POSIX limits read to SSIZE_MAX. There are (bizarre)\n\t\t * systems where this amount is small.\n\t\t */\n\t\tamt_to_read = MIN(amt_to_read, SSIZE_MAX);\n#endif\n\n\t\tiop->count = iop->public.read_func(iop->public.fd, iop->dataend, amt_to_read);\n\t\tif (iop->count == -1) {\n\t\t\t*errcode = errno;\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\tbreak;\n\t\t} else if (iop->count == 0) {\n\t\t\t/*\n\t\t\t * Hit EOF before being certain that we've matched\n\t\t\t * the end of the record. If ret is TERMNEAREND,\n\t\t\t * we need to pull out what we've got in the buffer.\n\t\t\t * Eventually we'll come back here and see the EOF,\n\t\t\t * end the record and set RT to \"\".\n\t\t\t */\n\t\t\tif (ret != TERMNEAREND)\n\t\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\tbreak;\n\t\t} else\n\t\t\tiop->dataend += iop->count;\n\t}\n\n\t/* set record, RT, return right value */\n\n\t/*\n\t * rtval is not a static pointer to avoid dangling pointer problems\n\t * in case awk code assigns to RT.  A remote possibility, to be sure,\n\t * but Bitter Experience teaches us not to make ``that'll never\n\t * happen'' kinds of assumptions.\n\t */\n\trtval = RT_node->var_value;\n\n\tif (recm.rt_len == 0) {\n\t\tset_RT_to_null();\n\t\tlastmatchrec = NULL;\n\t} else {\n\t\tassert(recm.rt_start != NULL);\n\t\t/*\n\t\t * Optimization. For rs1 case, don't set RT if\n\t\t * character is same as last time.  This knocks a\n\t\t * chunk of time off something simple like\n\t\t *\n\t\t *      gawk '{ print }' /some/big/file\n\t\t *\n\t\t * Similarly, for rsnull case, if length of new RT is\n\t\t * shorter than current RT, just bump length down in RT.\n\t\t *\n\t\t * Make sure that matchrec didn't change since the last\n\t\t * check.  (Ugh, details, details, details.)\n\t\t */\n\t\tif (lastmatchrec == NULL || lastmatchrec != matchrec) {\n\t\t\tlastmatchrec = matchrec;\n\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t} else if (matchrec == rs1scan) {\n\t\t\tif (rtval->stlen != 1 || rtval->stptr[0] != recm.rt_start[0])\n\t\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t\t/* else\n\t\t\t\tleave it alone */\n\t\t} else if (matchrec == rsnullscan) {\n\t\t\tif (rtval->stlen >= recm.rt_len) {\n\t\t\t\trtval->stlen = recm.rt_len;\n\t\t\t\tfree_wstr(rtval);\n\t\t\t} else\n\t\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t} else\n\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t}\n\n\tif (recm.len == 0) {\n\t\t*out = NULL;\n\t\tretval = 0;\n\t} else {\n\t\tassert(recm.start != NULL);\n\t\t*out = recm.start;\n\t\tretval = recm.len;\n\t}\n\n\tiop->off += recm.len + recm.rt_len;\n\n\tif (recm.len == 0 && recm.rt_len == 0 && at_eof(iop))\n\t\treturn EOF;\n\telse\n\t\treturn retval;\n}"
}