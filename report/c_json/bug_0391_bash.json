{
    "project": "bash",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "bashline.c",
    "message": "Dereference of null pointer (loaded from variable 'qcp')",
    "warning_function_name": "bash_directory_completion_hook",
    "warning_line": "if (*qcp == '\\0' && cs == COMPLETE_BSQUOTE && mbschr (s, '\\n'))",
    "warning_context": "   characters through without examination. */\nstatic char *\nquote_word_break_chars (text)\n     char *text;\n{\n  char *ret, *r, *s;\n  int l;\n\n  l = strlen (text);\n  ret = (char *)xmalloc ((2 * l) + 1);\n  for (s = text, r = ret; *s; s++)\n    {\n      /* Pass backslash-quoted characters through, including the backslash. */\n      if (*s == '\\\\')\n\t{\n\t  *r++ = '\\\\';\n\t  *r++ = *++s;\n\t  if (*s == '\\0')\n\t    break;\n\t  continue;\n\t}\n      /* OK, we have an unquoted character.  Check its presence in\n\t rl_completer_word_break_characters. */\n      if (mbschr (rl_completer_word_break_characters, *s))\n\t*r++ = '\\\\';\n      /* XXX -- check for standalone tildes here and backslash-quote them */\n      if (s == text && *s == '~' && file_exists (text))\n        *r++ = '\\\\';\n      *r++ = *s;\n    }\n  *r = '\\0';\n  return ret;\n}\n\n/* Use characters in STRING to populate the table of characters that should\n   be backslash-quoted.  The table will be used for sh_backslash_quote from\n   this file. */\nstatic void\nset_filename_bstab (string)\n     const char *string;\n{\n  const char *s;\n\n  memset (filename_bstab, 0, sizeof (filename_bstab));\n  for (s = string; s && *s; s++)\n    filename_bstab[*s] = 1;\n}\n\n/* Quote a filename using double quotes, single quotes, or backslashes\n   depending on the value of completion_quoting_style.  If we're\n   completing using backslashes, we need to quote some additional\n   characters (those that readline treats as word breaks), so we call\n   quote_word_break_chars on the result.  This returns newly-allocated\n   memory. */\nstatic char *\nbash_quote_filename (s, rtype, qcp)\n     char *s;\n     int rtype;\n     char *qcp;\n{\n  char *rtext, *mtext, *ret;\n  int rlen, cs;\n\n  rtext = (char *)NULL;\n\n  /* If RTYPE == MULT_MATCH, it means that there is\n     more than one match.  In this case, we do not add\n     the closing quote or attempt to perform tilde\n     expansion.  If RTYPE == SINGLE_MATCH, we try\n     to perform tilde expansion, because single and double\n     quotes inhibit tilde expansion by the shell. */\n\n  cs = completion_quoting_style;\n  /* Might need to modify the default completion style based on *qcp,\n     since it's set to any user-provided opening quote.  We also change\n     to single-quoting if there is no user-provided opening quote and\n     the word being completed contains newlines, since those are not\n     quoted correctly using backslashes (a backslash-newline pair is\n     special to the shell parser). */\n  if (*qcp == '\\0' && cs == COMPLETE_BSQUOTE && mbschr (s, '\\n'))\n    cs = COMPLETE_SQUOTE;\n  else if (*qcp == '\"')\n    cs = COMPLETE_DQUOTE;\n  else if (*qcp == '\\'')\n    cs = COMPLETE_SQUOTE;\n#if defined (BANG_HISTORY)\n  else if (*qcp == '\\0' && history_expansion && cs == COMPLETE_DQUOTE &&\n\t   history_expansion_inhibited == 0 && mbschr (s, '!'))\n    cs = COMPLETE_BSQUOTE;\n\n  if (*qcp == '\"' && history_expansion && cs == COMPLETE_DQUOTE &&\n\thistory_expansion_inhibited == 0 && mbschr (s, '!'))\n    {\n      cs = COMPLETE_BSQUOTE;\n      *qcp = '\\0';\n    }\n#endif\n\n  /* Don't tilde-expand backslash-quoted filenames, since only single and\n     double quotes inhibit tilde expansion. */\n  mtext = s;\n"
}