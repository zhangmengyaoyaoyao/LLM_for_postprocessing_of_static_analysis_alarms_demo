{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      ADVANCE_CHAR (s, slen, sindex);",
    "Code_function": "get_word_from_string (stringp, separators, endptr)\n     char **stringp, *separators, **endptr;\n{\n  register char *s;\n  char *current_word;\n  int sindex, sh_style_split, whitesep, xflags;\n  size_t slen;\n\n  if (!stringp || !*stringp || !**stringp)\n    return ((char *)NULL);\n\n  sh_style_split = separators && separators[0] == ' ' &&\n\t\t\t\t separators[1] == '\\t' &&\n\t\t\t\t separators[2] == '\\n' &&\n\t\t\t\t separators[3] == '\\0';\n  for (xflags = 0, s = ifs_value; s && *s; s++)\n    {\n      if (*s == CTLESC) xflags |= SX_NOCTLESC;\n      if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;\n    }\n\n  s = *stringp;\n  slen = 0;\n\n  /* Remove sequences of whitespace at the beginning of STRING, as\n     long as those characters appear in IFS. */\n  if (sh_style_split || !separators || !*separators)\n    {\n      for (; *s && spctabnl (*s) && isifs (*s); s++);\n\n      /* If the string is nothing but whitespace, update it and return. */\n      if (!*s)\n\t{\n\t  *stringp = s;\n\t  if (endptr)\n\t    *endptr = s;\n\t  return ((char *)NULL);\n\t}\n    }\n\n  /* OK, S points to a word that does not begin with white space.\n     Now extract a word, stopping at a separator, save a pointer to\n     the first character after the word, then skip sequences of spc,\n     tab, or nl as long as they are separators.\n\n     This obeys the field splitting rules in Posix.2. */\n  sindex = 0;\n  /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim\n     unless multibyte chars are possible. */\n  slen = (MB_CUR_MAX > 1) ? strlen (s) : 1;\n  current_word = string_extract_verbatim (s, slen, &sindex, separators, xflags);\n\n  /* Set ENDPTR to the first character after the end of the word. */\n  if (endptr)\n    *endptr = s + sindex;\n\n  /* Note whether or not the separator is IFS whitespace, used later. */\n  whitesep = s[sindex] && spctabnl (s[sindex]);\n\n  /* Move past the current separator character. */\n  if (s[sindex])\n    {\n      DECLARE_MBSTATE;\n      ADVANCE_CHAR (s, slen, sindex);\n    }\n\n  /* Now skip sequences of space, tab, or newline characters if they are\n     in the list of separators. */\n  while (s[sindex] && spctabnl (s[sindex]) && isifs (s[sindex]))\n    sindex++;\n\n  /* If the first separator was IFS whitespace and the current character is\n     a non-whitespace IFS character, it should be part of the current field\n     delimiter, not a separate delimiter that would result in an empty field.\n     Look at POSIX.2, 3.6.5, (3)(b). */\n  if (s[sindex] && whitesep && isifs (s[sindex]) && !spctabnl (s[sindex]))\n    {\n      sindex++;\n      /* An IFS character that is not IFS white space, along with any adjacent\n\t IFS white space, shall delimit a field. */\n      while (s[sindex] && spctabnl (s[sindex]) && isifs (s[sindex]))\n\tsindex++;\n    }\n\n  /* Update STRING to point to the next field. */\n  *stringp = s + sindex;\n  return (current_word);\n}"
}