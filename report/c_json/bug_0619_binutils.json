{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/cofflink.c",
    "message": "Offset added: [12, +oo] (⇐ [0, +oo] + 12) Size: [0, +oo] by call to `_bfd_coff_link_input_bfd`.",
    "warning_function_name": "_bfd_coff_final_link",
    "warning_line": "if (! _bfd_coff_link_input_bfd (&flaginfo, sub))",
    "warning_context": "\t  if (o->reloc_count > max_output_reloc_count)\n\t    max_output_reloc_count = o->reloc_count;\n\t}\n\n      /* Reset the reloc and lineno counts, so that we can use them to\n\t count the number of entries we have output so far.  */\n      o->reloc_count = 0;\n      o->lineno_count = 0;\n    }\n\n  obj_sym_filepos (abfd) = line_filepos;\n\n  /* Figure out the largest number of symbols in an input BFD.  Take\n     the opportunity to clear the output_has_begun fields of all the\n     input BFD's.  */\n  max_sym_count = 0;\n  for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n    {\n      size_t sz;\n\n      sub->output_has_begun = FALSE;\n      sz = bfd_family_coff (sub) ? obj_raw_syment_count (sub) : 2;\n      if (sz > max_sym_count)\n\tmax_sym_count = sz;\n    }\n\n  /* Allocate some buffers used while linking.  */\n  amt = max_sym_count * sizeof (struct internal_syment);\n  flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);\n  amt = max_sym_count * sizeof (asection *);\n  flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);\n  amt = max_sym_count * sizeof (long);\n  flaginfo.sym_indices = (long int *) bfd_malloc (amt);\n  flaginfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);\n  amt = max_lineno_count * bfd_coff_linesz (abfd);\n  flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);\n  flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);\n  amt = max_reloc_count * relsz;\n  flaginfo.external_relocs = (bfd_byte *) bfd_malloc (amt);\n  if (! info->relocatable)\n    {\n      amt = max_reloc_count * sizeof (struct internal_reloc);\n      flaginfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);\n    }\n  if ((flaginfo.internal_syms == NULL && max_sym_count > 0)\n      || (flaginfo.sec_ptrs == NULL && max_sym_count > 0)\n      || (flaginfo.sym_indices == NULL && max_sym_count > 0)\n      || flaginfo.outsyms == NULL\n      || (flaginfo.linenos == NULL && max_lineno_count > 0)\n      || (flaginfo.contents == NULL && max_contents_size > 0)\n      || (flaginfo.external_relocs == NULL && max_reloc_count > 0)\n      || (! info->relocatable\n\t  && flaginfo.internal_relocs == NULL\n\t  && max_reloc_count > 0))\n    goto error_return;\n\n  /* We now know the position of everything in the file, except that\n     we don't know the size of the symbol table and therefore we don't\n     know where the string table starts.  We just build the string\n     table in memory as we go along.  We process all the relocations\n     for a single input file at once.  */\n  obj_raw_syment_count (abfd) = 0;\n\n  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)\n    {\n      if (! bfd_coff_start_final_link (abfd, info))\n\tgoto error_return;\n    }\n\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  if (p->type == bfd_indirect_link_order\n\t      && bfd_family_coff (p->u.indirect.section->owner))\n\t    {\n\t      sub = p->u.indirect.section->owner;\n\t      if (! bfd_coff_link_output_has_begun (sub, & flaginfo))\n\t\t{\n\t\t  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))\n\t\t    goto error_return;\n\t\t  sub->output_has_begun = TRUE;\n\t\t}\n\t    }\n\t  else if (p->type == bfd_section_reloc_link_order\n\t\t   || p->type == bfd_symbol_reloc_link_order)\n\t    {\n\t      if (! _bfd_coff_reloc_link_order (abfd, &flaginfo, o, p))\n\t\tgoto error_return;\n\t    }\n\t  else\n\t    {\n\t      if (! _bfd_default_link_order (abfd, info, o, p))\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  if (flaginfo.info->strip != strip_all && flaginfo.info->discard != discard_all)\n    {\n      /* Add local symbols from foreign inputs.  */\n"
}