{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `sdyn` last assigned on line 3157 could be null and is dereferenced at line 3161, column 17.",
    "Code_line": "  for (extdyn = sdyn->contents;",
    "Code_function": "elf_finalize_dynstr (bfd *output_bfd, struct bfd_link_info *info)\n{\n  struct elf_link_hash_table *hash_table = elf_hash_table (info);\n  struct elf_link_local_dynamic_entry *entry;\n  struct elf_strtab_hash *dynstr = hash_table->dynstr;\n  bfd *dynobj = hash_table->dynobj;\n  asection *sdyn;\n  bfd_size_type size;\n  const struct elf_backend_data *bed;\n  bfd_byte *extdyn;\n\n  _bfd_elf_strtab_finalize (dynstr);\n  size = _bfd_elf_strtab_size (dynstr);\n\n  bed = get_elf_backend_data (dynobj);\n  sdyn = bfd_get_linker_section (dynobj, \".dynamic\");\n  BFD_ASSERT (sdyn != NULL);\n\n  /* Update all .dynamic entries referencing .dynstr strings.  */\n  for (extdyn = sdyn->contents;\n       extdyn < sdyn->contents + sdyn->size;\n       extdyn += bed->s->sizeof_dyn)\n    {\n      Elf_Internal_Dyn dyn;\n\n      bed->s->swap_dyn_in (dynobj, extdyn, &dyn);\n      switch (dyn.d_tag)\n\t{\n\tcase DT_STRSZ:\n\t  dyn.d_un.d_val = size;\n\t  break;\n\tcase DT_NEEDED:\n\tcase DT_SONAME:\n\tcase DT_RPATH:\n\tcase DT_RUNPATH:\n\tcase DT_FILTER:\n\tcase DT_AUXILIARY:\n\tcase DT_AUDIT:\n\tcase DT_DEPAUDIT:\n\t  dyn.d_un.d_val = _bfd_elf_strtab_offset (dynstr, dyn.d_un.d_val);\n\t  break;\n\tdefault:\n\t  continue;\n\t}\n      bed->s->swap_dyn_out (dynobj, &dyn, extdyn);\n    }\n\n  /* Now update local dynamic symbols.  */\n  for (entry = hash_table->dynlocal; entry ; entry = entry->next)\n    entry->isym.st_name = _bfd_elf_strtab_offset (dynstr,\n\t\t\t\t\t\t  entry->isym.st_name);\n\n  /* And the rest of dynamic symbols.  */\n  elf_link_hash_traverse (hash_table, elf_adjust_dynstr_offsets, dynstr);\n\n  /* Adjust version definitions.  */\n  if (elf_tdata (output_bfd)->cverdefs)\n    {\n      asection *s;\n      bfd_byte *p;\n      bfd_size_type i;\n      Elf_Internal_Verdef def;\n      Elf_Internal_Verdaux defaux;\n\n      s = bfd_get_linker_section (dynobj, \".gnu.version_d\");\n      p = s->contents;\n      do\n\t{\n\t  _bfd_elf_swap_verdef_in (output_bfd, (Elf_External_Verdef *) p,\n\t\t\t\t   &def);\n\t  p += sizeof (Elf_External_Verdef);\n\t  if (def.vd_aux != sizeof (Elf_External_Verdef))\n\t    continue;\n\t  for (i = 0; i < def.vd_cnt; ++i)\n\t    {\n\t      _bfd_elf_swap_verdaux_in (output_bfd,\n\t\t\t\t\t(Elf_External_Verdaux *) p, &defaux);\n\t      defaux.vda_name = _bfd_elf_strtab_offset (dynstr,\n\t\t\t\t\t\t\tdefaux.vda_name);\n\t      _bfd_elf_swap_verdaux_out (output_bfd,\n\t\t\t\t\t &defaux, (Elf_External_Verdaux *) p);\n\t      p += sizeof (Elf_External_Verdaux);\n\t    }\n\t}\n      while (def.vd_next);\n    }\n\n  /* Adjust version references.  */\n  if (elf_tdata (output_bfd)->verref)\n    {\n      asection *s;\n      bfd_byte *p;\n      bfd_size_type i;\n      Elf_Internal_Verneed need;\n      Elf_Internal_Vernaux needaux;\n\n      s = bfd_get_linker_section (dynobj, \".gnu.version_r\");\n      p = s->contents;\n      do\n\t{\n\t  _bfd_elf_swap_verneed_in (output_bfd, (Elf_External_Verneed *) p,\n\t\t\t\t    &need);\n\t  need.vn_file = _bfd_elf_strtab_offset (dynstr, need.vn_file);\n\t  _bfd_elf_swap_verneed_out (output_bfd, &need,\n\t\t\t\t     (Elf_External_Verneed *) p);\n\t  p += sizeof (Elf_External_Verneed);\n\t  for (i = 0; i < need.vn_cnt; ++i)\n\t    {\n\t      _bfd_elf_swap_vernaux_in (output_bfd,\n\t\t\t\t\t(Elf_External_Vernaux *) p, &needaux);\n\t      needaux.vna_name = _bfd_elf_strtab_offset (dynstr,\n\t\t\t\t\t\t\t needaux.vna_name);\n\t      _bfd_elf_swap_vernaux_out (output_bfd,\n\t\t\t\t\t &needaux,\n\t\t\t\t\t (Elf_External_Vernaux *) p);\n\t      p += sizeof (Elf_External_Vernaux);\n\t    }\n\t}\n      while (need.vn_next);\n    }\n\n  return TRUE;\n}"
}