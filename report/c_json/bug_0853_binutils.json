{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset: [-oo, 9999] Size: 200.",
    "Code_line": "  *yyssp = yystate;",
    "Code_function": "yyparse ()\n\n#endif\n#endif\n{\n\n  int yystate;\n  int yyn;\n  int yyresult;\n  /* Number of tokens to shift before error messages enabled.  */\n  int yyerrstatus;\n  /* Look-ahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n  /* Three stacks and their tools:\n     `yyss': related to states,\n     `yyvs': related to semantic values,\n     `yyls': related to locations.\n\n     Refer to the stacks thru separate pointers, to allow yyoverflow\n     to reallocate them elsewhere.  */\n\n  /* The state stack.  */\n  yytype_int16 yyssa[YYINITDEPTH];\n  yytype_int16 *yyss = yyssa;\n  yytype_int16 *yyssp;\n\n  /* The semantic value stack.  */\n  YYSTYPE yyvsa[YYINITDEPTH];\n  YYSTYPE *yyvs = yyvsa;\n  YYSTYPE *yyvsp;\n\n\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  YYSIZE_T yystacksize = YYINITDEPTH;\n\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY;\t\t/* Cause a token to be read.  */\n\n  /* Initialize stack pointers.\n     Waste one element of value and location stack\n     so that they stay on the same level as the state stack.\n     The wasted elements are never initialized.  */\n\n  yyssp = yyss;\n  yyvsp = yyvs;\n\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t/* Give user a chance to reallocate the stack.  Use copies of\n\t   these so that the &'s don't force the real ones into\n\t   memory.  */\n\tYYSTYPE *yyvs1 = yyvs;\n\tyytype_int16 *yyss1 = yyss;\n\n\n\t/* Each stack pointer address is followed by the size of the\n\t   data in use in that stack, in bytes.  This used to be a\n\t   conditional around just the two extra args, but that might\n\t   be undefined if yyoverflow is a macro.  */\n\tyyoverflow (YY_(\"memory exhausted\"),\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n\t\t    &yyvs1, yysize * sizeof (*yyvsp),\n\n\t\t    &yystacksize);\n\n\tyyss = yyss1;\n\tyyvs = yyvs1;\n      }\n#else /* no yyoverflow */\n# ifndef YYSTACK_RELOCATE\n      goto yyexhaustedlab;\n# else\n      /* Extend the stack our own way.  */\n      if (YYMAXDEPTH <= yystacksize)\n\tgoto yyexhaustedlab;\n      yystacksize *= 2;\n      if (YYMAXDEPTH < yystacksize)\n\tyystacksize = YYMAXDEPTH;\n\n      {\n\tyytype_int16 *yyss1 = yyss;\n\tunion yyalloc *yyptr =\n\t  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));\n\tif (! yyptr)\n\t  goto yyexhaustedlab;\n\tYYSTACK_RELOCATE (yyss);\n\tYYSTACK_RELOCATE (yyvs);\n\n#  undef YYSTACK_RELOCATE\n\tif (yyss1 != yyssa)\n\t  YYSTACK_FREE (yyss1);\n      }\n# endif\n#endif /* no yyoverflow */\n\n      yyssp = yyss + yysize - 1;\n      yyvsp = yyvs + yysize - 1;\n\n\n      YYDPRINTF ((stderr, \"Stack size increased to %lu\\n\",\n\t\t  (unsigned long int) yystacksize));\n\n      if (yyss + yystacksize - 1 <= yyssp)\n\tYYABORT;\n    }\n\n  YYDPRINTF ((stderr, \"Entering state %d\\n\", yystate));\n\n  goto yybackup;\n\n/*-----------.\n| yybackup.  |\n`-----------*/\nyybackup:\n\n  /* Do appropriate processing given the current state.  Read a\n     look-ahead token if we need one and don't already have one.  */\n\n  /* First try to decide what to do without reference to look-ahead token.  */\n  yyn = yypact[yystate];\n  if (yyn == YYPACT_NINF)\n    goto yydefault;\n\n  /* Not known => get a look-ahead token if don't already have one.  */\n\n  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */\n  if (yychar == YYEMPTY)\n    {\n      YYDPRINTF ((stderr, \"Reading a token: \"));\n      yychar = YYLEX;\n    }\n\n  if (yychar <= YYEOF)\n    {\n      yychar = yytoken = YYEOF;\n      YYDPRINTF ((stderr, \"Now at end of input.\\n\"));\n    }\n  else\n    {\n      yytoken = YYTRANSLATE (yychar);\n      YY_SYMBOL_PRINT (\"Next token is\", yytoken, &yylval, &yylloc);\n    }\n\n  /* If the proper action on seeing token YYTOKEN is to reduce or to\n     detect an error, take that action.  */\n  yyn += yytoken;\n  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)\n    goto yydefault;\n  yyn = yytable[yyn];\n  if (yyn <= 0)\n    {\n      if (yyn == 0 || yyn == YYTABLE_NINF)\n\tgoto yyerrlab;\n      yyn = -yyn;\n      goto yyreduce;\n    }\n\n  if (yyn == YYFINAL)\n    YYACCEPT;\n\n  /* Count tokens shifted since error; after three, turn off error\n     status.  */\n  if (yyerrstatus)\n    yyerrstatus--;\n\n  /* Shift the look-ahead token.  */\n  YY_SYMBOL_PRINT (\"Shifting\", yytoken, &yylval, &yylloc);\n\n  /* Discard the shifted token unless it is eof.  */\n  if (yychar != YYEOF)\n    yychar = YYEMPTY;\n\n  yystate = yyn;\n  *++yyvsp = yylval;\n\n  goto yynewstate;\n\n\n/*-----------------------------------------------------------.\n| yydefault -- do the default action for the current state.  |\n`-----------------------------------------------------------*/\nyydefault:\n  yyn = yydefact[yystate];\n  if (yyn == 0)\n    goto yyerrlab;\n  goto yyreduce;\n\n\n/*-----------------------------.\n| yyreduce -- Do a reduction.  |\n`-----------------------------*/\nyyreduce:\n  /* yyn is the number of a rule to reduce with.  */\n  yylen = yyr2[yyn];\n\n  /* If YYLEN is nonzero, implement the default value of the action:\n     `$$ = $1'.\n\n     Otherwise, the following line sets YYVAL to garbage.\n     This behavior is undocumented and Bison\n     users should not rely upon it.  Assigning to YYVAL\n     unconditionally makes the parser a bit smaller, and it avoids a\n     GCC warning that YYVAL may be used uninitialized.  */\n  yyval = yyvsp[1-yylen];\n\n\n  YY_REDUCE_PRINT (yyn);\n  switch (yyn)\n    {\n        case 8:\n#line 178 \"ldgram.y\"\n    { ldlex_defsym(); }\n    break;\n\n  case 9:\n#line 180 \"ldgram.y\"\n    {\n\t\t  ldlex_popstate();\n\t\t  lang_add_assignment (exp_defsym ((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)));\n\t\t}\n    break;\n\n  case 10:\n#line 188 \"ldgram.y\"\n    {\n\t\t  ldlex_mri_script ();\n\t\t  PUSH_ERROR (_(\"MRI style script\"));\n\t\t}\n    break;\n\n  case 11:\n#line 193 \"ldgram.y\"\n    {\n\t\t  ldlex_popstate ();\n\t\t  mri_draw_tree ();\n\t\t  POP_ERROR ();\n\t\t}\n    break;\n\n  case 16:\n#line 208 \"ldgram.y\"\n    {\n\t\t\teinfo(_(\"%P%F: unrecognised keyword in MRI style script '%s'\\n\"),(yyvsp[(1) - (1)].name));\n\t\t\t}\n    break;\n\n  case 17:\n#line 211 \"ldgram.y\"\n    {\n\t\t\tconfig.map_filename = \"-\";\n\t\t\t}\n    break;\n\n  case 20:\n#line 217 \"ldgram.y\"\n    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }\n    break;\n\n  case 21:\n#line 219 \"ldgram.y\"\n    { mri_public((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree)); }\n    break;\n\n  case 22:\n#line 221 \"ldgram.y\"\n    { mri_public((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 23:\n#line 223 \"ldgram.y\"\n    { mri_format((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 24:\n#line 225 \"ldgram.y\"\n    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}\n    break;\n\n  case 25:\n#line 227 \"ldgram.y\"\n    { mri_output_section((yyvsp[(2) - (3)].name), (yyvsp[(3) - (3)].etree));}\n    break;\n\n  case 26:\n#line 229 \"ldgram.y\"\n    { mri_output_section((yyvsp[(2) - (4)].name), (yyvsp[(4) - (4)].etree));}\n    break;\n\n  case 27:\n#line 231 \"ldgram.y\"\n    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }\n    break;\n\n  case 28:\n#line 233 \"ldgram.y\"\n    { mri_align((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }\n    break;\n\n  case 29:\n#line 235 \"ldgram.y\"\n    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }\n    break;\n\n  case 30:\n#line 237 \"ldgram.y\"\n    { mri_alignmod((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].etree)); }\n    break;\n\n  case 33:\n#line 241 \"ldgram.y\"\n    { mri_name((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 34:\n#line 243 \"ldgram.y\"\n    { mri_alias((yyvsp[(2) - (4)].name),(yyvsp[(4) - (4)].name),0);}\n    break;\n\n  case 35:\n#line 245 \"ldgram.y\"\n    { mri_alias ((yyvsp[(2) - (4)].name), 0, (int) (yyvsp[(4) - (4)].bigint).integer); }\n    break;\n\n  case 36:\n#line 247 \"ldgram.y\"\n    { mri_base((yyvsp[(2) - (2)].etree)); }\n    break;\n\n  case 37:\n#line 249 \"ldgram.y\"\n    { mri_truncate ((unsigned int) (yyvsp[(2) - (2)].bigint).integer); }\n    break;\n\n  case 40:\n#line 253 \"ldgram.y\"\n    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 41:\n#line 255 \"ldgram.y\"\n    { ldlex_popstate (); }\n    break;\n\n  case 42:\n#line 257 \"ldgram.y\"\n    { lang_add_entry ((yyvsp[(2) - (2)].name), FALSE); }\n    break;\n\n  case 44:\n#line 262 \"ldgram.y\"\n    { mri_order((yyvsp[(3) - (3)].name)); }\n    break;\n\n  case 45:\n#line 263 \"ldgram.y\"\n    { mri_order((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 47:\n#line 269 \"ldgram.y\"\n    { mri_load((yyvsp[(1) - (1)].name)); }\n    break;\n\n  case 48:\n#line 270 \"ldgram.y\"\n    { mri_load((yyvsp[(3) - (3)].name)); }\n    break;\n\n  case 49:\n#line 275 \"ldgram.y\"\n    { mri_only_load((yyvsp[(1) - (1)].name)); }\n    break;\n\n  case 50:\n#line 277 \"ldgram.y\"\n    { mri_only_load((yyvsp[(3) - (3)].name)); }\n    break;\n\n  case 51:\n#line 281 \"ldgram.y\"\n    { (yyval.name) = NULL; }\n    break;\n\n  case 54:\n#line 288 \"ldgram.y\"\n    { ldlex_expression (); }\n    break;\n\n  case 55:\n#line 290 \"ldgram.y\"\n    { ldlex_popstate (); }\n    break;\n\n  case 56:\n#line 294 \"ldgram.y\"\n    { ldlang_add_undef ((yyvsp[(1) - (1)].name), FALSE); }\n    break;\n\n  case 57:\n#line 296 \"ldgram.y\"\n    { ldlang_add_undef ((yyvsp[(2) - (2)].name), FALSE); }\n    break;\n\n  case 58:\n#line 298 \"ldgram.y\"\n    { ldlang_add_undef ((yyvsp[(3) - (3)].name), FALSE); }\n    break;\n\n  case 59:\n#line 302 \"ldgram.y\"\n    { ldlex_both(); }\n    break;\n\n  case 60:\n#line 304 \"ldgram.y\"\n    { ldlex_popstate(); }\n    break;\n\n  case 73:\n#line 325 \"ldgram.y\"\n    { lang_add_target((yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 74:\n#line 327 \"ldgram.y\"\n    { ldfile_add_library_path ((yyvsp[(3) - (4)].name), FALSE); }\n    break;\n\n  case 75:\n#line 329 \"ldgram.y\"\n    { lang_add_output((yyvsp[(3) - (4)].name), 1); }\n    break;\n\n  case 76:\n#line 331 \"ldgram.y\"\n    { lang_add_output_format ((yyvsp[(3) - (4)].name), (char *) NULL,\n\t\t\t\t\t    (char *) NULL, 1); }\n    break;\n\n  case 77:\n#line 334 \"ldgram.y\"\n    { lang_add_output_format ((yyvsp[(3) - (8)].name), (yyvsp[(5) - (8)].name), (yyvsp[(7) - (8)].name), 1); }\n    break;\n\n  case 78:\n#line 336 \"ldgram.y\"\n    { ldfile_set_output_arch ((yyvsp[(3) - (4)].name), bfd_arch_unknown); }\n    break;\n\n  case 79:\n#line 338 \"ldgram.y\"\n    { command_line.force_common_definition = TRUE ; }\n    break;\n\n  case 80:\n#line 340 \"ldgram.y\"\n    { command_line.inhibit_common_definition = TRUE ; }\n    break;\n\n  case 82:\n#line 343 \"ldgram.y\"\n    { lang_enter_group (); }\n    break;\n\n  case 83:\n#line 345 \"ldgram.y\"\n    { lang_leave_group (); }\n    break;\n\n  case 84:\n#line 347 \"ldgram.y\"\n    { lang_add_map((yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 85:\n#line 349 \"ldgram.y\"\n    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 86:\n#line 351 \"ldgram.y\"\n    { ldlex_popstate (); }\n    break;\n\n  case 87:\n#line 353 \"ldgram.y\"\n    {\n\t\t  lang_add_nocrossref ((yyvsp[(3) - (4)].nocrossref));\n\t\t}\n    break;\n\n  case 89:\n#line 358 \"ldgram.y\"\n    { lang_add_insert ((yyvsp[(3) - (3)].name), 0); }\n    break;\n\n  case 90:\n#line 360 \"ldgram.y\"\n    { lang_add_insert ((yyvsp[(3) - (3)].name), 1); }\n    break;\n\n  case 91:\n#line 362 \"ldgram.y\"\n    { lang_memory_region_alias ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].name)); }\n    break;\n\n  case 92:\n#line 364 \"ldgram.y\"\n    { lang_ld_feature ((yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 93:\n#line 368 \"ldgram.y\"\n    { ldlex_inputlist(); }\n    break;\n\n  case 94:\n#line 370 \"ldgram.y\"\n    { ldlex_popstate(); }\n    break;\n\n  case 95:\n#line 374 \"ldgram.y\"\n    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_search_file_enum,\n\t\t\t\t (char *)NULL); }\n    break;\n\n  case 96:\n#line 377 \"ldgram.y\"\n    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_search_file_enum,\n\t\t\t\t (char *)NULL); }\n    break;\n\n  case 97:\n#line 380 \"ldgram.y\"\n    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_search_file_enum,\n\t\t\t\t (char *)NULL); }\n    break;\n\n  case 98:\n#line 383 \"ldgram.y\"\n    { lang_add_input_file((yyvsp[(1) - (1)].name),lang_input_file_is_l_enum,\n\t\t\t\t (char *)NULL); }\n    break;\n\n  case 99:\n#line 386 \"ldgram.y\"\n    { lang_add_input_file((yyvsp[(3) - (3)].name),lang_input_file_is_l_enum,\n\t\t\t\t (char *)NULL); }\n    break;\n\n  case 100:\n#line 389 \"ldgram.y\"\n    { lang_add_input_file((yyvsp[(2) - (2)].name),lang_input_file_is_l_enum,\n\t\t\t\t (char *)NULL); }\n    break;\n\n  case 101:\n#line 392 \"ldgram.y\"\n    { (yyval.integer) = input_flags.add_DT_NEEDED_for_regular;\n\t\t    input_flags.add_DT_NEEDED_for_regular = TRUE; }\n    break;\n\n  case 102:\n#line 395 \"ldgram.y\"\n    { input_flags.add_DT_NEEDED_for_regular = (yyvsp[(3) - (5)].integer); }\n    break;\n\n  case 103:\n#line 397 \"ldgram.y\"\n    { (yyval.integer) = input_flags.add_DT_NEEDED_for_regular;\n\t\t    input_flags.add_DT_NEEDED_for_regular = TRUE; }\n    break;\n\n  case 104:\n#line 400 \"ldgram.y\"\n    { input_flags.add_DT_NEEDED_for_regular = (yyvsp[(5) - (7)].integer); }\n    break;\n\n  case 105:\n#line 402 \"ldgram.y\"\n    { (yyval.integer) = input_flags.add_DT_NEEDED_for_regular;\n\t\t    input_flags.add_DT_NEEDED_for_regular = TRUE; }\n    break;\n\n  case 106:\n#line 405 \"ldgram.y\"\n    { input_flags.add_DT_NEEDED_for_regular = (yyvsp[(4) - (6)].integer); }\n    break;\n\n  case 111:\n#line 420 \"ldgram.y\"\n    { lang_add_entry ((yyvsp[(3) - (4)].name), FALSE); }\n    break;\n\n  case 113:\n#line 422 \"ldgram.y\"\n    {ldlex_expression ();}\n    break;\n\n  case 114:\n#line 423 \"ldgram.y\"\n    { ldlex_popstate ();\n\t\t  lang_add_assignment (exp_assert ((yyvsp[(4) - (7)].etree), (yyvsp[(6) - (7)].name))); }\n    break;\n\n  case 115:\n#line 431 \"ldgram.y\"\n    {\n\t\t\t  (yyval.cname) = (yyvsp[(1) - (1)].name);\n\t\t\t}\n    break;\n\n  case 116:\n#line 435 \"ldgram.y\"\n    {\n\t\t\t  (yyval.cname) = \"*\";\n\t\t\t}\n    break;\n\n  case 117:\n#line 439 \"ldgram.y\"\n    {\n\t\t\t  (yyval.cname) = \"?\";\n\t\t\t}\n    break;\n\n  case 118:\n#line 446 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(1) - (1)].cname);\n\t\t\t  (yyval.wildcard).sorted = none;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 119:\n#line 453 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(5) - (5)].cname);\n\t\t\t  (yyval.wildcard).sorted = none;\n\t\t\t  (yyval.wildcard).exclude_name_list = (yyvsp[(3) - (5)].name_list);\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 120:\n#line 460 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_name;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 121:\n#line 467 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_alignment;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 122:\n#line 474 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_none;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 123:\n#line 481 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_name_alignment;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 124:\n#line 488 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_name;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 125:\n#line 495 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_alignment_name;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 126:\n#line 502 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(5) - (7)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_alignment;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 127:\n#line 509 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(7) - (8)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_name;\n\t\t\t  (yyval.wildcard).exclude_name_list = (yyvsp[(5) - (8)].name_list);\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 128:\n#line 516 \"ldgram.y\"\n    {\n\t\t\t  (yyval.wildcard).name = (yyvsp[(3) - (4)].cname);\n\t\t\t  (yyval.wildcard).sorted = by_init_priority;\n\t\t\t  (yyval.wildcard).exclude_name_list = NULL;\n\t\t\t  (yyval.wildcard).section_flag_list = NULL;\n\t\t\t}\n    break;\n\n  case 129:\n#line 525 \"ldgram.y\"\n    {\n\t\t\t  struct flag_info_list *n;\n\t\t\t  n = ((struct flag_info_list *) xmalloc (sizeof *n));\n\t\t\t  if ((yyvsp[(1) - (1)].name)[0] == '!')\n\t\t\t    {\n\t\t\t      n->with = without_flags;\n\t\t\t      n->name = &(yyvsp[(1) - (1)].name)[1];\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      n->with = with_flags;\n\t\t\t      n->name = (yyvsp[(1) - (1)].name);\n\t\t\t    }\n\t\t\t  n->valid = FALSE;\n\t\t\t  n->next = NULL;\n\t\t\t  (yyval.flag_info_list) = n;\n\t\t\t}\n    break;\n\n  case 130:\n#line 543 \"ldgram.y\"\n    {\n\t\t\t  struct flag_info_list *n;\n\t\t\t  n = ((struct flag_info_list *) xmalloc (sizeof *n));\n\t\t\t  if ((yyvsp[(3) - (3)].name)[0] == '!')\n\t\t\t    {\n\t\t\t      n->with = without_flags;\n\t\t\t      n->name = &(yyvsp[(3) - (3)].name)[1];\n\t\t\t    }\n\t\t\t  else\n\t\t\t    {\n\t\t\t      n->with = with_flags;\n\t\t\t      n->name = (yyvsp[(3) - (3)].name);\n\t\t\t    }\n\t\t\t  n->valid = FALSE;\n\t\t\t  n->next = (yyvsp[(1) - (3)].flag_info_list);\n\t\t\t  (yyval.flag_info_list) = n;\n\t\t\t}\n    break;\n\n  case 131:\n#line 564 \"ldgram.y\"\n    {\n\t\t\t  struct flag_info *n;\n\t\t\t  n = ((struct flag_info *) xmalloc (sizeof *n));\n\t\t\t  n->flag_list = (yyvsp[(3) - (4)].flag_info_list);\n\t\t\t  n->flags_initialized = FALSE;\n\t\t\t  n->not_with_flags = 0;\n\t\t\t  n->only_with_flags = 0;\n\t\t\t  (yyval.flag_info) = n;\n\t\t\t}\n    break;\n\n  case 132:\n#line 577 \"ldgram.y\"\n    {\n\t\t\t  struct name_list *tmp;\n\t\t\t  tmp = (struct name_list *) xmalloc (sizeof *tmp);\n\t\t\t  tmp->name = (yyvsp[(2) - (2)].cname);\n\t\t\t  tmp->next = (yyvsp[(1) - (2)].name_list);\n\t\t\t  (yyval.name_list) = tmp;\n\t\t\t}\n    break;\n\n  case 133:\n#line 586 \"ldgram.y\"\n    {\n\t\t\t  struct name_list *tmp;\n\t\t\t  tmp = (struct name_list *) xmalloc (sizeof *tmp);\n\t\t\t  tmp->name = (yyvsp[(1) - (1)].cname);\n\t\t\t  tmp->next = NULL;\n\t\t\t  (yyval.name_list) = tmp;\n\t\t\t}\n    break;\n\n  case 134:\n#line 597 \"ldgram.y\"\n    {\n\t\t\t  struct wildcard_list *tmp;\n\t\t\t  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);\n\t\t\t  tmp->next = (yyvsp[(1) - (3)].wildcard_list);\n\t\t\t  tmp->spec = (yyvsp[(3) - (3)].wildcard);\n\t\t\t  (yyval.wildcard_list) = tmp;\n\t\t\t}\n    break;\n\n  case 135:\n#line 606 \"ldgram.y\"\n    {\n\t\t\t  struct wildcard_list *tmp;\n\t\t\t  tmp = (struct wildcard_list *) xmalloc (sizeof *tmp);\n\t\t\t  tmp->next = NULL;\n\t\t\t  tmp->spec = (yyvsp[(1) - (1)].wildcard);\n\t\t\t  (yyval.wildcard_list) = tmp;\n\t\t\t}\n    break;\n\n  case 136:\n#line 617 \"ldgram.y\"\n    {\n\t\t\t  struct wildcard_spec tmp;\n\t\t\t  tmp.name = (yyvsp[(1) - (1)].name);\n\t\t\t  tmp.exclude_name_list = NULL;\n\t\t\t  tmp.sorted = none;\n\t\t\t  tmp.section_flag_list = NULL;\n\t\t\t  lang_add_wild (&tmp, NULL, ldgram_had_keep);\n\t\t\t}\n    break;\n\n  case 137:\n#line 626 \"ldgram.y\"\n    {\n\t\t\t  struct wildcard_spec tmp;\n\t\t\t  tmp.name = (yyvsp[(2) - (2)].name);\n\t\t\t  tmp.exclude_name_list = NULL;\n\t\t\t  tmp.sorted = none;\n\t\t\t  tmp.section_flag_list = (yyvsp[(1) - (2)].flag_info);\n\t\t\t  lang_add_wild (&tmp, NULL, ldgram_had_keep);\n\t\t\t}\n    break;\n\n  case 138:\n#line 635 \"ldgram.y\"\n    {\n\t\t\t  lang_add_wild (NULL, (yyvsp[(2) - (3)].wildcard_list), ldgram_had_keep);\n\t\t\t}\n    break;\n\n  case 139:\n#line 639 \"ldgram.y\"\n    {\n\t\t\t  struct wildcard_spec tmp;\n\t\t\t  tmp.name = NULL;\n\t\t\t  tmp.exclude_name_list = NULL;\n\t\t\t  tmp.sorted = none;\n\t\t\t  tmp.section_flag_list = (yyvsp[(1) - (4)].flag_info);\n\t\t\t  lang_add_wild (&tmp, (yyvsp[(3) - (4)].wildcard_list), ldgram_had_keep);\n\t\t\t}\n    break;\n\n  case 140:\n#line 648 \"ldgram.y\"\n    {\n\t\t\t  lang_add_wild (&(yyvsp[(1) - (4)].wildcard), (yyvsp[(3) - (4)].wildcard_list), ldgram_had_keep);\n\t\t\t}\n    break;\n\n  case 141:\n#line 652 \"ldgram.y\"\n    {\n\t\t\t  (yyvsp[(2) - (5)].wildcard).section_flag_list = (yyvsp[(1) - (5)].flag_info);\n\t\t\t  lang_add_wild (&(yyvsp[(2) - (5)].wildcard), (yyvsp[(4) - (5)].wildcard_list), ldgram_had_keep);\n\t\t\t}\n    break;\n\n  case 143:\n#line 661 \"ldgram.y\"\n    { ldgram_had_keep = TRUE; }\n    break;\n\n  case 144:\n#line 663 \"ldgram.y\"\n    { ldgram_had_keep = FALSE; }\n    break;\n\n  case 146:\n#line 669 \"ldgram.y\"\n    {\n \t\tlang_add_attribute(lang_object_symbols_statement_enum);\n\t      \t}\n    break;\n\n  case 148:\n#line 674 \"ldgram.y\"\n    {\n\n\t\t  lang_add_attribute(lang_constructors_statement_enum);\n\t\t}\n    break;\n\n  case 149:\n#line 679 \"ldgram.y\"\n    {\n\t\t  constructors_sorted = TRUE;\n\t\t  lang_add_attribute (lang_constructors_statement_enum);\n\t\t}\n    break;\n\n  case 151:\n#line 685 \"ldgram.y\"\n    {\n\t\t\t  lang_add_data ((int) (yyvsp[(1) - (4)].integer), (yyvsp[(3) - (4)].etree));\n\t\t\t}\n    break;\n\n  case 152:\n#line 690 \"ldgram.y\"\n    {\n\t\t\t  lang_add_fill ((yyvsp[(3) - (4)].fill));\n\t\t\t}\n    break;\n\n  case 153:\n#line 693 \"ldgram.y\"\n    {ldlex_expression ();}\n    break;\n\n  case 154:\n#line 694 \"ldgram.y\"\n    { ldlex_popstate ();\n\t\t\t  lang_add_assignment (exp_assert ((yyvsp[(4) - (8)].etree), (yyvsp[(6) - (8)].name))); }\n    break;\n\n  case 155:\n#line 697 \"ldgram.y\"\n    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 156:\n#line 699 \"ldgram.y\"\n    { ldlex_popstate (); }\n    break;\n\n  case 161:\n#line 714 \"ldgram.y\"\n    { (yyval.integer) = (yyvsp[(1) - (1)].token); }\n    break;\n\n  case 162:\n#line 716 \"ldgram.y\"\n    { (yyval.integer) = (yyvsp[(1) - (1)].token); }\n    break;\n\n  case 163:\n#line 718 \"ldgram.y\"\n    { (yyval.integer) = (yyvsp[(1) - (1)].token); }\n    break;\n\n  case 164:\n#line 720 \"ldgram.y\"\n    { (yyval.integer) = (yyvsp[(1) - (1)].token); }\n    break;\n\n  case 165:\n#line 722 \"ldgram.y\"\n    { (yyval.integer) = (yyvsp[(1) - (1)].token); }\n    break;\n\n  case 166:\n#line 727 \"ldgram.y\"\n    {\n\t\t  (yyval.fill) = exp_get_fill ((yyvsp[(1) - (1)].etree), 0, \"fill value\");\n\t\t}\n    break;\n\n  case 167:\n#line 734 \"ldgram.y\"\n    { (yyval.fill) = (yyvsp[(2) - (2)].fill); }\n    break;\n\n  case 168:\n#line 735 \"ldgram.y\"\n    { (yyval.fill) = (fill_type *) 0; }\n    break;\n\n  case 169:\n#line 740 \"ldgram.y\"\n    { (yyval.token) = '+'; }\n    break;\n\n  case 170:\n#line 742 \"ldgram.y\"\n    { (yyval.token) = '-'; }\n    break;\n\n  case 171:\n#line 744 \"ldgram.y\"\n    { (yyval.token) = '*'; }\n    break;\n\n  case 172:\n#line 746 \"ldgram.y\"\n    { (yyval.token) = '/'; }\n    break;\n\n  case 173:\n#line 748 \"ldgram.y\"\n    { (yyval.token) = LSHIFT; }\n    break;\n\n  case 174:\n#line 750 \"ldgram.y\"\n    { (yyval.token) = RSHIFT; }\n    break;\n\n  case 175:\n#line 752 \"ldgram.y\"\n    { (yyval.token) = '&'; }\n    break;\n\n  case 176:\n#line 754 \"ldgram.y\"\n    { (yyval.token) = '|'; }\n    break;\n\n  case 179:\n#line 764 \"ldgram.y\"\n    {\n\t\t  lang_add_assignment (exp_assign ((yyvsp[(1) - (3)].name), (yyvsp[(3) - (3)].etree), FALSE));\n\t\t}\n    break;\n\n  case 180:\n#line 768 \"ldgram.y\"\n    {\n\t\t  lang_add_assignment (exp_assign ((yyvsp[(1) - (3)].name),\n\t\t\t\t\t\t   exp_binop ((yyvsp[(2) - (3)].token),\n\t\t\t\t\t\t\t      exp_nameop (NAME,\n\t\t\t\t\t\t\t\t\t  (yyvsp[(1) - (3)].name)),\n\t\t\t\t\t\t\t      (yyvsp[(3) - (3)].etree)), FALSE));\n\t\t}\n    break;\n\n  case 181:\n#line 776 \"ldgram.y\"\n    {\n\t\t  lang_add_assignment (exp_assign ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), TRUE));\n\t\t}\n    break;\n\n  case 182:\n#line 780 \"ldgram.y\"\n    {\n\t\t  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), FALSE));\n\t\t}\n    break;\n\n  case 183:\n#line 784 \"ldgram.y\"\n    {\n\t\t  lang_add_assignment (exp_provide ((yyvsp[(3) - (6)].name), (yyvsp[(5) - (6)].etree), TRUE));\n\t\t}\n    break;\n\n  case 191:\n#line 807 \"ldgram.y\"\n    { region = lang_memory_region_lookup ((yyvsp[(1) - (1)].name), TRUE); }\n    break;\n\n  case 192:\n#line 810 \"ldgram.y\"\n    {}\n    break;\n\n  case 193:\n#line 812 \"ldgram.y\"\n    { ldlex_script (); ldfile_open_command_file((yyvsp[(2) - (2)].name)); }\n    break;\n\n  case 194:\n#line 814 \"ldgram.y\"\n    { ldlex_popstate (); }\n    break;\n\n  case 195:\n#line 819 \"ldgram.y\"\n    {\n\t\t  region->origin = exp_get_vma ((yyvsp[(3) - (3)].etree), 0, \"origin\");\n\t\t  region->current = region->origin;\n\t\t}\n    break;\n\n  case 196:\n#line 827 \"ldgram.y\"\n    {\n\t\t  region->length = exp_get_vma ((yyvsp[(3) - (3)].etree), -1, \"length\");\n\t\t}\n    break;\n\n  case 197:\n#line 834 \"ldgram.y\"\n    { /* dummy action to avoid bison 1.25 error message */ }\n    break;\n\n  case 201:\n#line 845 \"ldgram.y\"\n    { lang_set_flags (region, (yyvsp[(1) - (1)].name), 0); }\n    break;\n\n  case 202:\n#line 847 \"ldgram.y\"\n    { lang_set_flags (region, (yyvsp[(2) - (2)].name), 1); }\n    break;\n\n  case 203:\n#line 852 \"ldgram.y\"\n    { lang_startup((yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 205:\n#line 858 \"ldgram.y\"\n    { ldemul_hll((char *)NULL); }\n    break;\n\n  case 206:\n#line 863 \"ldgram.y\"\n    { ldemul_hll((yyvsp[(3) - (3)].name)); }\n    break;\n\n  case 207:\n#line 865 \"ldgram.y\"\n    { ldemul_hll((yyvsp[(1) - (1)].name)); }\n    break;\n\n  case 209:\n#line 873 \"ldgram.y\"\n    { ldemul_syslib((yyvsp[(3) - (3)].name)); }\n    break;\n\n  case 211:\n#line 879 \"ldgram.y\"\n    { lang_float(TRUE); }\n    break;\n\n  case 212:\n#line 881 \"ldgram.y\"\n    { lang_float(FALSE); }\n    break;\n\n  case 213:\n#line 886 \"ldgram.y\"\n    {\n\t\t  (yyval.nocrossref) = NULL;\n\t\t}\n    break;\n\n  case 214:\n#line 890 \"ldgram.y\"\n    {\n\t\t  struct lang_nocrossref *n;\n\n\t\t  n = (struct lang_nocrossref *) xmalloc (sizeof *n);\n\t\t  n->name = (yyvsp[(1) - (2)].name);\n\t\t  n->next = (yyvsp[(2) - (2)].nocrossref);\n\t\t  (yyval.nocrossref) = n;\n\t\t}\n    break;\n\n  case 215:\n#line 899 \"ldgram.y\"\n    {\n\t\t  struct lang_nocrossref *n;\n\n\t\t  n = (struct lang_nocrossref *) xmalloc (sizeof *n);\n\t\t  n->name = (yyvsp[(1) - (3)].name);\n\t\t  n->next = (yyvsp[(3) - (3)].nocrossref);\n\t\t  (yyval.nocrossref) = n;\n\t\t}\n    break;\n\n  case 216:\n#line 909 \"ldgram.y\"\n    { ldlex_expression (); }\n    break;\n\n  case 217:\n#line 911 \"ldgram.y\"\n    { ldlex_popstate (); (yyval.etree)=(yyvsp[(2) - (2)].etree);}\n    break;\n\n  case 218:\n#line 916 \"ldgram.y\"\n    { (yyval.etree) = exp_unop ('-', (yyvsp[(2) - (2)].etree)); }\n    break;\n\n  case 219:\n#line 918 \"ldgram.y\"\n    { (yyval.etree) = (yyvsp[(2) - (3)].etree); }\n    break;\n\n  case 220:\n#line 920 \"ldgram.y\"\n    { (yyval.etree) = exp_unop ((int) (yyvsp[(1) - (4)].integer),(yyvsp[(3) - (4)].etree)); }\n    break;\n\n  case 221:\n#line 922 \"ldgram.y\"\n    { (yyval.etree) = exp_unop ('!', (yyvsp[(2) - (2)].etree)); }\n    break;\n\n  case 222:\n#line 924 \"ldgram.y\"\n    { (yyval.etree) = (yyvsp[(2) - (2)].etree); }\n    break;\n\n  case 223:\n#line 926 \"ldgram.y\"\n    { (yyval.etree) = exp_unop ('~', (yyvsp[(2) - (2)].etree));}\n    break;\n\n  case 224:\n#line 929 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('*', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 225:\n#line 931 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('/', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 226:\n#line 933 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('%', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 227:\n#line 935 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('+', (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 228:\n#line 937 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('-' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 229:\n#line 939 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (LSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 230:\n#line 941 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (RSHIFT , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 231:\n#line 943 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (EQ , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 232:\n#line 945 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (NE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 233:\n#line 947 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (LE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 234:\n#line 949 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (GE , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 235:\n#line 951 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('<' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 236:\n#line 953 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('>' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 237:\n#line 955 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('&' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 238:\n#line 957 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('^' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 239:\n#line 959 \"ldgram.y\"\n    { (yyval.etree) = exp_binop ('|' , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 240:\n#line 961 \"ldgram.y\"\n    { (yyval.etree) = exp_trinop ('?' , (yyvsp[(1) - (5)].etree), (yyvsp[(3) - (5)].etree), (yyvsp[(5) - (5)].etree)); }\n    break;\n\n  case 241:\n#line 963 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (ANDAND , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 242:\n#line 965 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (OROR , (yyvsp[(1) - (3)].etree), (yyvsp[(3) - (3)].etree)); }\n    break;\n\n  case 243:\n#line 967 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (DEFINED, (yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 244:\n#line 969 \"ldgram.y\"\n    { (yyval.etree) = exp_bigintop ((yyvsp[(1) - (1)].bigint).integer, (yyvsp[(1) - (1)].bigint).str); }\n    break;\n\n  case 245:\n#line 971 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (SIZEOF_HEADERS,0); }\n    break;\n\n  case 246:\n#line 974 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (ALIGNOF,(yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 247:\n#line 976 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (SIZEOF,(yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 248:\n#line 978 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (ADDR,(yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 249:\n#line 980 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (LOADADDR,(yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 250:\n#line 982 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (CONSTANT,(yyvsp[(3) - (4)].name)); }\n    break;\n\n  case 251:\n#line 984 \"ldgram.y\"\n    { (yyval.etree) = exp_unop (ABSOLUTE, (yyvsp[(3) - (4)].etree)); }\n    break;\n\n  case 252:\n#line 986 \"ldgram.y\"\n    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }\n    break;\n\n  case 253:\n#line 988 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (ALIGN_K,(yyvsp[(3) - (6)].etree),(yyvsp[(5) - (6)].etree)); }\n    break;\n\n  case 254:\n#line 990 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (DATA_SEGMENT_ALIGN, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etree)); }\n    break;\n\n  case 255:\n#line 992 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (DATA_SEGMENT_RELRO_END, (yyvsp[(5) - (6)].etree), (yyvsp[(3) - (6)].etree)); }\n    break;\n\n  case 256:\n#line 994 \"ldgram.y\"\n    { (yyval.etree) = exp_unop (DATA_SEGMENT_END, (yyvsp[(3) - (4)].etree)); }\n    break;\n\n  case 257:\n#line 996 \"ldgram.y\"\n    { /* The operands to the expression node are\n\t\t\t     placed in the opposite order from the way\n\t\t\t     in which they appear in the script as\n\t\t\t     that allows us to reuse more code in\n\t\t\t     fold_binary.  */\n\t\t\t  (yyval.etree) = exp_binop (SEGMENT_START,\n\t\t\t\t\t  (yyvsp[(5) - (6)].etree),\n\t\t\t\t\t  exp_nameop (NAME, (yyvsp[(3) - (6)].name))); }\n    break;\n\n  case 258:\n#line 1005 \"ldgram.y\"\n    { (yyval.etree) = exp_unop (ALIGN_K,(yyvsp[(3) - (4)].etree)); }\n    break;\n\n  case 259:\n#line 1007 \"ldgram.y\"\n    { (yyval.etree) = exp_nameop (NAME,(yyvsp[(1) - (1)].name)); }\n    break;\n\n  case 260:\n#line 1009 \"ldgram.y\"\n    { (yyval.etree) = exp_binop (MAX_K, (yyvsp[(3) - (6)].etree), (yyvsp[(5) - (6)].etre"
}