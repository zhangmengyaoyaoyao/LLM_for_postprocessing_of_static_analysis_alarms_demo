{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf.c",
    "message": "Offset added: [-20, 203] (⇐ [-100, 123] + 80) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "_bfd_elf_map_sections_to_segments",
    "warning_line": "m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);",
    "warning_context": "\t      BFD_ASSERT ((s->flags & SEC_THREAD_LOCAL) == 0);\n\t      *pm = m;\n\t      pm = &m->next;\n\t    }\n\t  if (s->flags & SEC_THREAD_LOCAL)\n\t    {\n\t      if (! tls_count)\n\t\tfirst_tls = s;\n\t      tls_count++;\n\t    }\n\t}\n\n      /* If there are any SHF_TLS output sections, add PT_TLS segment.  */\n      if (tls_count > 0)\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  amt += (tls_count - 1) * sizeof (asection *);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_TLS;\n\t  m->count = tls_count;\n\t  /* Mandated PF_R.  */\n\t  m->p_flags = PF_R;\n\t  m->p_flags_valid = 1;\n\t  s = first_tls;\n\t  for (i = 0; i < (unsigned int) tls_count; ++i)\n\t    {\n\t      if ((s->flags & SEC_THREAD_LOCAL) == 0)\n\t\t{\n\t\t  _bfd_error_handler\n\t\t    (_(\"%B: TLS sections are not adjacent:\"), abfd);\n\t\t  s = first_tls;\n\t\t  i = 0;\n\t\t  while (i < (unsigned int) tls_count)\n\t\t    {\n\t\t      if ((s->flags & SEC_THREAD_LOCAL) != 0)\n\t\t\t{\n\t\t\t  _bfd_error_handler (_(\"\t    TLS: %A\"), s);\n\t\t\t  i++;\n\t\t\t}\n\t\t      else\n\t\t\t_bfd_error_handler (_(\"\tnon-TLS: %A\"), s);\n\t\t      s = s->next;\n\t\t    }\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t  goto error_return;\n\t\t}\n\t      m->sections[i] = s;\n\t      s = s->next;\n\t    }\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME\n\t segment.  */\n      eh_frame_hdr = elf_eh_frame_hdr (abfd);\n      if (eh_frame_hdr != NULL\n\t  && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_GNU_EH_FRAME;\n\t  m->count = 1;\n\t  m->sections[0] = eh_frame_hdr->output_section;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      if (elf_stack_flags (abfd))\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_GNU_STACK;\n\t  m->p_flags = elf_stack_flags (abfd);\n\t  m->p_align = bed->stack_align;\n\t  m->p_flags_valid = 1;\n\t  m->p_align_valid = m->p_align != 0;\n\t  if (info->stacksize > 0)\n\t    {\n\t      m->p_size = info->stacksize;\n\t      m->p_size_valid = 1;\n\t    }\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      if (info != NULL && info->relro)\n\t{\n\t  for (m = mfirst; m != NULL; m = m->next)\n"
}