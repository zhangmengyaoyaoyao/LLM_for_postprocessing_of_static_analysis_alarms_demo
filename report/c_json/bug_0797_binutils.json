{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "      strcpy (newp, \"../\");",
    "Code_function": "adjust_relative_path (const char * path, const char * ref_path)\n{\n  static char *pathbuf = NULL;\n  static unsigned int pathbuf_len = 0;\n  const char *pathp;\n  const char *refp;\n  char * lpath;\n  char * rpath;\n  unsigned int len;\n  unsigned int dir_up = 0;\n  unsigned int dir_down = 0;\n  char *newp;\n  char * pwd = getpwd ();\n  const char * down;\n\n  /* Remove symlinks, '.' and '..' from the paths, if possible.  */\n  lpath = lrealpath (path);\n  pathp = lpath == NULL ? path : lpath;\n\n  rpath = lrealpath (ref_path);\n  refp = rpath == NULL ? ref_path : rpath;\n\n  /* Remove common leading path elements.  */\n  for (;;)\n    {\n      const char *e1 = pathp;\n      const char *e2 = refp;\n\n      while (*e1 && ! IS_DIR_SEPARATOR (*e1))\n\t++e1;\n      while (*e2 && ! IS_DIR_SEPARATOR (*e2))\n\t++e2;\n      if (*e1 == '\\0' || *e2 == '\\0' || e1 - pathp != e2 - refp\n\t  || filename_ncmp (pathp, refp, e1 - pathp) != 0)\n\tbreak;\n      pathp = e1 + 1;\n      refp = e2 + 1;\n    }\n\n  len = strlen (pathp) + 1;\n  /* For each leading path element in the reference path,\n     insert \"../\" into the path.  */\n  for (; *refp; ++refp)\n    if (IS_DIR_SEPARATOR (*refp))\n      {\n\t/* PR 12710:  If the path element is \"../\" then instead of\n\t   inserting \"../\" we need to insert the name of the directory\n\t   at the current level.  */\n\tif (refp > ref_path + 1\n\t    && refp[-1] == '.'\n\t    && refp[-2] == '.')\n\t  dir_down ++;\n\telse\n\t  dir_up ++;\n      }\n\n  /* If the lrealpath calls above succeeded then we should never\n     see dir_up and dir_down both being non-zero.  */\n\n  len += 3 * dir_up;\n\n  if (dir_down)\n    {\n      down = pwd + strlen (pwd) - 1;\n\n      while (dir_down && down > pwd)\n\t{\n\t  if (IS_DIR_SEPARATOR (*down))\n\t    --dir_down;\n\t}\n      BFD_ASSERT (dir_down == 0);\n      len += strlen (down) + 1;\n    }\n  else\n    down = NULL;\n\n  if (len > pathbuf_len)\n    {\n      if (pathbuf != NULL)\n\tfree (pathbuf);\n      pathbuf_len = 0;\n      pathbuf = (char *) bfd_malloc (len);\n      if (pathbuf == NULL)\n\tgoto out;\n      pathbuf_len = len;\n    }\n\n  newp = pathbuf;\n  while (dir_up-- > 0)\n    {\n      /* FIXME: Support Windows style path separators as well.  */\n      strcpy (newp, \"../\");\n      newp += 3;\n    }\n\n  if (down)\n    sprintf (newp, \"%s/%s\", down, pathp);\n  else\n    strcpy (newp, pathp);\n\n out:\n  free (lpath);\n  free (rpath);\n  return pathbuf;\n}"
}