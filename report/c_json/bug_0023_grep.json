{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)",
    "Code_function": "GEAcompile (char const *pattern, size_t size, reg_syntax_t syntax_bits)\n{\n  size_t total = size;\n  char *motif;\n\n  if (match_icase)\n    syntax_bits |= RE_ICASE;\n  re_set_syntax (syntax_bits);\n  dfasyntax (syntax_bits, match_icase, eolbyte);\n\n  /* For GNU regex, pass the patterns separately to detect errors like\n     \"[\\nallo\\n]\\n\", where the patterns are \"[\", \"allo\" and \"]\", and\n     this should be a syntax error.  The same for backref, where the\n     backref should be local to each pattern.  */\n  char const *p = pattern;\n  do\n    {\n      size_t len;\n      char const *sep = memchr (p, '\\n', total);\n      if (sep)\n        {\n          len = sep - p;\n          sep++;\n          total -= (len + 1);\n        }\n      else\n        {\n          len = total;\n          total = 0;\n        }\n\n      patterns = xnrealloc (patterns, pcount + 1, sizeof *patterns);\n      patterns[pcount] = patterns0;\n\n      char const *err = re_compile_pattern (p, len,\n                                            &(patterns[pcount].regexbuf));\n      if (err)\n        error (EXIT_TROUBLE, 0, \"%s\", err);\n      pcount++;\n      p = sep;\n    }\n  while (p);\n\n  /* In the match_words and match_lines cases, we use a different pattern\n     for the DFA matcher that will quickly throw out cases that won't work.\n     Then if DFA succeeds we do some hairy stuff using the regex matcher\n     to decide whether the match should really count. */\n  if (match_words || match_lines)\n    {\n      static char const line_beg_no_bk[] = \"^(\";\n      static char const line_end_no_bk[] = \")$\";\n      static char const word_beg_no_bk[] = \"(^|[^[:alnum:]_])(\";\n      static char const word_end_no_bk[] = \")([^[:alnum:]_]|$)\";\n      static char const line_beg_bk[] = \"^\\\\(\";\n      static char const line_end_bk[] = \"\\\\)$\";\n      static char const word_beg_bk[] = \"\\\\(^\\\\|[^[:alnum:]_]\\\\)\\\\(\";\n      static char const word_end_bk[] = \"\\\\)\\\\([^[:alnum:]_]\\\\|$\\\\)\";\n      int bk = !(syntax_bits & RE_NO_BK_PARENS);\n      char *n = xmalloc (sizeof word_beg_bk - 1 + size + sizeof word_end_bk);\n\n      strcpy (n, match_lines ? (bk ? line_beg_bk : line_beg_no_bk)\n                             : (bk ? word_beg_bk : word_beg_no_bk));\n      total = strlen(n);\n      memcpy (n + total, pattern, size);\n      total += size;\n      strcpy (n + total, match_lines ? (bk ? line_end_bk : line_end_no_bk)\n                                     : (bk ? word_end_bk : word_end_no_bk));\n      total += strlen (n + total);\n      pattern = motif = n;\n      size = total;\n    }\n  else\n    motif = NULL;\n\n  dfa = dfaalloc ();\n  dfacomp (pattern, size, dfa, 1);\n  kwsmusts ();\n\n  free(motif);\n}"
}