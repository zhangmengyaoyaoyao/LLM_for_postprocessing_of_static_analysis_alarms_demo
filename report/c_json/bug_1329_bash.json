{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: -1 Size: 1 by call to `bash_add_history`.",
    "Code_line": "      bash_add_history (\"\");",
    "Code_function": "edit_and_execute_command (count, c, editing_mode, edit_command)\n     int count, c, editing_mode;\n     char *edit_command;\n{\n  char *command, *metaval;\n  int r, rrs, metaflag;\n  sh_parser_state_t ps;\n\n  rrs = rl_readline_state;\n  saved_command_line_count = current_command_line_count;\n\n  /* Accept the current line. */\n  rl_newline (1, c);\n\n  if (rl_explicit_arg)\n    {\n      command = (char *)xmalloc (strlen (edit_command) + 8);\n      sprintf (command, \"%s %d\", edit_command, count);\n    }\n  else\n    {\n      /* Take the command we were just editing, add it to the history file,\n\t then call fc to operate on it.  We have to add a dummy command to\n\t the end of the history because fc ignores the last command (assumes\n\t it's supposed to deal with the command before the `fc'). */\n      /* This breaks down when using command-oriented history and are not\n\t finished with the command, so we should not ignore the last command */\n      using_history ();\n      current_command_line_count++;\t/* for rl_newline above */\n      bash_add_history (rl_line_buffer);\n      current_command_line_count = 0;\t/* for dummy history entry */\n      bash_add_history (\"\");\n      history_lines_this_session++;\n      using_history ();\n      command = savestring (edit_command);\n    }\n\n  metaval = rl_variable_value (\"input-meta\");\n  metaflag = RL_BOOLEAN_VARIABLE_VALUE (metaval);\n\n  /* Now, POSIX.1-2001 and SUSv3 say that the commands executed from the\n     temporary file should be placed into the history.  We don't do that\n     yet. */\n  if (rl_deprep_term_function)\n    (*rl_deprep_term_function) ();\n  save_parser_state (&ps);\n  r = parse_and_execute (command, (editing_mode == VI_EDITING_MODE) ? \"v\" : \"C-xC-e\", SEVAL_NOHIST);\n  restore_parser_state (&ps);\n  if (rl_prep_term_function)\n    (*rl_prep_term_function) (metaflag);\n\n  current_command_line_count = saved_command_line_count;\n\n  /* Now erase the contents of the current line and undo the effects of the\n     rl_accept_line() above.  We don't even want to make the text we just\n     executed available for undoing. */\n  rl_line_buffer[0] = '\\0';\t/* XXX */\n  rl_point = rl_end = 0;\n  rl_done = 0;\n  rl_readline_state = rrs;\n\n  rl_forced_update_display ();\n\n  return r;\n}"
}