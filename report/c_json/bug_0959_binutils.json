{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\tindx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,",
    "Code_function": "bfd_elf_size_dynamic_sections (bfd *output_bfd,\n\t\t\t       const char *soname,\n\t\t\t       const char *rpath,\n\t\t\t       const char *filter_shlib,\n\t\t\t       const char *audit,\n\t\t\t       const char *depaudit,\n\t\t\t       const char * const *auxiliary_filters,\n\t\t\t       struct bfd_link_info *info,\n\t\t\t       asection **sinterpptr)\n{\n  bfd_size_type soname_indx;\n  bfd *dynobj;\n  const struct elf_backend_data *bed;\n  struct elf_info_failed asvinfo;\n\n  *sinterpptr = NULL;\n\n  soname_indx = (bfd_size_type) -1;\n\n  if (!is_elf_hash_table (info->hash))\n    return TRUE;\n\n  bed = get_elf_backend_data (output_bfd);\n\n  /* Any syms created from now on start with -1 in\n     got.refcount/offset and plt.refcount/offset.  */\n  elf_hash_table (info)->init_got_refcount\n    = elf_hash_table (info)->init_got_offset;\n  elf_hash_table (info)->init_plt_refcount\n    = elf_hash_table (info)->init_plt_offset;\n\n  if (info->relocatable\n      && !_bfd_elf_size_group_sections (info))\n    return FALSE;\n\n  /* The backend may have to create some sections regardless of whether\n     we're dynamic or not.  */\n  if (bed->elf_backend_always_size_sections\n      && ! (*bed->elf_backend_always_size_sections) (output_bfd, info))\n    return FALSE;\n\n  /* Determine any GNU_STACK segment requirements, after the backend\n     has had a chance to set a default segment size.  */\n  if (info->execstack)\n    elf_stack_flags (output_bfd) = PF_R | PF_W | PF_X;\n  else if (info->noexecstack)\n    elf_stack_flags (output_bfd) = PF_R | PF_W;\n  else\n    {\n      bfd *inputobj;\n      asection *notesec = NULL;\n      int exec = 0;\n\n      for (inputobj = info->input_bfds;\n\t   inputobj;\n\t   inputobj = inputobj->link.next)\n\t{\n\t  asection *s;\n\n\t  if (inputobj->flags\n\t      & (DYNAMIC | EXEC_P | BFD_PLUGIN | BFD_LINKER_CREATED))\n\t    continue;\n\t  s = bfd_get_section_by_name (inputobj, \".note.GNU-stack\");\n\t  if (s)\n\t    {\n\t      if (s->flags & SEC_CODE)\n\t\texec = PF_X;\n\t      notesec = s;\n\t    }\n\t  else if (bed->default_execstack)\n\t    exec = PF_X;\n\t}\n      if (notesec || info->stacksize > 0)\n\telf_stack_flags (output_bfd) = PF_R | PF_W | exec;\n      if (notesec && exec && info->relocatable\n\t  && notesec->output_section != bfd_abs_section_ptr)\n\tnotesec->output_section->flags |= SEC_CODE;\n    }\n\n  dynobj = elf_hash_table (info)->dynobj;\n\n  if (dynobj != NULL && elf_hash_table (info)->dynamic_sections_created)\n    {\n      struct elf_info_failed eif;\n      struct elf_link_hash_entry *h;\n      asection *dynstr;\n      struct bfd_elf_version_tree *t;\n      struct bfd_elf_version_expr *d;\n      asection *s;\n      bfd_boolean all_defined;\n\n      *sinterpptr = bfd_get_linker_section (dynobj, \".interp\");\n      BFD_ASSERT (*sinterpptr != NULL || !info->executable);\n\n      if (soname != NULL)\n\t{\n\t  soname_indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,\n\t\t\t\t\t     soname, TRUE);\n\t  if (soname_indx == (bfd_size_type) -1\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_SONAME, soname_indx))\n\t    return FALSE;\n\t}\n\n      if (info->symbolic)\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_SYMBOLIC, 0))\n\t    return FALSE;\n\t  info->flags |= DF_SYMBOLIC;\n\t}\n\n      if (rpath != NULL)\n\t{\n\t  bfd_size_type indx;\n\t  bfd_vma tag;\n\n\t  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, rpath,\n\t\t\t\t      TRUE);\n\t  if (indx == (bfd_size_type) -1)\n\t    return FALSE;\n\n\t  tag = info->new_dtags ? DT_RUNPATH : DT_RPATH;\n\t  if (!_bfd_elf_add_dynamic_entry (info, tag, indx))\n\t    return FALSE;\n\t}\n\n      if (filter_shlib != NULL)\n\t{\n\t  bfd_size_type indx;\n\n\t  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,\n\t\t\t\t      filter_shlib, TRUE);\n\t  if (indx == (bfd_size_type) -1\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_FILTER, indx))\n\t    return FALSE;\n\t}\n\n      if (auxiliary_filters != NULL)\n\t{\n\t  const char * const *p;\n\n\t  for (p = auxiliary_filters; *p != NULL; p++)\n\t    {\n\t      bfd_size_type indx;\n\n\t      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,\n\t\t\t\t\t  *p, TRUE);\n\t      if (indx == (bfd_size_type) -1\n\t\t  || !_bfd_elf_add_dynamic_entry (info, DT_AUXILIARY, indx))\n\t\treturn FALSE;\n\t    }\n\t}\n\n      if (audit != NULL)\n\t{\n\t  bfd_size_type indx;\n\n\t  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, audit,\n\t\t\t\t      TRUE);\n\t  if (indx == (bfd_size_type) -1\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_AUDIT, indx))\n\t    return FALSE;\n\t}\n\n      if (depaudit != NULL)\n\t{\n\t  bfd_size_type indx;\n\n\t  indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr, depaudit,\n\t\t\t\t      TRUE);\n\t  if (indx == (bfd_size_type) -1\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_DEPAUDIT, indx))\n\t    return FALSE;\n\t}\n\n      eif.info = info;\n      eif.failed = FALSE;\n\n      /* If we are supposed to export all symbols into the dynamic symbol\n\t table (this is not the normal case), then do so.  */\n      if (info->export_dynamic\n\t  || (info->executable && info->dynamic))\n\t{\n\t  elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t  _bfd_elf_export_symbol,\n\t\t\t\t  &eif);\n\t  if (eif.failed)\n\t    return FALSE;\n\t}\n\n      /* Make all global versions with definition.  */\n      for (t = info->version_info; t != NULL; t = t->next)\n\tfor (d = t->globals.list; d != NULL; d = d->next)\n\t  if (!d->symver && d->literal)\n\t    {\n\t      const char *verstr, *name;\n\t      size_t namelen, verlen, newlen;\n\t      char *newname, *p, leading_char;\n\t      struct elf_link_hash_entry *newh;\n\n\t      leading_char = bfd_get_symbol_leading_char (output_bfd);\n\t      name = d->pattern;\n\t      namelen = strlen (name) + (leading_char != '\\0');\n\t      verstr = t->name;\n\t      verlen = strlen (verstr);\n\t      newlen = namelen + verlen + 3;\n\n\t      newname = (char *) bfd_malloc (newlen);\n\t      if (newname == NULL)\n\t\treturn FALSE;\n\t      newname[0] = leading_char;\n\t      memcpy (newname + (leading_char != '\\0'), name, namelen);\n\n\t      /* Check the hidden versioned definition.  */\n\t      p = newname + namelen;\n\t      *p++ = ELF_VER_CHR;\n\t      memcpy (p, verstr, verlen + 1);\n\t      newh = elf_link_hash_lookup (elf_hash_table (info),\n\t\t\t\t\t   newname, FALSE, FALSE,\n\t\t\t\t\t   FALSE);\n\t      if (newh == NULL\n\t\t  || (newh->root.type != bfd_link_hash_defined\n\t\t      && newh->root.type != bfd_link_hash_defweak))\n\t\t{\n\t\t  /* Check the default versioned definition.  */\n\t\t  *p++ = ELF_VER_CHR;\n\t\t  memcpy (p, verstr, verlen + 1);\n\t\t  newh = elf_link_hash_lookup (elf_hash_table (info),\n\t\t\t\t\t       newname, FALSE, FALSE,\n\t\t\t\t\t       FALSE);\n\t\t}\n\t      free (newname);\n\n\t      /* Mark this version if there is a definition and it is\n\t\t not defined in a shared object.  */\n\t      if (newh != NULL\n\t\t  && !newh->def_dynamic\n\t\t  && (newh->root.type == bfd_link_hash_defined\n\t\t      || newh->root.type == bfd_link_hash_defweak))\n\t\td->symver = 1;\n\t    }\n\n      /* Attach all the symbols to their version information.  */\n      asvinfo.info = info;\n      asvinfo.failed = FALSE;\n\n      elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t      _bfd_elf_link_assign_sym_version,\n\t\t\t      &asvinfo);\n      if (asvinfo.failed)\n\treturn FALSE;\n\n      if (!info->allow_undefined_version)\n\t{\n\t  /* Check if all global versions have a definition.  */\n\t  all_defined = TRUE;\n\t  for (t = info->version_info; t != NULL; t = t->next)\n\t    for (d = t->globals.list; d != NULL; d = d->next)\n\t      if (d->literal && !d->symver && !d->script)\n\t\t{\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"%s: undefined version: %s\"),\n\t\t     d->pattern, t->name);\n\t\t  all_defined = FALSE;\n\t\t}\n\n\t  if (!all_defined)\n\t    {\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\t    }\n\t}\n\n      /* Find all symbols which were defined in a dynamic object and make\n\t the backend pick a reasonable value for them.  */\n      elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t      _bfd_elf_adjust_dynamic_symbol,\n\t\t\t      &eif);\n      if (eif.failed)\n\treturn FALSE;\n\n      /* Add some entries to the .dynamic section.  We fill in some of the\n\t values later, in bfd_elf_final_link, but we must add the entries\n\t now so that we know the final size of the .dynamic section.  */\n\n      /* If there are initialization and/or finalization functions to\n\t call then add the corresponding DT_INIT/DT_FINI entries.  */\n      h = (info->init_function\n\t   ? elf_link_hash_lookup (elf_hash_table (info),\n\t\t\t\t   info->init_function, FALSE,\n\t\t\t\t   FALSE, FALSE)\n\t   : NULL);\n      if (h != NULL\n\t  && (h->ref_regular\n\t      || h->def_regular))\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT, 0))\n\t    return FALSE;\n\t}\n      h = (info->fini_function\n\t   ? elf_link_hash_lookup (elf_hash_table (info),\n\t\t\t\t   info->fini_function, FALSE,\n\t\t\t\t   FALSE, FALSE)\n\t   : NULL);\n      if (h != NULL\n\t  && (h->ref_regular\n\t      || h->def_regular))\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI, 0))\n\t    return FALSE;\n\t}\n\n      s = bfd_get_section_by_name (output_bfd, \".preinit_array\");\n      if (s != NULL && s->linker_has_input)\n\t{\n\t  /* DT_PREINIT_ARRAY is not allowed in shared library.  */\n\t  if (! info->executable)\n\t    {\n\t      bfd *sub;\n\t      asection *o;\n\n\t      for (sub = info->input_bfds; sub != NULL;\n\t\t   sub = sub->link.next)\n\t\tif (bfd_get_flavour (sub) == bfd_target_elf_flavour)\n\t\t  for (o = sub->sections; o != NULL; o = o->next)\n\t\t    if (elf_section_data (o)->this_hdr.sh_type\n\t\t\t== SHT_PREINIT_ARRAY)\n\t\t      {\n\t\t\t(*_bfd_error_handler)\n\t\t\t  (_(\"%B: .preinit_array section is not allowed in DSO\"),\n\t\t\t   sub);\n\t\t\tbreak;\n\t\t      }\n\n\t      bfd_set_error (bfd_error_nonrepresentable_section);\n\t      return FALSE;\n\t    }\n\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAY, 0)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_PREINIT_ARRAYSZ, 0))\n\t    return FALSE;\n\t}\n      s = bfd_get_section_by_name (output_bfd, \".init_array\");\n      if (s != NULL && s->linker_has_input)\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAY, 0)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_INIT_ARRAYSZ, 0))\n\t    return FALSE;\n\t}\n      s = bfd_get_section_by_name (output_bfd, \".fini_array\");\n      if (s != NULL && s->linker_has_input)\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAY, 0)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_FINI_ARRAYSZ, 0))\n\t    return FALSE;\n\t}\n\n      dynstr = bfd_get_linker_section (dynobj, \".dynstr\");\n      /* If .dynstr is excluded from the link, we don't want any of\n\t these tags.  Strictly, we should be checking each section\n\t individually;  This quick check covers for the case where\n\t someone does a /DISCARD/ : { *(*) }.  */\n      if (dynstr != NULL && dynstr->output_section != bfd_abs_section_ptr)\n\t{\n\t  bfd_size_type strsize;\n\n\t  strsize = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);\n\t  if ((info->emit_hash\n\t       && !_bfd_elf_add_dynamic_entry (info, DT_HASH, 0))\n\t      || (info->emit_gnu_hash\n\t\t  && !_bfd_elf_add_dynamic_entry (info, DT_GNU_HASH, 0))\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_STRTAB, 0)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_SYMTAB, 0)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_STRSZ, strsize)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_SYMENT,\n\t\t\t\t\t      bed->s->sizeof_sym))\n\t    return FALSE;\n\t}\n    }\n\n  /* The backend must work out the sizes of all the other dynamic\n     sections.  */\n  if (dynobj != NULL\n      && bed->elf_backend_size_dynamic_sections != NULL\n      && ! (*bed->elf_backend_size_dynamic_sections) (output_bfd, info))\n    return FALSE;\n\n  if (! _bfd_elf_maybe_strip_eh_frame_hdr (info))\n    return FALSE;\n\n  if (dynobj != NULL && elf_hash_table (info)->dynamic_sections_created)\n    {\n      unsigned long section_sym_count;\n      struct bfd_elf_version_tree *verdefs;\n      asection *s;\n\n      /* Set up the version definition section.  */\n      s = bfd_get_linker_section (dynobj, \".gnu.version_d\");\n      BFD_ASSERT (s != NULL);\n\n      /* We may have created additional version definitions if we are\n\t just linking a regular application.  */\n      verdefs = info->version_info;\n\n      /* Skip anonymous version tag.  */\n      if (verdefs != NULL && verdefs->vernum == 0)\n\tverdefs = verdefs->next;\n\n      if (verdefs == NULL && !info->create_default_symver)\n\ts->flags |= SEC_EXCLUDE;\n      else\n\t{\n\t  unsigned int cdefs;\n\t  bfd_size_type size;\n\t  struct bfd_elf_version_tree *t;\n\t  bfd_byte *p;\n\t  Elf_Internal_Verdef def;\n\t  Elf_Internal_Verdaux defaux;\n\t  struct bfd_link_hash_entry *bh;\n\t  struct elf_link_hash_entry *h;\n\t  const char *name;\n\n\t  cdefs = 0;\n\t  size = 0;\n\n\t  /* Make space for the base version.  */\n\t  size += sizeof (Elf_External_Verdef);\n\t  size += sizeof (Elf_External_Verdaux);\n\t  ++cdefs;\n\n\t  /* Make space for the default version.  */\n\t  if (info->create_default_symver)\n\t    {\n\t      size += sizeof (Elf_External_Verdef);\n\t      ++cdefs;\n\t    }\n\n\t  for (t = verdefs; t != NULL; t = t->next)\n\t    {\n\t      struct bfd_elf_version_deps *n;\n\n\t      /* Don't emit base version twice.  */\n\t      if (t->vernum == 0)\n\t\tcontinue;\n\n\t      size += sizeof (Elf_External_Verdef);\n\t      size += sizeof (Elf_External_Verdaux);\n\t      ++cdefs;\n\n\t      for (n = t->deps; n != NULL; n = n->next)\n\t\tsize += sizeof (Elf_External_Verdaux);\n\t    }\n\n\t  s->size = size;\n\t  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);\n\t  if (s->contents == NULL && s->size != 0)\n\t    return FALSE;\n\n\t  /* Fill in the version definition section.  */\n\n\t  p = s->contents;\n\n\t  def.vd_version = VER_DEF_CURRENT;\n\t  def.vd_flags = VER_FLG_BASE;\n\t  def.vd_ndx = 1;\n\t  def.vd_cnt = 1;\n\t  if (info->create_default_symver)\n\t    {\n\t      def.vd_aux = 2 * sizeof (Elf_External_Verdef);\n\t      def.vd_next = sizeof (Elf_External_Verdef);\n\t    }\n\t  else\n\t    {\n\t      def.vd_aux = sizeof (Elf_External_Verdef);\n\t      def.vd_next = (sizeof (Elf_External_Verdef)\n\t\t\t     + sizeof (Elf_External_Verdaux));\n\t    }\n\n\t  if (soname_indx != (bfd_size_type) -1)\n\t    {\n\t      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,\n\t\t\t\t      soname_indx);\n\t      def.vd_hash = bfd_elf_hash (soname);\n\t      defaux.vda_name = soname_indx;\n\t      name = soname;\n\t    }\n\t  else\n\t    {\n\t      bfd_size_type indx;\n\n\t      name = lbasename (output_bfd->filename);\n\t      def.vd_hash = bfd_elf_hash (name);\n\t      indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,\n\t\t\t\t\t  name, FALSE);\n\t      if (indx == (bfd_size_type) -1)\n\t\treturn FALSE;\n\t      defaux.vda_name = indx;\n\t    }\n\t  defaux.vda_next = 0;\n\n\t  _bfd_elf_swap_verdef_out (output_bfd, &def,\n\t\t\t\t    (Elf_External_Verdef *) p);\n\t  p += sizeof (Elf_External_Verdef);\n\t  if (info->create_default_symver)\n\t    {\n\t      /* Add a symbol representing this version.  */\n\t      bh = NULL;\n\t      if (! (_bfd_generic_link_add_one_symbol\n\t\t     (info, dynobj, name, BSF_GLOBAL, bfd_abs_section_ptr,\n\t\t      0, NULL, FALSE,\n\t\t      get_elf_backend_data (dynobj)->collect, &bh)))\n\t\treturn FALSE;\n\t      h = (struct elf_link_hash_entry *) bh;\n\t      h->non_elf = 0;\n\t      h->def_regular = 1;\n\t      h->type = STT_OBJECT;\n\t      h->verinfo.vertree = NULL;\n\n\t      if (! bfd_elf_link_record_dynamic_symbol (info, h))\n\t\treturn FALSE;\n\n\t      /* Create a duplicate of the base version with the same\n\t\t aux block, but different flags.  */\n\t      def.vd_flags = 0;\n\t      def.vd_ndx = 2;\n\t      def.vd_aux = sizeof (Elf_External_Verdef);\n\t      if (verdefs)\n\t\tdef.vd_next = (sizeof (Elf_External_Verdef)\n\t\t\t       + sizeof (Elf_External_Verdaux));\n\t      else\n\t\tdef.vd_next = 0;\n\t      _bfd_elf_swap_verdef_out (output_bfd, &def,\n\t\t\t\t\t(Elf_External_Verdef *) p);\n\t      p += sizeof (Elf_External_Verdef);\n\t    }\n\t  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,\n\t\t\t\t     (Elf_External_Verdaux *) p);\n\t  p += sizeof (Elf_External_Verdaux);\n\n\t  for (t = verdefs; t != NULL; t = t->next)\n\t    {\n\t      unsigned int cdeps;\n\t      struct bfd_elf_version_deps *n;\n\n\t      /* Don't emit the base version twice.  */\n\t      if (t->vernum == 0)\n\t\tcontinue;\n\n\t      cdeps = 0;\n\t      for (n = t->deps; n != NULL; n = n->next)\n\t\t++cdeps;\n\n\t      /* Add a symbol representing this version.  */\n\t      bh = NULL;\n\t      if (! (_bfd_generic_link_add_one_symbol\n\t\t     (info, dynobj, t->name, BSF_GLOBAL, bfd_abs_section_ptr,\n\t\t      0, NULL, FALSE,\n\t\t      get_elf_backend_data (dynobj)->collect, &bh)))\n\t\treturn FALSE;\n\t      h = (struct elf_link_hash_entry *) bh;\n\t      h->non_elf = 0;\n\t      h->def_regular = 1;\n\t      h->type = STT_OBJECT;\n\t      h->verinfo.vertree = t;\n\n\t      if (! bfd_elf_link_record_dynamic_symbol (info, h))\n\t\treturn FALSE;\n\n\t      def.vd_version = VER_DEF_CURRENT;\n\t      def.vd_flags = 0;\n\t      if (t->globals.list == NULL\n\t\t  && t->locals.list == NULL\n\t\t  && ! t->used)\n\t\tdef.vd_flags |= VER_FLG_WEAK;\n\t      def.vd_ndx = t->vernum + (info->create_default_symver ? 2 : 1);\n\t      def.vd_cnt = cdeps + 1;\n\t      def.vd_hash = bfd_elf_hash (t->name);\n\t      def.vd_aux = sizeof (Elf_External_Verdef);\n\t      def.vd_next = 0;\n\n\t      /* If a basever node is next, it *must* be the last node in\n\t\t the chain, otherwise Verdef construction breaks.  */\n\t      if (t->next != NULL && t->next->vernum == 0)\n\t\tBFD_ASSERT (t->next->next == NULL);\n\n\t      if (t->next != NULL && t->next->vernum != 0)\n\t\tdef.vd_next = (sizeof (Elf_External_Verdef)\n\t\t\t       + (cdeps + 1) * sizeof (Elf_External_Verdaux));\n\n\t      _bfd_elf_swap_verdef_out (output_bfd, &def,\n\t\t\t\t\t(Elf_External_Verdef *) p);\n\t      p += sizeof (Elf_External_Verdef);\n\n\t      defaux.vda_name = h->dynstr_index;\n\t      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,\n\t\t\t\t      h->dynstr_index);\n\t      defaux.vda_next = 0;\n\t      if (t->deps != NULL)\n\t\tdefaux.vda_next = sizeof (Elf_External_Verdaux);\n\t      t->name_indx = defaux.vda_name;\n\n\t      _bfd_elf_swap_verdaux_out (output_bfd, &defaux,\n\t\t\t\t\t (Elf_External_Verdaux *) p);\n\t      p += sizeof (Elf_External_Verdaux);\n\n\t      for (n = t->deps; n != NULL; n = n->next)\n\t\t{\n\t\t  if (n->version_needed == NULL)\n\t\t    {\n\t\t      /* This can happen if there was an error in the\n\t\t\t version script.  */\n\t\t      defaux.vda_name = 0;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      defaux.vda_name = n->version_needed->name_indx;\n\t\t      _bfd_elf_strtab_addref (elf_hash_table (info)->dynstr,\n\t\t\t\t\t      defaux.vda_name);\n\t\t    }\n\t\t  if (n->next == NULL)\n\t\t    defaux.vda_next = 0;\n\t\t  else\n\t\t    defaux.vda_next = sizeof (Elf_External_Verdaux);\n\n\t\t  _bfd_elf_swap_verdaux_out (output_bfd, &defaux,\n\t\t\t\t\t     (Elf_External_Verdaux *) p);\n\t\t  p += sizeof (Elf_External_Verdaux);\n\t\t}\n\t    }\n\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_VERDEF, 0)\n\t      || !_bfd_elf_add_dynamic_entry (info, DT_VERDEFNUM, cdefs))\n\t    return FALSE;\n\n\t  elf_tdata (output_bfd)->cverdefs = cdefs;\n\t}\n\n      if ((info->new_dtags && info->flags) || (info->flags & DF_STATIC_TLS))\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS, info->flags))\n\t    return FALSE;\n\t}\n      else if (info->flags & DF_BIND_NOW)\n\t{\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_BIND_NOW, 0))\n\t    return FALSE;\n\t}\n\n      if (info->flags_1)\n\t{\n\t  if (info->executable)\n\t    info->flags_1 &= ~ (DF_1_INITFIRST\n\t\t\t\t| DF_1_NODELETE\n\t\t\t\t| DF_1_NOOPEN);\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_FLAGS_1, info->flags_1))\n\t    return FALSE;\n\t}\n\n      /* Work out the size of the version reference section.  */\n\n      s = bfd_get_linker_section (dynobj, \".gnu.version_r\");\n      BFD_ASSERT (s != NULL);\n      {\n\tstruct elf_find_verdep_info sinfo;\n\n\tsinfo.info = info;\n\tsinfo.vers = elf_tdata (output_bfd)->cverdefs;\n\tif (sinfo.vers == 0)\n\t  sinfo.vers = 1;\n\tsinfo.failed = FALSE;\n\n\telf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t_bfd_elf_link_find_version_dependencies,\n\t\t\t\t&sinfo);\n\tif (sinfo.failed)\n\t  return FALSE;\n\n\tif (elf_tdata (output_bfd)->verref == NULL)\n\t  s->flags |= SEC_EXCLUDE;\n\telse\n\t  {\n\t    Elf_Internal_Verneed *t;\n\t    unsigned int size;\n\t    unsigned int crefs;\n\t    bfd_byte *p;\n\n\t    /* Build the version dependency section.  */\n\t    size = 0;\n\t    crefs = 0;\n\t    for (t = elf_tdata (output_bfd)->verref;\n\t\t t != NULL;\n\t\t t = t->vn_nextref)\n\t      {\n\t\tElf_Internal_Vernaux *a;\n\n\t\tsize += sizeof (Elf_External_Verneed);\n\t\t++crefs;\n\t\tfor (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)\n\t\t  size += sizeof (Elf_External_Vernaux);\n\t      }\n\n\t    s->size = size;\n\t    s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);\n\t    if (s->contents == NULL)\n\t      return FALSE;\n\n\t    p = s->contents;\n\t    for (t = elf_tdata (output_bfd)->verref;\n\t\t t != NULL;\n\t\t t = t->vn_nextref)\n\t      {\n\t\tunsigned int caux;\n\t\tElf_Internal_Vernaux *a;\n\t\tbfd_size_type indx;\n\n\t\tcaux = 0;\n\t\tfor (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)\n\t\t  ++caux;\n\n\t\tt->vn_version = VER_NEED_CURRENT;\n\t\tt->vn_cnt = caux;\n\t\tindx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,\n\t\t\t\t\t    elf_dt_name (t->vn_bfd) != NULL\n\t\t\t\t\t    ? elf_dt_name (t->vn_bfd)\n\t\t\t\t\t    : lbasename (t->vn_bfd->filename),\n\t\t\t\t\t    FALSE);\n\t\tif (indx == (bfd_size_type) -1)\n\t\t  return FALSE;\n\t\tt->vn_file = indx;\n\t\tt->vn_aux = sizeof (Elf_External_Verneed);\n\t\tif (t->vn_nextref == NULL)\n\t\t  t->vn_next = 0;\n\t\telse\n\t\t  t->vn_next = (sizeof (Elf_External_Verneed)\n\t\t\t\t+ caux * sizeof (Elf_External_Vernaux));\n\n\t\t_bfd_elf_swap_verneed_out (output_bfd, t,\n\t\t\t\t\t   (Elf_External_Verneed *) p);\n\t\tp += sizeof (Elf_External_Verneed);\n\n\t\tfor (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)\n\t\t  {\n\t\t    a->vna_hash = bfd_elf_hash (a->vna_nodename);\n\t\t    indx = _bfd_elf_strtab_add (elf_hash_table (info)->dynstr,\n\t\t\t\t\t\ta->vna_nodename, FALSE);\n\t\t    if (indx == (bfd_size_type) -1)\n\t\t      return FALSE;\n\t\t    a->vna_name = indx;\n\t\t    if (a->vna_nextptr == NULL)\n\t\t      a->vna_next = 0;\n\t\t    else\n\t\t      a->vna_next = sizeof (Elf_External_Vernaux);\n\n\t\t    _bfd_elf_swap_vernaux_out (output_bfd, a,\n\t\t\t\t\t       (Elf_External_Vernaux *) p);\n\t\t    p += sizeof (Elf_External_Vernaux);\n\t\t  }\n\t      }\n\n\t    if (!_bfd_elf_add_dynamic_entry (info, DT_VERNEED, 0)\n\t\t|| !_bfd_elf_add_dynamic_entry (info, DT_VERNEEDNUM, crefs))\n\t      return FALSE;\n\n\t    elf_tdata (output_bfd)->cverrefs = crefs;\n\t  }\n      }\n\n      if ((elf_tdata (output_bfd)->cverrefs == 0\n\t   && elf_tdata (output_bfd)->cverdefs == 0)\n\t  || _bfd_elf_link_renumber_dynsyms (output_bfd, info,\n\t\t\t\t\t     &section_sym_count) == 0)\n\t{\n\t  s = bfd_get_linker_section (dynobj, \".gnu.version\");\n\t  s->flags |= SEC_EXCLUDE;\n\t}\n    }\n  return TRUE;\n}"
}