{
    "Project": "apr",
    "Tool": "CSA",
    "Bug Type": "core.uninitialized.Assign",
    "Code_line": "        rootpath = getpath;",
    "Code_function": "APR_DECLARE(apr_status_t) apr_filepath_merge(char **newpath,\n                                             const char *rootpath,\n                                             const char *addpath,\n                                             apr_int32_t flags,\n                                             apr_pool_t *p)\n{\n    char *path;\n    apr_size_t rootlen; /* is the length of the src rootpath */\n    apr_size_t maxlen;  /* maximum total path length */\n    apr_size_t keptlen; /* is the length of the retained rootpath */\n    apr_size_t pathlen; /* is the length of the result path */\n    apr_size_t seglen;  /* is the end of the current segment */\n    apr_status_t rv;\n\n    /* Treat null as an empty path.\n     */\n    if (!addpath)\n        addpath = \"\";\n\n    if (addpath[0] == '/') {\n        /* If addpath is rooted, then rootpath is unused.\n         * Ths violates any APR_FILEPATH_SECUREROOTTEST and\n         * APR_FILEPATH_NOTABSOLUTE flags specified.\n         */\n        if (flags & APR_FILEPATH_SECUREROOTTEST)\n            return APR_EABOVEROOT;\n        if (flags & APR_FILEPATH_NOTABSOLUTE)\n            return APR_EABSOLUTE;\n\n        /* If APR_FILEPATH_NOTABOVEROOT wasn't specified,\n         * we won't test the root again, it's ignored.\n         * Waste no CPU retrieving the working path.\n         */\n        if (!rootpath && !(flags & APR_FILEPATH_NOTABOVEROOT))\n            rootpath = \"\";\n    }\n    else {\n        /* If APR_FILEPATH_NOTABSOLUTE is specified, the caller\n         * requires a relative result.  If the rootpath is\n         * ommitted, we do not retrieve the working path,\n         * if rootpath was supplied as absolute then fail.\n         */\n        if (flags & APR_FILEPATH_NOTABSOLUTE) {\n            if (!rootpath)\n                rootpath = \"\";\n            else if (rootpath[0] == '/')\n                return APR_EABSOLUTE;\n        }\n    }\n\n    if (!rootpath) {\n        /* Start with the current working path.  This is bass akwards,\n         * but required since the compiler (at least vc) doesn't like\n         * passing the address of a char const* for a char** arg.\n         */\n        char *getpath;\n        rv = apr_filepath_get(&getpath, flags, p);\n        rootpath = getpath;\n        if (rv != APR_SUCCESS)\n            return errno;\n\n        /* XXX: Any kernel subject to goofy, uncanonical results\n         * must run the rootpath against the user's given flags.\n         * Simplest would be a recursive call to apr_filepath_merge\n         * with an empty (not null) rootpath and addpath of the cwd.\n         */\n    }\n\n    rootlen = strlen(rootpath);\n    maxlen = rootlen + strlen(addpath) + 4; /* 4 for slashes at start, after\n                                             * root, and at end, plus trailing\n                                             * null */\n    if (maxlen > APR_PATH_MAX) {\n        return APR_ENAMETOOLONG;\n    }\n    path = (char *)apr_palloc(p, maxlen);\n\n    if (addpath[0] == '/') {\n        /* Ignore the given root path, strip off leading\n         * '/'s to a single leading '/' from the addpath,\n         * and leave addpath at the first non-'/' character.\n         */\n        keptlen = 0;\n        while (addpath[0] == '/')\n            ++addpath;\n        path[0] = '/';\n        pathlen = 1;\n    }\n    else {\n        /* If both paths are relative, fail early\n         */\n        if (rootpath[0] != '/' && (flags & APR_FILEPATH_NOTRELATIVE))\n            return APR_ERELATIVE;\n\n        /* Base the result path on the rootpath\n         */\n        keptlen = rootlen;\n        memcpy(path, rootpath, rootlen);\n\n        /* Always '/' terminate the given root path\n         */\n        if (keptlen && path[keptlen - 1] != '/') {\n            path[keptlen++] = '/';\n        }\n        pathlen = keptlen;\n    }\n\n    while (*addpath) {\n        /* Parse each segment, find the closing '/'\n         */\n        const char *next = addpath;\n        while (*next && (*next != '/')) {\n            ++next;\n        }\n        seglen = next - addpath;\n\n        if (seglen == 0 || (seglen == 1 && addpath[0] == '.')) {\n            /* noop segment (/ or ./) so skip it\n             */\n        }\n        else if (seglen == 2 && addpath[0] == '.' && addpath[1] == '.') {\n            /* backpath (../) */\n            if (pathlen == 1 && path[0] == '/') {\n                /* Attempt to move above root.  Always die if the\n                 * APR_FILEPATH_SECUREROOTTEST flag is specified.\n                 */\n                if (flags & APR_FILEPATH_SECUREROOTTEST) {\n                    return APR_EABOVEROOT;\n                }\n\n                /* Otherwise this is simply a noop, above root is root.\n                 * Flag that rootpath was entirely replaced.\n                 */\n                keptlen = 0;\n            }\n            else if (pathlen == 0\n                     || (pathlen == 3\n                         && !memcmp(path + pathlen - 3, \"../\", 3))\n                     || (pathlen  > 3\n                         && !memcmp(path + pathlen - 4, \"/../\", 4))) {\n                /* Path is already backpathed or empty, if the\n                 * APR_FILEPATH_SECUREROOTTEST.was given die now.\n                 */\n                if (flags & APR_FILEPATH_SECUREROOTTEST) {\n                    return APR_EABOVEROOT;\n                }\n\n                /* Otherwise append another backpath, including\n                 * trailing slash if present.\n                 */\n                memcpy(path + pathlen, \"../\", *next ? 3 : 2);\n                pathlen += *next ? 3 : 2;\n            }\n            else {\n                /* otherwise crop the prior segment\n                 */\n                do {\n                    --pathlen;\n                } while (pathlen && path[pathlen - 1] != '/');\n            }\n\n            /* Now test if we are above where we started and back up\n             * the keptlen offset to reflect the added/altered path.\n             */\n            if (pathlen < keptlen) {\n                if (flags & APR_FILEPATH_SECUREROOTTEST) {\n                    return APR_EABOVEROOT;\n                }\n                keptlen = pathlen;\n            }\n        }\n        else {\n            /* An actual segment, append it to the destination path\n             */\n            if (*next) {\n                seglen++;\n            }\n            memcpy(path + pathlen, addpath, seglen);\n            pathlen += seglen;\n        }\n\n        /* Skip over trailing slash to the next segment\n         */\n        if (*next) {\n            ++next;\n        }\n\n        addpath = next;\n    }\n    path[pathlen] = '\\0';\n\n    /* keptlen will be the rootlen unless the addpath contained\n     * backpath elements.  If so, and APR_FILEPATH_NOTABOVEROOT\n     * is specified (APR_FILEPATH_SECUREROOTTEST was caught above),\n     * compare the original root to assure the result path is\n     * still within given root path.\n     */\n    if ((flags & APR_FILEPATH_NOTABOVEROOT) && keptlen < rootlen) {\n        if (strncmp(rootpath, path, rootlen)) {\n            return APR_EABOVEROOT;\n        }\n        if (rootpath[rootlen - 1] != '/'\n            && path[rootlen] && path[rootlen] != '/') {\n            return APR_EABOVEROOT;\n        }\n    }\n\n    *newpath = path;\n    return APR_SUCCESS;\n}"
}