{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/complete.c",
    "message": "The value read from printed_len was never initialized.",
    "warning_function_name": "print_filename",
    "warning_line": "return printed_len;",
    "warning_context": "\t    dn = \"/\";\t\t/* don't turn /// into // */\n\t  else\n\t    dn = full_pathname;\n\t  s = tilde_expand (dn);\n\t  if (rl_directory_completion_hook)\n\t    (*rl_directory_completion_hook) (&s);\n\n\t  slen = strlen (s);\n\t  tlen = strlen (to_print);\n\t  new_full_pathname = (char *)xmalloc (slen + tlen + 2);\n\t  strcpy (new_full_pathname, s);\n\t  if (s[slen - 1] == '/')\n\t    slen--;\n\t  else\n\t    new_full_pathname[slen] = '/';\n\t  new_full_pathname[slen] = '/';\n\t  strcpy (new_full_pathname + slen + 1, to_print);\n\n#if defined (VISIBLE_STATS)\n\t  if (rl_visible_stats)\n\t    extension_char = stat_char (new_full_pathname);\n\t  else\n#endif\n\t  if (_rl_complete_mark_directories)\n\t    {\n\t      dn = 0;\n\t      if (rl_directory_completion_hook == 0 && rl_filename_stat_hook)\n\t\t{\n\t\t  dn = savestring (new_full_pathname);\n\t\t  (*rl_filename_stat_hook) (&dn);\n\t\t  free (new_full_pathname);\n\t\t  new_full_pathname = dn;\n\t\t}\n\t      if (path_isdir (new_full_pathname))\n\t\textension_char = '/';\n\t    }\n\n#if defined (COLOR_SUPPORT)\n\t  if (_rl_colored_stats)\n\t    {\n\t      colored_stat_start (new_full_pathname);\n\t      printed_len = fnprint (to_print, prefix_bytes);\n\t      colored_stat_end ();\n\t    }\n#endif\n\n\t  xfree (new_full_pathname);\n\t  to_print[-1] = c;\n\t}\n      else\n\t{\n\t  s = tilde_expand (full_pathname);\n#if defined (VISIBLE_STATS)\n\t  if (rl_visible_stats)\n\t    extension_char = stat_char (s);\n\t  else\n#endif\n\t    if (_rl_complete_mark_directories && path_isdir (s))\n\t      extension_char = '/';\n\n#if defined (COLOR_SUPPORT)\n\t  if (_rl_colored_stats)\n\t    {\n\t      colored_stat_start (s);\n\t      printed_len = fnprint (to_print, prefix_bytes);\n\t      colored_stat_end ();\n\t    }\n#endif\n\n\t}\n\n      xfree (s);\n      if (extension_char)\n\t{\n\t  putc (extension_char, rl_outstream);\n\t  printed_len++;\n\t}\n    }\n\n  return printed_len;\n}\n\nstatic char *\nrl_quote_filename (s, rtype, qcp)\n     char *s;\n     int rtype;\n     char *qcp;\n{\n  char *r;\n\n  r = (char *)xmalloc (strlen (s) + 2);\n  *r = *rl_completer_quote_characters;\n  strcpy (r + 1, s);\n  if (qcp)\n    *qcp = *rl_completer_quote_characters;\n  return r;\n}\n\n/* Find the bounds of the current word for completion purposes, and leave\n   rl_point set to the end of the word.  This function skips quoted\n   substrings (characters between matched pairs of characters in\n"
}