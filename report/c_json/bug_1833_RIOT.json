{
    "project": "RIOT",
    "tool": "Cppcheck",
    "category": "Null Pointer Dereference",
    "file": "drivers/ccs811/ccs811.c",
    "message": "Either the condition 'params!=NULL' is redundant or there is possible null pointer dereference: params.",
    "warning_function_name": "ccs811_init",
    "warning_line": "dev->params = *params;",
    "warning_context": "int ccs811_init(ccs811_t *dev, const ccs811_params_t *params)\n{\n    ASSERT_PARAM(dev != NULL);\n    ASSERT_PARAM(params != NULL);\n\n    /* init sensor data structure */\n    dev->params = *params;\n\n    int res = CCS811_OK;\n\n    if (dev->params.reset_pin != GPIO_UNDEF &&\n        gpio_init(dev->params.reset_pin, GPIO_OUT) == 0) {\n        DEBUG_DEV(\"nRESET pin configured\", dev);\n        /* enable low active reset signal */\n        gpio_clear(dev->params.reset_pin);\n        /* t_RESET (reset impuls) has to be at least 20 us, we wait 1 ms */\n        xtimer_usleep(1000);\n        /* disable low active reset signal */\n        gpio_set(dev->params.reset_pin);\n        /* t_START after reset is 1 ms, we wait 1 further ms */\n        xtimer_usleep(1000);\n    }\n\n    if (dev->params.wake_pin != GPIO_UNDEF &&\n        gpio_init(dev->params.wake_pin, GPIO_OUT) == 0) {\n        gpio_clear(dev->params.wake_pin);\n        DEBUG_DEV(\"nWAKE pin configured\", dev);\n    }\n\n    /* check whether sensor is available including the check of the hardware id */\n    if ((res = _is_available(dev)) != CCS811_OK) {\n        return res;\n    }\n\n    static const uint8_t sw_reset[4] = { 0x11, 0xe5, 0x72, 0x8a };\n\n    /* doing a software reset first */\n    if (_reg_write(dev, CCS811_REG_SW_RESET, (uint8_t *)sw_reset, 4) != CCS811_OK) {\n        DEBUG_DEV(\"could not write software reset command \"\n                  \"to register CCS811_REG_SW_RESET\", dev);\n        return -CCS811_ERROR_I2C;\n    }\n\n    uint8_t status;\n\n    /* wait 100 ms after the reset */\n    xtimer_usleep(100000);\n\n    /* get the status to check whether sensor is in bootloader mode */\n    if (_reg_read(dev, CCS811_REG_STATUS, &status, 1) != CCS811_OK) {\n        DEBUG_DEV(\"could not read register CCS811_REG_STATUS\", dev);\n        return -CCS811_ERROR_I2C;\n    }\n\n    /*\n     * if sensor is in bootloader mode (FW_MODE == 0), it has to switch\n     * to the application mode first\n     */\n    if (!(status & CCS811_STATUS_FW_MODE)) {\n        /* check whether valid application firmware is loaded */\n        if (!(status & CCS811_STATUS_APP_VALID)) {\n            DEBUG_DEV(\"sensor is in boot mode, but has no app\", dev);\n            return -CCS811_ERROR_NO_APP;\n        }\n\n        /* switch to application mode */\n        if (_reg_write(dev, CCS811_REG_APP_START, 0, 0) != CCS811_OK) {\n            DEBUG_DEV(\"could not write app start command \"\n                      \"to register CCS811_REG_APP_START\", dev);\n            return -CCS811_ERROR_I2C;\n        }\n\n        /* wait 100 ms after starting the app */\n        xtimer_usleep(100000);\n\n        /* get the status to check whether sensor switched to application mode */\n        if (_reg_read(dev, CCS811_REG_STATUS, &status, 1) != CCS811_OK) {\n            DEBUG_DEV(\"could not read register CCS811_REG_STATUS\", dev);\n            return -CCS811_ERROR_I2C;\n        }\n        if ((status & CCS811_STATUS_FW_MODE) == 0) {\n            DEBUG_DEV(\"could not start application\", dev);\n            return -CCS811_ERROR_NO_APP;\n        }\n    }\n\n#if MODULE_CCS811_FULL\n    /* try to set interrupt mode */\n    if (dev->params.int_mode != CCS811_INT_NONE &&\n        (res = ccs811_set_int_mode (dev, dev->params.int_mode)) != CCS811_OK) {\n        return res;\n    }\n#endif /* MODULE_CCS811_FULL */\n\n    /* try to set default measurement mode */\n    return ccs811_set_mode(dev, dev->params.mode);\n}\n"
}