{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "\tmemset(new, '\\0', cursize * sizeof(BUCKET *));",
    "Code_function": "int_copy(NODE *symbol, NODE *newsymb)\n{\n\tBUCKET **old, **new, **pnew;\n\tBUCKET *chain, *newchain;\n\tint j;\n\tunsigned long i, cursize;\n\n\tassert(symbol->buckets != NULL);\n\n\t/* find the current hash size */\n\tcursize = symbol->array_size;\n\n\t/* allocate new table */\n\temalloc(new, BUCKET **, cursize * sizeof(BUCKET *), \"int_copy\");\n\tmemset(new, '\\0', cursize * sizeof(BUCKET *));\n\n\told = symbol->buckets;\n\n\tfor (i = 0; i < cursize; i++) {\n\t\tfor (chain = old[i], pnew = & new[i]; chain != NULL;\n\t\t\t\tchain = chain->ainext\n\t\t) {\n\t\t\tgetbucket(newchain);\n\t\t\tnewchain->aicount = chain->aicount;\n\t\t\tnewchain->ainext = NULL;\n\t\t\tfor (j = 0; j < chain->aicount; j++) {\n\t\t\t\tNODE *oldval;\n\n\t\t\t\t/*\n\t\t\t\t * copy the corresponding key and\n\t\t\t\t * value from the original input list\n\t\t\t\t */\n\t\t\t\tnewchain->ainum[j] = chain->ainum[j];\n\n\t\t\t\toldval = chain->aivalue[j];\n\t\t\t\tif (oldval->type == Node_val)\n\t\t\t\t\tnewchain->aivalue[j] = dupnode(oldval);\n\t\t\t\telse {\n\t\t\t\t\tNODE *r;\n\t\t\t\t\tr = make_array();\n\t\t\t\t\tr->vname = estrdup(oldval->vname, strlen(oldval->vname));\n\t\t\t\t\tr->parent_array = newsymb;\n\t\t\t\t\tnewchain->aivalue[j] = assoc_copy(oldval, r);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*pnew = newchain;\n\t\t\tnewchain->ainext = NULL;\n\t\t\tpnew = & newchain->ainext;\n\t\t}\n\t}\n\n\tif (symbol->xarray != NULL) {\n\t\tNODE *xn, *n;\n\t\txn = symbol->xarray;\n\t\tn = make_array();\n\t\tn->vname = newsymb->vname;\t/* shallow copy */\n\t\t(void) xn->acopy(xn, n);\n\t\tnewsymb->xarray = n;\n\t} else\n\t\tnewsymb->xarray = NULL;\n\n\tnewsymb->table_size = symbol->table_size;\n\tnewsymb->buckets = new;\n\tnewsymb->array_size = cursize;\n\tnewsymb->flags = symbol->flags;\n\n\treturn NULL;\n}"
}