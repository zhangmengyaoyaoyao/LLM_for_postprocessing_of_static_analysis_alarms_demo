{
    "project": "bash",
    "tool": "Cppcheck",
    "category": "arrayIndexOutOfBoundsCond",
    "file": "lib/malloc/malloc.c",
    "message": "Either the condition 'nu>=2' is redundant or the array 'nextf[30]' is accessed at index 30, which is out of bounds.",
    "warning_function_name": "morecore",
    "warning_line": "if (nextf[nu] != 0)",
    "warning_context": "static void\nmorecore (nu)\n     register int nu;\t\t/* size index to get more of  */\n{\n  register union mhead *mp;\n  register int nblks;\n  register long siz;\n  long sbrk_amt;\t\t/* amount to get via sbrk() */\n  sigset_t set, oset;\n  int blocked_sigs;\n\n  /* Block all signals in case we are executed from a signal handler. */\n  blocked_sigs = 0;\n#ifdef SHELL\n#  if defined (SIGCHLD)\n  if (interrupt_immediately || running_trap || signal_is_trapped (SIGINT) || signal_is_trapped (SIGCHLD))\n#  else\n  if (interrupt_immediately || running_trap || signal_is_trapped (SIGINT))\n#  endif\n#endif\n    {\n      _malloc_block_signals (&set, &oset);\n      blocked_sigs = 1;\n    }\n\n  siz = binsize (nu);\t/* size of desired block for nextf[nu] */\n\n  if (siz < 0)\n    goto morecore_done;\t\t/* oops */\n\n#ifdef MALLOC_STATS\n  _mstats.nmorecore[nu]++;\n#endif\n\n  /* Try to split a larger block here, if we're within the range of sizes\n     to split. */\n  if (nu >= SPLIT_MIN)\n    {\n      bsplit (nu);\n      if (nextf[nu] != 0)\n\tgoto morecore_done;\n    }\n\n  /* Try to coalesce two adjacent blocks from the free list on nextf[nu - 1],\n     if we can, and we're within the range of the block coalescing limits. */\n  if (nu >= COMBINE_MIN && nu < COMBINE_MAX && busy[nu - 1] == 0 && nextf[nu - 1])\n    {\n      bcoalesce (nu);\n      if (nextf[nu] != 0)\n\tgoto morecore_done;\n    }\n\n  /* Take at least a page, and figure out how many blocks of the requested\n     size we're getting. */\n  if (siz <= pagesz)\n    {\n      sbrk_amt = pagesz;\n      nblks = sbrk_amt / siz;\n    }\n  else\n    {\n      /* We always want to request an integral multiple of the page size\n\t from the kernel, so let's compute whether or not `siz' is such\n\t an amount.  If it is, we can just request it.  If not, we want\n\t the smallest integral multiple of pagesize that is larger than\n\t `siz' and will satisfy the request. */\n      sbrk_amt = siz & (pagesz - 1);\n      if (sbrk_amt == 0)\n\tsbrk_amt = siz;\n      else\n\tsbrk_amt = siz + pagesz - sbrk_amt;\n      nblks = 1;\n    }\n\n#ifdef MALLOC_STATS\n  _mstats.nsbrk++;\n  _mstats.tsbrk += sbrk_amt;\n#endif\n\n  mp = (union mhead *) sbrk (sbrk_amt);\n\n  /* Totally out of memory. */\n  if ((long)mp == -1)\n    goto morecore_done;\n\n  memtop += sbrk_amt;\n\n  /* shouldn't happen, but just in case -- require 8-byte alignment */\n  if ((long)mp & MALIGN_MASK)\n    {\n      mp = (union mhead *) (((long)mp + MALIGN_MASK) & ~MALIGN_MASK);\n      nblks--;\n    }\n\n  /* save new header and link the nblks blocks together */\n  nextf[nu] = mp;\n  while (1)\n    {\n      mp->mh_alloc = ISFREE;\n      mp->mh_index = nu;\n      if (--nblks <= 0) break;\n"
}