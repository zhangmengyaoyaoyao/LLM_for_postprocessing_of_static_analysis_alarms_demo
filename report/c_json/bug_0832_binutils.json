{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [2, +oo] (⇐ [0, +oo] + [2, +oo]) Size: [1, +oo] by call to `_bfd_default_link_order`.",
    "Code_line": "\t      if (! _bfd_default_link_order (abfd, info, o, p))",
    "Code_function": "_bfd_generic_final_link (bfd *abfd, struct bfd_link_info *info)\n{\n  bfd *sub;\n  asection *o;\n  struct bfd_link_order *p;\n  size_t outsymalloc;\n  struct generic_write_global_symbol_info wginfo;\n\n  bfd_get_outsymbols (abfd) = NULL;\n  bfd_get_symcount (abfd) = 0;\n  outsymalloc = 0;\n\n  /* Mark all sections which will be included in the output file.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    for (p = o->map_head.link_order; p != NULL; p = p->next)\n      if (p->type == bfd_indirect_link_order)\n\tp->u.indirect.section->linker_mark = TRUE;\n\n  /* Build the output symbol table.  */\n  for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n    if (! _bfd_generic_link_output_symbols (abfd, sub, info, &outsymalloc))\n      return FALSE;\n\n  /* Accumulate the global symbols.  */\n  wginfo.info = info;\n  wginfo.output_bfd = abfd;\n  wginfo.psymalloc = &outsymalloc;\n  _bfd_generic_link_hash_traverse (_bfd_generic_hash_table (info),\n\t\t\t\t   _bfd_generic_link_write_global_symbol,\n\t\t\t\t   &wginfo);\n\n  /* Make sure we have a trailing NULL pointer on OUTSYMBOLS.  We\n     shouldn't really need one, since we have SYMCOUNT, but some old\n     code still expects one.  */\n  if (! generic_add_output_symbol (abfd, &outsymalloc, NULL))\n    return FALSE;\n\n  if (info->relocatable)\n    {\n      /* Allocate space for the output relocs for each section.  */\n      for (o = abfd->sections; o != NULL; o = o->next)\n\t{\n\t  o->reloc_count = 0;\n\t  for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t    {\n\t      if (p->type == bfd_section_reloc_link_order\n\t\t  || p->type == bfd_symbol_reloc_link_order)\n\t\t++o->reloc_count;\n\t      else if (p->type == bfd_indirect_link_order)\n\t\t{\n\t\t  asection *input_section;\n\t\t  bfd *input_bfd;\n\t\t  long relsize;\n\t\t  arelent **relocs;\n\t\t  asymbol **symbols;\n\t\t  long reloc_count;\n\n\t\t  input_section = p->u.indirect.section;\n\t\t  input_bfd = input_section->owner;\n\t\t  relsize = bfd_get_reloc_upper_bound (input_bfd,\n\t\t\t\t\t\t       input_section);\n\t\t  if (relsize < 0)\n\t\t    return FALSE;\n\t\t  relocs = (arelent **) bfd_malloc (relsize);\n\t\t  if (!relocs && relsize != 0)\n\t\t    return FALSE;\n\t\t  symbols = _bfd_generic_link_get_symbols (input_bfd);\n\t\t  reloc_count = bfd_canonicalize_reloc (input_bfd,\n\t\t\t\t\t\t\tinput_section,\n\t\t\t\t\t\t\trelocs,\n\t\t\t\t\t\t\tsymbols);\n\t\t  free (relocs);\n\t\t  if (reloc_count < 0)\n\t\t    return FALSE;\n\t\t  BFD_ASSERT ((unsigned long) reloc_count\n\t\t\t      == input_section->reloc_count);\n\t\t  o->reloc_count += reloc_count;\n\t\t}\n\t    }\n\t  if (o->reloc_count > 0)\n\t    {\n\t      bfd_size_type amt;\n\n\t      amt = o->reloc_count;\n\t      amt *= sizeof (arelent *);\n\t      o->orelocation = (struct reloc_cache_entry **) bfd_alloc (abfd, amt);\n\t      if (!o->orelocation)\n\t\treturn FALSE;\n\t      o->flags |= SEC_RELOC;\n\t      /* Reset the count so that it can be used as an index\n\t\t when putting in the output relocs.  */\n\t      o->reloc_count = 0;\n\t    }\n\t}\n    }\n\n  /* Handle all the link order information for the sections.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  switch (p->type)\n\t    {\n\t    case bfd_section_reloc_link_order:\n\t    case bfd_symbol_reloc_link_order:\n\t      if (! _bfd_generic_reloc_link_order (abfd, info, o, p))\n\t\treturn FALSE;\n\t      break;\n\t    case bfd_indirect_link_order:\n\t      if (! default_indirect_link_order (abfd, info, o, p, TRUE))\n\t\treturn FALSE;\n\t      break;\n\t    default:\n\t      if (! _bfd_default_link_order (abfd, info, o, p))\n\t\treturn FALSE;\n\t      break;\n\t    }\n\t}\n    }\n\n  return TRUE;\n}"
}