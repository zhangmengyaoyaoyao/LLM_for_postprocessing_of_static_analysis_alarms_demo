{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t\t\tgenflags2str(pc->sub_flags, values));",
    "Code_function": "print_instruction(INSTRUCTION *pc, Func_print print_func, FILE *fp, int in_dump)\n{\n\tint pcount = 0;\n\tstatic NODE *func = NULL;\n\tstatic int noffset = 0;\n\n\tif (noffset == 0) {\n\t\tstatic char buf[50];\n\t\t/* offset for 2nd to last lines in a multi-line output */\n\t\tnoffset = sprintf(buf, \"[      :%p] %-20.20s: \", (void *) pc,\n\t\t\t\topcode2str(pc->opcode));\n\t}\n\n\tif (pc->opcode == Op_func) {\n\t\tfunc = pc->func_body;\n\t\tpcount = func->param_cnt;\n\t\tif (in_dump) {\n\t\t\tint j;\n\t\t\tprint_func(fp, \"\\n\\t# Function: %s (\", func->vname);\n\t\t\tfor (j = 0; j < pcount; j++) {\n\t\t\t\tprint_func(fp, \"%s\", func->fparms[j].param);\n\t\t\t\tif (j < pcount - 1)\n\t\t\t\t\tprint_func(fp, \", \");\n\t\t\t}\n\t\t\tprint_func(fp, \")\\n\\n\");\n\t\t}\n\t} else if (pc->opcode == Op_rule) {\n\t\tif (in_dump)\n\t\t\tprint_func(fp, \"\\n\\t# %s\\n\\n\", ruletab[pc->in_rule]);\n\t}\n\n\tif (pc->opcode == Op_newfile)\n\t\tprint_func(fp, \"\\n\");\n\n\tif (pc->source_line <= 0)\n\t\tprint_func(fp, \"[      :%p] %-20.20s: \", pc, opcode2str(pc->opcode));\n\telse\n\t\tprint_func(fp, \"[%6d:%p] %-20.20s: \",\n\t\t                pc->source_line, pc, opcode2str(pc->opcode));\n\n\tif (prog_running && ! in_dump) {\n\t\t/* find Node_func if in function */\n\t\tfunc = find_frame(0)->func_node;\n\t}\n\n\n\tswitch (pc->opcode) {\n\tcase Op_var_update:\n\t\tprint_func(fp, \"[update_%s()]\\n\", get_spec_varname(pc->update_var));\n\t\tbreak;\n\n\tcase Op_var_assign:\n\t\tprint_func(fp, \"[set_%s()]\", get_spec_varname(pc->assign_var));\n\t\tif (pc->assign_ctxt != 0)\n\t\t\tprint_func(fp, \" [assign_ctxt = %s]\", opcode2str(pc->assign_ctxt));\n\t\tprint_func(fp, \"\\n\");\n\t\tbreak;\n\n\tcase Op_field_assign:\n\t\tprint_func(fp, \"[%s]\\n\", pc->field_assign == reset_record ?\n\t\t\t\t\t\"reset_record()\" : \"invalidate_field0()\");\n\t\tbreak;\n\n\tcase Op_field_spec_lhs:\n\t\tprint_func(fp, \"[target_assign = %p] [do_reference = %s]\\n\",\n\t\t\t\tpc->target_assign, pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_func:\n\t\tprint_func(fp, \"[param_cnt = %d] [source_file = %s]\\n\", pcount,\n\t\t\t\tpc->source_file ? pc->source_file : \"cmd. line\");\n\t\tbreak;\n\n\tcase Op_K_getline_redir:\n\t\tprint_func(fp, \"[into_var = %s] [redir_type = \\\"%s\\\"]\\n\",\n\t\t                pc->into_var ? \"true\" : \"false\",\n\t\t                redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_K_getline:\n\t\tprint_func(fp, \"[into_var = %s]\\n\", pc->into_var ? \"true\" : \"false\");\n\t\tprint_func(fp, \"%*s[target_beginfile = %p] [target_endfile = %p]\\n\",\n\t\t                noffset, \"\",\n\t\t                (pc + 1)->target_beginfile, (pc + 1)->target_endfile);\n\t\tbreak;\n\n\tcase Op_K_print_rec:\n\t\tprint_func(fp, \"[redir_type = \\\"%s\\\"]\\n\", redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_K_print:\n\tcase Op_K_printf:\n\t\tprint_func(fp, \"[expr_count = %ld] [redir_type = \\\"%s\\\"]\\n\",\n\t\t                pc->expr_count, redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_indirect_func_call:\n\tcase Op_func_call:\n\t\tprint_func(fp, \"[func_name = %s] [arg_count = %ld]\\n\",\n\t\t                pc->func_name, (pc + 1)->expr_count);\n\t\tbreak;\n\n\tcase Op_K_nextfile:\n\t\tprint_func(fp, \"[target_newfile = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_newfile, pc->target_endfile);\n\t\tbreak;\n\n\tcase Op_newfile:\n\t\tprint_func(fp, \"[target_jmp = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_jmp, pc->target_endfile);\n\t\tprint_func(fp, \"%*s[target_get_record = %p]\\n\",\n\t\t                noffset, \"\", (pc + 1)->target_get_record);\n\t\tbreak;\n\n\tcase Op_get_record:\n\t\tprint_func(fp, \"[target_newfile = %p]\\n\", pc->target_newfile);\n\t\tbreak;\n\n\tcase Op_jmp:\n\tcase Op_jmp_false:\n\tcase Op_jmp_true:\n\tcase Op_and:\n\tcase Op_or:\n\tcase Op_K_next:\n\tcase Op_arrayfor_init:\n\tcase Op_K_break:\n\tcase Op_K_continue:\n\t\tprint_func(fp, \"[target_jmp = %p]\\n\", pc->target_jmp);\n\t\tbreak;\n\tcase Op_K_exit:\n\t\tprint_func(fp, \"[target_end = %p] [target_atexit = %p]\\n\",\n\t\t\t\t\t\tpc->target_end, pc->target_atexit);\n\t\tbreak;\n\n\tcase Op_K_case:\n\t\tprint_func(fp, \"[target_jmp = %p] [match_exp = %s]\\n\",\n\t\t\t\t\t\tpc->target_jmp,\t(pc + 1)->match_exp ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_arrayfor_incr:\n\t\tprint_func(fp, \"[array_var = %s] [target_jmp = %p]\\n\",\n\t\t                pc->array_var->type == Node_param_list ?\n\t\t                   func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,\n\t\t                pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_line_range:\n\t\tprint_func(fp, \"[triggered = %ld] [target_jmp = %p]\\n\",\n\t\t                pc->triggered, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_cond_pair:\n\t\tprint_func(fp, \"[line_range = %p] [target_jmp = %p]\\n\",\n\t\t                pc->line_range, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_sub_builtin:\n\t{\n\t\tconst char *fname = \"sub\";\n\t\tstatic const struct flagtab values[] = {\n\t\t\t{ GSUB, \"GSUB\" },\n\t\t\t{ GENSUB, \"GENSUB\" },\n\t\t\t{ LITERAL, \"LITERAL\" },\n\t\t\t{ 0, NULL }\n\t\t};\n\n\t\tif ((pc->sub_flags & GSUB) != 0)\n\t\t\tfname = \"gsub\";\n\t\telse if ((pc->sub_flags & GENSUB) != 0)\n\t\t\tfname = \"gensub\";\n\t\tprint_func(fp, \"%s [arg_count = %ld] [sub_flags = %s]\\n\",\n\t\t\t\tfname, pc->expr_count,\n\t\t\t\tgenflags2str(pc->sub_flags, values));\n\t}\n\t\tbreak;\n\n\tcase Op_builtin:\n\t\tprint_func(fp, \"%s [arg_count = %ld]\\n\", getfname(pc->builtin),\n\t\t\t\t\t\tpc->expr_count);\n\t\tbreak;\n\n\tcase Op_ext_builtin:\n\t\tprint_func(fp, \"%s [arg_count = %ld]\\n\", (pc + 1)->func_name,\n\t\t\t\t\t\tpc->expr_count);\n\t\tbreak;\n\n\tcase Op_subscript:\n\tcase Op_sub_array:\n\t\tprint_func(fp, \"[sub_count = %ld]\\n\", pc->sub_count);\n\t\tbreak;\n\n\tcase Op_store_sub:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tprint_func(fp, \" [sub_count = %ld]\\n\", pc->expr_count);\n\t\tbreak;\n\n\tcase Op_subscript_lhs:\n\t\tprint_func(fp, \"[sub_count = %ld] [do_reference = %s]\\n\",\n\t\t                pc->sub_count,\n\t\t                pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_K_delete:\n\tcase Op_in_array:\n\t\tprint_func(fp, \"[expr_count = %ld]\\n\", pc->expr_count);\n\t\tbreak;\n\n\tcase Op_concat:\n\t\t/* NB: concat_flag CSVAR only used in grammar, don't display it */\n\t\tprint_func(fp, \"[expr_count = %ld] [concat_flag = %s]\\n\",\n\t\t\t\t\t\tpc->expr_count,\n\t\t\t\t\t\t(pc->concat_flag & CSUBSEP) != 0 ? \"CSUBSEP\" : \"0\");\n\t\tbreak;\n\n\tcase Op_rule:\n\t\tprint_func(fp, \"[in_rule = %s] [source_file = %s]\\n\",\n\t\t                ruletab[pc->in_rule],\n\t\t                pc->source_file ? pc->source_file : \"cmd. line\");\n\t\tbreak;\n\n\tcase Op_lint:\n\t{\n\t\tstatic const char *const linttypetab[] = {\n\t\t\t\"LINT_illegal\",\n\t\t\t\"LINT_assign_in_cond\",\n\t\t\t\"LINT_no_effect\"\n\t\t};\n\t\tprint_func(fp, \"[lint_type = %s]\\n\", linttypetab[pc->lint_type]);\n\t}\n\t\tbreak;\n\n\tcase Op_exec_count:\n\t\tprint_func(fp, \"[exec_count = %ld]\\n\", pc->exec_count);\n\t\tbreak;\n\n \tcase Op_store_var:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tif (pc->initval != NULL) {\n\t\t\tprint_func(fp, \" = \");\n\t\t\tprint_memory(pc->initval, func, print_func, fp);\n\t\t}\n\t\tprint_func(fp, \"\\n\");\n\t\tbreak;\n\n\tcase Op_push_lhs:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tprint_func(fp, \" [do_reference = %s]\\n\",\n\t\t                pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_push_i:\n\tcase Op_push:\n\tcase Op_push_arg:\n\tcase Op_push_param:\n\tcase Op_push_array:\n\tcase Op_push_re:\n\tcase Op_match_rec:\n\tcase Op_match:\n\tcase Op_nomatch:\n\tcase Op_plus_i:\n\tcase Op_minus_i:\n\tcase Op_times_i:\n\tcase Op_exp_i:\n\tcase Op_quotient_i:\n\tcase Op_mod_i:\n\tcase Op_assign_concat:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\t/* fall through */\n\tdefault:\n\t\tprint_func(fp, \"\\n\");\n\t\tbreak;\n\t}\n}"
}