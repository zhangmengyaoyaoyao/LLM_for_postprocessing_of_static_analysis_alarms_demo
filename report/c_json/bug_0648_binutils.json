{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "gas/macro.c",
    "message": "Offset added: [`out->len` + 2, +oo] (⇐ [`out->len` + 2, +oo] + [0, +oo]) Size: [1, +oo] by call to `sb_add_sb`.",
    "warning_function_name": "macro_expand_body",
    "warning_line": "sb_add_sb (out, &t);",
    "warning_context": "\t\t\t\tout, 1);\n\t    }\n\t  else\n\t    {\n\t      src = sb_skip_white (src + 5, in);\n\t      while (in->ptr[src] != '\\n')\n\t\t{\n\t\t  const char *name;\n\t\t  formal_entry *f = new_formal ();\n\n\t\t  src = get_token (src, in, &f->name);\n\t\t  name = sb_terminate (&f->name);\n\t\t  if (! hash_find (formal_hash, name))\n\t\t    {\n\t\t      static int loccnt;\n\t\t      char buf[20];\n\n\t\t      f->index = LOCAL_INDEX;\n\t\t      f->next = loclist;\n\t\t      loclist = f;\n\n\t\t      sprintf (buf, IS_ELF ? \".LL%04x\" : \"LL%04x\", ++loccnt);\n\t\t      sb_add_string (&f->actual, buf);\n\n\t\t      err = hash_jam (formal_hash, name, f);\n\t\t      if (err != NULL)\n\t\t\tbreak;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      as_bad_where (macro->file,\n\t\t\t\t    macro->line + macro_line,\n\t\t\t\t    _(\"`%s' was already used as parameter (or another local) name\"),\n\t\t\t\t    name);\n\t\t      del_formal (f);\n\t\t    }\n\n\t\t  src = sb_skip_comma (src, in);\n\t\t}\n\t    }\n\t}\n      else if (in->ptr[src] == '\"'\n\t       || (macro_mri && in->ptr[src] == '\\''))\n\t{\n\t  inquote = !inquote;\n\t  sb_add_char (out, in->ptr[src++]);\n\t}\n      else if (in->ptr[src] == '@' && macro_strip_at)\n\t{\n\t  ++src;\n\t  if (src < in->len\n\t      && in->ptr[src] == '@')\n\t    {\n\t      sb_add_char (out, '@');\n\t      ++src;\n\t    }\n\t}\n      else if (macro_mri\n\t       && in->ptr[src] == '='\n\t       && src + 1 < in->len\n\t       && in->ptr[src + 1] == '=')\n\t{\n\t  formal_entry *ptr;\n\n\t  sb_reset (&t);\n\t  src = get_token (src + 2, in, &t);\n\t  ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (&t));\n\t  if (ptr == NULL)\n\t    {\n\t      /* FIXME: We should really return a warning string here,\n\t\t but we can't, because the == might be in the MRI\n\t\t comment field, and, since the nature of the MRI\n\t\t comment field depends upon the exact instruction\n\t\t being used, we don't have enough information here to\n\t\t figure out whether it is or not.  Instead, we leave\n\t\t the == in place, which should cause a syntax error if\n\t\t it is not in a comment.  */\n\t      sb_add_char (out, '=');\n\t      sb_add_char (out, '=');\n\t      sb_add_sb (out, &t);\n\t    }\n\t  else\n\t    {\n\t      if (ptr->actual.len)\n\t\t{\n\t\t  sb_add_string (out, \"-1\");\n\t\t}\n\t      else\n\t\t{\n\t\t  sb_add_char (out, '0');\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  if (in->ptr[src] == '\\n')\n\t    ++macro_line;\n\t  sb_add_char (out, in->ptr[src++]);\n\t}\n    }\n\n"
}