{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t  ADVANCE_CHAR (text, tlen, i);",
    "Code_function": "brace_gobbler (text, tlen, indx, satisfy)\n     char *text;\n     size_t tlen;\n     int *indx;\n     int satisfy;\n{\n  register int i, c, quoted, level, commas, pass_next;\n#if defined (SHELL)\n  int si;\n  char *t;\n#endif\n  DECLARE_MBSTATE;\n\n  level = quoted = pass_next = 0;\n#if defined (CSH_BRACE_COMPAT)\n  commas = 1;\n#else\n  commas = (satisfy == '}') ? 0 : 1;\n#endif\n\n  i = *indx;\n  while (c = text[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  ADVANCE_CHAR (text, tlen, i);\n\t  continue;\n\t}\n\n      /* A backslash escapes the next character.  This allows backslash to\n\t escape the quote character in a double-quoted string. */\n      if (c == '\\\\' && (quoted == 0 || quoted == '\"' || quoted == '`'))\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n\n#if defined (SHELL)\n      /* If compiling for the shell, treat ${...} like \\{...} */\n      if (c == '$' && text[i+1] == '{' && quoted != '\\'')\t\t/* } */\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  if (quoted == 0)\n\t    level++;\n\t  continue;\n\t}\n#endif\n\n      if (quoted)\n\t{\n\t  if (c == quoted)\n\t    quoted = 0;\n#if defined (SHELL)\n\t  /* The shell allows quoted command substitutions */\n\t  if (quoted == '\"' && c == '$' && text[i+1] == '(')\t/*)*/\n\t    goto comsub;\n#endif\n\t  ADVANCE_CHAR (text, tlen, i);\n\t  continue;\n\t}\n\n      if (c == '\"' || c == '\\'' || c == '`')\n\t{\n\t  quoted = c;\n\t  i++;\n\t  continue;\n\t}\n\n#if defined (SHELL)\n      /* Pass new-style command and process substitutions through unchanged. */\n      if ((c == '$' || c == '<' || c == '>') && text[i+1] == '(')\t\t\t/* ) */\n\t{\ncomsub:\n\t  si = i + 2;\n\t  t = extract_command_subst (text, &si, 0);\n\t  i = si;\n\t  free (t);\n\t  i++;\n\t  continue;\n\t}\n#endif\n\n      if (c == satisfy && level == 0 && quoted == 0 && commas > 0)\n\t{\n\t  /* We ignore an open brace surrounded by whitespace, and also\n\t     an open brace followed immediately by a close brace preceded\n\t     by whitespace.  */\n\t  if (c == '{' &&\n\t      ((!i || brace_whitespace (text[i - 1])) &&\n\t       (brace_whitespace (text[i + 1]) || text[i + 1] == '}')))\n\t    {\n\t      i++;\n\t      continue;\n\t    }\n\n\t    break;\n\t}\n\n      if (c == '{')\n\tlevel++;\n      else if (c == '}' && level)\n\tlevel--;\n#if !defined (CSH_BRACE_COMPAT)\n      else if (satisfy == '}' && c == brace_arg_separator && level == 0)\n\tcommas++;\n      else if (satisfy == '}' && STREQN (text+i, BRACE_SEQ_SPECIFIER, 2) &&\n      \t\ttext[i+2] != satisfy && level == 0)\n\tcommas++;\n#endif\n\n      ADVANCE_CHAR (text, tlen, i);\n    }\n\n  *indx = i;\n  return (c);\n}"
}