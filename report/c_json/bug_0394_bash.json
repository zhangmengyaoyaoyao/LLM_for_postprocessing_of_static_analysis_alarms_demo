{
    "project": "bash",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "execute_cmd.c",
    "message": "Array access (via field 'bitmap') results in a null pointer dereference",
    "warning_function_name": "execute_pipeline",
    "warning_line": "fd_bitmap->bitmap[fildes[0]] = 1;",
    "warning_context": "static int\nexecute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous, pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;\n  int lstdin, lastpipe_flag, lastpipe_jid;\n  COMMAND *cmd;\n  struct fd_bitmap *fd_bitmap;\n  pid_t lastpid;\n\n#if defined (JOB_CONTROL)\n  sigset_t set, oset;\n  BLOCK_CHILD (set, oset);\n#endif /* JOB_CONTROL */\n\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n  prev = pipe_in;\n  cmd = command;\n\n  while (cmd && cmd->type == cm_connection &&\n\t cmd->value.Connection && cmd->value.Connection->connector == '|')\n    {\n      /* Make a pipeline between the two commands. */\n      if (pipe (fildes) < 0)\n\t{\n\t  sys_error (_(\"pipe error\"));\n#if defined (JOB_CONTROL)\n\t  terminate_current_pipeline ();\n\t  kill_current_pipeline ();\n\t  UNBLOCK_CHILD (oset);\n#endif /* JOB_CONTROL */\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  /* The unwind-protects installed below will take care\n\t     of closing all of the open file descriptors. */\n\t  throw_to_top_level ();\n\t  return (EXECUTION_FAILURE);\t/* XXX */\n\t}\n\n      /* Here is a problem: with the new file close-on-exec\n\t code, the read end of the pipe (fildes[0]) stays open\n\t in the first process, so that process will never get a\n\t SIGPIPE.  There is no way to signal the first process\n\t that it should close fildes[0] after forking, so it\n\t remains open.  No SIGPIPE is ever sent because there\n\t is still a file descriptor open for reading connected\n\t to the pipe.  We take care of that here.  This passes\n\t around a bitmap of file descriptors that must be\n\t closed after making a child process in execute_simple_command. */\n\n      /* We need fd_bitmap to be at least as big as fildes[0].\n\t If fildes[0] is less than fds_to_close->size, then\n\t use fds_to_close->size. */\n      new_bitmap_size = (fildes[0] < fds_to_close->size)\n\t\t\t\t? fds_to_close->size\n\t\t\t\t: fildes[0] + 8;\n\n      fd_bitmap = new_fd_bitmap (new_bitmap_size);\n\n      /* Now copy the old information into the new bitmap. */\n      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);\n\n      /* And mark the pipe file descriptors to be closed. */\n      fd_bitmap->bitmap[fildes[0]] = 1;\n\n      /* In case there are pipe or out-of-processes errors, we\n\t want all these file descriptors to be closed when\n\t unwind-protects are run, and the storage used for the\n\t bitmaps freed up. */\n      begin_unwind_frame (\"pipe-file-descriptors\");\n      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);\n      add_unwind_protect (close_fd_bitmap, fd_bitmap);\n      if (prev >= 0)\n\tadd_unwind_protect (close, prev);\n      dummyfd = fildes[1];\n      add_unwind_protect (close, dummyfd);\n\n#if defined (JOB_CONTROL)\n      add_unwind_protect (restore_signal_mask, &oset);\n#endif /* JOB_CONTROL */\n\n      if (ignore_return && cmd->value.Connection->first)\n\tcmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;\n      execute_command_internal (cmd->value.Connection->first, asynchronous,\n\t\t\t\tprev, fildes[1], fd_bitmap);\n\n      if (prev >= 0)\n\tclose (prev);\n\n      prev = fildes[0];\n      close (fildes[1]);\n\n      dispose_fd_bitmap (fd_bitmap);\n      discard_unwind_frame (\"pipe-file-descriptors\");\n\n      cmd = cmd->value.Connection->second;\n    }\n\n  lastpid = last_made_pid;\n"
}