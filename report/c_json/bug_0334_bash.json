{
    "project": "bash",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bashline.c",
    "message": "Offset added: [1, +oo] Size: [0, +oo] by call to `maybe_make_readline_line`.",
    "warning_function_name": "shell_expand_line",
    "warning_line": "maybe_make_readline_line (new_line);",
    "warning_context": "static int\nshell_expand_line (count, ignore)\n     int count, ignore;\n{\n  char *new_line;\n  WORD_LIST *expanded_string;\n\n  new_line = 0;\n#if defined (BANG_HISTORY)\n  new_line = history_expand_line_internal (rl_line_buffer);\n#endif\n\n#if defined (ALIAS)\n  if (new_line)\n    {\n      char *alias_line;\n\n      alias_line = alias_expand (new_line);\n      free (new_line);\n      new_line = alias_line;\n    }\n#endif /* ALIAS */\n\n  if (new_line)\n    {\n      int old_point = rl_point;\n      int at_end = rl_point == rl_end;\n\n      /* If the line was history and alias expanded, then make that\n\t be one thing to undo. */\n      maybe_make_readline_line (new_line);\n      free (new_line);\n\n      /* If there is variable expansion to perform, do that as a separate\n\t operation to be undone. */\n      new_line = savestring (rl_line_buffer);\n      expanded_string = expand_string (new_line, 0);\n      FREE (new_line);\n      if (expanded_string == 0)\n\t{\n\t  new_line = (char *)xmalloc (1);\n\t  new_line[0] = '\\0';\n\t}\n      else\n\t{\n\t  new_line = string_list (expanded_string);\n\t  dispose_words (expanded_string);\n\t}\n\n      maybe_make_readline_line (new_line);\n      free (new_line);\n\n      /* Place rl_point where we think it should go. */\n      if (at_end)\n\trl_point = rl_end;\n      else if (old_point < rl_end)\n\t{\n\t  rl_point = old_point;\n\t  if (!whitespace (rl_line_buffer[rl_point]))\n\t    rl_forward_word (1, 0);\n\t}\n      return 0;\n    }\n  else\n    {\n      cleanup_expansion_error ();\n      return 1;\n    }\n}\n"
}