{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "ld/ldlang.c",
    "message": "Offset added: [16, +oo] (⇐ [0, +oo] + [16, +oo]) Size: [0, +oo] by call to `bfd_check_format_matches`.",
    "warning_function_name": "load_symbols",
    "warning_line": "&& ! bfd_check_format_matches (entry->the_bfd, bfd_object, &matching))",
    "warning_context": "bfd_boolean\nload_symbols (lang_input_statement_type *entry,\n\t      lang_statement_list_type *place)\n{\n  char **matching;\n\n  if (entry->flags.loaded)\n    return TRUE;\n\n  ldfile_open_file (entry);\n\n  /* Do not process further if the file was missing.  */\n  if (entry->flags.missing_file)\n    return TRUE;\n\n  if (! bfd_check_format (entry->the_bfd, bfd_archive)\n      && ! bfd_check_format_matches (entry->the_bfd, bfd_object, &matching))\n    {\n      bfd_error_type err;\n      struct lang_input_statement_flags save_flags;\n      extern FILE *yyin;\n\n      err = bfd_get_error ();\n\n      /* See if the emulation has some special knowledge.  */\n      if (ldemul_unrecognized_file (entry))\n\treturn TRUE;\n\n      if (err == bfd_error_file_ambiguously_recognized)\n\t{\n\t  char **p;\n\n\t  einfo (_(\"%B: file not recognized: %E\\n\"), entry->the_bfd);\n\t  einfo (_(\"%B: matching formats:\"), entry->the_bfd);\n\t  for (p = matching; *p != NULL; p++)\n\t    einfo (\" %s\", *p);\n\t  einfo (\"%F\\n\");\n\t}\n      else if (err != bfd_error_file_not_recognized\n\t       || place == NULL)\n\teinfo (_(\"%F%B: file not recognized: %E\\n\"), entry->the_bfd);\n\n      bfd_close (entry->the_bfd);\n      entry->the_bfd = NULL;\n\n      /* Try to interpret the file as a linker script.  */\n      save_flags = input_flags;\n      ldfile_open_command_file (entry->filename);\n\n      push_stat_ptr (place);\n      input_flags.add_DT_NEEDED_for_regular\n\t= entry->flags.add_DT_NEEDED_for_regular;\n      input_flags.add_DT_NEEDED_for_dynamic\n\t= entry->flags.add_DT_NEEDED_for_dynamic;\n      input_flags.whole_archive = entry->flags.whole_archive;\n      input_flags.dynamic = entry->flags.dynamic;\n\n      ldfile_assumed_script = TRUE;\n      parser_input = input_script;\n      yyparse ();\n      ldfile_assumed_script = FALSE;\n\n      /* missing_file is sticky.  sysrooted will already have been\n\t restored when seeing EOF in yyparse, but no harm to restore\n\t again.  */\n      save_flags.missing_file |= input_flags.missing_file;\n      input_flags = save_flags;\n      pop_stat_ptr ();\n      fclose (yyin);\n      yyin = NULL;\n      entry->flags.loaded = TRUE;\n\n      return TRUE;\n    }\n\n  if (ldemul_recognized_file (entry))\n    return TRUE;\n\n  /* We don't call ldlang_add_file for an archive.  Instead, the\n     add_symbols entry point will call ldlang_add_file, via the\n     add_archive_element callback, for each element of the archive\n     which is used.  */\n  switch (bfd_get_format (entry->the_bfd))\n    {\n    default:\n      break;\n\n    case bfd_object:\n      if (!entry->flags.reload)\n\tldlang_add_file (entry);\n      if (trace_files || verbose)\n\tinfo_msg (\"%I\\n\", entry);\n      break;\n\n    case bfd_archive:\n      check_excluded_libs (entry->the_bfd);\n\n      if (entry->flags.whole_archive)\n\t{\n\t  bfd *member = NULL;\n\t  bfd_boolean loaded = TRUE;\n"
}