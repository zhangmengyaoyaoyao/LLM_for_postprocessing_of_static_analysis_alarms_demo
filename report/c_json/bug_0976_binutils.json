{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: 5 Size: [0, +oo].",
    "Code_line": "      memcpy (names, \"@plt\", sizeof (\"@plt\"));",
    "Code_function": "_bfd_elf_get_synthetic_symtab (bfd *abfd,\n\t\t\t       long symcount ATTRIBUTE_UNUSED,\n\t\t\t       asymbol **syms ATTRIBUTE_UNUSED,\n\t\t\t       long dynsymcount,\n\t\t\t       asymbol **dynsyms,\n\t\t\t       asymbol **ret)\n{\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  asection *relplt;\n  asymbol *s;\n  const char *relplt_name;\n  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);\n  arelent *p;\n  long count, i, n;\n  size_t size;\n  Elf_Internal_Shdr *hdr;\n  char *names;\n  asection *plt;\n\n  *ret = NULL;\n\n  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)\n    return 0;\n\n  if (dynsymcount <= 0)\n    return 0;\n\n  if (!bed->plt_sym_val)\n    return 0;\n\n  relplt_name = bed->relplt_name;\n  if (relplt_name == NULL)\n    relplt_name = bed->rela_plts_and_copies_p ? \".rela.plt\" : \".rel.plt\";\n  relplt = bfd_get_section_by_name (abfd, relplt_name);\n  if (relplt == NULL)\n    return 0;\n\n  hdr = &elf_section_data (relplt)->this_hdr;\n  if (hdr->sh_link != elf_dynsymtab (abfd)\n      || (hdr->sh_type != SHT_REL && hdr->sh_type != SHT_RELA))\n    return 0;\n\n  plt = bfd_get_section_by_name (abfd, \".plt\");\n  if (plt == NULL)\n    return 0;\n\n  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;\n  if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))\n    return -1;\n\n  count = relplt->size / hdr->sh_entsize;\n  size = count * sizeof (asymbol);\n  p = relplt->relocation;\n  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)\n    {\n      size += strlen ((*p->sym_ptr_ptr)->name) + sizeof (\"@plt\");\n      if (p->addend != 0)\n\t{\n#ifdef BFD64\n\t  size += sizeof (\"+0x\") - 1 + 8 + 8 * (bed->s->elfclass == ELFCLASS64);\n#else\n\t  size += sizeof (\"+0x\") - 1 + 8;\n#endif\n\t}\n    }\n\n  s = *ret = (asymbol *) bfd_malloc (size);\n  if (s == NULL)\n    return -1;\n\n  names = (char *) (s + count);\n  p = relplt->relocation;\n  n = 0;\n  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)\n    {\n      size_t len;\n      bfd_vma addr;\n\n      addr = bed->plt_sym_val (i, plt, p);\n      if (addr == (bfd_vma) -1)\n\tcontinue;\n\n      *s = **p->sym_ptr_ptr;\n      /* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL set.  Since\n\t we are defining a symbol, ensure one of them is set.  */\n      if ((s->flags & BSF_LOCAL) == 0)\n\ts->flags |= BSF_GLOBAL;\n      s->flags |= BSF_SYNTHETIC;\n      s->section = plt;\n      s->value = addr - plt->vma;\n      s->name = names;\n      s->udata.p = NULL;\n      len = strlen ((*p->sym_ptr_ptr)->name);\n      memcpy (names, (*p->sym_ptr_ptr)->name, len);\n      names += len;\n      if (p->addend != 0)\n\t{\n\t  char buf[30], *a;\n\n\t  memcpy (names, \"+0x\", sizeof (\"+0x\") - 1);\n\t  names += sizeof (\"+0x\") - 1;\n\t  bfd_sprintf_vma (abfd, buf, p->addend);\n\t  for (a = buf; *a == '0'; ++a)\n\t    ;\n\t  len = strlen (a);\n\t  memcpy (names, a, len);\n\t  names += len;\n\t}\n      memcpy (names, \"@plt\", sizeof (\"@plt\"));\n      names += sizeof (\"@plt\");\n      ++s, ++n;\n    }\n\n  return n;\n}"
}