{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Message": "Access to field 'bpi' results in a dereference of a null pointer (loaded from variable 'b')",
    "Code_line": "\t\tlineno = b->bpi->source_line;",
    "Code_function": "set_breakpoint(CMDARG *arg, bool temporary)\n{\n\tint lineno;\n\tBREAKPOINT *b = NULL;\n\tINSTRUCTION *rp, *ip;\n\tNODE *func;\n\tSRCFILE *s = cur_srcfile;\n\tchar *src = cur_srcfile->src;\n\n\tif (arg == NULL) {\n/*\n* (From GDB Documentation):\n*\n* When called without any arguments, break sets a breakpoint at the next instruction\n* to be executed in the selected stack frame (see section Examining the Stack).\n* In any selected frame but the innermost, this makes your program stop as soon\n* as control returns to that frame. This is similar to the effect of a finish command\n* in the frame inside the selected frame--except that finish does not leave an\n* active breakpoint. If you use break without an argument in the innermost frame,\n* GDB stops the next time it reaches the current location; this may be useful\n* inside loops.\n* GDB normally ignores breakpoints when it resumes execution, until at least\n* one instruction has been executed. If it did not do this,\n* you would be unable to proceed past a breakpoint without first disabling the\n* breakpoint. This rule applies whether or not the breakpoint already existed\n* when your program stopped.\n*/\n\t\tCHECK_PROG_RUNNING();\n\t\tif (cur_frame == 0) {\n\t\t\tsrc = source;\n\t\t\tip = cur_pc;\n\t\t} else {\n\t\t\tNODE *f;\n\t\t\tf = find_frame(cur_frame);\n\t\t\tsrc = f->vname;\n\t\t\tip = (INSTRUCTION *) find_frame(cur_frame - 1)->reti;  /* Op_func_call */\n\t\t}\n\t\trp = find_rule(src, ip->source_line);\n\t\tassert(rp != NULL);\n\t\tif ((b = set_breakpoint_next(rp, ip)) == NULL)\n\t\t\tfprintf(out_fp, _(\"Can't set breakpoint in file `%s'\\n\"), src);\n\t\telse {\n\t\t\tif (cur_frame == 0) {\t/* stop next time */\n\t\t\t\tb->flags |= BP_IGNORE;\n\t\t\t\tb->ignore_count = 1;\n\t\t\t}\n\t\t\tif (temporary)\n\t\t\t\tb->flags |= BP_TEMP;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/* arg != NULL */\n\n\tswitch (arg->type) {\n\tcase D_string:\t/* break filename:lineno|function */\n\t\ts = source_find(arg->a_string);\n\t\targ = arg->next;\n\t\tif (s == NULL || arg == NULL\n\t\t\t\t|| (arg->type != D_int && arg->type != D_func))\n\t\t\treturn false;\n\t\tsrc = s->src;\n\t\tif (arg->type == D_func) /* break filename:function */\n\t\t\tgoto func;\n\t\telse\n\t\t\t/* fall through */\n\tcase D_int:\t\t/* break lineno */\n\t\tlineno = (int) arg->a_int;\n\t\tif (lineno <= 0 || lineno > s->srclines)\n\t\t\td_error(_(\"line number %d in file `%s' out of range\"), lineno, src);\n\t\telse {\n\t\t\trp = find_rule(src, lineno);\n\t\t\tif (rp == NULL)\n\t\t\t\tfprintf(out_fp, _(\"Can't find rule!!!\\n\"));\n\t\t\tif (rp == NULL || (b = set_breakpoint_at(rp, lineno, false)) == NULL)\n\t\t\t\tfprintf(out_fp, _(\"Can't set breakpoint at `%s':%d\\n\"),\n\t\t\t\t\t\tsrc, lineno);\n\t\t\tif (b != NULL && temporary)\n\t\t\t\tb->flags |= BP_TEMP;\n\t\t}\n\t\tbreak;\n\n\tcase D_func:\t/* break function */\nfunc:\n\t\tfunc = arg->a_node;\n\t\trp = func->code_ptr;\n\t\tif ((b = set_breakpoint_at(rp, rp->source_line, false)) == NULL)\n\t\t\tfprintf(out_fp, _(\"Can't set breakpoint in function `%s'\\n\"),\n\t\t\t\t\t\tfunc->vname);\n\t\telse if (temporary)\n\t\t\tb->flags |= BP_TEMP;\n\t\tlineno = b->bpi->source_line;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\t/* condition if any */\n\targ = arg->next;\n\tif (b != NULL && arg != NULL) {\n\t\tif (parse_condition(D_break, b->number, arg->a_string) == 0)\n\t\t\targ->a_string = NULL;\t/* don't let free_cmdarg free it */\n\t\telse\n\t\t\tfprintf(out_fp, _(\"breakpoint %d set at file `%s', line %d is unconditional\\n\"),\n\t\t\t\t\t\t\tb->number, src, lineno);\n\t}\n\treturn false;\n}"
}