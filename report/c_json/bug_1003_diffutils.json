{
    "Project": "diffutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "lib/tempname.c",
    "message": "Offset: [-61, 61] Size: 63.",
    "warning_function_name": "__gen_tempname",
    "warning_line": "XXXXXX[0] = letters[v % 62];",
    "warning_context": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n  struct_stat64 st;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      switch (kind)\n        {\n        case __GT_FILE:\n          fd = __open (tmpl,\n                       (flags & ~O_ACCMODE)\n                       | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n          break;\n\n        case __GT_DIR:\n          fd = __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n          break;\n\n        case __GT_NOCREATE:\n          /* This case is backward from the other three.  __gen_tempname\n             succeeds if __xstat fails because the name does not exist.\n             Note the continue to bypass the common logic at the bottom\n             of the loop.  */\n          if (__lxstat64 (_STAT_VER, tmpl, &st) < 0)\n            {\n              if (errno == ENOENT)\n                {\n                  __set_errno (save_errno);\n                  return 0;\n                }\n              else\n                /* Give up now. */\n                return -1;\n            }\n          continue;\n\n        default:\n          assert (! \"invalid KIND in __gen_tempname\");\n          abort ();\n        }\n"
}