{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "binutils/ieee.c",
    "message": "Offset: [1+max(489, `info->vars.tail->c`), `info->vars.tail->c` + 1] Size: 490 by call to `ieee_real_write_byte`.",
    "warning_function_name": "ieee_finish_compilation_unit",
    "warning_line": "|| ! ieee_write_byte (info, 6)",
    "warning_context": "static bfd_boolean\nieee_finish_compilation_unit (struct ieee_handle *info)\n{\n  struct ieee_range *r;\n\n  if (! ieee_buffer_emptyp (&info->types))\n    {\n      if (! ieee_change_buffer (info, &info->types)\n\t  || ! ieee_write_byte (info, (int) ieee_be_record_enum))\n\treturn FALSE;\n    }\n\n  if (! ieee_buffer_emptyp (&info->cxx))\n    {\n      /* Append any C++ information to the global function and\n         variable information.  */\n      assert (! ieee_buffer_emptyp (&info->vars));\n      if (! ieee_change_buffer (info, &info->vars))\n\treturn FALSE;\n\n      /* We put the pmisc records in a dummy procedure, just as the\n         MRI compiler does.  */\n      if (! ieee_write_byte (info, (int) ieee_bb_record_enum)\n\t  || ! ieee_write_byte (info, 6)\n\t  || ! ieee_write_number (info, 0)\n\t  || ! ieee_write_id (info, \"__XRYCPP\")\n\t  || ! ieee_write_number (info, 0)\n\t  || ! ieee_write_number (info, 0)\n\t  || ! ieee_write_number (info, info->highaddr - 1)\n\t  || ! ieee_append_buffer (info, &info->vars, &info->cxx)\n\t  || ! ieee_change_buffer (info, &info->vars)\n\t  || ! ieee_write_byte (info, (int) ieee_be_record_enum)\n\t  || ! ieee_write_number (info, info->highaddr - 1))\n\treturn FALSE;\n    }\n\n  if (! ieee_buffer_emptyp (&info->vars))\n    {\n      if (! ieee_change_buffer (info, &info->vars)\n\t  || ! ieee_write_byte (info, (int) ieee_be_record_enum))\n\treturn FALSE;\n    }\n\n  if (info->pending_lineno_filename != NULL)\n    {\n      /* Force out the pending line number.  */\n      if (! ieee_lineno ((void *) info, (const char *) NULL, 0, (bfd_vma) -1))\n\treturn FALSE;\n    }\n  if (! ieee_buffer_emptyp (&info->linenos))\n    {\n      if (! ieee_change_buffer (info, &info->linenos)\n\t  || ! ieee_write_byte (info, (int) ieee_be_record_enum))\n\treturn FALSE;\n      if (filename_cmp (info->filename, info->lineno_filename) != 0)\n\t{\n\t  /* We were not in the main file.  We just closed the\n             included line number block, and now we must close the\n             main line number block.  */\n\t  if (! ieee_write_byte (info, (int) ieee_be_record_enum))\n\t    return FALSE;\n\t}\n    }\n\n  if (! ieee_append_buffer (info, &info->data, &info->types)\n      || ! ieee_append_buffer (info, &info->data, &info->vars)\n      || ! ieee_append_buffer (info, &info->data, &info->linenos))\n    return FALSE;\n\n  /* Build BB10/BB11 blocks based on the ranges we recorded.  */\n  if (! ieee_change_buffer (info, &info->data))\n    return FALSE;\n\n  if (! ieee_write_byte (info, (int) ieee_bb_record_enum)\n      || ! ieee_write_byte (info, 10)\n      || ! ieee_write_number (info, 0)\n      || ! ieee_write_id (info, info->modname)\n      || ! ieee_write_id (info, \"\")\n      || ! ieee_write_number (info, 0)\n      || ! ieee_write_id (info, \"GNU objcopy\"))\n    return FALSE;\n\n  for (r = info->ranges; r != NULL; r = r->next)\n    {\n      bfd_vma low, high;\n      asection *s;\n      int kind;\n\n      low = r->low;\n      high = r->high;\n\n      /* Find the section corresponding to this range.  */\n      for (s = info->abfd->sections; s != NULL; s = s->next)\n\t{\n\t  if (bfd_get_section_vma (info->abfd, s) <= low\n\t      && high <= (bfd_get_section_vma (info->abfd, s)\n\t\t\t  + bfd_section_size (info->abfd, s)))\n\t    break;\n\t}\n\n      if (s == NULL)\n"
}