{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/colors.c",
    "message": "The value read from mode was never initialized.",
    "warning_function_name": "_rl_print_color_indicator",
    "warning_line": "else if (S_ISCHR (mode))",
    "warning_context": "  int stat_ok;\n\n  name = f;\n\n  /* This should already have undergone tilde expansion */\n  filename = 0;\n  if (rl_filename_stat_hook)\n    {\n      filename = savestring (f);\n      (*rl_filename_stat_hook) (&filename);\n      name = filename;\n    }\n\n#if defined (HAVE_LSTAT)\n  stat_ok = lstat(name, &astat);\n#else\n  stat_ok = stat(name, &astat);\n#endif\n  if( stat_ok == 0 ) {\n    mode = astat.st_mode;\n    linkok = 1; //f->linkok;\n  }\n  else\n    linkok = -1;\n\n  /* Is this a nonexistent file?  If so, linkok == -1.  */\n\n  if (linkok == -1 && _rl_color_indicator[C_MISSING].string != NULL)\n    colored_filetype = C_MISSING;\n  else if(stat_ok != 0)\n    {\n      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n      colored_filetype = filetype_indicator[normal]; //f->filetype];\n    }\n  else\n    {\n      if (S_ISREG (mode))\n        {\n          colored_filetype = C_FILE;\n\n          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n            colored_filetype = C_SETUID;\n          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n            colored_filetype = C_SETGID;\n          else if (is_colored (C_CAP) && 0) //f->has_capability)\n            colored_filetype = C_CAP;\n          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n            colored_filetype = C_EXEC;\n          else if ((1 < astat.st_nlink) && is_colored (C_MULTIHARDLINK))\n            colored_filetype = C_MULTIHARDLINK;\n        }\n      else if (S_ISDIR (mode))\n        {\n          colored_filetype = C_DIR;\n\n#if defined (S_ISVTX)\n          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n              && is_colored (C_STICKY_OTHER_WRITABLE))\n            colored_filetype = C_STICKY_OTHER_WRITABLE;\n          else\n#endif\n          if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n            colored_filetype = C_OTHER_WRITABLE;\n#if defined (S_ISVTX)\n          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n            colored_filetype = C_STICKY;\n#endif\n        }\n      else if (S_ISLNK (mode))\n        colored_filetype = ((linkok == 0\n                 && (!strncmp (_rl_color_indicator[C_LINK].string, \"target\", 6)\n                     || _rl_color_indicator[C_ORPHAN].string))\n                ? C_ORPHAN : C_LINK);\n      else if (S_ISFIFO (mode))\n        colored_filetype = C_FIFO;\n      else if (S_ISSOCK (mode))\n        colored_filetype = C_SOCK;\n      else if (S_ISBLK (mode))\n        colored_filetype = C_BLK;\n      else if (S_ISCHR (mode))\n        colored_filetype = C_CHR;\n      else\n        {\n          /* Classify a file of some other type as C_ORPHAN.  */\n          colored_filetype = C_ORPHAN;\n        }\n    }\n\n  /* Check the file's suffix only if still classified as C_FILE.  */\n  ext = NULL;\n  if (colored_filetype == C_FILE)\n    {\n      /* Test if NAME has a recognized suffix.  */\n      len = strlen (name);\n      name += len;\t\t/* Pointer to final \\0.  */\n      for (ext = _rl_color_ext_list; ext != NULL; ext = ext->next)\n        {\n          if (ext->ext.len <= len\n              && strncmp (name - ext->ext.len, ext->ext.string,\n                          ext->ext.len) == 0)\n            break;\n"
}