{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from ofifo was never initialized.",
    "Code_line": "      if (nfifo > ofifo)",
    "Code_function": "execute_command_internal (command, asynchronous, pipe_in, pipe_out,\n\t\t\t  fds_to_close)\n     COMMAND *command;\n     int asynchronous;\n     int pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int exec_result, user_subshell, invert, ignore_return, was_error_trap;\n  REDIRECT *my_undo_list, *exec_undo_list;\n  char *tcmd;\n  volatile int last_pid;\n  volatile int save_line_number;\n#if defined (PROCESS_SUBSTITUTION)\n  volatile int ofifo, nfifo, osize, saved_fifo;\n  volatile char *ofifo_list;\n#endif\n\n  if (breaking || continuing)\n    return (last_command_exit_value);\n  if (command == 0 || read_but_dont_execute)\n    return (EXECUTION_SUCCESS);\n\n  QUIT;\n  run_pending_traps ();\n\n#if 0\n  if (running_trap == 0)\n#endif\n    currently_executing_command = command;\n\n  invert = (command->flags & CMD_INVERT_RETURN) != 0;\n\n  /* If we're inverting the return value and `set -e' has been executed,\n     we don't want a failing command to inadvertently cause the shell\n     to exit. */\n  if (exit_immediately_on_error && invert)\t/* XXX */\n    command->flags |= CMD_IGNORE_RETURN;\t/* XXX */\n\n  exec_result = EXECUTION_SUCCESS;\n\n  /* If a command was being explicitly run in a subshell, or if it is\n     a shell control-structure, and it has a pipe, then we do the command\n     in a subshell. */\n  if (command->type == cm_subshell && (command->flags & CMD_NO_FORK))\n    return (execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close));\n\n#if defined (COPROCESS_SUPPORT)\n  if (command->type == cm_coproc)\n    return (execute_coproc (command, pipe_in, pipe_out, fds_to_close));\n#endif\n\n  user_subshell = command->type == cm_subshell || ((command->flags & CMD_WANT_SUBSHELL) != 0);\n\n  if (command->type == cm_subshell ||\n      (command->flags & (CMD_WANT_SUBSHELL|CMD_FORCE_SUBSHELL)) ||\n      (shell_control_structure (command->type) &&\n       (pipe_out != NO_PIPE || pipe_in != NO_PIPE || asynchronous)))\n    {\n      pid_t paren_pid;\n      int s;\n\n      /* Fork a subshell, turn off the subshell bit, turn off job\n\t control and call execute_command () on the command again. */\n      line_number_for_err_trap = line_number;\n      tcmd = make_command_string (command);\n      paren_pid = make_child (savestring (tcmd), asynchronous);\n\n      if (user_subshell && signal_is_trapped (ERROR_TRAP) &&\n\t  signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n\t{\n\t  FREE (the_printed_command_except_trap);\n\t  the_printed_command_except_trap = savestring (the_printed_command);\n\t}\n\n      if (paren_pid == 0)\n        {\n\t  /* We want to run the exit trap for forced {} subshells, and we\n\t     want to note this before execute_in_subshell modifies the\n\t     COMMAND struct.  Need to keep in mind that execute_in_subshell\n\t     runs the exit trap for () subshells itself. */\n\t  /* This handles { command; } & */\n\t  s = user_subshell == 0 && command->type == cm_group && pipe_in == NO_PIPE && pipe_out == NO_PIPE && asynchronous;\n\t  /* run exit trap for : | { ...; } and { ...; } | : */\n\t  /* run exit trap for : | ( ...; ) and ( ...; ) | : */\n\t  s += user_subshell == 0 && command->type == cm_group && (pipe_in != NO_PIPE || pipe_out != NO_PIPE) && asynchronous == 0;\n\n\t  last_command_exit_value = execute_in_subshell (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n\t  if (s)\n\t    subshell_exit (last_command_exit_value);\n\t  else\n\t    exit (last_command_exit_value);\n\t  /* NOTREACHED */\n        }\n      else\n\t{\n\t  close_pipes (pipe_in, pipe_out);\n\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n\t  if (variable_context == 0)\t/* wait until shell function completes */\n\t    unlink_fifo_list ();\n#endif\n\t  /* If we are part of a pipeline, and not the end of the pipeline,\n\t     then we should simply return and let the last command in the\n\t     pipe be waited for.  If we are not in a pipeline, or are the\n\t     last command in the pipeline, then we wait for the subshell\n\t     and return its exit status as usual. */\n\t  if (pipe_out != NO_PIPE)\n\t    return (EXECUTION_SUCCESS);\n\n\t  stop_pipeline (asynchronous, (COMMAND *)NULL);\n\n\t  if (asynchronous == 0)\n\t    {\n\t      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n\t      invert = (command->flags & CMD_INVERT_RETURN) != 0;\n\t      ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n\t      exec_result = wait_for (paren_pid);\n\n\t      /* If we have to, invert the return value. */\n\t      if (invert)\n\t\texec_result = ((exec_result == EXECUTION_SUCCESS)\n\t\t\t\t? EXECUTION_FAILURE\n\t\t\t\t: EXECUTION_SUCCESS);\n\n\t      last_command_exit_value = exec_result;\n\t      if (user_subshell && was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t\t{\n\t\t  save_line_number = line_number;\n\t\t  line_number = line_number_for_err_trap;\n\t\t  run_error_trap ();\n\t\t  line_number = save_line_number;\n\t\t}\n\n\t      if (user_subshell && ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t\t{\n\t\t  run_pending_traps ();\n\t\t  jump_to_top_level (ERREXIT);\n\t\t}\n\n\t      return (last_command_exit_value);\n\t    }\n\t  else\n\t    {\n\t      DESCRIBE_PID (paren_pid);\n\n\t      run_pending_traps ();\n\n\t      /* Posix 2013 2.9.3.1: \"the exit status of an asynchronous list\n\t\t shall be zero.\" */\n\t      last_command_exit_value = 0;\n\t      return (EXECUTION_SUCCESS);\n\t    }\n\t}\n    }\n\n#if defined (COMMAND_TIMING)\n  if (command->flags & CMD_TIME_PIPELINE)\n    {\n      if (asynchronous)\n\t{\n\t  command->flags |= CMD_FORCE_SUBSHELL;\n\t  exec_result = execute_command_internal (command, 1, pipe_in, pipe_out, fds_to_close);\n\t}\n      else\n\t{\n\t  exec_result = time_command (command, asynchronous, pipe_in, pipe_out, fds_to_close);\n#if 0\n\t  if (running_trap == 0)\n#endif\n\t    currently_executing_command = (COMMAND *)NULL;\n\t}\n      return (exec_result);\n    }\n#endif /* COMMAND_TIMING */\n\n  if (shell_control_structure (command->type) && command->redirects)\n    stdin_redir = stdin_redirects (command->redirects);\n\n#if defined (PROCESS_SUBSTITUTION)\n  if (variable_context != 0)\n    {\n      ofifo = num_fifos ();\n      ofifo_list = copy_fifo_list ((int *)&osize);\n      saved_fifo = 1;\n    }\n  else\n    saved_fifo = 0;\n#endif\n\n  /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input\n     redirection.)  */\n  if (do_redirections (command->redirects, RX_ACTIVE|RX_UNDOABLE) != 0)\n    {\n      cleanup_redirects (redirection_undo_list);\n      redirection_undo_list = (REDIRECT *)NULL;\n      dispose_exec_redirects ();\n#if defined (PROCESS_SUBSTITUTION)\n      if (saved_fifo)\n\tfree ((void *)ofifo_list);\n#endif\n      return (last_command_exit_value = EXECUTION_FAILURE);\n    }\n\n  if (redirection_undo_list)\n    {\n      /* XXX - why copy here? */\n      my_undo_list = (REDIRECT *)copy_redirects (redirection_undo_list);\n      dispose_redirects (redirection_undo_list);\n      redirection_undo_list = (REDIRECT *)NULL;\n    }\n  else\n    my_undo_list = (REDIRECT *)NULL;\n\n  if (exec_redirection_undo_list)\n    {\n      /* XXX - why copy here? */\n      exec_undo_list = (REDIRECT *)copy_redirects (exec_redirection_undo_list);\n      dispose_redirects (exec_redirection_undo_list);\n      exec_redirection_undo_list = (REDIRECT *)NULL;\n    }\n  else\n    exec_undo_list = (REDIRECT *)NULL;\n\n  if (my_undo_list || exec_undo_list)\n    begin_unwind_frame (\"loop_redirections\");\n\n  if (my_undo_list)\n    add_unwind_protect ((Function *)cleanup_redirects, my_undo_list);\n\n  if (exec_undo_list)\n    add_unwind_protect ((Function *)dispose_redirects, exec_undo_list);\n\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n  QUIT;\n\n  switch (command->type)\n    {\n    case cm_simple:\n      {\n\tsave_line_number = line_number;\n\t/* We can't rely on variables retaining their values across a\n\t   call to execute_simple_command if a longjmp occurs as the\n\t   result of a `return' builtin.  This is true for sure with gcc. */\n#if defined (RECYCLES_PIDS)\n\tlast_made_pid = NO_PID;\n#endif\n\tlast_pid = last_made_pid;\n\twas_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n\n\tif (ignore_return && command->value.Simple)\n\t  command->value.Simple->flags |= CMD_IGNORE_RETURN;\n\tif (command->flags & CMD_STDIN_REDIR)\n\t  command->value.Simple->flags |= CMD_STDIN_REDIR;\n\n\tline_number_for_err_trap = line_number = command->value.Simple->line;\n\texec_result =\n\t  execute_simple_command (command->value.Simple, pipe_in, pipe_out,\n\t\t\t\t  asynchronous, fds_to_close);\n\tline_number = save_line_number;\n\n\t/* The temporary environment should be used for only the simple\n\t   command immediately following its definition. */\n\tdispose_used_env_vars ();\n\n#if (defined (ultrix) && defined (mips)) || defined (C_ALLOCA)\n\t/* Reclaim memory allocated with alloca () on machines which\n\t   may be using the alloca emulation code. */\n\t(void) alloca (0);\n#endif /* (ultrix && mips) || C_ALLOCA */\n\n\t/* If we forked to do the command, then we must wait_for ()\n\t   the child. */\n\n\t/* XXX - this is something to watch out for if there are problems\n\t   when the shell is compiled without job control.  Don't worry about\n\t   whether or not last_made_pid == last_pid; already_making_children\n\t   tells us whether or not there are unwaited-for children to wait\n\t   for and reap. */\n\tif (already_making_children && pipe_out == NO_PIPE)\n\t  {\n\t    stop_pipeline (asynchronous, (COMMAND *)NULL);\n\n\t    if (asynchronous)\n\t      {\n\t\tDESCRIBE_PID (last_made_pid);\n\t      }\n\t    else\n#if !defined (JOB_CONTROL)\n\t      /* Do not wait for asynchronous processes started from\n\t\t startup files. */\n\t    if (last_made_pid != last_asynchronous_pid)\n#endif\n\t    /* When executing a shell function that executes other\n\t       commands, this causes the last simple command in\n\t       the function to be waited for twice.  This also causes\n\t       subshells forked to execute builtin commands (e.g., in\n\t       pipelines) to be waited for twice. */\n\t      exec_result = wait_for (last_made_pid);\n\t  }\n      }\n\n      /* 2009/02/13 -- pipeline failure is processed elsewhere.  This handles\n\t only the failure of a simple command. */\n      if (was_error_trap && ignore_return == 0 && invert == 0 && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 &&\n\t  ((posixly_correct && interactive == 0 && special_builtin_failed) ||\n\t   (exit_immediately_on_error && pipe_in == NO_PIPE && pipe_out == NO_PIPE && exec_result != EXECUTION_SUCCESS)))\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n\n    case cm_for:\n      if (ignore_return)\n\tcommand->value.For->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_for_command (command->value.For);\n      break;\n\n#if defined (ARITH_FOR_COMMAND)\n    case cm_arith_for:\n      if (ignore_return)\n\tcommand->value.ArithFor->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_arith_for_command (command->value.ArithFor);\n      break;\n#endif\n\n#if defined (SELECT_COMMAND)\n    case cm_select:\n      if (ignore_return)\n\tcommand->value.Select->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_select_command (command->value.Select);\n      break;\n#endif\n\n    case cm_case:\n      if (ignore_return)\n\tcommand->value.Case->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_case_command (command->value.Case);\n      break;\n\n    case cm_while:\n      if (ignore_return)\n\tcommand->value.While->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_while_command (command->value.While);\n      break;\n\n    case cm_until:\n      if (ignore_return)\n\tcommand->value.While->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_until_command (command->value.While);\n      break;\n\n    case cm_if:\n      if (ignore_return)\n\tcommand->value.If->flags |= CMD_IGNORE_RETURN;\n      exec_result = execute_if_command (command->value.If);\n      break;\n\n    case cm_group:\n\n      /* This code can be executed from either of two paths: an explicit\n\t '{}' command, or via a function call.  If we are executed via a\n\t function call, we have already taken care of the function being\n\t executed in the background (down there in execute_simple_command ()),\n\t and this command should *not* be marked as asynchronous.  If we\n\t are executing a regular '{}' group command, and asynchronous == 1,\n\t we must want to execute the whole command in the background, so we\n\t need a subshell, and we want the stuff executed in that subshell\n\t (this group command) to be executed in the foreground of that\n\t subshell (i.e. there will not be *another* subshell forked).\n\n\t What we do is to force a subshell if asynchronous, and then call\n\t execute_command_internal again with asynchronous still set to 1,\n\t but with the original group command, so the printed command will\n\t look right.\n\n\t The code above that handles forking off subshells will note that\n\t both subshell and async are on, and turn off async in the child\n\t after forking the subshell (but leave async set in the parent, so\n\t the normal call to describe_pid is made).  This turning off\n\t async is *crucial*; if it is not done, this will fall into an\n\t infinite loop of executions through this spot in subshell after\n\t subshell until the process limit is exhausted. */\n\n      if (asynchronous)\n\t{\n\t  command->flags |= CMD_FORCE_SUBSHELL;\n\t  exec_result =\n\t    execute_command_internal (command, 1, pipe_in, pipe_out,\n\t\t\t\t      fds_to_close);\n\t}\n      else\n\t{\n\t  if (ignore_return && command->value.Group->command)\n\t    command->value.Group->command->flags |= CMD_IGNORE_RETURN;\n\t  exec_result =\n\t    execute_command_internal (command->value.Group->command,\n\t\t\t\t      asynchronous, pipe_in, pipe_out,\n\t\t\t\t      fds_to_close);\n\t}\n      break;\n\n    case cm_connection:\n      exec_result = execute_connection (command, asynchronous,\n\t\t\t\t\tpipe_in, pipe_out, fds_to_close);\n      break;\n\n#if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n      if (ignore_return)\n\tcommand->value.Arith->flags |= CMD_IGNORE_RETURN;\n      line_number_for_err_trap = save_line_number = line_number;\n      exec_result = execute_arith_command (command->value.Arith);\n      line_number = save_line_number;\n\n      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  save_line_number = line_number;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n#endif\n\n#if defined (COND_COMMAND)\n    case cm_cond:\n      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n      if (ignore_return)\n\tcommand->value.Cond->flags |= CMD_IGNORE_RETURN;\n\n      line_number_for_err_trap = save_line_number = line_number;\n      exec_result = execute_cond_command (command->value.Cond);\n      line_number = save_line_number;\n\n      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  save_line_number = line_number;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n#endif\n\n    case cm_function_def:\n      exec_result = execute_intern_function (command->value.Function_def->name,\n\t\t\t\t\t     command->value.Function_def);\n      break;\n\n    default:\n      command_error (\"execute_command\", CMDERR_BADTYPE, command->type, 0);\n    }\n\n  if (my_undo_list)\n    {\n      do_redirections (my_undo_list, RX_ACTIVE);\n      dispose_redirects (my_undo_list);\n    }\n\n  if (exec_undo_list)\n    dispose_redirects (exec_undo_list);\n\n  if (my_undo_list || exec_undo_list)\n    discard_unwind_frame (\"loop_redirections\");\n\n#if defined (PROCESS_SUBSTITUTION)\n  if (saved_fifo)\n    {\n      nfifo = num_fifos ();\n      if (nfifo > ofifo)\n\tclose_new_fifos ((char *)ofifo_list, osize);\n      free ((void *)ofifo_list);\n    }\n#endif\n\n  /* Invert the return value if we have to */\n  if (invert)\n    exec_result = (exec_result == EXECUTION_SUCCESS)\n\t\t    ? EXECUTION_FAILURE\n\t\t    : EXECUTION_SUCCESS;\n\n#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)\n  /* This is where we set PIPESTATUS from the exit status of the appropriate\n     compound commands (the ones that look enough like simple commands to\n     cause confusion).  We might be able to optimize by not doing this if\n     subshell_environment != 0. */\n  switch (command->type)\n    {\n#  if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n#  endif\n#  if defined (COND_COMMAND)\n    case cm_cond:\n#  endif\n      set_pipestatus_from_exit (exec_result);\n      break;\n    }\n#endif\n\n  last_command_exit_value = exec_result;\n  run_pending_traps ();\n#if 0\n  if (running_trap == 0)\n#endif\n    currently_executing_command = (COMMAND *)NULL;\n\n  return (last_command_exit_value);\n}"
}