{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from old_interactive was never initialized.",
    "Code_line": "\tinteractive = old_interactive;",
    "Code_function": "_evalfile (filename, flags)\n     const char *filename;\n     int flags;\n{\n  volatile int old_interactive;\n  procenv_t old_return_catch;\n  int return_val, fd, result, pflags, i, nnull;\n  ssize_t nr;\t\t\t/* return value from read(2) */\n  char *string;\n  struct stat finfo;\n  size_t file_size;\n  sh_vmsg_func_t *errfunc;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *funcname_v, *nfv, *bash_source_v, *bash_lineno_v;\n  ARRAY *funcname_a, *bash_source_a, *bash_lineno_a;\n#  if defined (DEBUGGER)\n  SHELL_VAR *bash_argv_v, *bash_argc_v;\n  ARRAY *bash_argv_a, *bash_argc_a;\n#  endif\n  char *t, tt[2];\n#endif\n\n  USE_VAR(pflags);\n\n#if defined (ARRAY_VARS)\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", funcname_v, funcname_a);\n  GET_ARRAY_FROM_VAR (\"BASH_SOURCE\", bash_source_v, bash_source_a);\n  GET_ARRAY_FROM_VAR (\"BASH_LINENO\", bash_lineno_v, bash_lineno_a);\n#  if defined (DEBUGGER)\n  GET_ARRAY_FROM_VAR (\"BASH_ARGV\", bash_argv_v, bash_argv_a);\n  GET_ARRAY_FROM_VAR (\"BASH_ARGC\", bash_argc_v, bash_argc_a);\n#  endif\n#endif\n\n  fd = open (filename, O_RDONLY);\n\n  if (fd < 0 || (fstat (fd, &finfo) == -1))\n    {\n      i = errno;\n      if (fd >= 0)\n\tclose (fd);\n      errno = i;\n\nfile_error_and_exit:\n      if (((flags & FEVAL_ENOENTOK) == 0) || errno != ENOENT)\n\tfile_error (filename);\n\n      if (flags & FEVAL_LONGJMP)\n\t{\n\t  last_command_exit_value = 1;\n\t  jump_to_top_level (EXITPROG);\n\t}\n\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE\n      \t\t\t\t      : ((errno == ENOENT) ? 0 : -1));\n    }\n\n  errfunc = ((flags & FEVAL_BUILTIN) ? builtin_error : internal_error);\n\n  if (S_ISDIR (finfo.st_mode))\n    {\n      (*errfunc) (_(\"%s: is a directory\"), filename);\n      close (fd);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);\n    }\n  else if ((flags & FEVAL_REGFILE) && S_ISREG (finfo.st_mode) == 0)\n    {\n      (*errfunc) (_(\"%s: not a regular file\"), filename);\n      close (fd);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);\n    }\n\n  file_size = (size_t)finfo.st_size;\n  /* Check for overflow with large files. */\n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      (*errfunc) (_(\"%s: file is too large\"), filename);\n      close (fd);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_FAILURE : -1);\n    }\n\n  if (S_ISREG (finfo.st_mode) && file_size <= SSIZE_MAX)\n    {\n      string = (char *)xmalloc (1 + file_size);\n      nr = read (fd, string, file_size);\n      if (nr >= 0)\n\tstring[nr] = '\\0';\n    }\n  else\n    nr = zmapfd (fd, &string, 0);\n\n  return_val = errno;\n  close (fd);\n  errno = return_val;\n\n  if (nr < 0)\t\t/* XXX was != file_size, not < 0 */\n    {\n      free (string);\n      goto file_error_and_exit;\n    }\n\n  if (nr == 0)\n    {\n      free (string);\n      return ((flags & FEVAL_BUILTIN) ? EXECUTION_SUCCESS : 1);\n    }\n\n  if ((flags & FEVAL_CHECKBINARY) &&\n      check_binary_file (string, (nr > 80) ? 80 : nr))\n    {\n      free (string);\n      (*errfunc) (_(\"%s: cannot execute binary file\"), filename);\n      return ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);\n    }\n\n  i = strlen (string);\n  if (i < nr)\n    {\n      for (nnull = i = 0; i < nr; i++)\n\tif (string[i] == '\\0')\n          {\n\t    memmove (string+i, string+i+1, nr - i);\n\t    nr--;\n\t    /* Even if the `check binary' flag is not set, we want to avoid\n\t       sourcing files with more than 256 null characters -- that\n\t       probably indicates a binary file. */\n\t    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)\n\t      {\n\t\tfree (string);\n\t\t(*errfunc) (_(\"%s: cannot execute binary file\"), filename);\n\t\treturn ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);\n\t      }\n          }\n    }\n\n  if (flags & FEVAL_UNWINDPROT)\n    {\n      begin_unwind_frame (\"_evalfile\");\n\n      unwind_protect_int (return_catch_flag);\n      unwind_protect_jmp_buf (return_catch);\n      if (flags & FEVAL_NONINT)\n\tunwind_protect_int (interactive);\n      unwind_protect_int (sourcelevel);\n    }\n  else\n    {\n      COPY_PROCENV (return_catch, old_return_catch);\n      if (flags & FEVAL_NONINT)\n\told_interactive = interactive;\n    }\n\n  if (flags & FEVAL_NONINT)\n    interactive = 0;\n\n  return_catch_flag++;\n  sourcelevel++;\n\n#if defined (ARRAY_VARS)\n  array_push (bash_source_a, (char *)filename);\n  t = itos (executing_line_number ());\n  array_push (bash_lineno_a, t);\n  free (t);\n  array_push (funcname_a, \"source\");\t/* not exactly right */\n#  if defined (DEBUGGER)\n  /* Have to figure out a better way to do this when `source' is supplied\n     arguments */\n  if ((flags & FEVAL_NOPUSHARGS) == 0)\n    {\n      array_push (bash_argv_a, (char *)filename);\n      tt[0] = '1'; tt[1] = '\\0';\n      array_push (bash_argc_a, tt);\n    }\n#  endif\n#endif\n\n  /* set the flags to be passed to parse_and_execute */\n  pflags = SEVAL_RESETLINE;\n  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;\n\n  if (flags & FEVAL_BUILTIN)\n    result = EXECUTION_SUCCESS;\n\n  return_val = setjmp_nosigs (return_catch);\n\n  /* If `return' was seen outside of a function, but in the script, then\n     force parse_and_execute () to clean up. */\n  if (return_val)\n    {\n      parse_and_execute_cleanup ();\n      result = return_catch_value;\n    }\n  else\n    result = parse_and_execute (string, filename, pflags);\n\n  if (flags & FEVAL_UNWINDPROT)\n    run_unwind_frame (\"_evalfile\");\n  else\n    {\n      if (flags & FEVAL_NONINT)\n\tinteractive = old_interactive;\n      return_catch_flag--;\n      sourcelevel--;\n      COPY_PROCENV (old_return_catch, return_catch);\n    }\n\n#if defined (ARRAY_VARS)\n  /* These two variables cannot be unset, and cannot be affected by the\n     sourced file. */\n  array_pop (bash_source_a);\n  array_pop (bash_lineno_a);\n\n  /* FUNCNAME can be unset, and so can potentially be changed by the\n     sourced file. */\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", nfv, funcname_a);\n  if (nfv == funcname_v)\n    array_pop (funcname_a);\n#  if defined (DEBUGGER)\n  if ((flags & FEVAL_NOPUSHARGS) == 0)\n    {\n      array_pop (bash_argc_a);\n      array_pop (bash_argv_a);\n    }\n#  endif\n#endif\n\n  return ((flags & FEVAL_BUILTIN) ? result : 1);\n}"
}