{
    "project": "combine",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/process_files.c",
    "message": "The value read from hash_index was never initialized.",
    "warning_function_name": "process_data_reference_matches",
    "warning_line": "if ((hash_index == -1 || keep_match != 1) && gi_reference_file_count != 0) {",
    "warning_context": "int\nprocess_data_reference_matches (data_output_fields, reference_file_number,\n\t\t\t\twrite_record, input_record_desc)\n     STRINGTYPE **data_output_fields;\n     int reference_file_number;\n     int *write_record;\n     STRINGTYPE *input_record_desc;\n{\n  STRINGTYPE *key_value;\n  int j;\n  int k;\n  HASHTYPE hash_index;\n  int first_written;\n\n  if (reference_file_number < gi_reference_file_count) {\n    /* Assemble key value. */\n    key_value = dstrnew ();\n    if (key_value == NULL)\n      FATAL_ERROR (_(\"unable to allocate memory\"));\n\n    find_input_ranges (key_value, input_record_desc,\n\t\t       REFINFO[reference_file_number].data_key_ranges,\n\t\t       REFINFO[reference_file_number].data_key_range_count,\n\t\t       REFINFO[reference_file_number].data_key_end_start,\n\t\t       gs_data_input_field_delimiter,\n\t\t       gi_data_input_field_delimiter_repeat,\n\t\t       gs_output_field_delimiter);\n\n    hash_index\n      = find_table_entry (key_value, REFINFO[reference_file_number].hash_table,\n\t\t\t  REFINFO[reference_file_number].hash_size);\n    }\n\n  do {\n    int keep_match;\n\n    keep_match = 1;\n\n#ifdef HAVE_LIBGUILE\n    if (gi_reference_file_count != 0 && hash_index != -1\n\t&& REFINFO[reference_file_number].ext_match_command != NULL) {\n      int ifield;\n      SCM return_val;\n      char *command_string;\n      int still_keep_match;\n\n      /* Given the values available from the reference and data records, send a guile command */\n      /* First make the fields available to guile */\n      for (ifield = 0;\n\t   ifield < gi_data_out_range_count + (gi_data_out_end_start != 0 ? 1\n\t\t\t\t\t       : 0); ifield++) {\n\tcreate_scheme_string_variable (&df_name_data_field, ifield + 1,\n\t\t\t\t       data_output_fields[ifield]);\n\t}\n\n      for (ifield = 0;\n\t   ifield\n\t   < REFINFO[reference_file_number].out_range_count\n\t   + (REFINFO[reference_file_number].out_end_start != 0 ? 1 : 0);\n\t   ifield++) {\n\tcreate_scheme_string_variable (&df_name_reference_field, ifield + 1,\n\t\t\t\t       REFINFO[reference_file_number]\n\t\t\t\t       .hash_table[hash_index]\n\t\t\t\t       .output_fields[ifield]);\n\t}\n\n\n      command_string\n\t= strdupdstr (REFINFO[reference_file_number].ext_match_command);\n      if (command_string == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      still_keep_match = eval_scheme_boolean_function (command_string);\n      free (command_string);\n      if (!still_keep_match)\n\tkeep_match = 0;\n      }\n#  endif /* HAVE_LIBGUILE */\n\n    if ((hash_index == -1 || keep_match != 1) && gi_reference_file_count != 0) {\n      /* If necessary, invalidate writing. */\n      if (gi_reference_file_count != 0\n\t  && REFINFO[reference_file_number].optional_ind == 0)\n\t*write_record = 0;\n      }\n    else if (gi_reference_file_count != 0 && keep_match == 1) {\n      /* We need to traverse the hierarchy if requested.  Otherwise, treat this match. */\n      if (REFINFO[reference_file_number].hrchy_key_range_count != 0\n\t  || REFINFO[reference_file_number].hrchy_key_end_start != 0) {\n\ttraverse_hierarchy (data_output_fields, reference_file_number,\n\t\t\t    write_record, input_record_desc, hash_index, 0);\n\t}\n      /* Update flags, counters, and sums. */\n      else\n\tupdate_counters (reference_file_number, hash_index, data_output_fields,\n\t\t\t input_record_desc);\n      }\n\n    if (keep_match != 1 || gi_reference_file_count == 0\n\t|| (REFINFO[reference_file_number].hrchy_key_range_count == 0\n\t    && REFINFO[reference_file_number].hrchy_key_end_start == 0)) {\n      /* Either continue with next reference file or write. */\n"
}