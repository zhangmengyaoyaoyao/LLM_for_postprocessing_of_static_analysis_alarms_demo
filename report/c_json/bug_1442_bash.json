{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      c = *bufp++;",
    "Code_function": "read_comsub (fd, quoted, rflag)\n     int fd, quoted;\n     int *rflag;\n{\n  char *istring, buf[128], *bufp, *s;\n  int istring_index, istring_size, c, tflag, skip_ctlesc, skip_ctlnul;\n  ssize_t bufn;\n\n  istring = (char *)NULL;\n  istring_index = istring_size = bufn = tflag = 0;\n\n  for (skip_ctlesc = skip_ctlnul = 0, s = ifs_value; s && *s; s++)\n    skip_ctlesc |= *s == CTLESC, skip_ctlnul |= *s == CTLNUL;\n\n  /* Read the output of the command through the pipe.  This may need to be\n     changed to understand multibyte characters in the future. */\n  while (1)\n    {\n      if (fd < 0)\n\tbreak;\n      if (--bufn <= 0)\n\t{\n\t  bufn = zread (fd, buf, sizeof (buf));\n\t  if (bufn <= 0)\n\t    break;\n\t  bufp = buf;\n\t}\n      c = *bufp++;\n\n      if (c == 0)\n\t{\n#if 0\n\t  internal_warning (\"read_comsub: ignored null byte in input\");\n#endif\n\t  continue;\n\t}\n\n      /* Add the character to ISTRING, possibly after resizing it. */\n      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size, DEFAULT_ARRAY_SIZE);\n\n      /* This is essentially quote_string inline */\n      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) /* || c == CTLESC || c == CTLNUL */)\n\tistring[istring_index++] = CTLESC;\n      /* Escape CTLESC and CTLNUL in the output to protect those characters\n\t from the rest of the word expansions (word splitting and globbing.)\n\t This is essentially quote_escapes inline. */\n      else if (skip_ctlesc == 0 && c == CTLESC)\n\t{\n\t  tflag |= W_HASCTLESC;\n\t  istring[istring_index++] = CTLESC;\n\t}\n      else if ((skip_ctlnul == 0 && c == CTLNUL) || (c == ' ' && (ifs_value && *ifs_value == 0)))\n\tistring[istring_index++] = CTLESC;\n\n      istring[istring_index++] = c;\n\n#if 0\n#if defined (__CYGWIN__)\n      if (c == '\\n' && istring_index > 1 && istring[istring_index - 2] == '\\r')\n\t{\n\t  istring_index--;\n\t  istring[istring_index - 1] = '\\n';\n\t}\n#endif\n#endif\n    }\n\n  if (istring)\n    istring[istring_index] = '\\0';\n\n  /* If we read no output, just return now and save ourselves some\n     trouble. */\n  if (istring_index == 0)\n    {\n      FREE (istring);\n      if (rflag)\n\t*rflag = tflag;\n      return (char *)NULL;\n    }\n\n  /* Strip trailing newlines from the output of the command. */\n  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n    {\n      while (istring_index > 0)\n\t{\n\t  if (istring[istring_index - 1] == '\\n')\n\t    {\n\t      --istring_index;\n\n\t      /* If the newline was quoted, remove the quoting char. */\n\t      if (istring[istring_index - 1] == CTLESC)\n\t\t--istring_index;\n\t    }\n\t  else\n\t    break;\n\t}\n      istring[istring_index] = '\\0';\n    }\n  else\n    strip_trailing (istring, istring_index - 1, 1);\n\n  if (rflag)\n    *rflag = tflag;\n  return istring;\n}"
}