{
    "Project": "apr",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [-1, +oo] Size: [8192, +oo].",
    "Code_line": "                *ch = '\\0';",
    "Code_function": "APR_DECLARE(apr_status_t) apr_proc_create(apr_proc_t *new,\n                                          const char *progname,\n                                          const char * const *args,\n                                          const char * const *env,\n                                          apr_procattr_t *attr,\n                                          apr_pool_t *pool)\n{\n    int i;\n    const char * const empty_envp[] = {NULL};\n\n    if (!env) { /* Specs require an empty array instead of NULL;\n                 * Purify will trigger a failure, even if many\n                 * implementations don't.\n                 */\n        env = empty_envp;\n    }\n\n    new->in = attr->parent_in;\n    new->err = attr->parent_err;\n    new->out = attr->parent_out;\n\n    if (attr->errchk) {\n        if (attr->currdir) {\n            if (access(attr->currdir, X_OK) == -1) {\n                /* chdir() in child wouldn't have worked */\n                return errno;\n            }\n        }\n\n        if (attr->cmdtype == APR_PROGRAM ||\n            attr->cmdtype == APR_PROGRAM_ENV ||\n            *progname == '/') {\n            /* for both of these values of cmdtype, caller must pass\n             * full path, so it is easy to check;\n             * caller can choose to pass full path for other\n             * values of cmdtype\n             */\n            if (access(progname, X_OK) == -1) {\n                /* exec*() in child wouldn't have worked */\n                return errno;\n            }\n        }\n        else {\n            /* todo: search PATH for progname then try to access it */\n        }\n    }\n\n    if ((new->pid = fork()) < 0) {\n        return errno;\n    }\n    else if (new->pid == 0) {\n        /* child process */\n\n        /*\n         * If we do exec cleanup before the dup2() calls to set up pipes\n         * on 0-2, we accidentally close the pipes used by programs like\n         * mod_cgid.\n         *\n         * If we do exec cleanup after the dup2() calls, cleanup can accidentally\n         * close our pipes which replaced any files which previously had\n         * descriptors 0-2.\n         *\n         * The solution is to kill the cleanup for the pipes, then do\n         * exec cleanup, then do the dup2() calls.\n         */\n\n        if (attr->child_in) {\n            apr_pool_cleanup_kill(apr_file_pool_get(attr->child_in),\n                                  attr->child_in, apr_unix_file_cleanup);\n        }\n\n        if (attr->child_out) {\n            apr_pool_cleanup_kill(apr_file_pool_get(attr->child_out),\n                                  attr->child_out, apr_unix_file_cleanup);\n        }\n\n        if (attr->child_err) {\n            apr_pool_cleanup_kill(apr_file_pool_get(attr->child_err),\n                                  attr->child_err, apr_unix_file_cleanup);\n        }\n\n        apr_pool_cleanup_for_exec();\n\n        if ((attr->child_in) && (attr->child_in->filedes == -1)) {\n            close(STDIN_FILENO);\n        }\n        else if (attr->child_in &&\n                 attr->child_in->filedes != STDIN_FILENO) {\n            dup2(attr->child_in->filedes, STDIN_FILENO);\n            apr_file_close(attr->child_in);\n        }\n\n        if ((attr->child_out) && (attr->child_out->filedes == -1)) {\n            close(STDOUT_FILENO);\n        }\n        else if (attr->child_out &&\n                 attr->child_out->filedes != STDOUT_FILENO) {\n            dup2(attr->child_out->filedes, STDOUT_FILENO);\n            apr_file_close(attr->child_out);\n        }\n\n        if ((attr->child_err) && (attr->child_err->filedes == -1)) {\n            close(STDERR_FILENO);\n        }\n        else if (attr->child_err &&\n                 attr->child_err->filedes != STDERR_FILENO) {\n            dup2(attr->child_err->filedes, STDERR_FILENO);\n            apr_file_close(attr->child_err);\n        }\n\n        apr_signal(SIGCHLD, SIG_DFL); /* not sure if this is needed or not */\n\n        if (attr->currdir != NULL) {\n            if (chdir(attr->currdir) == -1) {\n                if (attr->errfn) {\n                    attr->errfn(pool, errno, \"change of working directory failed\");\n                }\n                _exit(-1);   /* We have big problems, the child should exit. */\n            }\n        }\n\n        /* Only try to switch if we are running as root */\n        if (attr->gid != -1 && !geteuid()) {\n            if (setgid(attr->gid)) {\n                if (attr->errfn) {\n                    attr->errfn(pool, errno, \"setting of group failed\");\n                }\n                _exit(-1);   /* We have big problems, the child should exit. */\n            }\n        }\n\n        if (attr->uid != -1 && !geteuid()) {\n            if (setuid(attr->uid)) {\n                if (attr->errfn) {\n                    attr->errfn(pool, errno, \"setting of user failed\");\n                }\n                _exit(-1);   /* We have big problems, the child should exit. */\n            }\n        }\n\n        if (limit_proc(attr) != APR_SUCCESS) {\n            if (attr->errfn) {\n                attr->errfn(pool, errno, \"setting of resource limits failed\");\n            }\n            _exit(-1);   /* We have big problems, the child should exit. */\n        }\n\n        if (attr->cmdtype == APR_SHELLCMD ||\n            attr->cmdtype == APR_SHELLCMD_ENV) {\n            int onearg_len = 0;\n            const char *newargs[4];\n\n            newargs[0] = SHELL_PATH;\n            newargs[1] = \"-c\";\n\n            i = 0;\n            while (args[i]) {\n                onearg_len += strlen(args[i]);\n                onearg_len++; /* for space delimiter */\n                i++;\n            }\n\n            switch(i) {\n            case 0:\n                /* bad parameters; we're doomed */\n                break;\n            case 1:\n                /* no args, or caller already built a single string from\n                 * progname and args\n                 */\n                newargs[2] = args[0];\n                break;\n            default:\n            {\n                char *ch, *onearg;\n\n                ch = onearg = apr_palloc(pool, onearg_len);\n                i = 0;\n                while (args[i]) {\n                    size_t len = strlen(args[i]);\n\n                    memcpy(ch, args[i], len);\n                    ch += len;\n                    *ch = ' ';\n                    ++ch;\n                    ++i;\n                }\n                --ch; /* back up to trailing blank */\n                *ch = '\\0';\n                newargs[2] = onearg;\n            }\n            }\n\n            newargs[3] = NULL;\n\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n\n            if (attr->cmdtype == APR_SHELLCMD) {\n                execve(SHELL_PATH, (char * const *) newargs, (char * const *)env);\n            }\n            else {\n                execv(SHELL_PATH, (char * const *)newargs);\n            }\n        }\n        else if (attr->cmdtype == APR_PROGRAM) {\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n\n            execve(progname, (char * const *)args, (char * const *)env);\n        }\n        else if (attr->cmdtype == APR_PROGRAM_ENV) {\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n\n            execv(progname, (char * const *)args);\n        }\n        else {\n            /* APR_PROGRAM_PATH */\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n\n            execvp(progname, (char * const *)args);\n        }\n        if (attr->errfn) {\n            char *desc;\n\n            desc = apr_psprintf(pool, \"exec of '%s' failed\",\n                                progname);\n            attr->errfn(pool, errno, desc);\n        }\n\n        _exit(-1);  /* if we get here, there is a problem, so exit with an\n                     * error code. */\n    }\n\n    /* Parent process */\n    if (attr->child_in && (attr->child_in->filedes != -1)) {\n        apr_file_close(attr->child_in);\n    }\n\n    if (attr->child_out && (attr->child_out->filedes != -1)) {\n        apr_file_close(attr->child_out);\n    }\n\n    if (attr->child_err && (attr->child_err->filedes != -1)) {\n        apr_file_close(attr->child_err);\n    }\n\n    return APR_SUCCESS;\n}"
}