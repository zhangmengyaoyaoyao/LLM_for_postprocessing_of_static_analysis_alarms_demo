{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [4, +oo] (⇐ [0, +oo] + 4) Size: [1, +oo].",
    "Code_line": "      type = sym[TYPEOFF];",
    "Code_function": "_bfd_discard_section_stabs (bfd *abfd,\n\t\t\t    asection *stabsec,\n\t\t\t    void * psecinfo,\n\t\t\t    bfd_boolean (*reloc_symbol_deleted_p) (bfd_vma, void *),\n\t\t\t    void * cookie)\n{\n  bfd_size_type count, amt;\n  struct stab_section_info *secinfo;\n  bfd_byte *stabbuf = NULL;\n  bfd_byte *sym, *symend;\n  bfd_size_type skip;\n  bfd_size_type *pstridx;\n  int deleting;\n\n  if (stabsec->size == 0)\n    /* This file does not contain stabs debugging information.  */\n    return FALSE;\n\n  if (stabsec->size % STABSIZE != 0)\n    /* Something is wrong with the format of these stab symbols.\n       Don't try to optimize them.  */\n    return FALSE;\n\n  if ((stabsec->output_section != NULL\n       && bfd_is_abs_section (stabsec->output_section)))\n    /* At least one of the sections is being discarded from the\n       link, so we should just ignore them.  */\n    return FALSE;\n\n  /* We should have initialized our data in _bfd_link_section_stabs.\n     If there was some bizarre error reading the string sections, though,\n     we might not have.  Bail rather than asserting.  */\n  if (psecinfo == NULL)\n    return FALSE;\n\n  count = stabsec->rawsize / STABSIZE;\n  secinfo = (struct stab_section_info *) psecinfo;\n\n  /* Read the stabs information from abfd.  */\n  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf))\n    goto error_return;\n\n  /* Look through the stabs symbols and discard any information for\n     discarded functions.  */\n  skip = 0;\n  deleting = -1;\n\n  symend = stabbuf + stabsec->rawsize;\n  for (sym = stabbuf, pstridx = secinfo->stridxs;\n       sym < symend;\n       sym += STABSIZE, ++pstridx)\n    {\n      int type;\n\n      if (*pstridx == (bfd_size_type) -1)\n\t/* This stab was deleted in a previous pass.  */\n\tcontinue;\n\n      type = sym[TYPEOFF];\n\n      if (type == (int) N_FUN)\n\t{\n\t  int strx = bfd_get_32 (abfd, sym + STRDXOFF);\n\n\t  if (strx == 0)\n\t    {\n\t      if (deleting)\n\t\t{\n\t\t  skip++;\n\t\t  *pstridx = -1;\n\t\t}\n\t      deleting = -1;\n\t      continue;\n\t    }\n\t  deleting = 0;\n\t  if ((*reloc_symbol_deleted_p) (sym + VALOFF - stabbuf, cookie))\n\t    deleting = 1;\n\t}\n\n      if (deleting == 1)\n\t{\n\t  *pstridx = -1;\n\t  skip++;\n\t}\n      else if (deleting == -1)\n\t{\n\t  /* Outside of a function.  Check for deleted variables.  */\n\t  if (type == (int) N_STSYM || type == (int) N_LCSYM)\n\t    if ((*reloc_symbol_deleted_p) (sym + VALOFF - stabbuf, cookie))\n\t      {\n\t\t*pstridx = -1;\n\t\tskip ++;\n\t      }\n\t  /* We should also check for N_GSYM entries which reference a\n\t     deleted global, but those are less harmful to debuggers\n\t     and would require parsing the stab strings.  */\n\t}\n    }\n\n  free (stabbuf);\n  stabbuf = NULL;\n\n  /* Shrink the stabsec as needed.  */\n  stabsec->size -= skip * STABSIZE;\n  if (stabsec->size == 0)\n    stabsec->flags |= SEC_EXCLUDE | SEC_KEEP;\n\n  /* Recalculate the `cumulative_skips' array now that stabs have been\n     deleted for this section.  */\n\n  if (skip != 0)\n    {\n      bfd_size_type i, offset;\n      bfd_size_type *pskips;\n\n      if (secinfo->cumulative_skips == NULL)\n\t{\n\t  amt = count * sizeof (bfd_size_type);\n\t  secinfo->cumulative_skips = (bfd_size_type *) bfd_alloc (abfd, amt);\n\t  if (secinfo->cumulative_skips == NULL)\n\t    goto error_return;\n\t}\n\n      pskips = secinfo->cumulative_skips;\n      pstridx = secinfo->stridxs;\n      offset = 0;\n\n      for (i = 0; i < count; i++, pskips++, pstridx++)\n\t{\n\t  *pskips = offset;\n\t  if (*pstridx == (bfd_size_type) -1)\n\t    offset += STABSIZE;\n\t}\n\n      BFD_ASSERT (offset != 0);\n    }\n\n  return skip > 0;\n\n error_return:\n  if (stabbuf != NULL)\n    free (stabbuf);\n  return FALSE;\n}"
}