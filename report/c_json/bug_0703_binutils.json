{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "bfd/elf64-x86-64.c",
    "message": "Offset: [4+max(3, `rel->r_offset`), `rel->r_offset` + 4] (⇐ [max(3, `rel->r_offset`), `rel->r_offset`] + 4) Size: [1, +oo].",
    "warning_function_name": "elf_x86_64_check_tls_transition",
    "warning_line": "if (0xe8 != *(contents + offset + 4))",
    "warning_context": "\t  elf_section_data (sec)->this_hdr.contents = contents;\n\t}\n    }\n\n  htab = elf_x86_64_hash_table (info);\n  offset = rel->r_offset;\n  switch (r_type)\n    {\n    case R_X86_64_TLSGD:\n    case R_X86_64_TLSLD:\n      if ((rel + 1) >= relend)\n\treturn FALSE;\n\n      if (r_type == R_X86_64_TLSGD)\n\t{\n\t  /* Check transition from GD access model.  For 64bit, only\n\t\t.byte 0x66; leaq foo@tlsgd(%rip), %rdi\n\t\t.word 0x6666; rex64; call __tls_get_addr\n\t     can transit to different access model.  For 32bit, only\n\t\tleaq foo@tlsgd(%rip), %rdi\n\t\t.word 0x6666; rex64; call __tls_get_addr\n\t     can transit to different access model.  For largepic\n\t     we also support:\n\t        leaq foo@tlsgd(%rip), %rdi\n\t        movabsq $__tls_get_addr@pltoff, %rax\n\t        addq $rbx, %rax\n\t        call *%rax.  */\n\n\t  static const unsigned char call[] = { 0x66, 0x66, 0x48, 0xe8 };\n\t  static const unsigned char leaq[] = { 0x66, 0x48, 0x8d, 0x3d };\n\n\t  if ((offset + 12) > sec->size)\n\t    return FALSE;\n\n\t  if (memcmp (contents + offset + 4, call, 4) != 0)\n\t    {\n\t      if (!ABI_64_P (abfd)\n\t\t  || (offset + 19) > sec->size\n\t\t  || offset < 3\n\t\t  || memcmp (contents + offset - 3, leaq + 1, 3) != 0\n\t\t  || memcmp (contents + offset + 4, \"\\x48\\xb8\", 2) != 0\n\t\t  || memcmp (contents + offset + 14, \"\\x48\\x01\\xd8\\xff\\xd0\", 5)\n\t\t     != 0)\n\t\treturn FALSE;\n\t      largepic = TRUE;\n\t    }\n\t  else if (ABI_64_P (abfd))\n\t    {\n\t      if (offset < 4\n\t\t  || memcmp (contents + offset - 4, leaq, 4) != 0)\n\t\treturn FALSE;\n\t    }\n\t  else\n\t    {\n\t      if (offset < 3\n\t\t  || memcmp (contents + offset - 3, leaq + 1, 3) != 0)\n\t\treturn FALSE;\n\t    }\n\t}\n      else\n\t{\n\t  /* Check transition from LD access model.  Only\n\t\tleaq foo@tlsld(%rip), %rdi;\n\t\tcall __tls_get_addr\n\t     can transit to different access model.  For largepic\n\t     we also support:\n\t        leaq foo@tlsld(%rip), %rdi\n\t        movabsq $__tls_get_addr@pltoff, %rax\n\t        addq $rbx, %rax\n\t        call *%rax.  */\n\n\t  static const unsigned char lea[] = { 0x48, 0x8d, 0x3d };\n\n\t  if (offset < 3 || (offset + 9) > sec->size)\n\t    return FALSE;\n\n\t  if (memcmp (contents + offset - 3, lea, 3) != 0)\n\t    return FALSE;\n\n\t  if (0xe8 != *(contents + offset + 4))\n\t    {\n\t      if (!ABI_64_P (abfd)\n\t\t  || (offset + 19) > sec->size\n\t\t  || memcmp (contents + offset + 4, \"\\x48\\xb8\", 2) != 0\n\t\t  || memcmp (contents + offset + 14, \"\\x48\\x01\\xd8\\xff\\xd0\", 5)\n\t\t     != 0)\n\t\treturn FALSE;\n\t      largepic = TRUE;\n\t    }\n\t}\n\n      r_symndx = htab->r_sym (rel[1].r_info);\n      if (r_symndx < symtab_hdr->sh_info)\n\treturn FALSE;\n\n      h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n      /* Use strncmp to check __tls_get_addr since __tls_get_addr\n\t may be versioned.  */\n      return (h != NULL\n\t      && h->root.root.string != NULL\n\t      && (largepic\n"
}