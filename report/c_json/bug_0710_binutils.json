{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Message": "Offset added: [`out->len` + 2, +oo] (⇐ [`out->len`, +oo] + 2) Size: [1, +oo] by call to `sb_add_string`.",
    "Code_line": "\t\t  sb_add_string (out, \"-1\");",
    "Code_function": "macro_expand_body (sb *in, sb *out, formal_entry *formals,\n\t\t   struct hash_control *formal_hash, const macro_entry *macro)\n{\n  sb t;\n  size_t src = 0;\n  int inquote = 0, macro_line = 0;\n  formal_entry *loclist = NULL;\n  const char *err = NULL;\n\n  sb_new (&t);\n\n  while (src < in->len && !err)\n    {\n      if (in->ptr[src] == '&')\n\t{\n\t  sb_reset (&t);\n\t  if (macro_mri)\n\t    {\n\t      if (src + 1 < in->len && in->ptr[src + 1] == '&')\n\t\tsrc = sub_actual (src + 2, in, &t, formal_hash, '\\'', out, 1);\n\t      else\n\t\tsb_add_char (out, in->ptr[src++]);\n\t    }\n\t  else\n\t    {\n\t      /* Permit macro parameter substition delineated with\n\t\t an '&' prefix and optional '&' suffix.  */\n\t      src = sub_actual (src + 1, in, &t, formal_hash, '&', out, 0);\n\t    }\n\t}\n      else if (in->ptr[src] == '\\\\')\n\t{\n\t  src++;\n\t  if (src < in->len && in->ptr[src] == '(')\n\t    {\n\t      /* Sub in till the next ')' literally.  */\n\t      src++;\n\t      while (src < in->len && in->ptr[src] != ')')\n\t\t{\n\t\t  sb_add_char (out, in->ptr[src++]);\n\t\t}\n\t      if (src < in->len)\n\t\tsrc++;\n\t      else if (!macro)\n\t\terr = _(\"missing `)'\");\n\t      else\n\t\tas_bad_where (macro->file, macro->line + macro_line, _(\"missing `)'\"));\n\t    }\n\t  else if (src < in->len && in->ptr[src] == '@')\n\t    {\n\t      /* Sub in the macro invocation number.  */\n\n\t      char buffer[10];\n\t      src++;\n\t      sprintf (buffer, \"%d\", macro_number);\n\t      sb_add_string (out, buffer);\n\t    }\n\t  else if (src < in->len && in->ptr[src] == '&')\n\t    {\n\t      /* This is a preprocessor variable name, we don't do them\n\t\t here.  */\n\t      sb_add_char (out, '\\\\');\n\t      sb_add_char (out, '&');\n\t      src++;\n\t    }\n\t  else if (macro_mri && src < in->len && ISALNUM (in->ptr[src]))\n\t    {\n\t      int ind;\n\t      formal_entry *f;\n\n\t      if (ISDIGIT (in->ptr[src]))\n\t\tind = in->ptr[src] - '0';\n\t      else if (ISUPPER (in->ptr[src]))\n\t\tind = in->ptr[src] - 'A' + 10;\n\t      else\n\t\tind = in->ptr[src] - 'a' + 10;\n\t      ++src;\n\t      for (f = formals; f != NULL; f = f->next)\n\t\t{\n\t\t  if (f->index == ind - 1)\n\t\t    {\n\t\t      if (f->actual.len != 0)\n\t\t\tsb_add_sb (out, &f->actual);\n\t\t      else\n\t\t\tsb_add_sb (out, &f->def);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      sb_reset (&t);\n\t      src = sub_actual (src, in, &t, formal_hash, '\\'', out, 0);\n\t    }\n\t}\n      else if ((macro_alternate || macro_mri)\n\t       && is_name_beginner (in->ptr[src])\n\t       && (! inquote\n\t\t   || ! macro_strip_at\n\t\t   || (src > 0 && in->ptr[src - 1] == '@')))\n\t{\n\t  if (! macro\n\t      || src + 5 >= in->len\n\t      || strncasecmp (in->ptr + src, \"LOCAL\", 5) != 0\n\t      || ! ISWHITE (in->ptr[src + 5])\n\t      /* PR 11507: Skip keyword LOCAL if it is found inside a quoted string.  */\n\t      || inquote)\n\t    {\n\t      sb_reset (&t);\n\t      src = sub_actual (src, in, &t, formal_hash,\n\t\t\t\t(macro_strip_at && inquote) ? '@' : '\\'',\n\t\t\t\tout, 1);\n\t    }\n\t  else\n\t    {\n\t      src = sb_skip_white (src + 5, in);\n\t      while (in->ptr[src] != '\\n')\n\t\t{\n\t\t  const char *name;\n\t\t  formal_entry *f = new_formal ();\n\n\t\t  src = get_token (src, in, &f->name);\n\t\t  name = sb_terminate (&f->name);\n\t\t  if (! hash_find (formal_hash, name))\n\t\t    {\n\t\t      static int loccnt;\n\t\t      char buf[20];\n\n\t\t      f->index = LOCAL_INDEX;\n\t\t      f->next = loclist;\n\t\t      loclist = f;\n\n\t\t      sprintf (buf, IS_ELF ? \".LL%04x\" : \"LL%04x\", ++loccnt);\n\t\t      sb_add_string (&f->actual, buf);\n\n\t\t      err = hash_jam (formal_hash, name, f);\n\t\t      if (err != NULL)\n\t\t\tbreak;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      as_bad_where (macro->file,\n\t\t\t\t    macro->line + macro_line,\n\t\t\t\t    _(\"`%s' was already used as parameter (or another local) name\"),\n\t\t\t\t    name);\n\t\t      del_formal (f);\n\t\t    }\n\n\t\t  src = sb_skip_comma (src, in);\n\t\t}\n\t    }\n\t}\n      else if (in->ptr[src] == '\"'\n\t       || (macro_mri && in->ptr[src] == '\\''))\n\t{\n\t  inquote = !inquote;\n\t  sb_add_char (out, in->ptr[src++]);\n\t}\n      else if (in->ptr[src] == '@' && macro_strip_at)\n\t{\n\t  ++src;\n\t  if (src < in->len\n\t      && in->ptr[src] == '@')\n\t    {\n\t      sb_add_char (out, '@');\n\t      ++src;\n\t    }\n\t}\n      else if (macro_mri\n\t       && in->ptr[src] == '='\n\t       && src + 1 < in->len\n\t       && in->ptr[src + 1] == '=')\n\t{\n\t  formal_entry *ptr;\n\n\t  sb_reset (&t);\n\t  src = get_token (src + 2, in, &t);\n\t  ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (&t));\n\t  if (ptr == NULL)\n\t    {\n\t      /* FIXME: We should really return a warning string here,\n\t\t but we can't, because the == might be in the MRI\n\t\t comment field, and, since the nature of the MRI\n\t\t comment field depends upon the exact instruction\n\t\t being used, we don't have enough information here to\n\t\t figure out whether it is or not.  Instead, we leave\n\t\t the == in place, which should cause a syntax error if\n\t\t it is not in a comment.  */\n\t      sb_add_char (out, '=');\n\t      sb_add_char (out, '=');\n\t      sb_add_sb (out, &t);\n\t    }\n\t  else\n\t    {\n\t      if (ptr->actual.len)\n\t\t{\n\t\t  sb_add_string (out, \"-1\");\n\t\t}\n\t      else\n\t\t{\n\t\t  sb_add_char (out, '0');\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  if (in->ptr[src] == '\\n')\n\t    ++macro_line;\n\t  sb_add_char (out, in->ptr[src++]);\n\t}\n    }\n\n  sb_kill (&t);\n\n  while (loclist != NULL)\n    {\n      formal_entry *f;\n      const char *name;\n\n      f = loclist->next;\n      name = sb_terminate (&loclist->name);\n      hash_delete (formal_hash, name, f == NULL);\n      del_formal (loclist);\n      loclist = f;\n    }\n\n  return err;\n}"
}