{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/cofflink.c",
    "message": "Offset: [5, +oo] Size: [1, +oo] by call to `get_name`.",
    "warning_function_name": "process_embedded_commands",
    "warning_line": "s = get_name (s, &name);",
    "warning_context": "static int\nprocess_embedded_commands (bfd *output_bfd,\n\t\t\t   struct bfd_link_info *info ATTRIBUTE_UNUSED,\n\t\t\t   bfd *abfd)\n{\n  asection *sec = bfd_get_section_by_name (abfd, \".drectve\");\n  char *s;\n  char *e;\n  bfd_byte *copy;\n\n  if (!sec)\n    return 1;\n\n  if (!bfd_malloc_and_get_section (abfd, sec, &copy))\n    {\n      if (copy != NULL)\n\tfree (copy);\n      return 0;\n    }\n  e = (char *) copy + sec->size;\n\n  for (s = (char *) copy; s < e ; )\n    {\n      if (s[0] != '-')\n\t{\n\t  s++;\n\t  continue;\n\t}\n      if (CONST_STRNEQ (s, \"-attr\"))\n\t{\n\t  char *name;\n\t  char *attribs;\n\t  asection *asec;\n\t  int loop = 1;\n\t  int had_write = 0;\n\t  int had_exec= 0;\n\n\t  s += 5;\n\t  s = get_name (s, &name);\n\t  s = get_name (s, &attribs);\n\n\t  while (loop)\n\t    {\n\t      switch (*attribs++)\n\t\t{\n\t\tcase 'W':\n\t\t  had_write = 1;\n\t\t  break;\n\t\tcase 'R':\n\t\t  break;\n\t\tcase 'S':\n\t\t  break;\n\t\tcase 'X':\n\t\t  had_exec = 1;\n\t\t  break;\n\t\tdefault:\n\t\t  loop = 0;\n\t\t}\n\t    }\n\t  asec = bfd_get_section_by_name (abfd, name);\n\t  if (asec)\n\t    {\n\t      if (had_exec)\n\t\tasec->flags |= SEC_CODE;\n\t      if (!had_write)\n\t\tasec->flags |= SEC_READONLY;\n\t    }\n\t}\n      else if (CONST_STRNEQ (s, \"-heap\"))\n\ts = dores_com (s + 5, output_bfd, 1);\n\n      else if (CONST_STRNEQ (s, \"-stack\"))\n\ts = dores_com (s + 6, output_bfd, 0);\n\n      /* GNU extension for aligned commons.  */\n      else if (CONST_STRNEQ (s, \"-aligncomm:\"))\n\t{\n\t  /* Common symbols must be aligned on reading, as it\n\t  is too late to do anything here, after they have\n\t  already been allocated, so just skip the directive.  */\n\t  s += 11;\n\t}\n\n      else\n\ts++;\n    }\n  free (copy);\n  return 1;\n}\n"
}