{
    "Project": "bash",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Code_line": "    maybe_make_readline_line (value_cell (v));",
    "Code_function": "bash_execute_unix_command (count, key)\n     int count;\t/* ignored */\n     int key;\n{\n  Keymap ckmap;\t\t/* current keymap */\n  Keymap xkmap;\t\t/* unix command executing keymap */\n  rl_command_func_t *func;\n  int type;\n  register int i, r;\n  intmax_t mi;\n  sh_parser_state_t ps;\n  char *cmd, *value, *l, *l1, *ce;\n  SHELL_VAR *v;\n  char ibuf[INT_STRLEN_BOUND(int) + 1];\n\n  /* First, we need to find the right command to execute.  This is tricky,\n     because we might have already indirected into another keymap, so we\n     have to walk cmd_xmap using the entire key sequence. */\n  cmd = (char *)rl_function_of_keyseq (rl_executing_keyseq, cmd_xmap, &type);\n\n  if (cmd == 0 || type != ISMACR)\n    {\n      rl_crlf ();\n      internal_error (_(\"bash_execute_unix_command: cannot find keymap for command\"));\n      rl_forced_update_display ();\n      return 1;\n    }\n\n  ce = rl_get_termcap (\"ce\");\n  if (ce)\t/* clear current line */\n    {\n      fprintf (rl_outstream, \"\\r\");\n      tputs (ce, 1, putx);\n      fflush (rl_outstream);\n    }\n  else\n    rl_crlf ();\t/* move to a new line */\n\n  v = bind_variable (\"READLINE_LINE\", rl_line_buffer, 0);\n  if (v)\n    VSETATTR (v, att_exported);\n  l = v ? value_cell (v) : 0;\n  value = inttostr (rl_point, ibuf, sizeof (ibuf));\n  v = bind_int_variable (\"READLINE_POINT\", value);\n  if (v)\n    VSETATTR (v, att_exported);\n  array_needs_making = 1;\n\n  save_parser_state (&ps);\n  r = parse_and_execute (cmd, \"bash_execute_unix_command\", SEVAL_NOHIST|SEVAL_NOFREE);\n  restore_parser_state (&ps);\n\n  v = find_variable (\"READLINE_LINE\");\n  l1 = v ? value_cell (v) : 0;\n  if (l1 != l)\n    maybe_make_readline_line (value_cell (v));\n  v = find_variable (\"READLINE_POINT\");\n  if (v && legal_number (value_cell (v), &mi))\n    {\n      i = mi;\n      if (i != rl_point)\n\t{\n\t  rl_point = i;\n\t  if (rl_point > rl_end)\n\t    rl_point = rl_end;\n\t  else if (rl_point < 0)\n\t    rl_point = 0;\n\t}\n    }\n\n  unbind_variable (\"READLINE_LINE\");\n  unbind_variable (\"READLINE_POINT\");\n  array_needs_making = 1;\n\n  /* and restore the readline buffer and display after command execution. */\n  rl_forced_update_display ();\n  return 0;\n}"
}