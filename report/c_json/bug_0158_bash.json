{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/bind.c",
    "message": "The value read from k.type was never initialized.",
    "warning_function_name": "rl_generic_bind",
    "warning_line": "if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))",
    "warning_context": "int\nrl_generic_bind (type, keyseq, data, map)\n     int type;\n     const char *keyseq;\n     char *data;\n     Keymap map;\n{\n  char *keys;\n  int keys_len;\n  register int i;\n  KEYMAP_ENTRY k;\n\n  k.function = 0;\n\n  /* If no keys to bind to, exit right away. */\n  if (keyseq == 0 || *keyseq == 0)\n    {\n      if (type == ISMACR)\n\txfree (data);\n      return -1;\n    }\n\n  keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));\n\n  /* Translate the ASCII representation of KEYSEQ into an array of\n     characters.  Stuff the characters into KEYS, and the length of\n     KEYS into KEYS_LEN. */\n  if (rl_translate_keyseq (keyseq, keys, &keys_len))\n    {\n      xfree (keys);\n      return -1;\n    }\n\n  /* Bind keys, making new keymaps as necessary. */\n  for (i = 0; i < keys_len; i++)\n    {\n      unsigned char uc = keys[i];\n      int ic;\n\n      ic = uc;\n      if (ic < 0 || ic >= KEYMAP_SIZE)\n        {\n          xfree (keys);\n\t  return -1;\n        }\n\n      if (META_CHAR (ic) && _rl_convert_meta_chars_to_ascii)\n\t{\n\t  ic = UNMETA (ic);\n\t  if (map[ESC].type == ISKMAP)\n\t    map = FUNCTION_TO_KEYMAP (map, ESC);\n\t}\n\n      if ((i + 1) < keys_len)\n\t{\n\t  if (map[ic].type != ISKMAP)\n\t    {\n\t      /* We allow subsequences of keys.  If a keymap is being\n\t\t created that will `shadow' an existing function or macro\n\t\t key binding, we save that keybinding into the ANYOTHERKEY\n\t\t index in the new map.  The dispatch code will look there\n\t\t to find the function to execute if the subsequence is not\n\t\t matched.  ANYOTHERKEY was chosen to be greater than\n\t\t UCHAR_MAX. */\n\t      k = map[ic];\n\n\t      map[ic].type = ISKMAP;\n\t      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());\n\t    }\n\t  map = FUNCTION_TO_KEYMAP (map, ic);\n\t  /* The dispatch code will return this function if no matching\n\t     key sequence is found in the keymap.  This (with a little\n\t     help from the dispatch code in readline.c) allows `a' to be\n\t     mapped to something, `abc' to be mapped to something else,\n\t     and the function bound  to `a' to be executed when the user\n\t     types `abx', leaving `bx' in the input queue. */\n\t  if (k.function && ((k.type == ISFUNC && k.function != rl_do_lowercase_version) || k.type == ISMACR))\n\t    {\n\t      map[ANYOTHERKEY] = k;\n\t      k.function = 0;\n\t    }\n\t}\n      else\n\t{\n\t  if (map[ic].type == ISMACR)\n\t    xfree ((char *)map[ic].function);\n\t  else if (map[ic].type == ISKMAP)\n\t    {\n\t      map = FUNCTION_TO_KEYMAP (map, ic);\n\t      ic = ANYOTHERKEY;\n\t      /* If we're trying to override a keymap with a null function\n\t\t (e.g., trying to unbind it), we can't use a null pointer\n\t\t here because that's indistinguishable from having not been\n\t\t overridden.  We use a special bindable function that does\n\t\t nothing. */\n\t      if (type == ISFUNC && data == 0)\n\t\tdata = (char *)_rl_null_function;\n\t    }\n\n\t  map[ic].function = KEYMAP_TO_FUNCTION (data);\n\t  map[ic].type = type;\n"
}