{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "  line = parse_insn (line, mnemonic);",
    "Code_function": "md_assemble (char *line)\n{\n  unsigned int j;\n  char mnemonic[MAX_MNEM_SIZE];\n  const insn_template *t;\n\n  /* Initialize globals.  */\n  memset (&i, '\\0', sizeof (i));\n  for (j = 0; j < MAX_OPERANDS; j++)\n    i.reloc[j] = NO_RELOC;\n  memset (disp_expressions, '\\0', sizeof (disp_expressions));\n  memset (im_expressions, '\\0', sizeof (im_expressions));\n  save_stack_p = save_stack;\n\n  /* First parse an instruction mnemonic & call i386_operand for the operands.\n     We assume that the scrubber has arranged it so that line[0] is the valid\n     start of a (possibly prefixed) mnemonic.  */\n\n  line = parse_insn (line, mnemonic);\n  if (line == NULL)\n    return;\n\n  line = parse_operands (line, mnemonic);\n  this_operand = -1;\n  if (line == NULL)\n    return;\n\n  /* Now we've parsed the mnemonic into a set of templates, and have the\n     operands at hand.  */\n\n  /* All intel opcodes have reversed operands except for \"bound\" and\n     \"enter\".  We also don't reverse intersegment \"jmp\" and \"call\"\n     instructions with 2 immediate operands so that the immediate segment\n     precedes the offset, as it does when in AT&T mode. */\n  if (intel_syntax\n      && i.operands > 1\n      && (strcmp (mnemonic, \"bound\") != 0)\n      && (strcmp (mnemonic, \"invlpga\") != 0)\n      && !(operand_type_check (i.types[0], imm)\n\t   && operand_type_check (i.types[1], imm)))\n    swap_operands ();\n\n  /* The order of the immediates should be reversed\n     for 2 immediates extrq and insertq instructions */\n  if (i.imm_operands == 2\n      && (strcmp (mnemonic, \"extrq\") == 0\n\t  || strcmp (mnemonic, \"insertq\") == 0))\n      swap_2_operands (0, 1);\n\n  if (i.imm_operands)\n    optimize_imm ();\n\n  /* Don't optimize displacement for movabs since it only takes 64bit\n     displacement.  */\n  if (i.disp_operands\n      && i.disp_encoding != disp_encoding_32bit\n      && (flag_code != CODE_64BIT\n\t  || strcmp (mnemonic, \"movabs\") != 0))\n    optimize_disp ();\n\n  /* Next, we find a template that matches the given insn,\n     making sure the overlap of the given operands types is consistent\n     with the template operand types.  */\n\n  if (!(t = match_template ()))\n    return;\n\n  if (sse_check != check_none\n      && !i.tm.opcode_modifier.noavx\n      && (i.tm.cpu_flags.bitfield.cpusse\n\t  || i.tm.cpu_flags.bitfield.cpusse2\n\t  || i.tm.cpu_flags.bitfield.cpusse3\n\t  || i.tm.cpu_flags.bitfield.cpussse3\n\t  || i.tm.cpu_flags.bitfield.cpusse4_1\n\t  || i.tm.cpu_flags.bitfield.cpusse4_2))\n    {\n      (sse_check == check_warning\n       ? as_warn\n       : as_bad) (_(\"SSE instruction `%s' is used\"), i.tm.name);\n    }\n\n  /* Zap movzx and movsx suffix.  The suffix has been set from\n     \"word ptr\" or \"byte ptr\" on the source operand in Intel syntax\n     or extracted from mnemonic in AT&T syntax.  But we'll use\n     the destination register to choose the suffix for encoding.  */\n  if ((i.tm.base_opcode & ~9) == 0x0fb6)\n    {\n      /* In Intel syntax, there must be a suffix.  In AT&T syntax, if\n\t there is no suffix, the default will be byte extension.  */\n      if (i.reg_operands != 2\n\t  && !i.suffix\n\t  && intel_syntax)\n\tas_bad (_(\"ambiguous operand size for `%s'\"), i.tm.name);\n\n      i.suffix = 0;\n    }\n\n  if (i.tm.opcode_modifier.fwait)\n    if (!add_prefix (FWAIT_OPCODE))\n      return;\n\n  /* Check if REP prefix is OK.  */\n  if (i.rep_prefix && !i.tm.opcode_modifier.repprefixok)\n    {\n      as_bad (_(\"invalid instruction `%s' after `%s'\"),\n\t\ti.tm.name, i.rep_prefix);\n      return;\n    }\n\n  /* Check for lock without a lockable instruction.  Destination operand\n     must be memory unless it is xchg (0x86).  */\n  if (i.prefix[LOCK_PREFIX]\n      && (!i.tm.opcode_modifier.islockable\n\t  || i.mem_operands == 0\n\t  || (i.tm.base_opcode != 0x86\n\t      && !operand_type_check (i.types[i.operands - 1], anymem))))\n    {\n      as_bad (_(\"expecting lockable instruction after `lock'\"));\n      return;\n    }\n\n  /* Check if HLE prefix is OK.  */\n  if (i.hle_prefix && !check_hle ())\n    return;\n\n  /* Check BND prefix.  */\n  if (i.bnd_prefix && !i.tm.opcode_modifier.bndprefixok)\n    as_bad (_(\"expecting valid branch instruction after `bnd'\"));\n\n  if (i.tm.cpu_flags.bitfield.cpumpx\n      && flag_code == CODE_64BIT\n      && i.prefix[ADDR_PREFIX])\n    as_bad (_(\"32-bit address isn't allowed in 64-bit MPX instructions.\"));\n\n  /* Insert BND prefix.  */\n  if (add_bnd_prefix\n      && i.tm.opcode_modifier.bndprefixok\n      && !i.prefix[BND_PREFIX])\n    add_prefix (BND_PREFIX_OPCODE);\n\n  /* Check string instruction segment overrides.  */\n  if (i.tm.opcode_modifier.isstring && i.mem_operands != 0)\n    {\n      if (!check_string ())\n\treturn;\n      i.disp_operands = 0;\n    }\n\n  if (!process_suffix ())\n    return;\n\n  /* Update operand types.  */\n  for (j = 0; j < i.operands; j++)\n    i.types[j] = operand_type_and (i.types[j], i.tm.operand_types[j]);\n\n  /* Make still unresolved immediate matches conform to size of immediate\n     given in i.suffix.  */\n  if (!finalize_imm ())\n    return;\n\n  if (i.types[0].bitfield.imm1)\n    i.imm_operands = 0;\t/* kludge for shift insns.  */\n\n  /* We only need to check those implicit registers for instructions\n     with 3 operands or less.  */\n  if (i.operands <= 3)\n    for (j = 0; j < i.operands; j++)\n      if (i.types[j].bitfield.inoutportreg\n\t  || i.types[j].bitfield.shiftcount\n\t  || i.types[j].bitfield.acc\n\t  || i.types[j].bitfield.floatacc)\n\ti.reg_operands--;\n\n  /* ImmExt should be processed after SSE2AVX.  */\n  if (!i.tm.opcode_modifier.sse2avx\n      && i.tm.opcode_modifier.immext)\n    process_immext ();\n\n  /* For insns with operands there are more diddles to do to the opcode.  */\n  if (i.operands)\n    {\n      if (!process_operands ())\n\treturn;\n    }\n  else if (!quiet_warnings && i.tm.opcode_modifier.ugh)\n    {\n      /* UnixWare fsub no args is alias for fsubp, fadd -> faddp, etc.  */\n      as_warn (_(\"translating to `%sp'\"), i.tm.name);\n    }\n\n  if (i.tm.opcode_modifier.vex || i.tm.opcode_modifier.evex)\n    {\n      if (flag_code == CODE_16BIT)\n\t{\n\t  as_bad (_(\"instruction `%s' isn't supported in 16-bit mode.\"),\n\t\t  i.tm.name);\n\t  return;\n\t}\n\n      if (i.tm.opcode_modifier.vex)\n\tbuild_vex_prefix (t);\n      else\n\tbuild_evex_prefix ();\n    }\n\n  /* Handle conversion of 'int $3' --> special int3 insn.  XOP or FMA4\n     instructions may define INT_OPCODE as well, so avoid this corner\n     case for those instructions that use MODRM.  */\n  if (i.tm.base_opcode == INT_OPCODE\n      && !i.tm.opcode_modifier.modrm\n      && i.op[0].imms->X_add_number == 3)\n    {\n      i.tm.base_opcode = INT3_OPCODE;\n      i.imm_operands = 0;\n    }\n\n  if ((i.tm.opcode_modifier.jump\n       || i.tm.opcode_modifier.jumpbyte\n       || i.tm.opcode_modifier.jumpdword)\n      && i.op[0].disps->X_op == O_constant)\n    {\n      /* Convert \"jmp constant\" (and \"call constant\") to a jump (call) to\n\t the absolute address given by the constant.  Since ix86 jumps and\n\t calls are pc relative, we need to generate a reloc.  */\n      i.op[0].disps->X_add_symbol = &abs_symbol;\n      i.op[0].disps->X_op = O_symbol;\n    }\n\n  if (i.tm.opcode_modifier.rex64)\n    i.rex |= REX_W;\n\n  /* For 8 bit registers we need an empty rex prefix.  Also if the\n     instruction already has a prefix, we need to convert old\n     registers to new ones.  */\n\n  if ((i.types[0].bitfield.reg8\n       && (i.op[0].regs->reg_flags & RegRex64) != 0)\n      || (i.types[1].bitfield.reg8\n\t  && (i.op[1].regs->reg_flags & RegRex64) != 0)\n      || ((i.types[0].bitfield.reg8\n\t   || i.types[1].bitfield.reg8)\n\t  && i.rex != 0))\n    {\n      int x;\n\n      i.rex |= REX_OPCODE;\n      for (x = 0; x < 2; x++)\n\t{\n\t  /* Look for 8 bit operand that uses old registers.  */\n\t  if (i.types[x].bitfield.reg8\n\t      && (i.op[x].regs->reg_flags & RegRex64) == 0)\n\t    {\n\t      /* In case it is \"hi\" register, give up.  */\n\t      if (i.op[x].regs->reg_num > 3)\n\t\tas_bad (_(\"can't encode register '%s%s' in an \"\n\t\t\t  \"instruction requiring REX prefix.\"),\n\t\t\tregister_prefix, i.op[x].regs->reg_name);\n\n\t      /* Otherwise it is equivalent to the extended register.\n\t\t Since the encoding doesn't change this is merely\n\t\t cosmetic cleanup for debug output.  */\n\n\t      i.op[x].regs = i.op[x].regs + 8;\n\t    }\n\t}\n    }\n\n  if (i.rex != 0)\n    add_prefix (REX_OPCODE | i.rex);\n\n  /* We are ready to output the insn.  */\n  output_insn ();\n}"
}