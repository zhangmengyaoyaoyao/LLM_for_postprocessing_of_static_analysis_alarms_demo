{
    "project": "binutils",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "bfd/elflink.c",
    "message": "pointer `s` last assigned on line 6386 could be null and is dereferenced at line 6389, column 8.",
    "warning_function_name": "bfd_elf_size_dynsym_hash_dynstr",
    "warning_line": "&& (s->flags & SEC_EXCLUDE) == 0)",
    "warning_context": "bfd_boolean\nbfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)\n{\n  const struct elf_backend_data *bed;\n\n  if (!is_elf_hash_table (info->hash))\n    return TRUE;\n\n  bed = get_elf_backend_data (output_bfd);\n  (*bed->elf_backend_init_index_section) (output_bfd, info);\n\n  if (elf_hash_table (info)->dynamic_sections_created)\n    {\n      bfd *dynobj;\n      asection *s;\n      bfd_size_type dynsymcount;\n      unsigned long section_sym_count;\n      unsigned int dtagcount;\n\n      dynobj = elf_hash_table (info)->dynobj;\n\n      /* Assign dynsym indicies.  In a shared library we generate a\n\t section symbol for each output section, which come first.\n\t Next come all of the back-end allocated local dynamic syms,\n\t followed by the rest of the global symbols.  */\n\n      dynsymcount = _bfd_elf_link_renumber_dynsyms (output_bfd, info,\n\t\t\t\t\t\t    &section_sym_count);\n\n      /* Work out the size of the symbol version section.  */\n      s = bfd_get_linker_section (dynobj, \".gnu.version\");\n      BFD_ASSERT (s != NULL);\n      if (dynsymcount != 0\n\t  && (s->flags & SEC_EXCLUDE) == 0)\n\t{\n\t  s->size = dynsymcount * sizeof (Elf_External_Versym);\n\t  s->contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);\n\t  if (s->contents == NULL)\n\t    return FALSE;\n\n\t  if (!_bfd_elf_add_dynamic_entry (info, DT_VERSYM, 0))\n\t    return FALSE;\n\t}\n\n      /* Set the size of the .dynsym and .hash sections.  We counted\n\t the number of dynamic symbols in elf_link_add_object_symbols.\n\t We will build the contents of .dynsym and .hash when we build\n\t the final symbol table, because until then we do not know the\n\t correct value to give the symbols.  We built the .dynstr\n\t section as we went along in elf_link_add_object_symbols.  */\n      s = bfd_get_linker_section (dynobj, \".dynsym\");\n      BFD_ASSERT (s != NULL);\n      s->size = dynsymcount * bed->s->sizeof_sym;\n\n      if (dynsymcount != 0)\n\t{\n\t  s->contents = (unsigned char *) bfd_alloc (output_bfd, s->size);\n\t  if (s->contents == NULL)\n\t    return FALSE;\n\n\t  /* The first entry in .dynsym is a dummy symbol.\n\t     Clear all the section syms, in case we don't output them all.  */\n\t  ++section_sym_count;\n\t  memset (s->contents, 0, section_sym_count * bed->s->sizeof_sym);\n\t}\n\n      elf_hash_table (info)->bucketcount = 0;\n\n      /* Compute the size of the hashing table.  As a side effect this\n\t computes the hash values for all the names we export.  */\n      if (info->emit_hash)\n\t{\n\t  unsigned long int *hashcodes;\n\t  struct hash_codes_info hashinf;\n\t  bfd_size_type amt;\n\t  unsigned long int nsyms;\n\t  size_t bucketcount;\n\t  size_t hash_entry_size;\n\n\t  /* Compute the hash values for all exported symbols.  At the same\n\t     time store the values in an array so that we could use them for\n\t     optimizations.  */\n\t  amt = dynsymcount * sizeof (unsigned long int);\n\t  hashcodes = (unsigned long int *) bfd_malloc (amt);\n\t  if (hashcodes == NULL)\n\t    return FALSE;\n\t  hashinf.hashcodes = hashcodes;\n\t  hashinf.error = FALSE;\n\n\t  /* Put all hash values in HASHCODES.  */\n\t  elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t  elf_collect_hash_codes, &hashinf);\n\t  if (hashinf.error)\n\t    {\n\t      free (hashcodes);\n\t      return FALSE;\n\t    }\n\n\t  nsyms = hashinf.hashcodes - hashcodes;\n\t  bucketcount\n\t    = compute_bucket_count (info, hashcodes, nsyms, 0);\n"
}