{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "trap.c",
    "message": "Dereference of null pointer (loaded from variable 'first_arg')",
    "warning_function_name": NaN,
    "warning_line": "int running_trap;",
    "warning_context": "\n#include \"trap.h\"\n\n#include \"shell.h\"\n#include \"flags.h\"\n#include \"input.h\"\t/* for save_token_state, restore_token_state */\n#include \"jobs.h\"\n#include \"signames.h\"\n#include \"builtins.h\"\n#include \"builtins/common.h\"\n#include \"builtins/builtext.h\"\n\n#if defined (READLINE)\n#  include <readline/readline.h>\n#  include \"bashline.h\"\n#endif\n\n#ifndef errno\nextern int errno;\n#endif\n\n/* Flags which describe the current handling state of a signal. */\n#define SIG_INHERITED   0x0\t/* Value inherited from parent. */\n#define SIG_TRAPPED     0x1\t/* Currently trapped. */\n#define SIG_HARD_IGNORE 0x2\t/* Signal was ignored on shell entry. */\n#define SIG_SPECIAL     0x4\t/* Treat this signal specially. */\n#define SIG_NO_TRAP     0x8\t/* Signal cannot be trapped. */\n#define SIG_INPROGRESS\t0x10\t/* Signal handler currently executing. */\n#define SIG_CHANGED\t0x20\t/* Trap value changed in trap handler. */\n#define SIG_IGNORED\t0x40\t/* The signal is currently being ignored. */\n\n#define SPECIAL_TRAP(s)\t((s) == EXIT_TRAP || (s) == DEBUG_TRAP || (s) == ERROR_TRAP || (s) == RETURN_TRAP)\n\n/* An array of such flags, one for each signal, describing what the\n   shell will do with a signal.  DEBUG_TRAP == NSIG; some code below\n   assumes this. */\nstatic int sigmodes[BASH_NSIG];\n\nstatic void free_trap_command __P((int));\nstatic void change_signal __P((int, char *));\n\nstatic int _run_trap_internal __P((int, char *));\n\nstatic void free_trap_string __P((int));\nstatic void reset_signal __P((int));\nstatic void restore_signal __P((int));\nstatic void reset_or_restore_signal_handlers __P((sh_resetsig_func_t *));\n\n/* Variables used here but defined in other files. */\nextern int last_command_exit_value;\nextern int line_number;\n\nextern int sigalrm_seen;\nextern procenv_t alrmbuf;\n\nextern char *this_command_name;\nextern sh_builtin_func_t *this_shell_builtin;\nextern procenv_t wait_intr_buf;\nextern int return_catch_flag, return_catch_value;\nextern int subshell_level;\nextern WORD_LIST *subst_assign_varlist;\n\n/* The list of things to do originally, before we started trapping. */\nSigHandler *original_signals[NSIG];\n\n/* For each signal, a slot for a string, which is a command to be\n   executed when that signal is received.  The slot can also contain\n   DEFAULT_SIG, which means do whatever you were going to do before\n   you were so rudely interrupted, or IGNORE_SIG, which says ignore\n   this signal. */\nchar *trap_list[BASH_NSIG];\n\n/* A bitmap of signals received for which we have trap handlers. */\nint pending_traps[NSIG];\n\n/* Set to the number of the signal we're running the trap for + 1.\n   Used in execute_cmd.c and builtins/common.c to clean up when\n   parse_and_execute does not return normally after executing the\n   trap command (e.g., when `return' is executed in the trap command). */\nint running_trap;\n\n/* Set to last_command_exit_value before running a trap. */\nint trap_saved_exit_value;\n\n/* The (trapped) signal received while executing in the `wait' builtin */\nint wait_signal_received;\n\nint trapped_signal_received;\n\n#define GETORIGSIG(sig) \\\n  do { \\\n    original_signals[sig] = (SigHandler *)set_signal_handler (sig, SIG_DFL); \\\n    set_signal_handler (sig, original_signals[sig]); \\\n    if (original_signals[sig] == SIG_IGN) \\\n      sigmodes[sig] |= SIG_HARD_IGNORE; \\\n  } while (0)\n\n#define SETORIGSIG(sig,handler) \\\n  do { \\\n    original_signals[sig] = handler; \\\n    if (original_signals[sig] == SIG_IGN) \\\n"
}