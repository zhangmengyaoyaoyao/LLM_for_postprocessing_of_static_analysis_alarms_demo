{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/display.c",
    "message": "The value read from wc was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "temp = WCWIDTH (wc);",
    "warning_context": "#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\t{\n\t  n0 = num;\n          temp = local_prompt_len;\n          while (num < temp)\n\t    {\n\t      z = _rl_col_width  (local_prompt, n0, num, 1);\n\t      if (z > _rl_screenwidth)\n\t\t{\n\t          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n\t          break;\n\t\t}\n\t      else if (z == _rl_screenwidth)\n\t        break;\n\t      num++;\n\t    }\n          temp = num;\n\t}\n      else\n#endif /* !HANDLE_MULTIBYTE */\n\ttemp = ((newlines + 1) * _rl_screenwidth);\n\n      /* Now account for invisible characters in the current line. */\n      /* XXX - this assumes that the invisible characters may be split, but only\n\t between the first and the last lines. */\n      temp += (newlines == 0) ? prompt_invis_chars_first_line\n\t\t\t      : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line);\n\n      inv_lbreaks[++newlines] = temp;\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n\tlpos -= _rl_col_width (local_prompt, n0, num, 1);\n      else\n#endif\n\tlpos -= _rl_screenwidth;\n    }\n\n  prompt_last_screen_line = newlines;\n\n  /* Draw the rest of the line (after the prompt) into invisible_line, keeping\n     track of where the cursor is (cpos_buffer_position), the number of the line containing\n     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).\n     It maintains an array of line breaks for display (inv_lbreaks).\n     This handles expanding tabs for display and displaying meta characters. */\n  lb_linenum = 0;\n#if defined (HANDLE_MULTIBYTE)\n  in = 0;\n  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n    {\n      memset (&ps, 0, sizeof (mbstate_t));\n      /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);\n    }\n  else\n    wc_bytes = 1;\n  while (in < rl_end)\n#else\n  for (in = 0; in < rl_end; in++)\n#endif\n    {\n      c = (unsigned char)rl_line_buffer[in];\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  if (MB_INVALIDCH (wc_bytes))\n\t    {\n\t      /* Byte sequence is invalid or shortened.  Assume that the\n\t         first byte represents a character. */\n\t      wc_bytes = 1;\n\t      /* Assume that a character occupies a single column. */\n\t      wc_width = 1;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t    }\n\t  else if (MB_NULLWCH (wc_bytes))\n\t    break;\t\t\t/* Found '\\0' */\n\t  else\n\t    {\n\t      temp = WCWIDTH (wc);\n\t      wc_width = (temp >= 0) ? temp : 1;\n\t    }\n\t}\n#endif\n\n      if (out + 8 >= line_size)\t\t/* XXX - 8 for \\t */\n\t{\n\t  line_size *= 2;\n\t  visible_line = (char *)xrealloc (visible_line, line_size);\n\t  invisible_line = (char *)xrealloc (invisible_line, line_size);\n\t  line = invisible_line;\n\t}\n\n      if (in == rl_point)\n\t{\n\t  cpos_buffer_position = out;\n\t  lb_linenum = newlines;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (META_CHAR (c) && _rl_output_meta_chars == 0)\t/* XXX - clean up */\n"
}