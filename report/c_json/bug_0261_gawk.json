{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `mp` last assigned on line 4062 could be null and is dereferenced at line 4108, column 30.",
    "Code_line": "            must *lmp = mp = mp->prev;",
    "Code_function": "dfamust (struct dfa *d)\n{\n  must *mp = NULL;\n  char const *result = \"\";\n  size_t ri;\n  size_t i;\n  bool exact = false;\n  bool begline = false;\n  bool endline = false;\n  struct dfamust *dm;\n\n  for (ri = 0; ri < d->tindex; ++ri)\n    {\n      token t = d->tokens[ri];\n      switch (t)\n        {\n        case BEGLINE:\n          mp = allocmust (mp);\n          mp->begline = true;\n          break;\n        case ENDLINE:\n          mp = allocmust (mp);\n          mp->endline = true;\n          break;\n        case LPAREN:\n        case RPAREN:\n          assert (!\"neither LPAREN nor RPAREN may appear here\");\n\n        case EMPTY:\n        case BEGWORD:\n        case ENDWORD:\n        case LIMWORD:\n        case NOTLIMWORD:\n        case BACKREF:\n        case ANYCHAR:\n        case MBCSET:\n          mp = allocmust (mp);\n          break;\n\n        case STAR:\n        case QMARK:\n          resetmust (mp);\n          break;\n\n        case OR:\n          {\n            char **new;\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n            size_t j, ln, rn, n;\n\n            /* Guaranteed to be.  Unlikely, but ...  */\n            if (STREQ (lmp->is, rmp->is))\n              {\n                lmp->begline &= rmp->begline;\n                lmp->endline &= rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            /* Left side--easy */\n            i = 0;\n            while (lmp->left[i] != '\\0' && lmp->left[i] == rmp->left[i])\n              ++i;\n            lmp->left[i] = '\\0';\n            /* Right side */\n            ln = strlen (lmp->right);\n            rn = strlen (rmp->right);\n            n = ln;\n            if (n > rn)\n              n = rn;\n            for (i = 0; i < n; ++i)\n              if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])\n                break;\n            for (j = 0; j < i; ++j)\n              lmp->right[j] = lmp->right[(ln - i) + j];\n            lmp->right[j] = '\\0';\n            new = inboth (lmp->in, rmp->in);\n            freelist (lmp->in);\n            free (lmp->in);\n            lmp->in = new;\n            freemust (rmp);\n          }\n          break;\n\n        case PLUS:\n          mp->is[0] = '\\0';\n          break;\n\n        case END:\n          assert (!mp->prev);\n          for (i = 0; mp->in[i] != NULL; ++i)\n            if (strlen (mp->in[i]) > strlen (result))\n              result = mp->in[i];\n          if (STREQ (result, mp->is))\n            {\n              exact = true;\n              begline = mp->begline;\n              endline = mp->endline;\n            }\n          goto done;\n\n        case CAT:\n          {\n            must *rmp = mp;\n            must *lmp = mp = mp->prev;\n\n            /* In.  Everything in left, plus everything in\n               right, plus concatenation of\n               left's right and right's left.  */\n            lmp->in = addlists (lmp->in, rmp->in);\n            if (lmp->right[0] != '\\0' && rmp->left[0] != '\\0')\n              {\n                size_t lrlen = strlen (lmp->right);\n                size_t rllen = strlen (rmp->left);\n                char *tp = xmalloc (lrlen + rllen);\n                memcpy (tp, lmp->right, lrlen);\n                memcpy (tp + lrlen, rmp->left, rllen);\n                lmp->in = enlist (lmp->in, tp, lrlen + rllen);\n                free (tp);\n              }\n            /* Left-hand */\n            if (lmp->is[0] != '\\0')\n              lmp->left = icatalloc (lmp->left, rmp->left);\n            /* Right-hand */\n            if (rmp->is[0] == '\\0')\n              lmp->right[0] = '\\0';\n            lmp->right = icatalloc (lmp->right, rmp->right);\n            /* Guaranteed to be */\n            if ((lmp->is[0] != '\\0' || lmp->begline)\n                && (rmp->is[0] != '\\0' || rmp->endline))\n              {\n                lmp->is = icatalloc (lmp->is, rmp->is);\n                lmp->endline = rmp->endline;\n              }\n            else\n              {\n                lmp->is[0] = '\\0';\n                lmp->begline = false;\n                lmp->endline = false;\n              }\n            freemust (rmp);\n          }\n          break;\n\n        case '\\0':\n          /* Not on *my* shift.  */\n          goto done;\n\n        default:\n          mp = allocmust (mp);\n          if (CSET <= t)\n            {\n              /* If T is a singleton, or if case-folding in a unibyte\n                 locale and T's members all case-fold to the same char,\n                 convert T to one of its members.  Otherwise, do\n                 nothing further with T.  */\n              charclass *ccl = &d->charclasses[t - CSET];\n              int j;\n              for (j = 0; j < NOTCHAR; j++)\n                if (tstbit (j, *ccl))\n                  break;\n              if (! (j < NOTCHAR))\n                break;\n              t = j;\n              while (++j < NOTCHAR)\n                if (tstbit (j, *ccl)\n                    && ! (case_fold && !d->multibyte\n                          && toupper (j) == toupper (t)))\n                  break;\n              if (j < NOTCHAR)\n                break;\n            }\n          mp->is[0] = mp->left[0] = mp->right[0]\n            = case_fold && !d->multibyte ? toupper (t) : t;\n          mp->is[1] = mp->left[1] = mp->right[1] = '\\0';\n          mp->in = enlist (mp->in, mp->is, 1);\n          break;\n        }\n    }\ndone:\n  if (*result)\n    {\n      dm = xmalloc (sizeof *dm);\n      dm->exact = exact;\n      dm->begline = begline;\n      dm->endline = endline;\n      dm->must = xstrdup (result);\n      dm->next = d->musts;\n      d->musts = dm;\n    }\n\n  while (mp)\n    {\n      must *prev = mp->prev;\n      freemust (mp);\n      mp = prev;\n    }\n}"
}