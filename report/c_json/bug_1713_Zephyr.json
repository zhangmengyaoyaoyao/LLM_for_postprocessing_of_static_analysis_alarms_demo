{
    "Project": "Zephyr",
    "Tool": "Infer",
    "category": "Uninitialized Value",
    "file": "subsys/shell/shell.c",
    "message": "The value read from help_entry.handler was never initialized.",
    "warning_function_name": "execute",
    "warning_line": "shell->ctx->active_cmd = help_entry;",
    "warning_context": "static int execute(const struct shell *shell)\n{\n\tstruct shell_static_entry d_entry; /* Memory for dynamic commands. */\n\tchar *argv[CONFIG_SHELL_ARGC_MAX + 1]; /* +1 reserved for NULL */\n\tconst struct shell_static_entry *p_static_entry = NULL;\n\tconst struct shell_cmd_entry *p_cmd = NULL;\n\tstruct shell_static_entry help_entry;\n\tsize_t cmd_lvl = SHELL_CMD_ROOT_LVL;\n\tsize_t cmd_with_handler_lvl = 0;\n\tbool wildcard_found = false;\n\tsize_t cmd_idx = 0;\n\tsize_t argc;\n\tchar quote;\n\n\tshell_op_cursor_end_move(shell);\n\tif (!shell_cursor_in_empty_line(shell)) {\n\t\tcursor_next_line_move(shell);\n\t}\n\n\tmemset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));\n\n\tshell_cmd_trim(shell);\n\n\thistory_put(shell, shell->ctx->cmd_buff,\n\t\t    shell->ctx->cmd_buff_len);\n\n\tif (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {\n\t\tshell_wildcard_prepare(shell);\n\t}\n\n\t/* create argument list */\n\tquote = shell_make_argv(&argc, &argv[0], shell->ctx->cmd_buff,\n\t\t\t\tCONFIG_SHELL_ARGC_MAX);\n\n\tif (!argc) {\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (quote != 0) {\n\t\tshell_internal_fprintf(shell, SHELL_ERROR,\n\t\t\t\t       \"not terminated: %c\\n\",\n\t\t\t\t       quote);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* Initialize help variable */\n\thelp_entry.help = NULL;\n\n\t/* Below loop is analyzing subcommands of found root command. */\n\twhile (true) {\n\t\tif (cmd_lvl >= argc) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&\n\t\t    (!strcmp(argv[cmd_lvl], \"-h\") ||\n\t\t     !strcmp(argv[cmd_lvl], \"--help\"))) {\n\t\t\t/* Command called with help option so it makes no sense\n\t\t\t * to search deeper commands.\n\t\t\t */\n\t\t\tif (help_entry.help) {\n\t\t\t\tshell->ctx->active_cmd = help_entry;\n\t\t\t\tshell_internal_help_print(shell);\n\t\t\t\treturn SHELL_CMD_HELP_PRINTED;\n\t\t\t}\n\n\t\t\tshell_internal_fprintf(shell, SHELL_ERROR,\n\t\t\t\t\t       SHELL_MSG_SPECIFY_SUBCOMMAND);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {\n\t\t\tenum shell_wildcard_status status;\n\n\t\t\tstatus = shell_wildcard_process(shell, p_cmd,\n\t\t\t\t\t\t\targv[cmd_lvl]);\n\t\t\t/* Wildcard character found but there is no matching\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Wildcard character was not found function can process\n\t\t\t * argument.\n\t\t\t */\n\t\t\tif (status != SHELL_WILDCARD_NOT_FOUND) {\n\t\t\t\t++cmd_lvl;\n\t\t\t\twildcard_found = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tshell_cmd_get(shell, p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,\n\t\t\t      &d_entry);\n\n\t\tif ((cmd_idx == 0) || (p_static_entry == NULL)) {\n\t\t\tif (cmd_lvl == 0 &&\n\t\t\t\t(!shell_in_select_mode(shell) ||\n\t\t\t\t shell->ctx->selected_cmd->handler == NULL)) {\n\t\t\t\tshell_internal_fprintf(shell, SHELL_ERROR,\n"
}