{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf-nacl.c",
    "message": "Offset added: [-20, 475] (â‡ [-236, 259] + 216) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "nacl_modify_segment_map",
    "warning_line": "secdata = bfd_zalloc (abfd, sizeof *secdata);",
    "warning_context": "bfd_boolean\nnacl_modify_segment_map (bfd *abfd, struct bfd_link_info *info)\n{\n  const struct elf_backend_data *const bed = get_elf_backend_data (abfd);\n  struct elf_segment_map **m = &elf_seg_map (abfd);\n  struct elf_segment_map **first_load = NULL;\n  struct elf_segment_map **last_load = NULL;\n  bfd_boolean moved_headers = FALSE;\n  int sizeof_headers;\n\n  if (info != NULL && info->user_phdrs)\n    /* The linker script used PHDRS explicitly, so don't change what the\n       user asked for.  */\n    return TRUE;\n\n  if (info != NULL)\n    /* We're doing linking, so evalute SIZEOF_HEADERS as in a linker script.  */\n    sizeof_headers = bfd_sizeof_headers (abfd, info);\n  else\n    {\n      /* We're not doing linking, so this is objcopy or suchlike.\n\t We just need to collect the size of the existing headers.  */\n      struct elf_segment_map *seg;\n      sizeof_headers = bed->s->sizeof_ehdr;\n      for (seg = *m; seg != NULL; seg = seg->next)\n\tsizeof_headers += bed->s->sizeof_phdr;\n    }\n\n  while (*m != NULL)\n    {\n      struct elf_segment_map *seg = *m;\n\n      if (seg->p_type == PT_LOAD)\n\t{\n\t  bfd_boolean executable = segment_executable (seg);\n\n\t  if (executable\n\t      && seg->count > 0\n\t      && seg->sections[0]->vma % bed->minpagesize == 0)\n\t    {\n\t      asection *lastsec = seg->sections[seg->count - 1];\n\t      bfd_vma end = lastsec->vma + lastsec->size;\n\t      if (end % bed->minpagesize != 0)\n\t\t{\n\t\t  /* This is an executable segment that starts on a page\n\t\t     boundary but does not end on a page boundary.  Fill\n\t\t     it out to a whole page with code fill (the tail of\n\t\t     the segment will not be within any section).  Thus\n\t\t     the entire code segment can be mapped from the file\n\t\t     as whole pages and that mapping will contain only\n\t\t     valid instructions.\n\n\t\t     To accomplish this, we must fake out the code in\n\t\t     assign_file_positions_for_load_sections (elf.c) so\n\t\t     that it advances past the rest of the final page,\n\t\t     rather than trying to put the next (unaligned, or\n\t\t     unallocated) section.  We do this by appending a\n\t\t     dummy section record to this element in the segment\n\t\t     map.  No such output section ever actually exists,\n\t\t     but this gets the layout logic to advance the file\n\t\t     positions past this partial page.  Since we are\n\t\t     lying to BFD like this, nothing will ever know to\n\t\t     write the section contents.  So we do that by hand\n\t\t     after the fact, in nacl_final_write_processing, below.  */\n\n\t\t  struct elf_segment_map *newseg;\n\t\t  asection *sec;\n\t\t  struct bfd_elf_section_data *secdata;\n\n\t\t  BFD_ASSERT (!seg->p_size_valid);\n\n\t\t  secdata = bfd_zalloc (abfd, sizeof *secdata);\n\t\t  if (secdata == NULL)\n\t\t    return FALSE;\n\n\t\t  sec = bfd_zalloc (abfd, sizeof *sec);\n\t\t  if (sec == NULL)\n\t\t    return FALSE;\n\n\t\t  /* Fill in only the fields that actually affect the logic\n\t\t     in assign_file_positions_for_load_sections.  */\n\t\t  sec->vma = end;\n\t\t  sec->lma = lastsec->lma + lastsec->size;\n\t\t  sec->size = bed->minpagesize - (end % bed->minpagesize);\n\t\t  sec->flags = (SEC_ALLOC | SEC_LOAD\n\t\t\t\t| SEC_READONLY | SEC_CODE | SEC_LINKER_CREATED);\n\t\t  sec->used_by_bfd = secdata;\n\n\t\t  secdata->this_hdr.sh_type = SHT_PROGBITS;\n\t\t  secdata->this_hdr.sh_flags = SHF_ALLOC | SHF_EXECINSTR;\n\t\t  secdata->this_hdr.sh_addr = sec->vma;\n\t\t  secdata->this_hdr.sh_size = sec->size;\n\n\t\t  newseg = bfd_alloc (abfd,\n\t\t\t\t      sizeof *newseg + ((seg->count + 1)\n\t\t\t\t\t\t\t* sizeof (asection *)));\n\t\t  if (newseg == NULL)\n\t\t    return FALSE;\n\t\t  memcpy (newseg, seg,\n\t\t\t  sizeof *newseg + (seg->count * sizeof (asection *)));\n\t\t  newseg->sections[newseg->count++] = sec;\n"
}