{
    "Project": "Zephyr",
    "Tool": "Infer",
    "Bug Type": "Uninitialized Value",
    "Code_line": "\t\tif ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {",
    "Code_function": "static int nvs_gc(struct nvs_fs *fs)\n{\n\tint rc;\n\tstruct nvs_ate close_ate, gc_ate, wlk_ate;\n\tu32_t sec_addr, gc_addr, gc_prev_addr, wlk_addr, wlk_prev_addr,\n\t      data_addr, stop_addr;\n\tsize_t ate_size;\n\n\tate_size = nvs_al_size(fs, sizeof(struct nvs_ate));\n\n\tsec_addr = (fs->ate_wra & ADDR_SECT_MASK);\n\tnvs_sector_advance(fs, &sec_addr);\n\tgc_addr = sec_addr + fs->sector_size - ate_size;\n\n\t/* if the sector is not closed don't do gc */\n\trc = nvs_flash_ate_rd(fs, gc_addr, &close_ate);\n\tif (rc < 0) {\n\t\t/* flash error */\n\t\treturn rc;\n\t}\n\n\trc = nvs_ate_cmp_const(&close_ate, 0xff);\n\tif (!rc) {\n\t\trc = nvs_flash_erase_sector(fs, sec_addr);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstop_addr = gc_addr - ate_size;\n\n\tgc_addr &= ADDR_SECT_MASK;\n\tgc_addr += close_ate.offset;\n\n\twhile (1) {\n\t\tgc_prev_addr = gc_addr;\n\t\trc = nvs_prev_ate(fs, &gc_addr, &gc_ate);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t\twlk_addr = fs->ate_wra;\n\t\twhile (1) {\n\t\t\twlk_prev_addr = wlk_addr;\n\t\t\trc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);\n\t\t\tif (rc) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\t/* if ate with same id is reached we might need to copy.\n\t\t\t * only consider valid wlk_ate's. Something wrong might\n\t\t\t * have been written that has the same ate but is\n\t\t\t * invalid, don't consider these as a match.\n\t\t\t */\n\t\t\tif ((wlk_ate.id == gc_ate.id) &&\n\t\t\t    (!nvs_ate_crc8_check(&wlk_ate))) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* if walk has reached the same address as gc_addr copy is\n\t\t * needed unless it is a deleted item.\n\t\t */\n\t\tif ((wlk_prev_addr == gc_prev_addr) && gc_ate.len) {\n\t\t\t/* copy needed */\n\t\t\tLOG_DBG(\"Moving %d, len %d\", gc_ate.id, gc_ate.len);\n\n\t\t\tdata_addr = (gc_prev_addr & ADDR_SECT_MASK);\n\t\t\tdata_addr += gc_ate.offset;\n\n\t\t\tgc_ate.offset = (u16_t)(fs->data_wra & ADDR_OFFS_MASK);\n\t\t\tnvs_ate_crc8_update(&gc_ate);\n\n\t\t\trc = nvs_flash_block_move(fs, data_addr, gc_ate.len);\n\t\t\tif (rc) {\n\t\t\t\treturn rc;\n\t\t\t}\n\n\t\t\trc = nvs_flash_ate_wrt(fs, &gc_ate);\n\t\t\tif (rc) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\t/* stop gc at end of the sector */\n\t\tif (gc_prev_addr == stop_addr) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = nvs_flash_erase_sector(fs, sec_addr);\n\tif (rc) {\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
}