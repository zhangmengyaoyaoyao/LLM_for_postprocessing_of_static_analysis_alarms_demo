{
    "Project": "combine",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/df_options.c",
    "message": "The value read from field_found was never initialized.",
    "warning_function_name": "calculate_ranges",
    "warning_line": "return field_found;",
    "warning_context": "int\ncalculate_ranges (string, ranges, end_range_start, range_count)\n     char *string;\n     field_range **ranges;\n     int *end_range_start;\n     int *range_count;\n{\n  /* Parse a list of field specifications.\n     Each will be separated by commas.\n     Each will have the form m, m-n, -n, or m- (m and n being integers).\n     Each may be suffixed with a .n (for precision)\n     Each may have a suffix in parentheses to state a format. */\n\n  int field_found;\t\t/* Non-zero if at least one field spec\n\t\t\t\t   has been processed.  */\n  unsigned int start_value;\n  unsigned int end_value;\n  unsigned int precision;\n\n  unsigned int n_ranges;\n  unsigned int n_ranges_allocated;\n\n  char *string_copy;\n  char *current_range;\n  char *rest_of_string;\n  char *current_comment;\n\n  if (strlen (string) == 0) {\n    *end_range_start = 0;\n    *range_count = 0;\n    *ranges = NULL;\n    return 0;\n    }\n\n  n_ranges = 0;\n  n_ranges_allocated = 16;\n  *ranges = (field_range *) malloc (n_ranges_allocated * sizeof (**ranges));\n\n  string_copy = strdup (string);\n  if (string_copy == NULL)\n    return EXIT_FAILURE;\n\n  rest_of_string = string_copy;\n  while (rest_of_string != NULL) {\n    current_range = strsep (&rest_of_string, \",\");\n\n    start_value = 0;\n    end_value = 0;\n    precision = 0;\n    current_comment = NULL;\n\n    if (*current_range != '-') {\n      start_value = strtol (current_range, &current_range, 0);\n      }\n\n    if (*current_range == '-') {\n      current_range++;\n      end_value = strtol (current_range, &current_range, 0);\n      }\n    else\n      end_value = start_value;\n\n    if (*current_range == '.') {\n      current_range++;\n      precision = strtol (current_range, &current_range, 0);\n      }\n\n    current_comment = current_range;\n    if (*current_comment == '\\0')\n      current_comment = NULL;\n\n    if (start_value == 0 && end_value == 0)\n      FATAL_ERROR1 (_(\"invalid field specification: %s\"), string);\n    if (start_value == 0)\n      start_value = 1;\n\n    if (end_value == 0) {\n      /* A range that extends to the end. */\n      *end_range_start = start_value;\n      }\n    else {\n      /* Validate the range */\n      if (start_value > end_value)\n\tFATAL_ERROR2 (_(\"invalid field range: start %d, end %d\"), start_value,\n\t\t      end_value);\n\n      /* A normal range. */\n      ADD_RANGE_PAIR ((*ranges), start_value, end_value, precision,\n\t\t      current_comment);\n      }\n    }\n  /* Think about whether it matters if we have overlapping ranges.  I once thought it did,\n     but I removed that code. */\n  free (string_copy);\n  *range_count = n_ranges;\n  return field_found;\n  }\n"
}