{
    "Project": "Zephyr",
    "Tool": "Cppcheck",
    "category": "Uninitialized Variable",
    "file": "arch/arm/core/cortex_m/fault.c",
    "message": "Uninitialized variable: ptr_esf",
    "warning_function_name": "get_esf",
    "warning_line": "return ptr_esf;",
    "warning_context": "\t\talternative_state_exc = true;\n\n\t\t/* Dump the Secure stack before handling the actual fault. */\n\t\tz_arch_esf_t *secure_esf;\n\n\t\tif (exc_return & EXC_RETURN_SPSEL_PROCESS) {\n\t\t\t/* Secure stack pointed by PSP */\n\t\t\tsecure_esf = (z_arch_esf_t *)psp;\n\t\t} else {\n\t\t\t/* Secure stack pointed by MSP */\n\t\t\tsecure_esf = (z_arch_esf_t *)msp;\n\t\t\t*nested_exc = true;\n\t\t}\n\n\t\tSECURE_STACK_DUMP(secure_esf);\n\n\t\t/* Handle the actual fault.\n\t\t * Extract the correct stack frame from the Non-Secure state\n\t\t * and supply it to the fault handing function.\n\t\t */\n\t\tif (exc_return & EXC_RETURN_MODE_THREAD) {\n\t\t\tptr_esf = (z_arch_esf_t *)__TZ_get_PSP_NS();\n\t\t} else {\n\t\t\tptr_esf = (z_arch_esf_t *)__TZ_get_MSP_NS();\n\t\t}\n\t}\n#elif defined(CONFIG_ARM_NONSECURE_FIRMWARE)\n\tif (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {\n\t\t/* Non-Secure Firmware shall only handle Non-Secure Exceptions.\n\t\t * This is a fatal error.\n\t\t */\n\t\treturn NULL;\n\t}\n\n\tif (exc_return & EXC_RETURN_RETURN_STACK_Secure) {\n\t\t/* Exception entry occurred in Secure stack.\n\t\t *\n\t\t * Note that Non-Secure firmware cannot inspect the Secure\n\t\t * stack to determine the root cause of the fault. Fault\n\t\t * inspection will indicate the Non-Secure instruction\n\t\t * that performed the branch to the Secure domain.\n\t\t */\n\t\talternative_state_exc = true;\n\n\t\tPR_FAULT_INFO(\"Exception occurred in Secure State\");\n\n\t\tif (exc_return & EXC_RETURN_SPSEL_PROCESS) {\n\t\t\t/* Non-Secure stack frame on PSP */\n\t\t\tptr_esf = (z_arch_esf_t *)psp;\n\t\t} else {\n\t\t\t/* Non-Secure stack frame on MSP */\n\t\t\tptr_esf = (z_arch_esf_t *)msp;\n\t\t}\n\t} else {\n\t\t/* Exception entry occurred in Non-Secure stack. */\n\t}\n#else\n\t/* The processor has a single execution state.\n\t * We verify that the Thread mode is using PSP.\n\t */\n\tif ((exc_return & EXC_RETURN_MODE_THREAD) &&\n\t\t(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {\n\t\tPR_EXC(\"SPSEL in thread mode does not indicate PSP\");\n\t\treturn NULL;\n\t}\n#endif /* CONFIG_ARM_SECURE_FIRMWARE */\n\n\tif (!alternative_state_exc) {\n\t\tif (exc_return & EXC_RETURN_MODE_THREAD) {\n\t\t\t/* Returning to thread mode */\n\t\t\tptr_esf =  (z_arch_esf_t *)psp;\n\n\t\t} else {\n\t\t\t/* Returning to handler mode */\n\t\t\tptr_esf = (z_arch_esf_t *)msp;\n\t\t\t*nested_exc = true;\n\t\t}\n\t}\n\n\treturn ptr_esf;\n}\n\n/**\n *\n * @brief ARM Fault handler\n *\n * This routine is called when fatal error conditions are detected by hardware\n * and is responsible for:\n * - resetting the processor fault status registers (for the case when the\n *   error handling policy allows the system to recover from the error),\n * - reporting the error information,\n * - determining the error reason to be provided as input to the user-\n *   provided routine, k_sys_fatal_error_handler().\n * The k_sys_fatal_error_handler() is invoked once the above operations are\n * completed, and is responsible for implementing the error handling policy.\n *\n * The function needs, first, to determine the exception stack frame.\n * Note that the current security state might not be the actual\n * state in which the processor was executing, when the exception occurred.\n * The actual state may need to be determined by inspecting the EXC_RETURN\n * value, which is provided as argument to the Fault handler.\n"
}