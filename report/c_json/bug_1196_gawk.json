{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "field.c",
    "message": "Offset: 1 Size: [0, 4].",
    "warning_function_name": "set_FIELDWIDTHS",
    "warning_line": "FIELDWIDTHS[i] = -1;",
    "warning_context": "void\nset_FIELDWIDTHS()\n{\n\tchar *scan;\n\tchar *end;\n\tint i;\n\tstatic int fw_alloc = 4;\n\tstatic bool warned = false;\n\tbool fatal_error = false;\n\tNODE *tmp;\n\n\tif (do_lint && ! warned) {\n\t\twarned = true;\n\t\tlintwarn(_(\"`FIELDWIDTHS' is a gawk extension\"));\n\t}\n\tif (do_traditional)\t/* quick and dirty, does the trick */\n\t\treturn;\n\n\t/*\n\t * If changing the way fields are split, obey least-suprise\n\t * semantics, and force $0 to be split totally.\n\t */\n\tif (fields_arr != NULL)\n\t\t(void) get_field(UNLIMITED - 1, 0);\n\n\tparse_field = fw_parse_field;\n\ttmp = force_string(FIELDWIDTHS_node->var_value);\n\tscan = tmp->stptr;\n\n\tif (FIELDWIDTHS == NULL)\n\t\temalloc(FIELDWIDTHS, int *, fw_alloc * sizeof(int), \"set_FIELDWIDTHS\");\n\tFIELDWIDTHS[0] = 0;\n\tfor (i = 1; ; i++) {\n\t\tunsigned long int tmp;\n\t\tif (i + 2 >= fw_alloc) {\n\t\t\tfw_alloc *= 2;\n\t\t\terealloc(FIELDWIDTHS, int *, fw_alloc * sizeof(int), \"set_FIELDWIDTHS\");\n\t\t}\n\t\t/* Initialize value to be end of list */\n\t\tFIELDWIDTHS[i] = -1;\n\t\t/* Ensure that there is no leading `-' sign.  Otherwise,\n\t\t   strtoul would accept it and return a bogus result.  */\n\t\twhile (is_blank(*scan)) {\n\t\t\t++scan;\n\t\t}\n\t\tif (*scan == '-') {\n\t\t\tfatal_error = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (*scan == '\\0')\n\t\t\tbreak;\n\n\t\t/* Detect an invalid base-10 integer, a valid value that\n\t\t   is followed by something other than a blank or '\\0',\n\t\t   or a value that is not in the range [1..INT_MAX].  */\n\t\terrno = 0;\n\t\ttmp = strtoul(scan, &end, 10);\n\t\tif (errno != 0\n\t\t    \t|| (*end != '\\0' && ! is_blank(*end))\n\t\t\t\t|| !(0 < tmp && tmp <= INT_MAX)\n\t\t) {\n\t\t\tfatal_error = true;\t\n\t\t\tbreak;\n\t\t}\n\t\tFIELDWIDTHS[i] = tmp;\n\t\tscan = end;\n\t\t/* Skip past any trailing blanks.  */\n\t\twhile (is_blank(*scan)) {\n\t\t\t++scan;\n\t\t}\n\t\tif (*scan == '\\0')\n\t\t\tbreak;\n\t}\n\tFIELDWIDTHS[i+1] = -1;\n\n\tupdate_PROCINFO_str(\"FS\", \"FIELDWIDTHS\");\n\tif (fatal_error)\n\t\tfatal(_(\"invalid FIELDWIDTHS value, near `%s'\"),\n\t\t\t      scan);\n}\n"
}