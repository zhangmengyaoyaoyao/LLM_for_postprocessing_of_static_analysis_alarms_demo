{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf-eh-frame.c",
    "message": "Offset: 3 Size: [0, +oo].",
    "warning_function_name": "_bfd_elf_write_section_eh_frame_hdr",
    "warning_line": "contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4;",
    "warning_context": "bfd_boolean\n_bfd_elf_write_section_eh_frame_hdr (bfd *abfd, struct bfd_link_info *info)\n{\n  struct elf_link_hash_table *htab;\n  struct eh_frame_hdr_info *hdr_info;\n  asection *sec;\n  bfd_boolean retval = TRUE;\n\n  htab = elf_hash_table (info);\n  hdr_info = &htab->eh_info;\n  sec = hdr_info->hdr_sec;\n\n  if (info->eh_frame_hdr && sec != NULL)\n    {\n      bfd_byte *contents;\n      asection *eh_frame_sec;\n      bfd_size_type size;\n      bfd_vma encoded_eh_frame;\n\n      size = EH_FRAME_HDR_SIZE;\n      if (hdr_info->array && hdr_info->array_count == hdr_info->fde_count)\n\tsize += 4 + hdr_info->fde_count * 8;\n      contents = (bfd_byte *) bfd_malloc (size);\n      if (contents == NULL)\n\treturn FALSE;\n\n      eh_frame_sec = bfd_get_section_by_name (abfd, \".eh_frame\");\n      if (eh_frame_sec == NULL)\n\t{\n\t  free (contents);\n\t  return FALSE;\n\t}\n\n      memset (contents, 0, EH_FRAME_HDR_SIZE);\n      /* Version.  */\n      contents[0] = 1;\n      /* .eh_frame offset.  */\n      contents[1] = get_elf_backend_data (abfd)->elf_backend_encode_eh_address\n\t(abfd, info, eh_frame_sec, 0, sec, 4, &encoded_eh_frame);\n\n      if (hdr_info->array && hdr_info->array_count == hdr_info->fde_count)\n\t{\n\t  /* FDE count encoding.  */\n\t  contents[2] = DW_EH_PE_udata4;\n\t  /* Search table encoding.  */\n\t  contents[3] = DW_EH_PE_datarel | DW_EH_PE_sdata4;\n\t}\n      else\n\t{\n\t  contents[2] = DW_EH_PE_omit;\n\t  contents[3] = DW_EH_PE_omit;\n\t}\n      bfd_put_32 (abfd, encoded_eh_frame, contents + 4);\n\n      if (contents[2] != DW_EH_PE_omit)\n\t{\n\t  unsigned int i;\n\n\t  bfd_put_32 (abfd, hdr_info->fde_count, contents + EH_FRAME_HDR_SIZE);\n\t  qsort (hdr_info->array, hdr_info->fde_count,\n\t\t sizeof (*hdr_info->array), vma_compare);\n\t  for (i = 0; i < hdr_info->fde_count; i++)\n\t    {\n\t      bfd_vma val;\n\n\t      val = hdr_info->array[i].initial_loc - sec->output_section->vma;\n\t      val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n\t      if (elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64\n\t\t  && (hdr_info->array[i].initial_loc\n\t\t      != sec->output_section->vma + val))\n\t\t(*info->callbacks->einfo)\n\t\t  (_(\"%X%P: .eh_frame_hdr table[%u] PC overflow.\\n\"), i);\n\t      bfd_put_32 (abfd, val, contents + EH_FRAME_HDR_SIZE + i * 8 + 4);\n\n\t      val = hdr_info->array[i].fde - sec->output_section->vma;\n\t      val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n\t      if (elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64\n\t\t  && (hdr_info->array[i].fde\n\t\t      != sec->output_section->vma + val))\n\t\t(*info->callbacks->einfo)\n\t\t  (_(\"%X%P: .eh_frame_hdr table[%u] FDE overflow.\\n\"), i);\n\t      bfd_put_32 (abfd, val, contents + EH_FRAME_HDR_SIZE + i * 8 + 8);\n\n\t      if (i != 0\n\t\t  && (hdr_info->array[i].initial_loc\n\t\t      < (hdr_info->array[i - 1].initial_loc\n\t\t\t + hdr_info->array[i - 1].range)))\n\t\t(*info->callbacks->einfo)\n\t\t  (_(\"%X%P: .eh_frame_hdr table[%u] FDE at %V overlaps \"\n\t\t     \"table[%u] FDE at %V.\\n\"),\n\t\t   i - 1, hdr_info->array[i - 1].fde,\n\t\t   i, hdr_info->array[i].fde);\n\t    }\n\t}\n\n      /* FIXME: octets_per_byte.  */\n      if (!bfd_set_section_contents (abfd, sec->output_section, contents,\n\t\t\t\t     (file_ptr) sec->output_offset,\n\t\t\t\t     sec->size))\n\tretval = FALSE;\n      free (contents);\n"
}