{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf32-i386.c",
    "message": "Offset: [-203, 33] Size: 34 by call to `elf_i386_tls_transition`.",
    "warning_function_name": "elf_i386_relocate_section",
    "warning_line": "if (! elf_i386_tls_transition (info, input_bfd,",
    "warning_context": "\n\t      skip = FALSE;\n\t      relocate = FALSE;\n\n\t      outrel.r_offset =\n\t\t_bfd_elf_section_offset (output_bfd, info, input_section,\n\t\t\t\t\t rel->r_offset);\n\t      if (outrel.r_offset == (bfd_vma) -1)\n\t\tskip = TRUE;\n\t      else if (outrel.r_offset == (bfd_vma) -2)\n\t\tskip = TRUE, relocate = TRUE;\n\t      outrel.r_offset += (input_section->output_section->vma\n\t\t\t\t  + input_section->output_offset);\n\n\t      if (skip)\n\t\tmemset (&outrel, 0, sizeof outrel);\n\t      else if (h != NULL\n\t\t       && h->dynindx != -1\n\t\t       && (r_type == R_386_PC32\n\t\t\t   || !info->shared\n\t\t\t   || !SYMBOLIC_BIND (info, h)\n\t\t\t   || !h->def_regular))\n\t\toutrel.r_info = ELF32_R_INFO (h->dynindx, r_type);\n\t      else\n\t\t{\n\t\t  /* This symbol is local, or marked to become local.  */\n\t\t  relocate = TRUE;\n\t\t  outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n\t\t}\n\n\t      sreloc = elf_section_data (input_section)->sreloc;\n\n\t      if (sreloc == NULL || sreloc->contents == NULL)\n\t\t{\n\t\t  r = bfd_reloc_notsupported;\n\t\t  goto check_relocation_error;\n\t\t}\n\n\t      elf_append_rel (output_bfd, sreloc, &outrel);\n\n\t      /* If this reloc is against an external symbol, we do\n\t\t not want to fiddle with the addend.  Otherwise, we\n\t\t need to include the symbol value so that it becomes\n\t\t an addend for the dynamic reloc.  */\n\t      if (! relocate)\n\t\tcontinue;\n\t    }\n\t  break;\n\n\tcase R_386_TLS_IE:\n\t  if (!info->executable)\n\t    {\n\t      Elf_Internal_Rela outrel;\n\t      asection *sreloc;\n\n\t      outrel.r_offset = rel->r_offset\n\t\t\t\t+ input_section->output_section->vma\n\t\t\t\t+ input_section->output_offset;\n\t      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n\t      sreloc = elf_section_data (input_section)->sreloc;\n\t      if (sreloc == NULL)\n\t\tabort ();\n\t      elf_append_rel (output_bfd, sreloc, &outrel);\n\t    }\n\t  /* Fall through */\n\n\tcase R_386_TLS_GD:\n\tcase R_386_TLS_GOTDESC:\n\tcase R_386_TLS_DESC_CALL:\n\tcase R_386_TLS_IE_32:\n\tcase R_386_TLS_GOTIE:\n\t  tls_type = GOT_UNKNOWN;\n\t  if (h == NULL && local_got_offsets)\n\t    tls_type = elf_i386_local_got_tls_type (input_bfd) [r_symndx];\n\t  else if (h != NULL)\n\t    tls_type = elf_i386_hash_entry(h)->tls_type;\n\t  if (tls_type == GOT_TLS_IE)\n\t    tls_type = GOT_TLS_IE_NEG;\n\n\t  if (! elf_i386_tls_transition (info, input_bfd,\n\t\t\t\t\t input_section, contents,\n\t\t\t\t\t symtab_hdr, sym_hashes,\n\t\t\t\t\t &r_type, tls_type, rel,\n\t\t\t\t\t relend, h, r_symndx))\n\t    return FALSE;\n\n\t  if (r_type == R_386_TLS_LE_32)\n\t    {\n\t      BFD_ASSERT (! unresolved_reloc);\n\t      if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)\n\t\t{\n\t\t  unsigned int type;\n\t\t  bfd_vma roff;\n\n\t\t  /* GD->LE transition.  */\n\t\t  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);\n\t\t  if (type == 0x04)\n\t\t    {\n\t\t      /* leal foo(,%reg,1), %eax; call ___tls_get_addr\n\t\t\t Change it into:\n\t\t\t movl %gs:0, %eax; subl $foo@tpoff, %eax\n"
}