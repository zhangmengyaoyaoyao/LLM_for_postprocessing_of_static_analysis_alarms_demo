{
    "Project": "sed",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "    str_append(&s_accum, line.active + start, line.length-start);",
    "Code_function": "do_subst(sub)\n  struct subst *sub;\n{\n  size_t start = 0;\t/* where to start scan for (next) match in LINE */\n  size_t last_end = 0;  /* where did the last successful match end in LINE */\n  countT count = 0;\t/* number of matches found */\n  bool again = true;\n\n  static struct re_registers regs;\n\n  line_reset(&s_accum, &line);\n\n  /* The first part of the loop optimizes s/xxx// when xxx is at the\n     start, and s/xxx$// */\n  if (!match_regex(sub->regx, line.active, line.length, start,\n\t\t   &regs, sub->max_id + 1))\n    return;\n\n  if (!sub->replacement && sub->numb <= 1)\n    {\n      if (regs.start[0] == 0 && !sub->global)\n        {\n\t  /* We found a match, set the `replaced' flag. */\n\t  replaced = true;\n\n\t  line.active += regs.end[0];\n\t  line.length -= regs.end[0];\n\t  line.alloc -= regs.end[0];\n\t  goto post_subst;\n        }\n      else if (regs.end[0] == line.length)\n        {\n\t  /* We found a match, set the `replaced' flag. */\n\t  replaced = true;\n\n\t  line.length = regs.start[0];\n\t  goto post_subst;\n        }\n    }\n\n  do\n    {\n      enum replacement_types repl_mod = 0;\n\n      size_t offset = regs.start[0];\n      size_t matched = regs.end[0] - regs.start[0];\n\n      /* Copy stuff to the left of this match into the output string. */\n      if (start < offset)\n\tstr_append(&s_accum, line.active + start, offset - start);\n\n      /* If we're counting up to the Nth match, are we there yet?\n         And even if we are there, there is another case we have to\n\t skip: are we matching an empty string immediately following\n         another match?\n\n         This latter case avoids that baaaac, when passed through\n         s,a*,x,g, gives `xbxxcx' instead of xbxcx.  This behavior is\n         unacceptable because it is not consistently applied (for\n         example, `baaaa' gives `xbx', not `xbxx'). */\n      if ((matched > 0 || count == 0 || offset > last_end)\n\t  && ++count >= sub->numb)\n        {\n          /* We found a match, set the `replaced' flag. */\n          replaced = true;\n\n          /* Now expand the replacement string into the output string. */\n          repl_mod = append_replacement (&s_accum, sub->replacement, &regs, repl_mod);\n\t  again = sub->global;\n        }\n      else\n\t{\n          /* The match was not replaced.  Copy the text until its\n             end; if it was vacuous, skip over one character and\n\t     add that character to the output.  */\n\t  if (matched == 0)\n\t    {\n\t      if (start < line.length)\n\t        matched = 1;\n\t      else\n\t        break;\n\t    }\n\n\t  str_append(&s_accum, line.active + offset, matched);\n        }\n\n      /* Start after the match.  last_end is the real end of the matched\n\t substring, excluding characters that were skipped in case the RE\n\t matched the empty string.  */\n      start = offset + matched;\n      last_end = regs.end[0];\n    }\n  while (again\n\t && start <= line.length\n\t && match_regex(sub->regx, line.active, line.length, start,\n\t\t\t&regs, sub->max_id + 1));\n\n  /* Copy stuff to the right of the last match into the output string. */\n  if (start < line.length)\n    str_append(&s_accum, line.active + start, line.length-start);\n  s_accum.chomped = line.chomped;\n\n  /* Exchange line and s_accum.  This can be much cheaper\n     than copying s_accum.active into line.text (for huge lines). */\n  line_exchange(&line, &s_accum, false);\n\n  /* Finish up. */\n  if (count < sub->numb)\n    return;\n\n post_subst:\n  if (sub->print & 1)\n    output_line(line.active, line.length, line.chomped, &output_file);\n\n  if (sub->eval)\n    {\n#ifdef HAVE_POPEN\n      FILE *pipe_fp;\n      line_reset(&s_accum, NULL);\n\n      str_append (&line, \"\", 1);\n      pipe_fp = popen(line.active, \"r\");\n\n      if (pipe_fp != NULL)\n\t{\n\t  while (!feof (pipe_fp))\n\t    {\n\t      char buf[4096];\n\t      int n = fread (buf, sizeof(char), 4096, pipe_fp);\n\t      if (n > 0)\n\t\tstr_append(&s_accum, buf, n);\n\t    }\n\n\t  pclose (pipe_fp);\n\n\t  /* Exchange line and s_accum.  This can be much cheaper than copying\n\t     s_accum.active into line.text (for huge lines).  See comment above\n\t     for 'g' as to while the third argument is incorrect anyway.  */\n\t  line_exchange(&line, &s_accum, true);\n\t  if (line.length &&\n\t      line.active[line.length - 1] == '\\n')\n\t    line.length--;\n\t}\n      else\n\tpanic(_(\"error in subprocess\"));\n#else\n      panic(_(\"option `e' not supported\"));\n#endif\n    }\n\n  if (sub->print & 2)\n    output_line(line.active, line.length, line.chomped, &output_file);\n  if (sub->outf)\n    output_line(line.active, line.length, line.chomped, sub->outf);\n}"
}