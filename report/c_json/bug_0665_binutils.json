{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "  if (! stab_write_symbol (&info, N_SO, 0, info.last_text_address,",
    "Code_function": "write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,\n\t\t\t\t\tbfd_byte **psyms,\n\t\t\t\t\tbfd_size_type *psymsize,\n\t\t\t\t\tbfd_byte **pstrings,\n\t\t\t\t\tbfd_size_type *pstringsize)\n{\n  struct stab_write_handle info;\n  struct string_hash_entry *h;\n  bfd_byte *p;\n\n  info.abfd = abfd;\n\n  info.symbols_size = 0;\n  info.symbols_alloc = 500;\n  info.symbols = (bfd_byte *) xmalloc (info.symbols_alloc);\n\n  info.strings = NULL;\n  info.last_string = NULL;\n  /* Reserve 1 byte for a null byte.  */\n  info.strings_size = 1;\n\n  if (!bfd_hash_table_init (&info.strhash.table, string_hash_newfunc,\n\t\t\t    sizeof (struct string_hash_entry))\n      || !bfd_hash_table_init (&info.typedef_hash.table, string_hash_newfunc,\n\t\t\t       sizeof (struct string_hash_entry)))\n    {\n      non_fatal (\"bfd_hash_table_init_failed: %s\",\n\t\t bfd_errmsg (bfd_get_error ()));\n      return FALSE;\n    }\n\n  info.type_stack = NULL;\n  info.type_index = 1;\n  memset (&info.type_cache, 0, sizeof info.type_cache);\n  info.so_offset = -1;\n  info.fun_offset = -1;\n  info.last_text_address = 0;\n  info.nesting = 0;\n  info.fnaddr = 0;\n  info.pending_lbrac = (bfd_vma) -1;\n\n  /* The initial symbol holds the string size.  */\n  if (! stab_write_symbol (&info, 0, 0, 0, (const char *) NULL))\n    return FALSE;\n\n  /* Output an initial N_SO symbol.  */\n  info.so_offset = info.symbols_size;\n  if (! stab_write_symbol (&info, N_SO, 0, 0, bfd_get_filename (abfd)))\n    return FALSE;\n\n  if (! debug_write (dhandle, &stab_fns, (void *) &info))\n    return FALSE;\n\n  assert (info.pending_lbrac == (bfd_vma) -1);\n\n  /* Output a trailing N_SO.  */\n  if (! stab_write_symbol (&info, N_SO, 0, info.last_text_address,\n\t\t\t   (const char *) NULL))\n    return FALSE;\n\n  /* Put the string size in the initial symbol.  */\n  bfd_put_32 (abfd, info.strings_size, info.symbols + 8);\n\n  *psyms = info.symbols;\n  *psymsize = info.symbols_size;\n\n  *pstringsize = info.strings_size;\n  *pstrings = (bfd_byte *) xmalloc (info.strings_size);\n\n  p = *pstrings;\n  *p++ = '\\0';\n  for (h = info.strings; h != NULL; h = h->next)\n    {\n      strcpy ((char *) p, h->root.string);\n      p += strlen ((char *) p) + 1;\n    }\n\n  return TRUE;\n}"
}