{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t*--s = '0';",
    "Code_function": "disassemble_bytes (struct disassemble_info * inf,\n\t\t   disassembler_ftype        disassemble_fn,\n\t\t   bfd_boolean               insns,\n\t\t   bfd_byte *                data,\n\t\t   bfd_vma                   start_offset,\n\t\t   bfd_vma                   stop_offset,\n\t\t   bfd_vma\t\t     rel_offset,\n\t\t   arelent ***               relppp,\n\t\t   arelent **                relppend)\n{\n  struct objdump_disasm_info *aux;\n  asection *section;\n  int octets_per_line;\n  int skip_addr_chars;\n  bfd_vma addr_offset;\n  unsigned int opb = inf->octets_per_byte;\n  unsigned int skip_zeroes = inf->skip_zeroes;\n  unsigned int skip_zeroes_at_end = inf->skip_zeroes_at_end;\n  int octets = opb;\n  SFILE sfile;\n\n  aux = (struct objdump_disasm_info *) inf->application_data;\n  section = aux->sec;\n\n  sfile.alloc = 120;\n  sfile.buffer = (char *) xmalloc (sfile.alloc);\n  sfile.pos = 0;\n\n  if (insn_width)\n    octets_per_line = insn_width;\n  else if (insns)\n    octets_per_line = 4;\n  else\n    octets_per_line = 16;\n\n  /* Figure out how many characters to skip at the start of an\n     address, to make the disassembly look nicer.  We discard leading\n     zeroes in chunks of 4, ensuring that there is always a leading\n     zero remaining.  */\n  skip_addr_chars = 0;\n  if (! prefix_addresses)\n    {\n      char buf[30];\n\n      bfd_sprintf_vma (aux->abfd, buf, section->vma + section->size / opb);\n\n      while (buf[skip_addr_chars] == '0')\n\t++skip_addr_chars;\n\n      /* Don't discard zeros on overflow.  */\n      if (buf[skip_addr_chars] == '\\0' && section->vma != 0)\n\tskip_addr_chars = 0;\n\n      if (skip_addr_chars != 0)\n\tskip_addr_chars = (skip_addr_chars - 1) & -4;\n    }\n\n  inf->insn_info_valid = 0;\n\n  addr_offset = start_offset;\n  while (addr_offset < stop_offset)\n    {\n      bfd_vma z;\n      bfd_boolean need_nl = FALSE;\n      int previous_octets;\n\n      /* Remember the length of the previous instruction.  */\n      previous_octets = octets;\n      octets = 0;\n\n      /* Make sure we don't use relocs from previous instructions.  */\n      aux->reloc = NULL;\n\n      /* If we see more than SKIP_ZEROES octets of zeroes, we just\n\t print `...'.  */\n      for (z = addr_offset * opb; z < stop_offset * opb; z++)\n\tif (data[z] != 0)\n\t  break;\n      if (! disassemble_zeroes\n\t  && (inf->insn_info_valid == 0\n\t      || inf->branch_delay_insns == 0)\n\t  && (z - addr_offset * opb >= skip_zeroes\n\t      || (z == stop_offset * opb &&\n\t\t  z - addr_offset * opb < skip_zeroes_at_end)))\n\t{\n\t  /* If there are more nonzero octets to follow, we only skip\n\t     zeroes in multiples of 4, to try to avoid running over\n\t     the start of an instruction which happens to start with\n\t     zero.  */\n\t  if (z != stop_offset * opb)\n\t    z = addr_offset * opb + ((z - addr_offset * opb) &~ 3);\n\n\t  octets = z - addr_offset * opb;\n\n\t  /* If we are going to display more data, and we are displaying\n\t     file offsets, then tell the user how many zeroes we skip\n\t     and the file offset from where we resume dumping.  */\n\t  if (display_file_offsets && ((addr_offset + (octets / opb)) < stop_offset))\n\t    printf (\"\\t... (skipping %d zeroes, resuming at file offset: 0x%lx)\\n\",\n\t\t    octets / opb,\n\t\t    (unsigned long) (section->filepos\n\t\t\t\t     + (addr_offset + (octets / opb))));\n\t  else\n\t    printf (\"\\t...\\n\");\n\t}\n      else\n\t{\n\t  char buf[50];\n\t  int bpc = 0;\n\t  int pb = 0;\n\n\t  if (with_line_numbers || with_source_code)\n\t    show_line (aux->abfd, section, addr_offset);\n\n\t  if (! prefix_addresses)\n\t    {\n\t      char *s;\n\n\t      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);\n\t      for (s = buf + skip_addr_chars; *s == '0'; s++)\n\t\t*s = ' ';\n\t      if (*s == '\\0')\n\t\t*--s = '0';\n\t      printf (\"%s:\\t\", buf + skip_addr_chars);\n\t    }\n\t  else\n\t    {\n\t      aux->require_sec = TRUE;\n\t      objdump_print_address (section->vma + addr_offset, inf);\n\t      aux->require_sec = FALSE;\n\t      putchar (' ');\n\t    }\n\n\t  if (insns)\n\t    {\n\t      sfile.pos = 0;\n\t      inf->fprintf_func = (fprintf_ftype) objdump_sprintf;\n\t      inf->stream = &sfile;\n\t      inf->bytes_per_line = 0;\n\t      inf->bytes_per_chunk = 0;\n\t      inf->flags = disassemble_all ? DISASSEMBLE_DATA : 0;\n\t      if (machine)\n\t\tinf->flags |= USER_SPECIFIED_MACHINE_TYPE;\n\n\t      if (inf->disassembler_needs_relocs\n\t\t  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0\n\t\t  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0\n\t\t  && *relppp < relppend)\n\t\t{\n\t\t  bfd_signed_vma distance_to_rel;\n\n\t\t  distance_to_rel = (**relppp)->address\n\t\t    - (rel_offset + addr_offset);\n\n\t\t  /* Check to see if the current reloc is associated with\n\t\t     the instruction that we are about to disassemble.  */\n\t\t  if (distance_to_rel == 0\n\t\t      /* FIXME: This is wrong.  We are trying to catch\n\t\t\t relocs that are addressed part way through the\n\t\t\t current instruction, as might happen with a packed\n\t\t\t VLIW instruction.  Unfortunately we do not know the\n\t\t\t length of the current instruction since we have not\n\t\t\t disassembled it yet.  Instead we take a guess based\n\t\t\t upon the length of the previous instruction.  The\n\t\t\t proper solution is to have a new target-specific\n\t\t\t disassembler function which just returns the length\n\t\t\t of an instruction at a given address without trying\n\t\t\t to display its disassembly. */\n\t\t      || (distance_to_rel > 0\n\t\t\t  && distance_to_rel < (bfd_signed_vma) (previous_octets/ opb)))\n\t\t    {\n\t\t      inf->flags |= INSN_HAS_RELOC;\n\t\t      aux->reloc = **relppp;\n\t\t    }\n\t\t}\n\n\t      octets = (*disassemble_fn) (section->vma + addr_offset, inf);\n\t      inf->fprintf_func = (fprintf_ftype) fprintf;\n\t      inf->stream = stdout;\n\t      if (insn_width == 0 && inf->bytes_per_line != 0)\n\t\toctets_per_line = inf->bytes_per_line;\n\t      if (octets < (int) opb)\n\t\t{\n\t\t  if (sfile.pos)\n\t\t    printf (\"%s\\n\", sfile.buffer);\n\t\t  if (octets >= 0)\n\t\t    {\n\t\t      non_fatal (_(\"disassemble_fn returned length %d\"),\n\t\t\t\t octets);\n\t\t      exit_status = 1;\n\t\t    }\n\t\t  break;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      bfd_vma j;\n\n\t      octets = octets_per_line;\n\t      if (addr_offset + octets / opb > stop_offset)\n\t\toctets = (stop_offset - addr_offset) * opb;\n\n\t      for (j = addr_offset * opb; j < addr_offset * opb + octets; ++j)\n\t\t{\n\t\t  if (ISPRINT (data[j]))\n\t\t    buf[j - addr_offset * opb] = data[j];\n\t\t  else\n\t\t    buf[j - addr_offset * opb] = '.';\n\t\t}\n\t      buf[j - addr_offset * opb] = '\\0';\n\t    }\n\n\t  if (prefix_addresses\n\t      ? show_raw_insn > 0\n\t      : show_raw_insn >= 0)\n\t    {\n\t      bfd_vma j;\n\n\t      /* If ! prefix_addresses and ! wide_output, we print\n\t\t octets_per_line octets per line.  */\n\t      pb = octets;\n\t      if (pb > octets_per_line && ! prefix_addresses && ! wide_output)\n\t\tpb = octets_per_line;\n\n\t      if (inf->bytes_per_chunk)\n\t\tbpc = inf->bytes_per_chunk;\n\t      else\n\t\tbpc = 1;\n\n\t      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)\n\t\t{\n\t\t  int k;\n\n\t\t  if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)\n\t\t    {\n\t\t      for (k = bpc - 1; k >= 0; k--)\n\t\t\tprintf (\"%02x\", (unsigned) data[j + k]);\n\t\t      putchar (' ');\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      for (k = 0; k < bpc; k++)\n\t\t\tprintf (\"%02x\", (unsigned) data[j + k]);\n\t\t      putchar (' ');\n\t\t    }\n\t\t}\n\n\t      for (; pb < octets_per_line; pb += bpc)\n\t\t{\n\t\t  int k;\n\n\t\t  for (k = 0; k < bpc; k++)\n\t\t    printf (\"  \");\n\t\t  putchar (' ');\n\t\t}\n\n\t      /* Separate raw data from instruction by extra space.  */\n\t      if (insns)\n\t\tputchar ('\\t');\n\t      else\n\t\tprintf (\"    \");\n\t    }\n\n\t  if (! insns)\n\t    printf (\"%s\", buf);\n\t  else if (sfile.pos)\n\t    printf (\"%s\", sfile.buffer);\n\n\t  if (prefix_addresses\n\t      ? show_raw_insn > 0\n\t      : show_raw_insn >= 0)\n\t    {\n\t      while (pb < octets)\n\t\t{\n\t\t  bfd_vma j;\n\t\t  char *s;\n\n\t\t  putchar ('\\n');\n\t\t  j = addr_offset * opb + pb;\n\n\t\t  bfd_sprintf_vma (aux->abfd, buf, section->vma + j / opb);\n\t\t  for (s = buf + skip_addr_chars; *s == '0'; s++)\n\t\t    *s = ' ';\n\t\t  if (*s == '\\0')\n\t\t    *--s = '0';\n\t\t  printf (\"%s:\\t\", buf + skip_addr_chars);\n\n\t\t  pb += octets_per_line;\n\t\t  if (pb > octets)\n\t\t    pb = octets;\n\t\t  for (; j < addr_offset * opb + pb; j += bpc)\n\t\t    {\n\t\t      int k;\n\n\t\t      if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)\n\t\t\t{\n\t\t\t  for (k = bpc - 1; k >= 0; k--)\n\t\t\t    printf (\"%02x\", (unsigned) data[j + k]);\n\t\t\t  putchar (' ');\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  for (k = 0; k < bpc; k++)\n\t\t\t    printf (\"%02x\", (unsigned) data[j + k]);\n\t\t\t  putchar (' ');\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (!wide_output)\n\t    putchar ('\\n');\n\t  else\n\t    need_nl = TRUE;\n\t}\n\n      while ((*relppp) < relppend\n\t     && (**relppp)->address < rel_offset + addr_offset + octets / opb)\n\t{\n\t  if (dump_reloc_info || dump_dynamic_reloc_info)\n\t    {\n\t      arelent *q;\n\n\t      q = **relppp;\n\n\t      if (wide_output)\n\t\tputchar ('\\t');\n\t      else\n\t\tprintf (\"\\t\\t\\t\");\n\n\t      objdump_print_value (section->vma - rel_offset + q->address,\n\t\t\t\t   inf, TRUE);\n\n\t      if (q->howto == NULL)\n\t\tprintf (\": *unknown*\\t\");\n\t      else if (q->howto->name)\n\t\tprintf (\": %s\\t\", q->howto->name);\n\t      else\n\t\tprintf (\": %d\\t\", q->howto->type);\n\n\t      if (q->sym_ptr_ptr == NULL || *q->sym_ptr_ptr == NULL)\n\t\tprintf (\"*unknown*\");\n\t      else\n\t\t{\n\t\t  const char *sym_name;\n\n\t\t  sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);\n\t\t  if (sym_name != NULL && *sym_name != '\\0')\n\t\t    objdump_print_symname (aux->abfd, inf, *q->sym_ptr_ptr);\n\t\t  else\n\t\t    {\n\t\t      asection *sym_sec;\n\n\t\t      sym_sec = bfd_get_section (*q->sym_ptr_ptr);\n\t\t      sym_name = bfd_get_section_name (aux->abfd, sym_sec);\n\t\t      if (sym_name == NULL || *sym_name == '\\0')\n\t\t\tsym_name = \"*unknown*\";\n\t\t      printf (\"%s\", sym_name);\n\t\t    }\n\t\t}\n\n\t      if (q->addend)\n\t\t{\n\t\t  bfd_signed_vma addend = q->addend;\n\t\t  if (addend < 0)\n\t\t    {\n\t\t      printf (\"-0x\");\n\t\t      addend = -addend;\n\t\t    }\n\t\t  else\n\t\t    printf (\"+0x\");\n\t\t  objdump_print_value (addend, inf, TRUE);\n\t\t}\n\n\t      printf (\"\\n\");\n\t      need_nl = FALSE;\n\t    }\n\t  ++(*relppp);\n\t}\n\n      if (need_nl)\n\tprintf (\"\\n\");\n\n      addr_offset += octets / opb;\n    }\n\n  free (sfile.buffer);\n}"
}