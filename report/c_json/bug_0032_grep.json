{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from sub[_] was never initialized.",
    "Code_line": "      char const *matchend = p + sub[1];",
    "Code_function": "Pexecute (char const *buf, size_t size, size_t *match_size,\n          char const *start_ptr)\n{\n#if !HAVE_LIBPCRE\n  /* We can't get here, because Pcompile would have been called earlier.  */\n  error (EXIT_TROUBLE, 0, _(\"internal error\"));\n  return -1;\n#else\n  int sub[NSUB];\n  char const *p = start_ptr ? start_ptr : buf;\n  bool bol = p[-1] == eolbyte;\n  char const *line_start = buf;\n  int e = PCRE_ERROR_NOMATCH;\n  char const *line_end;\n\n  /* If the input type is unknown, the caller is still testing the\n     input, which means the current buffer cannot contain encoding\n     errors and a multiline search is typically more efficient.\n     Otherwise, a single-line search is typically faster, so that\n     pcre_exec doesn't waste time validating the entire input\n     buffer.  */\n  bool multiline = input_textbin == TEXTBIN_UNKNOWN;\n\n  for (; p < buf + size; p = line_start = line_end + 1)\n    {\n      bool too_big;\n\n      if (multiline)\n        {\n          size_t pcre_size_max = MIN (INT_MAX, SIZE_MAX - 1);\n          size_t scan_size = MIN (pcre_size_max + 1, buf + size - p);\n          line_end = memrchr (p, eolbyte, scan_size);\n          too_big = ! line_end;\n        }\n      else\n        {\n          line_end = memchr (p, eolbyte, buf + size - p);\n          too_big = INT_MAX < line_end - p;\n        }\n\n      if (too_big)\n        error (EXIT_TROUBLE, 0, _(\"exceeded PCRE's line length limit\"));\n\n      for (;;)\n        {\n          /* Skip past bytes that are easily determined to be encoding\n             errors, treating them as data that cannot match.  This is\n             faster than having pcre_exec check them.  */\n          while (mbclen_cache[to_uchar (*p)] == (size_t) -1)\n            {\n              p++;\n              bol = false;\n            }\n\n          /* Check for an empty match; this is faster than letting\n             pcre_exec do it.  */\n          int search_bytes = line_end - p;\n          if (search_bytes == 0)\n            {\n              sub[0] = sub[1] = 0;\n              e = empty_match[bol];\n              break;\n            }\n\n          int options = 0;\n          if (!bol)\n            options |= PCRE_NOTBOL;\n          if (multiline)\n            options |= PCRE_NO_UTF8_CHECK;\n\n          e = pcre_exec (cre, extra, p, search_bytes, 0,\n                         options, sub, NSUB);\n          if (e != PCRE_ERROR_BADUTF8)\n            {\n              if (0 < e && multiline && sub[1] - sub[0] != 0)\n                {\n                  char const *nl = memchr (p + sub[0], eolbyte,\n                                           sub[1] - sub[0]);\n                  if (nl)\n                    {\n                      /* This match crosses a line boundary; reject it.  */\n                      p += sub[0];\n                      line_end = nl;\n                      continue;\n                    }\n                }\n              break;\n            }\n          int valid_bytes = sub[0];\n\n          /* Try to match the string before the encoding error.\n             Again, handle the empty-match case specially, for speed.  */\n          if (valid_bytes == 0)\n            {\n              sub[1] = 0;\n              e = empty_match[bol];\n            }\n          else\n            e = pcre_exec (cre, extra, p, valid_bytes, 0,\n                           options | PCRE_NO_UTF8_CHECK | PCRE_NOTEOL,\n                           sub, NSUB);\n          if (e != PCRE_ERROR_NOMATCH)\n            break;\n\n          /* Treat the encoding error as data that cannot match.  */\n          p += valid_bytes + 1;\n          bol = false;\n        }\n\n      if (e != PCRE_ERROR_NOMATCH)\n        break;\n      bol = true;\n    }\n\n  if (e <= 0)\n    {\n      switch (e)\n        {\n        case PCRE_ERROR_NOMATCH:\n          break;\n\n        case PCRE_ERROR_NOMEMORY:\n          error (EXIT_TROUBLE, 0, _(\"memory exhausted\"));\n\n        case PCRE_ERROR_MATCHLIMIT:\n          error (EXIT_TROUBLE, 0,\n                 _(\"exceeded PCRE's backtracking limit\"));\n\n        default:\n          /* For now, we lump all remaining PCRE failures into this basket.\n             If anyone cares to provide sample grep usage that can trigger\n             particular PCRE errors, we can add to the list (above) of more\n             detailed diagnostics.  */\n          error (EXIT_TROUBLE, 0, _(\"internal PCRE error: %d\"), e);\n        }\n\n      return -1;\n    }\n  else\n    {\n      char const *matchbeg = p + sub[0];\n      char const *matchend = p + sub[1];\n      char const *beg;\n      char const *end;\n      if (start_ptr)\n        {\n          beg = matchbeg;\n          end = matchend;\n        }\n      else if (multiline)\n        {\n          char const *prev_nl = memrchr (line_start - 1, eolbyte,\n                                         matchbeg - (line_start - 1));\n          char const *next_nl = memchr (matchend, eolbyte,\n                                        line_end + 1 - matchend);\n          beg = prev_nl + 1;\n          end = next_nl + 1;\n        }\n      else\n        {\n          beg = line_start;\n          end = line_end + 1;\n        }\n      *match_size = end - beg;\n      return beg - buf;\n    }\n#endif\n}"
}