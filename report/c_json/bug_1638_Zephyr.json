{
    "Project": "Zephyr",
    "Tool": "Infer",
    "Bug Type": "Uninitialized Value",
    "Message": "The value read from help_entry.handler was never initialized.",
    "Code_line": "\t\t\t\tshell->ctx->active_cmd = help_entry;",
    "Code_function": "static int execute(const struct shell *shell)\n{\n\tstruct shell_static_entry d_entry; /* Memory for dynamic commands. */\n\tchar *argv[CONFIG_SHELL_ARGC_MAX + 1]; /* +1 reserved for NULL */\n\tconst struct shell_static_entry *p_static_entry = NULL;\n\tconst struct shell_cmd_entry *p_cmd = NULL;\n\tstruct shell_static_entry help_entry;\n\tsize_t cmd_lvl = SHELL_CMD_ROOT_LVL;\n\tsize_t cmd_with_handler_lvl = 0;\n\tbool wildcard_found = false;\n\tsize_t cmd_idx = 0;\n\tsize_t argc;\n\tchar quote;\n\n\tshell_op_cursor_end_move(shell);\n\tif (!shell_cursor_in_empty_line(shell)) {\n\t\tcursor_next_line_move(shell);\n\t}\n\n\tmemset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));\n\n\tshell_cmd_trim(shell);\n\n\thistory_put(shell, shell->ctx->cmd_buff,\n\t\t    shell->ctx->cmd_buff_len);\n\n\tif (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {\n\t\tshell_wildcard_prepare(shell);\n\t}\n\n\t/* create argument list */\n\tquote = shell_make_argv(&argc, &argv[0], shell->ctx->cmd_buff,\n\t\t\t\tCONFIG_SHELL_ARGC_MAX);\n\n\tif (!argc) {\n\t\treturn -ENOEXEC;\n\t}\n\n\tif (quote != 0) {\n\t\tshell_internal_fprintf(shell, SHELL_ERROR,\n\t\t\t\t       \"not terminated: %c\\n\",\n\t\t\t\t       quote);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* Initialize help variable */\n\thelp_entry.help = NULL;\n\n\t/* Below loop is analyzing subcommands of found root command. */\n\twhile (true) {\n\t\tif (cmd_lvl >= argc) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&\n\t\t    (!strcmp(argv[cmd_lvl], \"-h\") ||\n\t\t     !strcmp(argv[cmd_lvl], \"--help\"))) {\n\t\t\t/* Command called with help option so it makes no sense\n\t\t\t * to search deeper commands.\n\t\t\t */\n\t\t\tif (help_entry.help) {\n\t\t\t\tshell->ctx->active_cmd = help_entry;\n\t\t\t\tshell_internal_help_print(shell);\n\t\t\t\treturn SHELL_CMD_HELP_PRINTED;\n\t\t\t}\n\n\t\t\tshell_internal_fprintf(shell, SHELL_ERROR,\n\t\t\t\t\t       SHELL_MSG_SPECIFY_SUBCOMMAND);\n\t\t\treturn -ENOEXEC;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_SHELL_WILDCARD) && (cmd_lvl > 0)) {\n\t\t\tenum shell_wildcard_status status;\n\n\t\t\tstatus = shell_wildcard_process(shell, p_cmd,\n\t\t\t\t\t\t\targv[cmd_lvl]);\n\t\t\t/* Wildcard character found but there is no matching\n\t\t\t * command.\n\t\t\t */\n\t\t\tif (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Wildcard character was not found function can process\n\t\t\t * argument.\n\t\t\t */\n\t\t\tif (status != SHELL_WILDCARD_NOT_FOUND) {\n\t\t\t\t++cmd_lvl;\n\t\t\t\twildcard_found = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tshell_cmd_get(shell, p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,\n\t\t\t      &d_entry);\n\n\t\tif ((cmd_idx == 0) || (p_static_entry == NULL)) {\n\t\t\tif (cmd_lvl == 0 &&\n\t\t\t\t(!shell_in_select_mode(shell) ||\n\t\t\t\t shell->ctx->selected_cmd->handler == NULL)) {\n\t\t\t\tshell_internal_fprintf(shell, SHELL_ERROR,\n\t\t\t\t\t\t       \"%s%s\\n\", argv[0],\n\t\t\t\t\t\t       SHELL_MSG_CMD_NOT_FOUND);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\tif (IS_ENABLED(CONFIG_SHELL_CMDS_SELECT) &&\n\t\t\t    shell_in_select_mode(shell)\t\t &&\n\t\t\t    shell->ctx->selected_cmd->handler != NULL) {\n\t\t\t\tp_static_entry = shell->ctx->selected_cmd;\n\t\t\t\tshell->ctx->active_cmd = *p_static_entry;\n\t\t\t\tcmd_with_handler_lvl = cmd_lvl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(argv[cmd_lvl], p_static_entry->syntax) == 0) {\n\t\t\t/* checking if command has a handler */\n\t\t\tif (p_static_entry->handler != NULL) {\n\t\t\t\tif (IS_ENABLED(CONFIG_SHELL_WILDCARD) &&\n\t\t\t\t    (wildcard_found)) {\n\t\t\t\t\tshell_op_cursor_end_move(shell);\n\t\t\t\t\tshell_op_cond_next_line(shell);\n\n\t\t\t\t\t/* An error occurred, fnmatch  argument\n\t\t\t\t\t * cannot be followed by argument with\n\t\t\t\t\t * a handler to avoid multiple function\n\t\t\t\t\t * calls.\n\t\t\t\t\t */\n\t\t\t\t\tshell_internal_fprintf(shell,\n\t\t\t\t\t\tSHELL_ERROR,\n\t\t\t\t\t\t\"Error: requested multiple\"\n\t\t\t\t\t\t\" function executions\\n\");\n\n\t\t\t\t\treturn -ENOEXEC;\n\t\t\t\t}\n\n\t\t\t\tshell->ctx->active_cmd = *p_static_entry;\n\t\t\t\tcmd_with_handler_lvl = cmd_lvl;\n\t\t\t}\n\t\t\t/* checking if function has a help handler */\n\t\t\tif (p_static_entry->help != NULL) {\n\t\t\t\thelp_entry = *p_static_entry;\n\t\t\t}\n\n\t\t\tcmd_lvl++;\n\t\t\tcmd_idx = 0;\n\t\t\tp_cmd = p_static_entry->subcmd;\n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {\n\t\tshell_wildcard_finalize(shell);\n\t\t/* cmd_buffer has been overwritten by function finalize function\n\t\t * with all expanded commands. Hence shell_make_argv needs to\n\t\t * be called again.\n\t\t */\n\t\t(void)shell_make_argv(&argc, &argv[0],\n\t\t\t\t      shell->ctx->cmd_buff,\n\t\t\t\t      CONFIG_SHELL_ARGC_MAX);\n\t}\n\n\t/* Executing the deepest found handler. */\n\treturn exec_cmd(shell, argc - cmd_with_handler_lvl,\n\t\t\t&argv[cmd_with_handler_lvl], &help_entry);\n}"
}