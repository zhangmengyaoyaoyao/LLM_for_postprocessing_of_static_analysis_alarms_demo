{
    "Project": "bash",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Code_line": "\t\t\t\t      : process_exit_status (child->status);",
    "Code_function": "wait_for (pid)\n     pid_t pid;\n{\n  int job, termination_state, r;\n  WAIT s;\n  register PROCESS *child;\n  sigset_t set, oset;\n\n  /* In the case that this code is interrupted, and we longjmp () out of it,\n     we are relying on the code in throw_to_top_level () to restore the\n     top-level signal mask. */\n  child = 0;\n  BLOCK_CHILD (set, oset);\n\n  /* Ignore interrupts while waiting for a job run without job control\n     to finish.  We don't want the shell to exit if an interrupt is\n     received, only if one of the jobs run is killed via SIGINT.  If\n     job control is not set, the job will be run in the same pgrp as\n     the shell, and the shell will see any signals the job gets.  In\n     fact, we want this set every time the waiting shell and the waited-\n     for process are in the same process group, including command\n     substitution. */\n\n  /* This is possibly a race condition -- should it go in stop_pipeline? */\n  wait_sigint_received = child_caught_sigint = 0;\n  if (job_control == 0 || (subshell_environment&SUBSHELL_COMSUB))\n    {\n      old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);\n      waiting_for_child = 0;\n      if (old_sigint_handler == SIG_IGN)\n\tset_signal_handler (SIGINT, old_sigint_handler);\n    }\n\n  termination_state = last_command_exit_value;\n\n  if (interactive && job_control == 0)\n    QUIT;\n  /* Check for terminating signals and exit the shell if we receive one */\n  CHECK_TERMSIG;\n\n  /* Check for a trapped signal interrupting the wait builtin and jump out */\n  CHECK_WAIT_INTR;\n\n  /* If we say wait_for (), then we have a record of this child somewhere.\n     If it and none of its peers are running, don't call waitchld(). */\n\n  job = NO_JOB;\n  do\n    {\n      if (pid != ANY_PID)\n\tFIND_CHILD (pid, child);\n\n      /* If this child is part of a job, then we are really waiting for the\n\t job to finish.  Otherwise, we are waiting for the child to finish.\n\t We check for JDEAD in case the job state has been set by waitchld\n\t after receipt of a SIGCHLD. */\n      if (job == NO_JOB)\n\tjob = find_job (pid, 0, NULL);\n\n      /* waitchld() takes care of setting the state of the job.  If the job\n\t has already exited before this is called, sigchld_handler will have\n\t called waitchld and the state will be set to JDEAD. */\n\n      if (pid == ANY_PID || PRUNNING(child) || (job != NO_JOB && RUNNING (job)))\n\t{\n#if defined (WAITPID_BROKEN)    /* SCOv4 */\n\t  sigset_t suspend_set;\n\t  sigemptyset (&suspend_set);\n\t  sigsuspend (&suspend_set);\n#else /* !WAITPID_BROKEN */\n#  if defined (MUST_UNBLOCK_CHLD)\n\t  struct sigaction act, oact;\n\t  sigset_t nullset, chldset;\n\n\t  sigemptyset (&nullset);\n\t  sigemptyset (&chldset);\n\t  sigprocmask (SIG_SETMASK, &nullset, &chldset);\n\t  act.sa_handler = SIG_DFL;\n\t  sigemptyset (&act.sa_mask);\n\t  sigemptyset (&oact.sa_mask);\n\t  act.sa_flags = 0;\n#  if defined (SA_RESTART)\n\t  act.sa_flags |= SA_RESTART;\n#  endif\n\t  sigaction (SIGCHLD, &act, &oact);\n#  endif /* MUST_UNBLOCK_CHLD */\n\t  queue_sigchld = 1;\n\t  waiting_for_child++;\n\t  r = waitchld (pid, 1);\t/* XXX */\n\t  waiting_for_child--;\n#if 0\nitrace(\"wait_for: blocking wait for %d returns %d child = %p\", (int)pid, r, child);\n#endif\n#  if defined (MUST_UNBLOCK_CHLD)\n\t  sigaction (SIGCHLD, &oact, (struct sigaction *)NULL);\n\t  sigprocmask (SIG_SETMASK, &chldset, (sigset_t *)NULL);\n#  endif\n\t  queue_sigchld = 0;\n\t  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)\n\t    {\n\t      termination_state = -1;\n\t      /* XXX - restore sigint handler here? */\n\t      goto wait_for_return;\n\t    }\n\n\t  /* If child is marked as running, but waitpid() returns -1/ECHILD,\n\t     there is something wrong.  Somewhere, wait should have returned\n\t     that child's pid.  Mark the child as not running and the job,\n\t     if it exists, as JDEAD. */\n\t  if (r == -1 && errno == ECHILD)\n\t    {\n\t      if (child)\n\t\t{\n\t\t  child->running = PS_DONE;\n\t\t  WSTATUS (child->status) = 0;\t/* XXX -- can't find true status */\n\t\t}\n\t      js.c_living = 0;\t\t/* no living child processes */\n\t      if (job != NO_JOB)\n\t\t{\n\t\t  jobs[job]->state = JDEAD;\n\t\t  js.c_reaped++;\n\t\t  js.j_ndead++;\n\t\t}\n\t      if (pid == ANY_PID)\n\t\t{\n\t\t  termination_state = -1;\n\t\t  break;\n\t\t}\n\t    }\n#endif /* WAITPID_BROKEN */\n\t}\n\n      /* If the shell is interactive, and job control is disabled, see\n\t if the foreground process has died due to SIGINT and jump out\n\t of the wait loop if it has.  waitchld has already restored the\n\t old SIGINT signal handler. */\n      if (interactive && job_control == 0)\n\tQUIT;\n      /* Check for terminating signals and exit the shell if we receive one */\n      CHECK_TERMSIG;\n\n      /* Check for a trapped signal interrupting the wait builtin and jump out */\n      CHECK_WAIT_INTR;\n\n      if (pid == ANY_PID)\n        /* XXX - could set child but we don't have a handle on what waitchld\n\t   reaps.  Leave termination_state alone. */\n\tgoto wait_for_return;\n    }\n  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));\n\n  /* Restore the original SIGINT signal handler before we return. */\n  restore_sigint_handler ();\n\n  /* The exit state of the command is either the termination state of the\n     child, or the termination state of the job.  If a job, the status\n     of the last child in the pipeline is the significant one.  If the command\n     or job was terminated by a signal, note that value also. */\n  termination_state = (job != NO_JOB) ? job_exit_status (job)\n\t\t\t\t      : process_exit_status (child->status);\n  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)\n\t\t\t\t\t     : process_exit_signal (child->status);\n\n  /* XXX */\n  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || WIFSTOPPED (child->status))\n    termination_state = 128 + WSTOPSIG (child->status);\n\n  if (job == NO_JOB || IS_JOBCONTROL (job))\n    {\n      /* XXX - under what circumstances is a job not present in the jobs\n\t table (job == NO_JOB)?\n\t \t1.  command substitution\n\n\t In the case of command substitution, at least, it's probably not\n\t the right thing to give the terminal to the shell's process group,\n\t even though there is code in subst.c:command_substitute to work\n\t around it.\n\n\t Things that don't:\n\t\t$PROMPT_COMMAND execution\n\t\tprocess substitution\n       */\n#if 0\nif (job == NO_JOB)\n  itrace(\"wait_for: job == NO_JOB, giving the terminal to shell_pgrp (%ld)\", (long)shell_pgrp);\n#endif\n      give_terminal_to (shell_pgrp, 0);\n    }\n\n  /* If the command did not exit cleanly, or the job is just\n     being stopped, then reset the tty state back to what it\n     was before this command.  Reset the tty state and notify\n     the user of the job termination only if the shell is\n     interactive.  Clean up any dead jobs in either case. */\n  if (job != NO_JOB)\n    {\n      if (interactive_shell && subshell_environment == 0)\n\t{\n\t  /* This used to use `child->status'.  That's wrong, however, for\n\t     pipelines.  `child' is the first process in the pipeline.  It's\n\t     likely that the process we want to check for abnormal termination\n\t     or stopping is the last process in the pipeline, especially if\n\t     it's long-lived and the first process is short-lived.  Since we\n\t     know we have a job here, we can check all the processes in this\n\t     job's pipeline and see if one of them stopped or terminated due\n\t     to a signal.  We might want to change this later to just check\n\t     the last process in the pipeline.  If no process exits due to a\n\t     signal, S is left as the status of the last job in the pipeline. */\n\t  s = job_signal_status (job);\n\n\t  if (WIFSIGNALED (s) || WIFSTOPPED (s))\n\t    {\n\t      set_tty_state ();\n\n\t      /* If the current job was stopped or killed by a signal, and\n\t\t the user has requested it, get a possibly new window size */\n\t      if (check_window_size && (job == js.j_current || IS_FOREGROUND (job)))\n\t\tget_new_window_size (0, (int *)0, (int *)0);\n\t    }\n\t  else\n\t    get_tty_state ();\n\n\t  /* If job control is enabled, the job was started with job\n\t     control, the job was the foreground job, and it was killed\n\t     by SIGINT, then print a newline to compensate for the kernel\n\t     printing the ^C without a trailing newline. */\n\t  if (job_control && IS_JOBCONTROL (job) && IS_FOREGROUND (job) &&\n\t\tWIFSIGNALED (s) && WTERMSIG (s) == SIGINT)\n\t    {\n\t      /* If SIGINT is not trapped and the shell is in a for, while,\n\t\t or until loop, act as if the shell received SIGINT as\n\t\t well, so the loop can be broken.  This doesn't call the\n\t\t SIGINT signal handler; maybe it should. */\n\t      if (signal_is_trapped (SIGINT) == 0 && (loop_level || (shell_compatibility_level > 32 && executing_list)))\n\t\tADDINTERRUPT;\n\t      else\n\t\t{\n\t\t  putchar ('\\n');\n\t\t  fflush (stdout);\n\t\t}\n\t    }\n\t}\n      else if ((subshell_environment & (SUBSHELL_COMSUB|SUBSHELL_PIPE)) && wait_sigint_received)\n\t{\n\t  /* If waiting for a job in a subshell started to do command\n\t     substitution or to run a pipeline element that consists of\n\t     something like a while loop or a for loop, simulate getting\n\t     and being killed by the SIGINT to pass the status back to our\n\t     parent. */\n\t  s = job_signal_status (job);\n\n\t  if (child_caught_sigint == 0 && signal_is_trapped (SIGINT) == 0)\n\t    {\n\t      UNBLOCK_CHILD (oset);\n\t      old_sigint_handler = set_signal_handler (SIGINT, SIG_DFL);\n\t      if (old_sigint_handler == SIG_IGN)\n\t\trestore_sigint_handler ();\n\t      else\n\t\tkill (getpid (), SIGINT);\n\t    }\n\t}\n      else if (interactive_shell == 0 && IS_FOREGROUND (job) && check_window_size)\n\tget_new_window_size (0, (int *)0, (int *)0);\n\n      /* Moved here from set_job_status_and_cleanup, which is in the SIGCHLD\n         signal handler path */\n      if (DEADJOB (job) && IS_FOREGROUND (job) /*&& subshell_environment == 0*/)\n\tsetjstatus (job);\n\n      /* If this job is dead, notify the user of the status.  If the shell\n\t is interactive, this will display a message on the terminal.  If\n\t the shell is not interactive, make sure we turn on the notify bit\n\t so we don't get an unwanted message about the job's termination,\n\t and so delete_job really clears the slot in the jobs table. */\n      notify_and_cleanup ();\n    }\n\nwait_for_return:\n\n  UNBLOCK_CHILD (oset);\n\n  return (termination_state);\n}"
}