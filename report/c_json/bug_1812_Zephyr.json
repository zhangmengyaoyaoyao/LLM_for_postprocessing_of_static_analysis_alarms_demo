{
    "Project": "Zephyr",
    "Tool": "Infer",
    "category": "Uninitialized Value",
    "file": "subsys/fs/nvs/nvs.c",
    "message": "The value read from wlk_ate.offset was never initialized.",
    "warning_function_name": "nvs_write",
    "warning_line": "rd_addr += wlk_ate.offset;",
    "warning_context": "ssize_t nvs_write(struct nvs_fs *fs, u16_t id, const void *data, size_t len)\n{\n\tint rc, gc_count;\n\tsize_t ate_size, data_size;\n\tstruct nvs_ate wlk_ate;\n\tu32_t wlk_addr, rd_addr;\n\tu16_t required_space = 0U; /* no space, appropriate for delete ate */\n\tbool prev_found = false;\n\n\tif (!fs->ready) {\n\t\tLOG_ERR(\"NVS not initialized\");\n\t\treturn -EACCES;\n\t}\n\n\tate_size = nvs_al_size(fs, sizeof(struct nvs_ate));\n\tdata_size = nvs_al_size(fs, len);\n\n\t/* The maximum data size is sector size - 3 ate\n\t * where: 1 ate for data, 1 ate for sector close\n\t * and 1 ate to always allow a delete.\n\t */\n\tif ((len > (fs->sector_size - 3 * ate_size)) ||\n\t    ((len > 0) && (data == NULL))) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* find latest entry with same id */\n\twlk_addr = fs->ate_wra;\n\trd_addr = wlk_addr;\n\n\twhile (1) {\n\t\trd_addr = wlk_addr;\n\t\trc = nvs_prev_ate(fs, &wlk_addr, &wlk_ate);\n\t\tif (rc) {\n\t\t\treturn rc;\n\t\t}\n\t\tif ((wlk_ate.id == id) && (!nvs_ate_crc8_check(&wlk_ate))) {\n\t\t\tprev_found = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (wlk_addr == fs->ate_wra) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (prev_found) {\n\t\t/* previous entry found */\n\t\trd_addr &= ADDR_SECT_MASK;\n\t\trd_addr += wlk_ate.offset;\n\n\t\tif (len == 0) {\n\t\t\t/* do not try to compare with empty data */\n\t\t\tif (wlk_ate.len == 0U) {\n\t\t\t\t/* skip delete entry as it is already the\n\t\t\t\t * last one\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else if (len == wlk_ate.len) {\n\t\t\t/* do not try to compare if lengths are not equal */\n\t\t\t/* compare the data and if equal return 0 */\n\t\t\trc = nvs_flash_block_cmp(fs, rd_addr, data, len);\n\t\t\tif (rc <= 0) {\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* skip delete entry for non-existing entry */\n\t\tif (len == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* calculate required space if the entry contains data */\n\tif (data_size) {\n\t\t/* Leave space for delete ate */\n\t\trequired_space = data_size + ate_size;\n\t}\n\n\tk_mutex_lock(&fs->nvs_lock, K_FOREVER);\n\n\tgc_count = 0;\n\twhile (1) {\n\t\tif (gc_count == fs->sector_count) {\n\t\t\t/* gc'ed all sectors, no extra space will be created\n\t\t\t * by extra gc.\n\t\t\t */\n\t\t\trc = -ENOSPC;\n\t\t\tgoto end;\n\t\t}\n\n\t\tif (fs->ate_wra >= fs->data_wra + required_space) {\n\n\t\t\trc = nvs_flash_wrt_entry(fs, id, data, len);\n\t\t\tif (rc) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n"
}