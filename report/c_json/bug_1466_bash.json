{
    "Project": "bash",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Code_line": "\t\tind = array_max_index (array_cell (var)) + 1 + ind;",
    "Code_function": "assign_compound_array_list (var, nlist, flags)\n     SHELL_VAR *var;\n     WORD_LIST *nlist;\n     int flags;\n{\n  ARRAY *a;\n  HASH_TABLE *h;\n  WORD_LIST *list;\n  char *w, *val, *nval;\n  int len, iflags, free_val;\n  arrayind_t ind, last_ind;\n  char *akey;\n\n  a = (var && array_p (var)) ? array_cell (var) : (ARRAY *)0;\n  h = (var && assoc_p (var)) ? assoc_cell (var) : (HASH_TABLE *)0;\n\n  akey = (char *)0;\n  ind = 0;\n\n  /* Now that we are ready to assign values to the array, kill the existing\n     value. */\n  if ((flags & ASS_APPEND) == 0)\n    {\n      if (a && array_p (var))\n\tarray_flush (a);\n      else if (h && assoc_p (var))\n\tassoc_flush (h);\n    }\n\n  last_ind = (a && (flags & ASS_APPEND)) ? array_max_index (a) + 1 : 0;\n\n  for (list = nlist; list; list = list->next)\n    {\n      iflags = flags;\n      w = list->word->word;\n\n      /* We have a word of the form [ind]=value */\n      if ((list->word->flags & W_ASSIGNMENT) && w[0] == '[')\n\t{\n\t  /* Don't have to handle embedded quotes specially any more, since\n\t     associative array subscripts have not been expanded yet (see\n\t     above). */\n\t  len = skipsubscript (w, 0, 0);\n\n\t  /* XXX - changes for `+=' */\n \t  if (w[len] != ']' || (w[len+1] != '=' && (w[len+1] != '+' || w[len+2] != '=')))\n\t    {\n\t      if (assoc_p (var))\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  continue;\n\t\t}\n\t      nval = make_variable_value (var, w, flags);\n\t      if (var->assign_func)\n\t\t(*var->assign_func) (var, nval, last_ind, 0);\n\t      else\n\t\tarray_insert (a, last_ind, nval);\n\t      FREE (nval);\n\t      last_ind++;\n\t      continue;\n\t    }\n\n\t  if (len == 1)\n\t    {\n\t      err_badarraysub (w);\n\t      continue;\n\t    }\n\n\t  if (ALL_ELEMENT_SUB (w[1]) && len == 2)\n\t    {\n\t      last_command_exit_value = 1;\n\t      if (assoc_p (var))\n\t\treport_error (_(\"%s: invalid associative array key\"), w);\n\t      else\n\t\treport_error (_(\"%s: cannot assign to non-numeric index\"), w);\n\t      continue;\n\t    }\n\n\t  if (array_p (var))\n\t    {\n\t      ind = array_expand_index (var, w + 1, len);\n\t      /* negative subscripts to indexed arrays count back from end */\n\t      if (ind < 0)\n\t\tind = array_max_index (array_cell (var)) + 1 + ind;\n\t      if (ind < 0)\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  continue;\n\t\t}\n\n\t      last_ind = ind;\n\t    }\n\t  else if (assoc_p (var))\n\t    {\n\t      /* This is not performed above, see expand_compound_array_assignment */\n\t      w[len] = '\\0';\t/*[*/\n\t      akey = expand_assignment_string_to_string (w+1, 0);\n\t      w[len] = ']';\n\t      /* And we need to expand the value also, see below */\n\t      if (akey == 0 || *akey == 0)\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  FREE (akey);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  /* XXX - changes for `+=' -- just accept the syntax.  ksh93 doesn't do this */\n\t  if (w[len + 1] == '+' && w[len + 2] == '=')\n\t    {\n\t      iflags |= ASS_APPEND;\n\t      val = w + len + 3;\n\t    }\n\t  else\n\t    val = w + len + 2;\n\t}\n      else if (assoc_p (var))\n\t{\n\t  last_command_exit_value = 1;\n\t  report_error (_(\"%s: %s: must use subscript when assigning associative array\"), var->name, w);\n\t  continue;\n\t}\n      else\t\t/* No [ind]=value, just a stray `=' */\n\t{\n\t  ind = last_ind;\n\t  val = w;\n\t}\n\n      free_val = 0;\n      /* See above; we need to expand the value here */\n      if (assoc_p (var))\n\t{\n\t  val = expand_assignment_string_to_string (val, 0);\n\t  free_val = 1;\n\t}\n\n      if (integer_p (var))\n\tthis_command_name = (char *)NULL;\t/* no command name for errors */\n      bind_array_var_internal (var, ind, akey, val, iflags);\n      last_ind++;\n\n      if (free_val)\n\tfree (val);\n    }\n}"
}