{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset: [9, +oo] Size: [0, +oo] by call to `bfd_elf_set_obj_attr_contents`.",
    "warning_function_name": "bfd_elf_final_link",
    "warning_line": "bfd_elf_set_obj_attr_contents (abfd, contents, attr_size);",
    "warning_context": "\t\t  if (info->error_textrel)\n\t\t    info->callbacks->einfo\n\t\t      (_(\"%P%X: read-only segment has dynamic relocations.\\n\"));\n\t\t  else\n\t\t    info->callbacks->einfo\n\t\t      (_(\"%P: warning: creating a DT_TEXTREL in a shared object.\\n\"));\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      for (o = dynobj->sections; o != NULL; o = o->next)\n\t{\n\t  if ((o->flags & SEC_HAS_CONTENTS) == 0\n\t      || o->size == 0\n\t      || o->output_section == bfd_abs_section_ptr)\n\t    continue;\n\t  if ((o->flags & SEC_LINKER_CREATED) == 0)\n\t    {\n\t      /* At this point, we are only interested in sections\n\t\t created by _bfd_elf_link_create_dynamic_sections.  */\n\t      continue;\n\t    }\n\t  if (elf_hash_table (info)->stab_info.stabstr == o)\n\t    continue;\n\t  if (elf_hash_table (info)->eh_info.hdr_sec == o)\n\t    continue;\n\t  if (strcmp (o->name, \".dynstr\") != 0)\n\t    {\n\t      /* FIXME: octets_per_byte.  */\n\t      if (! bfd_set_section_contents (abfd, o->output_section,\n\t\t\t\t\t      o->contents,\n\t\t\t\t\t      (file_ptr) o->output_offset,\n\t\t\t\t\t      o->size))\n\t\tgoto error_return;\n\t    }\n\t  else\n\t    {\n\t      /* The contents of the .dynstr section are actually in a\n\t\t stringtab.  */\n\t      file_ptr off;\n\n\t      off = elf_section_data (o->output_section)->this_hdr.sh_offset;\n\t      if (bfd_seek (abfd, off, SEEK_SET) != 0\n\t\t  || ! _bfd_elf_strtab_emit (abfd,\n\t\t\t\t\t     elf_hash_table (info)->dynstr))\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  if (info->relocatable)\n    {\n      bfd_boolean failed = FALSE;\n\n      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);\n      if (failed)\n\tgoto error_return;\n    }\n\n  /* If we have optimized stabs strings, output them.  */\n  if (elf_hash_table (info)->stab_info.stabstr != NULL)\n    {\n      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))\n\tgoto error_return;\n    }\n\n  if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))\n    goto error_return;\n\n  elf_final_link_free (abfd, &flinfo);\n\n  elf_linker (abfd) = TRUE;\n\n  if (attr_section)\n    {\n      bfd_byte *contents = (bfd_byte *) bfd_malloc (attr_size);\n      if (contents == NULL)\n\treturn FALSE;\t/* Bail out and fail.  */\n      bfd_elf_set_obj_attr_contents (abfd, contents, attr_size);\n      bfd_set_section_contents (abfd, attr_section, contents, 0, attr_size);\n      free (contents);\n    }\n\n  return TRUE;\n\n error_return:\n  elf_final_link_free (abfd, &flinfo);\n  return FALSE;\n}\n\n/* Initialize COOKIE for input bfd ABFD.  */\n\nstatic bfd_boolean\ninit_reloc_cookie (struct elf_reloc_cookie *cookie,\n\t\t   struct bfd_link_info *info, bfd *abfd)\n{\n  Elf_Internal_Shdr *symtab_hdr;\n  const struct elf_backend_data *bed;\n\n  bed = get_elf_backend_data (abfd);\n"
}