{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "  unit = (struct comp_unit *) bfd_zalloc (abfd, amt);",
    "Code_function": "parse_comp_unit (struct dwarf2_debug *stash,\n\t\t bfd_vma unit_length,\n\t\t bfd_byte *info_ptr_unit,\n\t\t unsigned int offset_size)\n{\n  struct comp_unit* unit;\n  unsigned int version;\n  bfd_uint64_t abbrev_offset = 0;\n  unsigned int addr_size;\n  struct abbrev_info** abbrevs;\n  unsigned int abbrev_number, bytes_read, i;\n  struct abbrev_info *abbrev;\n  struct attribute attr;\n  bfd_byte *info_ptr = stash->info_ptr;\n  bfd_byte *end_ptr = info_ptr + unit_length;\n  bfd_size_type amt;\n  bfd_vma low_pc = 0;\n  bfd_vma high_pc = 0;\n  bfd *abfd = stash->bfd_ptr;\n  bfd_boolean high_pc_relative = FALSE;\n\n  version = read_2_bytes (abfd, info_ptr, end_ptr);\n  info_ptr += 2;\n  BFD_ASSERT (offset_size == 4 || offset_size == 8);\n  if (offset_size == 4)\n    abbrev_offset = read_4_bytes (abfd, info_ptr, end_ptr);\n  else\n    abbrev_offset = read_8_bytes (abfd, info_ptr, end_ptr);\n  info_ptr += offset_size;\n  addr_size = read_1_byte (abfd, info_ptr, end_ptr);\n  info_ptr += 1;\n\n  if (version != 2 && version != 3 && version != 4)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: found dwarf version '%u', this reader\"\n\t   \" only handles version 2, 3 and 4 information.\"), version);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  if (addr_size > sizeof (bfd_vma))\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: found address size '%u', this reader\"\n\t   \" can not handle sizes greater than '%u'.\"),\n\t addr_size,\n\t (unsigned int) sizeof (bfd_vma));\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  if (addr_size != 2 && addr_size != 4 && addr_size != 8)\n    {\n      (*_bfd_error_handler)\n\t(\"Dwarf Error: found address size '%u', this reader\"\n\t \" can only handle address sizes '2', '4' and '8'.\", addr_size);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  /* Read the abbrevs for this compilation unit into a table.  */\n  abbrevs = read_abbrevs (abfd, abbrev_offset, stash);\n  if (! abbrevs)\n    return 0;\n\n  abbrev_number = safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, end_ptr);\n  info_ptr += bytes_read;\n  if (! abbrev_number)\n    {\n      (*_bfd_error_handler) (_(\"Dwarf Error: Bad abbrev number: %u.\"),\n\t\t\t     abbrev_number);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  abbrev = lookup_abbrev (abbrev_number, abbrevs);\n  if (! abbrev)\n    {\n      (*_bfd_error_handler) (_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t\t\t     abbrev_number);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  amt = sizeof (struct comp_unit);\n  unit = (struct comp_unit *) bfd_zalloc (abfd, amt);\n  if (unit == NULL)\n    return NULL;\n  unit->abfd = abfd;\n  unit->version = version;\n  unit->addr_size = addr_size;\n  unit->offset_size = offset_size;\n  unit->abbrevs = abbrevs;\n  unit->end_ptr = end_ptr;\n  unit->stash = stash;\n  unit->info_ptr_unit = info_ptr_unit;\n  unit->sec_info_ptr = stash->sec_info_ptr;\n\n  for (i = 0; i < abbrev->num_attrs; ++i)\n    {\n      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, end_ptr);\n      if (info_ptr == NULL)\n\treturn NULL;\n\n      /* Store the data if it is of an attribute we want to keep in a\n\t partial symbol table.  */\n      switch (attr.name)\n\t{\n\tcase DW_AT_stmt_list:\n\t  unit->stmtlist = 1;\n\t  unit->line_offset = attr.u.val;\n\t  break;\n\n\tcase DW_AT_name:\n\t  unit->name = attr.u.str;\n\t  break;\n\n\tcase DW_AT_low_pc:\n\t  low_pc = attr.u.val;\n\t  /* If the compilation unit DIE has a DW_AT_low_pc attribute,\n\t     this is the base address to use when reading location\n\t     lists or range lists. */\n\t  if (abbrev->tag == DW_TAG_compile_unit)\n\t    unit->base_address = low_pc;\n\t  break;\n\n\tcase DW_AT_high_pc:\n\t  high_pc = attr.u.val;\n\t  high_pc_relative = attr.form != DW_FORM_addr;\n\t  break;\n\n\tcase DW_AT_ranges:\n\t  if (!read_rangelist (unit, &unit->arange, attr.u.val))\n\t    return NULL;\n\t  break;\n\n\tcase DW_AT_comp_dir:\n\t  {\n\t    char *comp_dir = attr.u.str;\n\n\t    /* PR 17512: file: 1fe726be.  */\n\t    if (! is_str_attr (attr.form))\n\t      {\n\t\t(*_bfd_error_handler)\n\t\t  (_(\"Dwarf Error: DW_AT_comp_dir attribute encountered with a non-string form.\"));\n\t\tcomp_dir = NULL;\n\t      }\n\n\t    if (comp_dir)\n\t      {\n\t\t/* Irix 6.2 native cc prepends <machine>.: to the compilation\n\t\t   directory, get rid of it.  */\n\t\tchar *cp = strchr (comp_dir, ':');\n\n\t\tif (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')\n\t\t  comp_dir = cp + 1;\n\t      }\n\t    unit->comp_dir = comp_dir;\n\t    break;\n\t  }\n\n\tcase DW_AT_language:\n\t  unit->lang = attr.u.val;\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n  if (high_pc_relative)\n    high_pc += low_pc;\n  if (high_pc != 0)\n    {\n      if (!arange_add (unit, &unit->arange, low_pc, high_pc))\n\treturn NULL;\n    }\n\n  unit->first_child_die_ptr = info_ptr;\n  return unit;\n}"
}