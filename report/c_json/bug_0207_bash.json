{
    "project": "bash",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "lib/readline/histexpand.c",
    "message": "Offset added: [-1, +oo] (‚áê [1, 3] + [-2, +oo]) Size: 24 by call to `get_history_event`.",
    "warning_function_name": "history_expand_internal",
    "warning_line": "event = get_history_event (fake_s, &fake_i, 0);",
    "warning_context": "static int\nhistory_expand_internal (string, start, qc, end_index_ptr, ret_string, current_line)\n     char *string;\n     int start, qc, *end_index_ptr;\n     char **ret_string;\n     char *current_line;\t/* for !# */\n{\n  int i, n, starting_index;\n  int substitute_globally, subst_bywords, want_quotes, print_only;\n  char *event, *temp, *result, *tstr, *t, c, *word_spec;\n  int result_len;\n#if defined (HANDLE_MULTIBYTE)\n  mbstate_t ps;\n\n  memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n  result = (char *)xmalloc (result_len = 128);\n\n  i = start;\n\n  /* If it is followed by something that starts a word specifier,\n     then !! is implied as the event specifier. */\n\n  if (member (string[i + 1], \":$*%^\"))\n    {\n      char fake_s[3];\n      int fake_i = 0;\n      i++;\n      fake_s[0] = fake_s[1] = history_expansion_char;\n      fake_s[2] = '\\0';\n      event = get_history_event (fake_s, &fake_i, 0);\n    }\n  else if (string[i + 1] == '#')\n    {\n      i += 2;\n      event = current_line;\n    }\n  else\n    event = get_history_event (string, &i, qc);\n\t  \n  if (event == 0)\n    {\n      *ret_string = hist_error (string, start, i, EVENT_NOT_FOUND);\n      xfree (result);\n      return (-1);\n    }\n\n  /* If a word specifier is found, then do what that requires. */\n  starting_index = i;\n  word_spec = get_history_word_specifier (string, event, &i);\n\n  /* There is no such thing as a `malformed word specifier'.  However,\n     it is possible for a specifier that has no match.  In that case,\n     we complain. */\n  if (word_spec == (char *)&error_pointer)\n    {\n      *ret_string = hist_error (string, starting_index, i, BAD_WORD_SPEC);\n      xfree (result);\n      return (-1);\n    }\n\n  /* If no word specifier, than the thing of interest was the event. */\n  temp = word_spec ? savestring (word_spec) : savestring (event);\n  FREE (word_spec);\n\n  /* Perhaps there are other modifiers involved.  Do what they say. */\n  want_quotes = substitute_globally = subst_bywords = print_only = 0;\n  starting_index = i;\n\n  while (string[i] == ':')\n    {\n      c = string[i + 1];\n\n      if (c == 'g' || c == 'a')\n\t{\n\t  substitute_globally = 1;\n\t  i++;\n\t  c = string[i + 1];\n\t}\n      else if (c == 'G')\n\t{\n\t  subst_bywords = 1;\n\t  i++;\n\t  c = string[i + 1];\n\t}\n\n      switch (c)\n\t{\n\tdefault:\n\t  *ret_string = hist_error (string, i+1, i+2, BAD_MODIFIER);\n\t  xfree (result);\n\t  xfree (temp);\n\t  return -1;\n\n\tcase 'q':\n\t  want_quotes = 'q';\n\t  break;\n\n\tcase 'x':\n\t  want_quotes = 'x';\n"
}