{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "bfd/elf64-x86-64.c",
    "message": "Offset: [-1+max(2, `rel->r_offset`), `rel->r_offset` - 1] (⇐ [max(2, `rel->r_offset`), `rel->r_offset`] + -1) Size: [1, +oo].",
    "warning_function_name": "elf_x86_64_check_tls_transition",
    "warning_line": "val = bfd_get_8 (abfd, contents + offset - 1);",
    "warning_context": "\t}\n      else\n\t{\n\t  /* Check transition from LD access model.  Only\n\t\tleaq foo@tlsld(%rip), %rdi;\n\t\tcall __tls_get_addr\n\t     can transit to different access model.  For largepic\n\t     we also support:\n\t        leaq foo@tlsld(%rip), %rdi\n\t        movabsq $__tls_get_addr@pltoff, %rax\n\t        addq $rbx, %rax\n\t        call *%rax.  */\n\n\t  static const unsigned char lea[] = { 0x48, 0x8d, 0x3d };\n\n\t  if (offset < 3 || (offset + 9) > sec->size)\n\t    return FALSE;\n\n\t  if (memcmp (contents + offset - 3, lea, 3) != 0)\n\t    return FALSE;\n\n\t  if (0xe8 != *(contents + offset + 4))\n\t    {\n\t      if (!ABI_64_P (abfd)\n\t\t  || (offset + 19) > sec->size\n\t\t  || memcmp (contents + offset + 4, \"\\x48\\xb8\", 2) != 0\n\t\t  || memcmp (contents + offset + 14, \"\\x48\\x01\\xd8\\xff\\xd0\", 5)\n\t\t     != 0)\n\t\treturn FALSE;\n\t      largepic = TRUE;\n\t    }\n\t}\n\n      r_symndx = htab->r_sym (rel[1].r_info);\n      if (r_symndx < symtab_hdr->sh_info)\n\treturn FALSE;\n\n      h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n      /* Use strncmp to check __tls_get_addr since __tls_get_addr\n\t may be versioned.  */\n      return (h != NULL\n\t      && h->root.root.string != NULL\n\t      && (largepic\n\t\t  ? ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLTOFF64\n\t\t  : (ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PC32\n\t\t     || ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLT32))\n\t      && (strncmp (h->root.root.string,\n\t\t\t   \"__tls_get_addr\", 14) == 0));\n\n    case R_X86_64_GOTTPOFF:\n      /* Check transition from IE access model:\n\t\tmov foo@gottpoff(%rip), %reg\n\t\tadd foo@gottpoff(%rip), %reg\n       */\n\n      /* Check REX prefix first.  */\n      if (offset >= 3 && (offset + 4) <= sec->size)\n\t{\n\t  val = bfd_get_8 (abfd, contents + offset - 3);\n\t  if (val != 0x48 && val != 0x4c)\n\t    {\n\t      /* X32 may have 0x44 REX prefix or no REX prefix.  */\n\t      if (ABI_64_P (abfd))\n\t\treturn FALSE;\n\t    }\n\t}\n      else\n\t{\n\t  /* X32 may not have any REX prefix.  */\n\t  if (ABI_64_P (abfd))\n\t    return FALSE;\n\t  if (offset < 2 || (offset + 3) > sec->size)\n\t    return FALSE;\n\t}\n\n      val = bfd_get_8 (abfd, contents + offset - 2);\n      if (val != 0x8b && val != 0x03)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      return (val & 0xc7) == 5;\n\n    case R_X86_64_GOTPC32_TLSDESC:\n      /* Check transition from GDesc access model:\n\t\tleaq x@tlsdesc(%rip), %rax\n\n\t Make sure it's a leaq adding rip to a 32-bit offset\n\t into any register, although it's probably almost always\n\t going to be rax.  */\n\n      if (offset < 3 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 3);\n      if ((val & 0xfb) != 0x48)\n\treturn FALSE;\n\n      if (bfd_get_8 (abfd, contents + offset - 2) != 0x8d)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n"
}