{
    "Project": "bash",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Code_line": "  if (*qcp == '\\0' && cs == COMPLETE_BSQUOTE && mbschr (s, '\\n'))",
    "Code_function": "bash_quote_filename (s, rtype, qcp)\n     char *s;\n     int rtype;\n     char *qcp;\n{\n  char *rtext, *mtext, *ret;\n  int rlen, cs;\n\n  rtext = (char *)NULL;\n\n  /* If RTYPE == MULT_MATCH, it means that there is\n     more than one match.  In this case, we do not add\n     the closing quote or attempt to perform tilde\n     expansion.  If RTYPE == SINGLE_MATCH, we try\n     to perform tilde expansion, because single and double\n     quotes inhibit tilde expansion by the shell. */\n\n  cs = completion_quoting_style;\n  /* Might need to modify the default completion style based on *qcp,\n     since it's set to any user-provided opening quote.  We also change\n     to single-quoting if there is no user-provided opening quote and\n     the word being completed contains newlines, since those are not\n     quoted correctly using backslashes (a backslash-newline pair is\n     special to the shell parser). */\n  if (*qcp == '\\0' && cs == COMPLETE_BSQUOTE && mbschr (s, '\\n'))\n    cs = COMPLETE_SQUOTE;\n  else if (*qcp == '\"')\n    cs = COMPLETE_DQUOTE;\n  else if (*qcp == '\\'')\n    cs = COMPLETE_SQUOTE;\n#if defined (BANG_HISTORY)\n  else if (*qcp == '\\0' && history_expansion && cs == COMPLETE_DQUOTE &&\n\t   history_expansion_inhibited == 0 && mbschr (s, '!'))\n    cs = COMPLETE_BSQUOTE;\n\n  if (*qcp == '\"' && history_expansion && cs == COMPLETE_DQUOTE &&\n\thistory_expansion_inhibited == 0 && mbschr (s, '!'))\n    {\n      cs = COMPLETE_BSQUOTE;\n      *qcp = '\\0';\n    }\n#endif\n\n  /* Don't tilde-expand backslash-quoted filenames, since only single and\n     double quotes inhibit tilde expansion. */\n  mtext = s;\n  if (mtext[0] == '~' && rtype == SINGLE_MATCH && cs != COMPLETE_BSQUOTE)\n    mtext = bash_tilde_expand (s, 0);\n\n  switch (cs)\n    {\n    case COMPLETE_DQUOTE:\n      rtext = sh_double_quote (mtext);\n      break;\n    case COMPLETE_SQUOTE:\n      rtext = sh_single_quote (mtext);\n      break;\n    case COMPLETE_BSQUOTE:\n      rtext = sh_backslash_quote (mtext, complete_fullquote ? 0 : filename_bstab, 0);\n      break;\n    }\n\n  if (mtext != s)\n    free (mtext);\n\n  /* We may need to quote additional characters: those that readline treats\n     as word breaks that are not quoted by backslash_quote. */\n  if (rtext && cs == COMPLETE_BSQUOTE)\n    {\n      mtext = quote_word_break_chars (rtext);\n      free (rtext);\n      rtext = mtext;\n    }\n\n  /* Leave the opening quote intact.  The readline completion code takes\n     care of avoiding doubled opening quotes. */\n  if (rtext)\n    {\n      rlen = strlen (rtext);\n      ret = (char *)xmalloc (rlen + 1);\n      strcpy (ret, rtext);\n    }\n  else\n    {\n      ret = (char *)xmalloc (rlen = 1);\n      ret[0] = '\\0';\n    }\n\n  /* If there are multiple matches, cut off the closing quote. */\n  if (rtype == MULT_MATCH && cs != COMPLETE_BSQUOTE)\n    ret[rlen - 1] = '\\0';\n  free (rtext);\n  return ret;\n}"
}