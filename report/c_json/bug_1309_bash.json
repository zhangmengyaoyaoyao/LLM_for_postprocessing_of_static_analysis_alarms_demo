{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\tredirectee->flags = oflags;",
    "Code_function": "do_redirection_internal (redirect, flags)\n     REDIRECT *redirect;\n     int flags;\n{\n  WORD_DESC *redirectee;\n  int redir_fd, fd, redirector, r, oflags;\n  intmax_t lfd;\n  char *redirectee_word;\n  enum r_instruction ri;\n  REDIRECT *new_redirect;\n  REDIRECTEE sd;\n\n  redirectee = redirect->redirectee.filename;\n  redir_fd = redirect->redirectee.dest;\n  redirector = redirect->redirector.dest;\n  ri = redirect->instruction;\n\n  if (redirect->flags & RX_INTERNAL)\n    flags |= RX_INTERNAL;\n\n  if (TRANSLATE_REDIRECT (ri))\n    {\n      /* We have [N]>&WORD[-] or [N]<&WORD[-] (or {V}>&WORD[-] or {V}<&WORD-).\n         and WORD, then translate the redirection into a new one and\n\t continue. */\n      redirectee_word = redirection_expand (redirectee);\n\n      /* XXX - what to do with [N]<&$w- where w is unset or null?  ksh93\n\t       closes N. */\n      if (redirectee_word == 0)\n\treturn (AMBIGUOUS_REDIRECT);\n      else if (redirectee_word[0] == '-' && redirectee_word[1] == '\\0')\n\t{\n\t  sd = redirect->redirector;\n\t  rd.dest = 0;\n\t  new_redirect = make_redirection (sd, r_close_this, rd, 0);\n\t}\n      else if (all_digits (redirectee_word))\n\t{\n\t  sd = redirect->redirector;\n\t  if (legal_number (redirectee_word, &lfd) && (int)lfd == lfd)\n\t    rd.dest = lfd;\n\t  else\n\t    rd.dest = -1;\t/* XXX */\n\t  switch (ri)\n\t    {\n\t    case r_duplicating_input_word:\n\t      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);\n\t      break;\n\t    case r_duplicating_output_word:\n\t      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);\n\t      break;\n\t    case r_move_input_word:\n\t      new_redirect = make_redirection (sd, r_move_input, rd, 0);\n\t      break;\n\t    case r_move_output_word:\n\t      new_redirect = make_redirection (sd, r_move_output, rd, 0);\n\t      break;\n\t    }\n\t}\n      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)\n\t{\n\t  sd = redirect->redirector;\n\t  rd.filename = make_bare_word (redirectee_word);\n\t  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);\n\t}\n      else\n\t{\n\t  free (redirectee_word);\n\t  return (AMBIGUOUS_REDIRECT);\n\t}\n\n      free (redirectee_word);\n\n      /* Set up the variables needed by the rest of the function from the\n\t new redirection. */\n      if (new_redirect->instruction == r_err_and_out)\n\t{\n\t  char *alloca_hack;\n\n\t  /* Copy the word without allocating any memory that must be\n\t     explicitly freed. */\n\t  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));\n\t  xbcopy ((char *)new_redirect->redirectee.filename,\n\t\t (char *)redirectee, sizeof (WORD_DESC));\n\n\t  alloca_hack = (char *)\n\t    alloca (1 + strlen (new_redirect->redirectee.filename->word));\n\t  redirectee->word = alloca_hack;\n\t  strcpy (redirectee->word, new_redirect->redirectee.filename->word);\n\t}\n      else\n\t/* It's guaranteed to be an integer, and shouldn't be freed. */\n\tredirectee = new_redirect->redirectee.filename;\n\n      redir_fd = new_redirect->redirectee.dest;\n      redirector = new_redirect->redirector.dest;\n      ri = new_redirect->instruction;\n\n      /* Overwrite the flags element of the old redirect with the new value. */\n      redirect->flags = new_redirect->flags;\n      dispose_redirects (new_redirect);\n    }\n\n  switch (ri)\n    {\n    case r_output_direction:\n    case r_appending_to:\n    case r_input_direction:\n    case r_inputa_direction:\n    case r_err_and_out:\t\t/* command &>filename */\n    case r_append_err_and_out:\t/* command &>> filename */\n    case r_input_output:\n    case r_output_force:\n      if (posixly_correct && interactive_shell == 0)\n\t{\n\t  oflags = redirectee->flags;\n\t  redirectee->flags |= W_NOGLOB;\n\t}\n      redirectee_word = redirection_expand (redirectee);\n      if (posixly_correct && interactive_shell == 0)\n\tredirectee->flags = oflags;\n\n      if (redirectee_word == 0)\n\treturn (AMBIGUOUS_REDIRECT);\n\n#if defined (RESTRICTED_SHELL)\n      if (restricted && (WRITE_REDIRECT (ri)))\n\t{\n\t  free (redirectee_word);\n\t  return (RESTRICTED_REDIRECT);\n\t}\n#endif /* RESTRICTED_SHELL */\n\n      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);\n      free (redirectee_word);\n\n      if (fd == NOCLOBBER_REDIRECT)\n\treturn (fd);\n\n      if (fd < 0)\n\treturn (errno);\n\n      if (flags & RX_ACTIVE)\n\t{\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);\t\t/* XXX try this for now */\n\t      r = errno;\n\t      if (redirector < 0)\n\t\tsys_error (_(\"redirection error: cannot duplicate fd\"));\n\t      REDIRECTION_ERROR (redirector, r, fd);\n\t    }\n\n\t  if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)\n\t    {\n\t      /* Only setup to undo it if the thing to undo is active. */\n\t      if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))\n\t\tr = add_undo_redirect (redirector, ri, -1);\n\t      else\n\t\tr = add_undo_close_redirect (redirector);\n\t      REDIRECTION_ERROR (r, errno, fd);\n\t    }\n\n#if defined (BUFFERED_INPUT)\n\t  /* inhibit call to sync_buffered_stream() for async processes */\n\t  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)\n\t    check_bash_input (redirector);\n#endif\n\n\t  /* Make sure there is no pending output before we change the state\n\t     of the underlying file descriptor, since the builtins use stdio\n\t     for output. */\n\t  if (redirector == 1 && fileno (stdout) == redirector)\n\t    {\n\t      fflush (stdout);\n\t      fpurge (stdout);\n\t    }\n\t  else if (redirector == 2 && fileno (stderr) == redirector)\n\t    {\n\t      fflush (stderr);\n\t      fpurge (stderr);\n\t    }\n\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      if ((r = redir_varassign (redirect, redirector)) < 0)\n\t\t{\n\t\t  close (redirector);\n\t\t  close (fd);\n\t\t  return (r);\t/* XXX */\n\t\t}\n\t    }\n\t  else if ((fd != redirector) && (dup2 (fd, redirector) < 0))\n\t    return (errno);\n\n#if defined (BUFFERED_INPUT)\n\t  /* Do not change the buffered stream for an implicit redirection\n\t     of /dev/null to fd 0 for asynchronous commands without job\n\t     control (r_inputa_direction). */\n\t  if (ri == r_input_direction || ri == r_input_output)\n\t    duplicate_buffered_stream (fd, redirector);\n#endif /* BUFFERED_INPUT */\n\n\t  /*\n\t   * If we're remembering, then this is the result of a while, for\n\t   * or until loop with a loop redirection, or a function/builtin\n\t   * executing in the parent shell with a redirection.  In the\n\t   * function/builtin case, we want to set all file descriptors > 2\n\t   * to be close-on-exec to duplicate the effect of the old\n\t   * for i = 3 to NOFILE close(i) loop.  In the case of the loops,\n\t   * both sh and ksh leave the file descriptors open across execs.\n\t   * The Posix standard mentions only the exec builtin.\n\t   */\n\t  if ((flags & RX_CLEXEC) && (redirector > 2))\n\t    SET_CLOSE_ON_EXEC (redirector);\n\t}\n\n      if (fd != redirector)\n\t{\n#if defined (BUFFERED_INPUT)\n\t  if (INPUT_REDIRECT (ri))\n\t    close_buffered_fd (fd);\n\t  else\n#endif /* !BUFFERED_INPUT */\n\t    close (fd);\t\t/* Don't close what we just opened! */\n\t}\n\n      /* If we are hacking both stdout and stderr, do the stderr\n\t redirection here.  XXX - handle {var} here? */\n      if (ri == r_err_and_out || ri == r_append_err_and_out)\n\t{\n\t  if (flags & RX_ACTIVE)\n\t    {\n\t      if (flags & RX_UNDOABLE)\n\t\tadd_undo_redirect (2, ri, -1);\n\t      if (dup2 (1, 2) < 0)\n\t\treturn (errno);\n\t    }\n\t}\n      break;\n\n    case r_reading_until:\n    case r_deblank_reading_until:\n    case r_reading_string:\n      /* REDIRECTEE is a pointer to a WORD_DESC containing the text of\n\t the new input.  Place it in a temporary file. */\n      if (redirectee)\n\t{\n\t  fd = here_document_to_fd (redirectee, ri);\n\n\t  if (fd < 0)\n\t    {\n\t      heredoc_errno = errno;\n\t      return (HEREDOC_REDIRECT);\n\t    }\n\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      redirector = fcntl (fd, F_DUPFD, SHELL_FD_BASE);\t\t/* XXX try this for now */\n\t      r = errno;\n\t      if (redirector < 0)\n\t\tsys_error (_(\"redirection error: cannot duplicate fd\"));\n\t      REDIRECTION_ERROR (redirector, r, fd);\n\t    }\n\n\t  if (flags & RX_ACTIVE)\n\t    {\n\t      if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)\n\t        {\n\t\t  /* Only setup to undo it if the thing to undo is active. */\n\t\t  if ((fd != redirector) && (fcntl (redirector, F_GETFD, 0) != -1))\n\t\t    r = add_undo_redirect (redirector, ri, -1);\n\t\t  else\n\t\t    r = add_undo_close_redirect (redirector);\n\t\t  REDIRECTION_ERROR (r, errno, fd);\n\t        }\n\n#if defined (BUFFERED_INPUT)\n\t      check_bash_input (redirector);\n#endif\n\t      if (redirect->rflags & REDIR_VARASSIGN)\n\t\t{\n\t\t  if ((r = redir_varassign (redirect, redirector)) < 0)\n\t\t    {\n\t\t      close (redirector);\n\t\t      close (fd);\n\t\t      return (r);\t/* XXX */\n\t\t    }\n\t\t}\n\t      else if (fd != redirector && dup2 (fd, redirector) < 0)\n\t\t{\n\t\t  r = errno;\n\t\t  close (fd);\n\t\t  return (r);\n\t\t}\n\n#if defined (BUFFERED_INPUT)\n\t      duplicate_buffered_stream (fd, redirector);\n#endif\n\n\t      if ((flags & RX_CLEXEC) && (redirector > 2))\n\t\tSET_CLOSE_ON_EXEC (redirector);\n\t    }\n\n\t  if (fd != redirector)\n#if defined (BUFFERED_INPUT)\n\t    close_buffered_fd (fd);\n#else\n\t    close (fd);\n#endif\n\t}\n      break;\n\n    case r_duplicating_input:\n    case r_duplicating_output:\n    case r_move_input:\n    case r_move_output:\n      if ((flags & RX_ACTIVE) && (redirect->rflags & REDIR_VARASSIGN))\n        {\n\t  redirector = fcntl (redir_fd, F_DUPFD, SHELL_FD_BASE);\t\t/* XXX try this for now */\n\t  r = errno;\n\t  if (redirector < 0)\n\t    sys_error (_(\"redirection error: cannot duplicate fd\"));\n\t  REDIRECTION_ERROR (redirector, r, -1);\n        }\n\n      if ((flags & RX_ACTIVE) && (redir_fd != redirector))\n\t{\n\t  if ((flags & RX_UNDOABLE) && (redirect->rflags & REDIR_VARASSIGN) == 0)\n\t    {\n\t      /* Only setup to undo it if the thing to undo is active. */\n\t      if (fcntl (redirector, F_GETFD, 0) != -1)\n\t\tr = add_undo_redirect (redirector, ri, redir_fd);\n\t      else\n\t\tr = add_undo_close_redirect (redirector);\n\t      REDIRECTION_ERROR (r, errno, -1);\n\t    }\n\t  if ((flags & RX_UNDOABLE) && (ri == r_move_input || ri == r_move_output))\n\t    {\n\t      /* r_move_input and r_move_output add an additional close()\n\t\t that needs to be undone */\n\t      if (fcntl (redirector, F_GETFD, 0) != -1)\n\t\t{\n\t\t  r = add_undo_redirect (redir_fd, r_close_this, -1);\n\t\t  REDIRECTION_ERROR (r, errno, -1);\n\t\t}\n\t    }\n#if defined (BUFFERED_INPUT)\n\t  /* inhibit call to sync_buffered_stream() for async processes */\n\t  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)\n\t    check_bash_input (redirector);\n#endif\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      if ((r = redir_varassign (redirect, redirector)) < 0)\n\t\t{\n\t\t  close (redirector);\n\t\t  return (r);\t/* XXX */\n\t\t}\n\t    }\n\t  /* This is correct.  2>&1 means dup2 (1, 2); */\n\t  else if (dup2 (redir_fd, redirector) < 0)\n\t    return (errno);\n\n#if defined (BUFFERED_INPUT)\n\t  if (ri == r_duplicating_input || ri == r_move_input)\n\t    duplicate_buffered_stream (redir_fd, redirector);\n#endif /* BUFFERED_INPUT */\n\n\t  /* First duplicate the close-on-exec state of redirectee.  dup2\n\t     leaves the flag unset on the new descriptor, which means it\n\t     stays open.  Only set the close-on-exec bit for file descriptors\n\t     greater than 2 in any case, since 0-2 should always be open\n\t     unless closed by something like `exec 2<&-'.  It should always\n\t     be safe to set fds > 2 to close-on-exec if they're being used to\n\t     save file descriptors < 2, since we don't need to preserve the\n\t     state of the close-on-exec flag for those fds -- they should\n\t     always be open. */\n\t  /* if ((already_set || set_unconditionally) && (ok_to_set))\n\t\tset_it () */\n#if 0\n\t  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || redir_fd < 2 || (flags & RX_CLEXEC)) &&\n\t       (redirector > 2))\n#else\n\t  if (((fcntl (redir_fd, F_GETFD, 0) == 1) || (redir_fd < 2 && (flags & RX_INTERNAL)) || (flags & RX_CLEXEC)) &&\n\t       (redirector > 2))\n#endif\n\t    SET_CLOSE_ON_EXEC (redirector);\n\n\t  /* When undoing saving of non-standard file descriptors (>=3) using\n\t     file descriptors >= SHELL_FD_BASE, we set the saving fd to be\n\t     close-on-exec and use a flag to decide how to set close-on-exec\n\t     when the fd is restored. */\n\t  if ((redirect->flags & RX_INTERNAL) && (redirect->flags & RX_SAVCLEXEC) && redirector >= 3 && (redir_fd >= SHELL_FD_BASE || (redirect->flags & RX_SAVEFD)))\n\t    SET_OPEN_ON_EXEC (redirector);\n\n\t  /* dup-and-close redirection */\n\t  if (ri == r_move_input || ri == r_move_output)\n\t    {\n\t      xtrace_fdchk (redir_fd);\n\n\t      close (redir_fd);\n#if defined (COPROCESS_SUPPORT)\n\t      coproc_fdchk (redir_fd);\t/* XXX - loses coproc fds */\n#endif\n\t    }\n\t}\n      break;\n\n    case r_close_this:\n      if (flags & RX_ACTIVE)\n\t{\n\t  if (redirect->rflags & REDIR_VARASSIGN)\n\t    {\n\t      redirector = redir_varvalue (redirect);\n\t      if (redirector < 0)\n\t\treturn AMBIGUOUS_REDIRECT;\n\t    }\n\n\t  r = 0;\n\t  /* XXX - only if REDIR_VARASSIGN not set? */\n\t  if ((flags & RX_UNDOABLE) && (fcntl (redirector, F_GETFD, 0) != -1))\n\t    {\n\t      r = add_undo_redirect (redirector, ri, -1);\n\t      REDIRECTION_ERROR (r, errno, redirector);\n\t    }\n\n#if defined (COPROCESS_SUPPORT)\n\t  coproc_fdchk (redirector);\n#endif\n\t  xtrace_fdchk (redirector);\n\n#if defined (BUFFERED_INPUT)\n\t  /* inhibit call to sync_buffered_stream() for async processes */\n\t  if (redirector != 0 || (subshell_environment & SUBSHELL_ASYNC) == 0)\n\t    check_bash_input (redirector);\n\t  r = close_buffered_fd (redirector);\n#else /* !BUFFERED_INPUT */\n\t  r = close (redirector);\n#endif /* !BUFFERED_INPUT */\n\n\t  if (r < 0 && (flags & RX_INTERNAL) && (errno == EIO || errno == ENOSPC))\n\t    REDIRECTION_ERROR (r, errno, -1);\n\t}\n      break;\n\n    case r_duplicating_input_word:\n    case r_duplicating_output_word:\n      break;\n    }\n  return (0);\n}"
}