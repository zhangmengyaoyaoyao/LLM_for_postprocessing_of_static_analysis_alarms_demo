{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\tstop = bcalloc(Op_stop, 1, 0);",
    "Code_function": "parse_condition(int type, int num, char *expr)\n{\n\tINSTRUCTION *code = NULL;\n\tAWK_CONTEXT *ctxt = NULL;\n\tint ret;\n\tBREAKPOINT *b;\n\tstruct list_item *w;\n\tNODE *this_func = NULL;\n\tINSTRUCTION *it, *stop, *rule;\n\tstruct condition *cndn = NULL;\n\tint save_flags = do_flags;\n\n\tif (type == D_break && (b = find_breakpoint(num)) != NULL) {\n\t\tINSTRUCTION *rp;\n\t\tcndn = &b->cndn;\n\t\trp = find_rule(b->src, b->bpi->source_line);\n\t\tif (rp != NULL && rp->opcode == Op_func)\n\t\t\tthis_func = rp->func_body;\n\t} else if (type == D_watch && (w = find_item(&watch_list, num)) != NULL) {\n\t\tcndn = &w->cndn;\n\t\tthis_func = find_frame(cur_frame)->func_node;\n\t}\n\n\tif (cndn == NULL)\n\t\treturn -1;\n\tif (expr == NULL)\n\t\tgoto out;\t/* delete condition */\n\n\tinstall_params(this_func);\n\tctxt = new_context();\n\tinvalid_symbol = 0;\n\tctxt->install_func = check_symbol;\n\tpush_context(ctxt);\n\t(void) add_srcfile(SRC_CMDLINE, expr, srcfiles, NULL, NULL);\n\tdo_flags = false;\n\tret = parse_program(&code);\n\tdo_flags = save_flags;\n\tremove_params(this_func);\n\tpop_context();\n\n\tif (ret != 0 || invalid_symbol) {\n\t\tfree_context(ctxt, false /* keep_globals */);\n\t\treturn -1;\n\t}\n\n\t/* condition expression is parsed as awk pattern without\n\t * any action. The code is then modified to end up with\n\t * a `1.0' on stack when the expression is true, `0.0' otherwise.\n\t */\n\n\tassert(code != NULL);\n\trule = ctxt->rule_list.nexti;\n\tstop = bcalloc(Op_stop, 1, 0);\n\n\tit = rule->firsti;\t/* Op_K_print_rec */\n\tassert(it->opcode == Op_K_print_rec);\n\tit->opcode = Op_push_i;\n\tit->memory = make_number(1.0);\n\tit->nexti = bcalloc(Op_jmp, 1, 0);\n\tit->nexti->target_jmp = stop;\n\tit->nexti->nexti = rule->lasti;\n\n\tit = rule->lasti;\t\t/* Op_no_op, target for Op_jmp_false */\n\tassert(it->opcode == Op_no_op);\n\tit->opcode = Op_push_i;\n\tit->memory = make_number(0.0);\n\tit->nexti = stop;\n\nout:\n\tif (cndn->expr != NULL)\n\t\tefree(cndn->expr);\n\tfree_context(cndn->ctxt, false);\n\tcndn->code = code;\n\tcndn->expr = expr;\n\tcndn->ctxt = ctxt;\n\n\treturn 0;\n}"
}