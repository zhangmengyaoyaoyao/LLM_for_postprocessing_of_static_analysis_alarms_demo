{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from modspec was never initialized.",
    "Code_line": "      temp1 = parameter_brace_casemod (name, temp, ind, modspec, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);",
    "Code_function": "parameter_brace_expand (string, indexp, quoted, pflags, quoted_dollar_atp, contains_dollar_at)\n     char *string;\n     int *indexp, quoted, *quoted_dollar_atp, *contains_dollar_at, pflags;\n{\n  int check_nullness, var_is_set, var_is_null, var_is_special;\n  int want_substring, want_indir, want_patsub, want_casemod;\n  char *name, *value, *temp, *temp1;\n  WORD_DESC *tdesc, *ret;\n  int t_index, sindex, c, tflag, modspec;\n  intmax_t number;\n  arrayind_t ind;\n\n  temp = temp1 = value = (char *)NULL;\n  var_is_set = var_is_null = var_is_special = check_nullness = 0;\n  want_substring = want_indir = want_patsub = want_casemod = 0;\n\n  sindex = *indexp;\n  t_index = ++sindex;\n  /* ${#var} doesn't have any of the other parameter expansions on it. */\n  if (string[t_index] == '#' && legal_variable_starter (string[t_index+1]))\t\t/* {{ */\n    name = string_extract (string, &t_index, \"}\", SX_VARNAME);\n  else\n#if defined (CASEMOD_EXPANSIONS)\n    /* To enable case-toggling expansions using the `~' operator character\n       change the 1 to 0. */\n#  if defined (CASEMOD_CAPCASE)\n    name = string_extract (string, &t_index, \"#%^,~:-=?+/}\", SX_VARNAME);\n#  else\n    name = string_extract (string, &t_index, \"#%^,:-=?+/}\", SX_VARNAME);\n#  endif /* CASEMOD_CAPCASE */\n#else\n    name = string_extract (string, &t_index, \"#%:-=?+/}\", SX_VARNAME);\n#endif /* CASEMOD_EXPANSIONS */\n\n  ret = 0;\n  tflag = 0;\n\n  ind = INTMAX_MIN;\n\n  /* If the name really consists of a special variable, then make sure\n     that we have the entire name.  We don't allow indirect references\n     to special variables except `#', `?', `@' and `*'. */\n  if ((sindex == t_index && VALID_SPECIAL_LENGTH_PARAM (string[t_index])) ||\n      (sindex == t_index - 1 && string[sindex] == '!' && VALID_INDIR_PARAM (string[t_index])))\n    {\n      t_index++;\n      temp1 = string_extract (string, &t_index, \"#%:-=?+/}\", 0);\n      name = (char *)xrealloc (name, 3 + (strlen (temp1)));\n      *name = string[sindex];\n      if (string[sindex] == '!')\n\t{\n\t  /* indirect reference of $#, $?, $@, or $* */\n\t  name[1] = string[sindex + 1];\n\t  strcpy (name + 2, temp1);\n\t}\n      else\n\tstrcpy (name + 1, temp1);\n      free (temp1);\n    }\n  sindex = t_index;\n\n  /* Find out what character ended the variable name.  Then\n     do the appropriate thing. */\n  if (c = string[sindex])\n    sindex++;\n\n  /* If c is followed by one of the valid parameter expansion\n     characters, move past it as normal.  If not, assume that\n     a substring specification is being given, and do not move\n     past it. */\n  if (c == ':' && VALID_PARAM_EXPAND_CHAR (string[sindex]))\n    {\n      check_nullness++;\n      if (c = string[sindex])\n\tsindex++;\n    }\n  else if (c == ':' && string[sindex] != RBRACE)\n    want_substring = 1;\n  else if (c == '/' /* && string[sindex] != RBRACE */)\t/* XXX */\n    want_patsub = 1;\n#if defined (CASEMOD_EXPANSIONS)\n  else if (c == '^' || c == ',' || c == '~')\n    {\n      modspec = c;\n      want_casemod = 1;\n    }\n#endif\n\n  /* Catch the valid and invalid brace expressions that made it through the\n     tests above. */\n  /* ${#-} is a valid expansion and means to take the length of $-.\n     Similarly for ${#?} and ${##}... */\n  if (name[0] == '#' && name[1] == '\\0' && check_nullness == 0 &&\n\tVALID_SPECIAL_LENGTH_PARAM (c) && string[sindex] == RBRACE)\n    {\n      name = (char *)xrealloc (name, 3);\n      name[1] = c;\n      name[2] = '\\0';\n      c = string[sindex++];\n    }\n\n  /* ...but ${#%}, ${#:}, ${#=}, ${#+}, and ${#/} are errors. */\n  if (name[0] == '#' && name[1] == '\\0' && check_nullness == 0 &&\n\tmember (c, \"%:=+/\") && string[sindex] == RBRACE)\n    {\n      temp = (char *)NULL;\n      goto bad_substitution;\n    }\n\n  /* Indirect expansion begins with a `!'.  A valid indirect expansion is\n     either a variable name, one of the positional parameters or a special\n     variable that expands to one of the positional parameters. */\n  want_indir = *name == '!' &&\n    (legal_variable_starter ((unsigned char)name[1]) || DIGIT (name[1])\n\t\t\t\t\t|| VALID_INDIR_PARAM (name[1]));\n\n  /* Determine the value of this variable. */\n\n  /* Check for special variables, directly referenced. */\n  if (SPECIAL_VAR (name, want_indir))\n    var_is_special++;\n\n  /* Check for special expansion things, like the length of a parameter */\n  if (*name == '#' && name[1])\n    {\n      /* If we are not pointing at the character just after the\n\t closing brace, then we haven't gotten all of the name.\n\t Since it begins with a special character, this is a bad\n\t substitution.  Also check NAME for validity before trying\n\t to go on. */\n      if (string[sindex - 1] != RBRACE || (valid_length_expression (name) == 0))\n\t{\n\t  temp = (char *)NULL;\n\t  goto bad_substitution;\n\t}\n\n      number = parameter_brace_expand_length (name);\n      if (number == INTMAX_MIN && unbound_vars_is_error)\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  err_unboundvar (name+1);\n\t  free (name);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n      free (name);\n\n      *indexp = sindex;\n      if (number < 0)\n        return (&expand_wdesc_error);\n      else\n\t{\n\t  ret = alloc_word_desc ();\n\t  ret->word = itos (number);\n\t  return ret;\n\t}\n    }\n\n  /* ${@} is identical to $@. */\n  if (name[0] == '@' && name[1] == '\\0')\n    {\n      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t*quoted_dollar_atp = 1;\n\n      if (contains_dollar_at)\n\t*contains_dollar_at = 1;\n\n      tflag |= W_DOLLARAT;\n    }\n\n  /* Process ${!PREFIX*} expansion. */\n  if (want_indir && string[sindex - 1] == RBRACE &&\n      (string[sindex - 2] == '*' || string[sindex - 2] == '@') &&\n      legal_variable_starter ((unsigned char) name[1]))\n    {\n      char **x;\n      WORD_LIST *xlist;\n\n      temp1 = savestring (name + 1);\n      number = strlen (temp1);\n      temp1[number - 1] = '\\0';\n      x = all_variables_matching_prefix (temp1);\n      xlist = strvec_to_word_list (x, 0, 0);\n      if (string[sindex - 2] == '*')\n\ttemp = string_list_dollar_star (xlist);\n      else\n\t{\n\t  temp = string_list_dollar_at (xlist, quoted);\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t    *quoted_dollar_atp = 1;\n\t  if (contains_dollar_at)\n\t    *contains_dollar_at = 1;\n\n\t  tflag |= W_DOLLARAT;\n\t}\n      free (x);\n      dispose_words (xlist);\n      free (temp1);\n      *indexp = sindex;\n\n      free (name);\n\n      ret = alloc_word_desc ();\n      ret->word = temp;\n      ret->flags = tflag;\t/* XXX */\n      return ret;\n    }\n\n#if defined (ARRAY_VARS)\n  /* Process ${!ARRAY[@]} and ${!ARRAY[*]} expansion. */ /* [ */\n  if (want_indir && string[sindex - 1] == RBRACE &&\n      string[sindex - 2] == ']' && valid_array_reference (name+1))\n    {\n      char *x, *x1;\n\n      temp1 = savestring (name + 1);\n      x = array_variable_name (temp1, &x1, (int *)0);\t/* [ */\n      FREE (x);\n      if (ALL_ELEMENT_SUB (x1[0]) && x1[1] == ']')\n\t{\n\t  temp = array_keys (temp1, quoted);\t/* handles assoc vars too */\n\t  if (x1[0] == '@')\n\t    {\n\t      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t\t*quoted_dollar_atp = 1;\n\t      if (contains_dollar_at)\n\t\t*contains_dollar_at = 1;\n\n\t      tflag |= W_DOLLARAT;\n\t    }\n\n\t  free (temp1);\n\t  *indexp = sindex;\n\n\t  ret = alloc_word_desc ();\n\t  ret->word = temp;\n\t  ret->flags = tflag;\t/* XXX */\n\t  return ret;\n\t}\n\n      free (temp1);\n    }\n#endif /* ARRAY_VARS */\n\n  /* Make sure that NAME is valid before trying to go on. */\n  if (valid_brace_expansion_word (want_indir ? name + 1 : name,\n\t\t\t\t\tvar_is_special) == 0)\n    {\n      temp = (char *)NULL;\n      goto bad_substitution;\n    }\n\n  if (want_indir)\n    tdesc = parameter_brace_expand_indir (name + 1, var_is_special, quoted, quoted_dollar_atp, contains_dollar_at);\n  else\n    tdesc = parameter_brace_expand_word (name, var_is_special, quoted, PF_IGNUNBOUND|(pflags&(PF_NOSPLIT2|PF_ASSIGNRHS)), &ind);\n\n  if (tdesc)\n    {\n      temp = tdesc->word;\n      tflag = tdesc->flags;\n      dispose_word_desc (tdesc);\n    }\n  else\n    temp = (char  *)0;\n\n  if (temp == &expand_param_error || temp == &expand_param_fatal)\n    {\n      FREE (name);\n      FREE (value);\n      return (temp == &expand_param_error ? &expand_wdesc_error : &expand_wdesc_fatal);\n    }\n\n#if defined (ARRAY_VARS)\n  if (valid_array_reference (name))\n    chk_atstar (name, quoted, quoted_dollar_atp, contains_dollar_at);\n#endif\n\n  var_is_set = temp != (char *)0;\n  var_is_null = check_nullness && (var_is_set == 0 || *temp == 0);\n  /* XXX - this may not need to be restricted to special variables */\n  if (check_nullness)\n    var_is_null |= var_is_set && var_is_special && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && QUOTED_NULL (temp);\n\n  /* Get the rest of the stuff inside the braces. */\n  if (c && c != RBRACE)\n    {\n      /* Extract the contents of the ${ ... } expansion\n\t according to the Posix.2 rules. */\n      value = extract_dollar_brace_string (string, &sindex, quoted, (c == '%' || c == '#' || c =='/' || c == '^' || c == ',' || c ==':') ? SX_POSIXEXP|SX_WORD : SX_WORD);\n      if (string[sindex] == RBRACE)\n\tsindex++;\n      else\n\tgoto bad_substitution;\n    }\n  else\n    value = (char *)NULL;\n\n  *indexp = sindex;\n\n  /* All the cases where an expansion can possibly generate an unbound\n     variable error. */\n  if (want_substring || want_patsub || want_casemod || c == '#' || c == '%' || c == RBRACE)\n    {\n      if (var_is_set == 0 && unbound_vars_is_error && ((name[0] != '@' && name[0] != '*') || name[1]))\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  err_unboundvar (name);\n\t  FREE (value);\n\t  FREE (temp);\n\t  free (name);\n\t  return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t}\n    }\n\n  /* If this is a substring spec, process it and add the result. */\n  if (want_substring)\n    {\n      temp1 = parameter_brace_substring (name, temp, ind, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      FREE (name);\n      FREE (value);\n      FREE (temp);\n\n      if (temp1 == &expand_param_error)\n\treturn (&expand_wdesc_error);\n      else if (temp1 == &expand_param_fatal)\n\treturn (&expand_wdesc_fatal);\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      /* We test quoted_dollar_atp because we want variants with double-quoted\n\t \"$@\" to take a different code path. In fact, we make sure at the end\n\t of expand_word_internal that we're only looking at these flags if\n\t quoted_dollar_at == 0. */\n      if (temp1 &&\n          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&\n\t  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n      return ret;\n    }\n  else if (want_patsub)\n    {\n      temp1 = parameter_brace_patsub (name, temp, ind, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      FREE (name);\n      FREE (value);\n      FREE (temp);\n\n      if (temp1 == &expand_param_error)\n\treturn (&expand_wdesc_error);\n      else if (temp1 == &expand_param_fatal)\n\treturn (&expand_wdesc_fatal);\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 &&\n          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&\n\t  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n      return ret;\n    }\n#if defined (CASEMOD_EXPANSIONS)\n  else if (want_casemod)\n    {\n      temp1 = parameter_brace_casemod (name, temp, ind, modspec, value, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      FREE (name);\n      FREE (value);\n      FREE (temp);\n\n      if (temp1 == &expand_param_error)\n\treturn (&expand_wdesc_error);\n      else if (temp1 == &expand_param_fatal)\n\treturn (&expand_wdesc_fatal);\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 &&\n          (quoted_dollar_atp == 0 || *quoted_dollar_atp == 0) &&\n\t  QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n      return ret;\n    }\n#endif\n\n  /* Do the right thing based on which character ended the variable name. */\n  switch (c)\n    {\n    default:\n    case '\\0':\n    bad_substitution:\n      last_command_exit_value = EXECUTION_FAILURE;\n      report_error (_(\"%s: bad substitution\"), string ? string : \"??\");\n      FREE (value);\n      FREE (temp);\n      free (name);\n      return &expand_wdesc_error;\n\n    case RBRACE:\n      break;\n\n    case '#':\t/* ${param#[#]pattern} */\n    case '%':\t/* ${param%[%]pattern} */\n      if (value == 0 || *value == '\\0' || temp == 0 || *temp == '\\0')\n\t{\n\t  FREE (value);\n\t  break;\n\t}\n      temp1 = parameter_brace_remove_pattern (name, temp, ind, value, c, quoted, (tflag & W_ARRAYIND) ? AV_USEIND : 0);\n      free (temp);\n      free (value);\n      free (name);\n\n      ret = alloc_word_desc ();\n      ret->word = temp1;\n      if (temp1 && QUOTED_NULL (temp1) && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\tret->flags |= W_QUOTED|W_HASQUOTEDNULL;\n      return ret;\n\n    case '-':\n    case '=':\n    case '?':\n    case '+':\n      if (var_is_set && var_is_null == 0)\n\t{\n\t  /* If the operator is `+', we don't want the value of the named\n\t     variable for anything, just the value of the right hand side. */\n\t  if (c == '+')\n\t    {\n\t      /* XXX -- if we're double-quoted and the named variable is \"$@\",\n\t\t\twe want to turn off any special handling of \"$@\" --\n\t\t\twe're not using it, so whatever is on the rhs applies. */\n\t      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t\t*quoted_dollar_atp = 0;\n\t      if (contains_dollar_at)\n\t\t*contains_dollar_at = 0;\n\n\t      FREE (temp);\n\t      if (value)\n\t\t{\n\t\t  /* From Posix discussion on austin-group list.  Issue 221\n\t\t     requires that backslashes escaping `}' inside\n\t\t     double-quoted ${...} be removed. */\n\t\t  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t\t    quoted |= Q_DOLBRACE;\n\t\t  ret = parameter_brace_expand_rhs (name, value, c,\n\t\t\t\t\t\t    quoted,\n\t\t\t\t\t\t    quoted_dollar_atp,\n\t\t\t\t\t\t    contains_dollar_at);\n\t\t  /* XXX - fix up later, esp. noting presence of\n\t\t\t   W_HASQUOTEDNULL in ret->flags */\n\t\t  free (value);\n\t\t}\n\t      else\n\t\ttemp = (char *)NULL;\n\t    }\n\t  else\n\t    {\n\t      FREE (value);\n\t    }\n\t  /* Otherwise do nothing; just use the value in TEMP. */\n\t}\n      else\t/* VAR not set or VAR is NULL. */\n\t{\n\t  FREE (temp);\n\t  temp = (char *)NULL;\n\t  if (c == '=' && var_is_special)\n\t    {\n\t      last_command_exit_value = EXECUTION_FAILURE;\n\t      report_error (_(\"$%s: cannot assign in this way\"), name);\n\t      free (name);\n\t      free (value);\n\t      return &expand_wdesc_error;\n\t    }\n\t  else if (c == '?')\n\t    {\n\t      parameter_brace_expand_error (name, value);\n\t      return (interactive_shell ? &expand_wdesc_error : &expand_wdesc_fatal);\n\t    }\n\t  else if (c != '+')\n\t    {\n\t      /* XXX -- if we're double-quoted and the named variable is \"$@\",\n\t\t\twe want to turn off any special handling of \"$@\" --\n\t\t\twe're not using it, so whatever is on the rhs applies. */\n\t      if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && quoted_dollar_atp)\n\t\t*quoted_dollar_atp = 0;\n\t      if (contains_dollar_at)\n\t\t*contains_dollar_at = 0;\n\n\t      /* From Posix discussion on austin-group list.  Issue 221 requires\n\t\t that backslashes escaping `}' inside double-quoted ${...} be\n\t\t removed. */\n\t      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t\tquoted |= Q_DOLBRACE;\n\t      ret = parameter_brace_expand_rhs (name, value, c, quoted,\n\t\t\t\t\t\tquoted_dollar_atp,\n\t\t\t\t\t\tcontains_dollar_at);\n\t      /* XXX - fix up later, esp. noting presence of\n\t\t       W_HASQUOTEDNULL in tdesc->flags */\n\t    }\n\t  free (value);\n\t}\n\n      break;\n    }\n  free (name);\n\n  if (ret == 0)\n    {\n      ret = alloc_word_desc ();\n      ret->flags = tflag;\n      ret->word = temp;\n    }\n  return (ret);\n}"
}