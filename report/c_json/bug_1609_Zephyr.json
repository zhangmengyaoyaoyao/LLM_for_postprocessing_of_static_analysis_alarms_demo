{
    "Project": "Zephyr",
    "Tool": "Cppcheck",
    "category": "Uninitialized Variable",
    "file": "drivers/neural_net/intel_gna.c",
    "message": "Uninitialized variable: rw_size",
    "warning_function_name": "intel_gna_register_model",
    "warning_line": "ro_size = header->model_size - rw_size;",
    "warning_context": "static int intel_gna_register_model(struct device *dev,\n\t\tstruct gna_model_info *model, void **model_handle)\n{\n\tstruct intel_gna_data *const gna = DEV_DATA(dev);\n\tstruct intel_gna_model *gna_model;\n\tstruct gna_model_header *header;\n\tu32_t ro_size, rw_size;\n\tvoid *virtual_base;\n\tvoid *ro_region;\n\n\tif ((gna->state != GNA_STATE_IDLE) &&\n\t\t\t(gna->state != GNA_STATE_ACTIVE)) {\n\t\tLOG_ERR(\"Invalid state (%u)\", gna->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((model_handle == NULL) || (model == NULL)) {\n\t\tLOG_ERR(\"model and/or model_handle is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((model->header == NULL) || (model->rw_region == NULL)) {\n\t\tLOG_ERR(\"model header / rw_region is/are NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check for 64B alignment */\n\tif (((u32_t)model->rw_region & BIT_MASK(6)) ||\n\t\t\t((u32_t)model->ro_region & BIT_MASK(6))) {\n\t\tLOG_ERR(\"rw_region / ro_region not aligned to 64B\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (k_mem_slab_alloc(&gna->model_slab, (void **)&gna_model,\n\t\t\t\tK_NO_WAIT)) {\n\t\tLOG_ERR(\"No memory to register model\");\n\t\treturn -ENOMEM;\n\t}\n\n\tLOG_INF(\"model header: %p rw: %p ro: %p\", model->header,\n\t\t\tmodel->rw_region, model->ro_region);\n\n\theader = model->header;\n\tvirtual_base = (void *)GNA_MODEL_VIRT_BASE_DEFAULT;\n\n\tLOG_INF(\"model_size: %u rw_region_size: %u\", header->model_size,\n\t\t\theader->rw_region_size);\n\n\t/* setup page table entries for RW region */\n\tif (model->rw_region && header->rw_region_size) {\n\t\t/* calculate layer descriptor size */\n\t\trw_size = header->layer_count *\n\t\t\tsizeof(struct intel_gna_layer_desc);\n\t\t/* round up to page boundary */\n\t\trw_size = GNA_PAGES_TO_BYTES(GNA_NUM_PAGES(rw_size));\n\t\t/* add the input rw_region_size to get total rw_region_size */\n\t\trw_size += header->rw_region_size;\n\n\t\tintel_gna_setup_page_table(model->rw_region, rw_size,\n\t\t\t\tvirtual_base);\n\t\tSOC_DCACHE_FLUSH(model->rw_region, rw_size);\n\t}\n\n\tif (model->ro_region == NULL) {\n\t\tro_region = (void *)((u32_t)model->rw_region + rw_size);\n\t} else {\n\t\tro_region = model->ro_region;\n\t}\n\n\tro_size = header->model_size - rw_size;\n\n\tLOG_INF(\"rw_region: %p (%u) ro_region: %p (%u)\",\n\t\t\tmodel->rw_region, rw_size, ro_region, ro_size);\n\n\t/* setup page table entries for RO region */\n\tintel_gna_setup_page_table(ro_region, ro_size,\n\t\t\t(void *)((u32_t)virtual_base + rw_size));\n\n\tSOC_DCACHE_FLUSH(ro_region, ro_size);\n\tSOC_DCACHE_FLUSH(gna_page_table, sizeof(gna_page_table));\n\n\t/* copy the model pointers */\n\tgna_model->model = *model;\n\tgna_model->vabase = virtual_base;\n\tgna_model->input = (void *)((u32_t)model->rw_region +\n\t\t\t*(u32_t *)((u32_t)model->rw_region +\n\t\t\t\theader->input_ptr_offset));\n\tgna_model->output = (void *)((u32_t)model->rw_region +\n\t\t\t*(u32_t *)((u32_t)model->rw_region +\n\t\t\t\theader->output_ptr_offset));\n\tgna_model->registered = true;\n\n\tLOG_INF(\"model->rw_region: %p\", model->rw_region);\n\tLOG_INF(\"input offset: %u\",\n\t\t*(u32_t *)((u32_t)model->rw_region + header->input_ptr_offset));\n\tLOG_INF(\"gna_model->input: %p\", gna_model->input);\n\tLOG_INF(\"output offset: %u\",\n\t\t*(u32_t *)((u32_t)model->rw_region +\n\t\t\theader->output_ptr_offset));\n\tLOG_INF(\"gna_model->output: %p\", gna_model->output);\n\tLOG_DBG(\"returning model handle: %p\", gna_model);\n"
}