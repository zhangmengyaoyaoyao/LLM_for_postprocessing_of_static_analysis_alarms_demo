{
    "Project": "tiff",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "libtiff/tif_dirread.c",
    "message": "Offset: [0, max(65, `tif->tif_fieldinfo->field_bit`)] Size: 4.",
    "warning_function_name": "TIFFReadDirectory",
    "warning_line": "TIFFSetFieldBit(tif, fip->field_bit);",
    "warning_context": "\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\t\t\t/* Unknown tag ... we'll deal with it below */\n\t\t\thaveunknowntags = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n\t\t\tfip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected, TRUE))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t\telse\n\t\t\t\t\tcompressionknown = 1;\n\t\t\t\tbreak;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv)\n\t\t\t\t    || !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\tcase TIFFTAG_TILELENGTH:\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we saw any unknown tags, make an extra pass over the directory\n\t * to deal with them.  This must be done separately because the tags\n\t * could have become known when we registered a codec after finding\n"
}