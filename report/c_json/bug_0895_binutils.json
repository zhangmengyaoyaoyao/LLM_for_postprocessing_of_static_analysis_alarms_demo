{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "\t  for (p = htab->root.table.table[i]; p != NULL; p = p->next)",
    "Code_function": "elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n{\n  Elf_Internal_Ehdr *ehdr;\n  Elf_Internal_Shdr *hdr;\n  bfd_size_type symcount;\n  bfd_size_type extsymcount;\n  bfd_size_type extsymoff;\n  struct elf_link_hash_entry **sym_hash;\n  bfd_boolean dynamic;\n  Elf_External_Versym *extversym = NULL;\n  Elf_External_Versym *ever;\n  struct elf_link_hash_entry *weaks;\n  struct elf_link_hash_entry **nondeflt_vers = NULL;\n  bfd_size_type nondeflt_vers_cnt = 0;\n  Elf_Internal_Sym *isymbuf = NULL;\n  Elf_Internal_Sym *isym;\n  Elf_Internal_Sym *isymend;\n  const struct elf_backend_data *bed;\n  bfd_boolean add_needed;\n  struct elf_link_hash_table *htab;\n  bfd_size_type amt;\n  void *alloc_mark = NULL;\n  struct bfd_hash_entry **old_table = NULL;\n  unsigned int old_size = 0;\n  unsigned int old_count = 0;\n  void *old_tab = NULL;\n  void *old_ent;\n  struct bfd_link_hash_entry *old_undefs = NULL;\n  struct bfd_link_hash_entry *old_undefs_tail = NULL;\n  long old_dynsymcount = 0;\n  bfd_size_type old_dynstr_size = 0;\n  size_t tabsize = 0;\n  asection *s;\n  bfd_boolean just_syms;\n\n  htab = elf_hash_table (info);\n  bed = get_elf_backend_data (abfd);\n\n  if ((abfd->flags & DYNAMIC) == 0)\n    dynamic = FALSE;\n  else\n    {\n      dynamic = TRUE;\n\n      /* You can't use -r against a dynamic object.  Also, there's no\n\t hope of using a dynamic object which does not exactly match\n\t the format of the output file.  */\n      if (info->relocatable\n\t  || !is_elf_hash_table (htab)\n\t  || info->output_bfd->xvec != abfd->xvec)\n\t{\n\t  if (info->relocatable)\n\t    bfd_set_error (bfd_error_invalid_operation);\n\t  else\n\t    bfd_set_error (bfd_error_wrong_format);\n\t  goto error_return;\n\t}\n    }\n\n  ehdr = elf_elfheader (abfd);\n  if (info->warn_alternate_em\n      && bed->elf_machine_code != ehdr->e_machine\n      && ((bed->elf_machine_alt1 != 0\n\t   && ehdr->e_machine == bed->elf_machine_alt1)\n\t  || (bed->elf_machine_alt2 != 0\n\t      && ehdr->e_machine == bed->elf_machine_alt2)))\n    info->callbacks->einfo\n      (_(\"%P: alternate ELF machine code found (%d) in %B, expecting %d\\n\"),\n       ehdr->e_machine, abfd, bed->elf_machine_code);\n\n  /* As a GNU extension, any input sections which are named\n     .gnu.warning.SYMBOL are treated as warning symbols for the given\n     symbol.  This differs from .gnu.warning sections, which generate\n     warnings when they are included in an output file.  */\n  /* PR 12761: Also generate this warning when building shared libraries.  */\n  for (s = abfd->sections; s != NULL; s = s->next)\n    {\n      const char *name;\n\n      name = bfd_get_section_name (abfd, s);\n      if (CONST_STRNEQ (name, \".gnu.warning.\"))\n\t{\n\t  char *msg;\n\t  bfd_size_type sz;\n\n\t  name += sizeof \".gnu.warning.\" - 1;\n\n\t  /* If this is a shared object, then look up the symbol\n\t     in the hash table.  If it is there, and it is already\n\t     been defined, then we will not be using the entry\n\t     from this shared object, so we don't need to warn.\n\t     FIXME: If we see the definition in a regular object\n\t     later on, we will warn, but we shouldn't.  The only\n\t     fix is to keep track of what warnings we are supposed\n\t     to emit, and then handle them all at the end of the\n\t     link.  */\n\t  if (dynamic)\n\t    {\n\t      struct elf_link_hash_entry *h;\n\n\t      h = elf_link_hash_lookup (htab, name, FALSE, FALSE, TRUE);\n\n\t      /* FIXME: What about bfd_link_hash_common?  */\n\t      if (h != NULL\n\t\t  && (h->root.type == bfd_link_hash_defined\n\t\t      || h->root.type == bfd_link_hash_defweak))\n\t\tcontinue;\n\t    }\n\n\t  sz = s->size;\n\t  msg = (char *) bfd_alloc (abfd, sz + 1);\n\t  if (msg == NULL)\n\t    goto error_return;\n\n\t  if (! bfd_get_section_contents (abfd, s, msg, 0, sz))\n\t    goto error_return;\n\n\t  msg[sz] = '\\0';\n\n\t  if (! (_bfd_generic_link_add_one_symbol\n\t\t (info, abfd, name, BSF_WARNING, s, 0, msg,\n\t\t  FALSE, bed->collect, NULL)))\n\t    goto error_return;\n\n\t  if (!info->relocatable && info->executable)\n\t    {\n\t      /* Clobber the section size so that the warning does\n\t\t not get copied into the output file.  */\n\t      s->size = 0;\n\n\t      /* Also set SEC_EXCLUDE, so that symbols defined in\n\t\t the warning section don't get copied to the output.  */\n\t      s->flags |= SEC_EXCLUDE;\n\t    }\n\t}\n    }\n\n  just_syms = ((s = abfd->sections) != NULL\n\t       && s->sec_info_type == SEC_INFO_TYPE_JUST_SYMS);\n\n  add_needed = TRUE;\n  if (! dynamic)\n    {\n      /* If we are creating a shared library, create all the dynamic\n\t sections immediately.  We need to attach them to something,\n\t so we attach them to this BFD, provided it is the right\n\t format and is not from ld --just-symbols.  FIXME: If there\n\t are no input BFD's of the same format as the output, we can't\n\t make a shared library.  */\n      if (!just_syms\n\t  && info->shared\n\t  && is_elf_hash_table (htab)\n\t  && info->output_bfd->xvec == abfd->xvec\n\t  && !htab->dynamic_sections_created)\n\t{\n\t  if (! _bfd_elf_link_create_dynamic_sections (abfd, info))\n\t    goto error_return;\n\t}\n    }\n  else if (!is_elf_hash_table (htab))\n    goto error_return;\n  else\n    {\n      const char *soname = NULL;\n      char *audit = NULL;\n      struct bfd_link_needed_list *rpath = NULL, *runpath = NULL;\n      int ret;\n\n      /* ld --just-symbols and dynamic objects don't mix very well.\n\t ld shouldn't allow it.  */\n      if (just_syms)\n\tabort ();\n\n      /* If this dynamic lib was specified on the command line with\n\t --as-needed in effect, then we don't want to add a DT_NEEDED\n\t tag unless the lib is actually used.  Similary for libs brought\n\t in by another lib's DT_NEEDED.  When --no-add-needed is used\n\t on a dynamic lib, we don't want to add a DT_NEEDED entry for\n\t any dynamic library in DT_NEEDED tags in the dynamic lib at\n\t all.  */\n      add_needed = (elf_dyn_lib_class (abfd)\n\t\t    & (DYN_AS_NEEDED | DYN_DT_NEEDED\n\t\t       | DYN_NO_NEEDED)) == 0;\n\n      s = bfd_get_section_by_name (abfd, \".dynamic\");\n      if (s != NULL)\n\t{\n\t  bfd_byte *dynbuf;\n\t  bfd_byte *extdyn;\n\t  unsigned int elfsec;\n\t  unsigned long shlink;\n\n\t  if (!bfd_malloc_and_get_section (abfd, s, &dynbuf))\n\t    {\nerror_free_dyn:\n\t      free (dynbuf);\n\t      goto error_return;\n\t    }\n\n\t  elfsec = _bfd_elf_section_from_bfd_section (abfd, s);\n\t  if (elfsec == SHN_BAD)\n\t    goto error_free_dyn;\n\t  shlink = elf_elfsections (abfd)[elfsec]->sh_link;\n\n\t  for (extdyn = dynbuf;\n\t       extdyn < dynbuf + s->size;\n\t       extdyn += bed->s->sizeof_dyn)\n\t    {\n\t      Elf_Internal_Dyn dyn;\n\n\t      bed->s->swap_dyn_in (abfd, extdyn, &dyn);\n\t      if (dyn.d_tag == DT_SONAME)\n\t\t{\n\t\t  unsigned int tagv = dyn.d_un.d_val;\n\t\t  soname = bfd_elf_string_from_elf_section (abfd, shlink, tagv);\n\t\t  if (soname == NULL)\n\t\t    goto error_free_dyn;\n\t\t}\n\t      if (dyn.d_tag == DT_NEEDED)\n\t\t{\n\t\t  struct bfd_link_needed_list *n, **pn;\n\t\t  char *fnm, *anm;\n\t\t  unsigned int tagv = dyn.d_un.d_val;\n\n\t\t  amt = sizeof (struct bfd_link_needed_list);\n\t\t  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);\n\t\t  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);\n\t\t  if (n == NULL || fnm == NULL)\n\t\t    goto error_free_dyn;\n\t\t  amt = strlen (fnm) + 1;\n\t\t  anm = (char *) bfd_alloc (abfd, amt);\n\t\t  if (anm == NULL)\n\t\t    goto error_free_dyn;\n\t\t  memcpy (anm, fnm, amt);\n\t\t  n->name = anm;\n\t\t  n->by = abfd;\n\t\t  n->next = NULL;\n\t\t  for (pn = &htab->needed; *pn != NULL; pn = &(*pn)->next)\n\t\t    ;\n\t\t  *pn = n;\n\t\t}\n\t      if (dyn.d_tag == DT_RUNPATH)\n\t\t{\n\t\t  struct bfd_link_needed_list *n, **pn;\n\t\t  char *fnm, *anm;\n\t\t  unsigned int tagv = dyn.d_un.d_val;\n\n\t\t  amt = sizeof (struct bfd_link_needed_list);\n\t\t  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);\n\t\t  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);\n\t\t  if (n == NULL || fnm == NULL)\n\t\t    goto error_free_dyn;\n\t\t  amt = strlen (fnm) + 1;\n\t\t  anm = (char *) bfd_alloc (abfd, amt);\n\t\t  if (anm == NULL)\n\t\t    goto error_free_dyn;\n\t\t  memcpy (anm, fnm, amt);\n\t\t  n->name = anm;\n\t\t  n->by = abfd;\n\t\t  n->next = NULL;\n\t\t  for (pn = & runpath;\n\t\t       *pn != NULL;\n\t\t       pn = &(*pn)->next)\n\t\t    ;\n\t\t  *pn = n;\n\t\t}\n\t      /* Ignore DT_RPATH if we have seen DT_RUNPATH.  */\n\t      if (!runpath && dyn.d_tag == DT_RPATH)\n\t\t{\n\t\t  struct bfd_link_needed_list *n, **pn;\n\t\t  char *fnm, *anm;\n\t\t  unsigned int tagv = dyn.d_un.d_val;\n\n\t\t  amt = sizeof (struct bfd_link_needed_list);\n\t\t  n = (struct bfd_link_needed_list *) bfd_alloc (abfd, amt);\n\t\t  fnm = bfd_elf_string_from_elf_section (abfd, shlink, tagv);\n\t\t  if (n == NULL || fnm == NULL)\n\t\t    goto error_free_dyn;\n\t\t  amt = strlen (fnm) + 1;\n\t\t  anm = (char *) bfd_alloc (abfd, amt);\n\t\t  if (anm == NULL)\n\t\t    goto error_free_dyn;\n\t\t  memcpy (anm, fnm, amt);\n\t\t  n->name = anm;\n\t\t  n->by = abfd;\n\t\t  n->next = NULL;\n\t\t  for (pn = & rpath;\n\t\t       *pn != NULL;\n\t\t       pn = &(*pn)->next)\n\t\t    ;\n\t\t  *pn = n;\n\t\t}\n\t      if (dyn.d_tag == DT_AUDIT)\n\t\t{\n\t\t  unsigned int tagv = dyn.d_un.d_val;\n\t\t  audit = bfd_elf_string_from_elf_section (abfd, shlink, tagv);\n\t\t}\n\t    }\n\n\t  free (dynbuf);\n\t}\n\n      /* DT_RUNPATH overrides DT_RPATH.  Do _NOT_ bfd_release, as that\n\t frees all more recently bfd_alloc'd blocks as well.  */\n      if (runpath)\n\trpath = runpath;\n\n      if (rpath)\n\t{\n\t  struct bfd_link_needed_list **pn;\n\t  for (pn = &htab->runpath; *pn != NULL; pn = &(*pn)->next)\n\t    ;\n\t  *pn = rpath;\n\t}\n\n      /* We do not want to include any of the sections in a dynamic\n\t object in the output file.  We hack by simply clobbering the\n\t list of sections in the BFD.  This could be handled more\n\t cleanly by, say, a new section flag; the existing\n\t SEC_NEVER_LOAD flag is not the one we want, because that one\n\t still implies that the section takes up space in the output\n\t file.  */\n      bfd_section_list_clear (abfd);\n\n      /* Find the name to use in a DT_NEEDED entry that refers to this\n\t object.  If the object has a DT_SONAME entry, we use it.\n\t Otherwise, if the generic linker stuck something in\n\t elf_dt_name, we use that.  Otherwise, we just use the file\n\t name.  */\n      if (soname == NULL || *soname == '\\0')\n\t{\n\t  soname = elf_dt_name (abfd);\n\t  if (soname == NULL || *soname == '\\0')\n\t    soname = bfd_get_filename (abfd);\n\t}\n\n      /* Save the SONAME because sometimes the linker emulation code\n\t will need to know it.  */\n      elf_dt_name (abfd) = soname;\n\n      ret = elf_add_dt_needed_tag (abfd, info, soname, add_needed);\n      if (ret < 0)\n\tgoto error_return;\n\n      /* If we have already included this dynamic object in the\n\t link, just ignore it.  There is no reason to include a\n\t particular dynamic object more than once.  */\n      if (ret > 0)\n\treturn TRUE;\n\n      /* Save the DT_AUDIT entry for the linker emulation code. */\n      elf_dt_audit (abfd) = audit;\n    }\n\n  /* If this is a dynamic object, we always link against the .dynsym\n     symbol table, not the .symtab symbol table.  The dynamic linker\n     will only see the .dynsym symbol table, so there is no reason to\n     look at .symtab for a dynamic object.  */\n\n  if (! dynamic || elf_dynsymtab (abfd) == 0)\n    hdr = &elf_tdata (abfd)->symtab_hdr;\n  else\n    hdr = &elf_tdata (abfd)->dynsymtab_hdr;\n\n  symcount = hdr->sh_size / bed->s->sizeof_sym;\n\n  /* The sh_info field of the symtab header tells us where the\n     external symbols start.  We don't care about the local symbols at\n     this point.  */\n  if (elf_bad_symtab (abfd))\n    {\n      extsymcount = symcount;\n      extsymoff = 0;\n    }\n  else\n    {\n      extsymcount = symcount - hdr->sh_info;\n      extsymoff = hdr->sh_info;\n    }\n\n  sym_hash = elf_sym_hashes (abfd);\n  if (extsymcount != 0)\n    {\n      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,\n\t\t\t\t      NULL, NULL, NULL);\n      if (isymbuf == NULL)\n\tgoto error_return;\n\n      if (sym_hash == NULL)\n\t{\n\t  /* We store a pointer to the hash table entry for each\n\t     external symbol.  */\n\t  amt = extsymcount * sizeof (struct elf_link_hash_entry *);\n\t  sym_hash = (struct elf_link_hash_entry **) bfd_zalloc (abfd, amt);\n\t  if (sym_hash == NULL)\n\t    goto error_free_sym;\n\t  elf_sym_hashes (abfd) = sym_hash;\n\t}\n    }\n\n  if (dynamic)\n    {\n      /* Read in any version definitions.  */\n      if (!_bfd_elf_slurp_version_tables (abfd,\n\t\t\t\t\t  info->default_imported_symver))\n\tgoto error_free_sym;\n\n      /* Read in the symbol versions, but don't bother to convert them\n\t to internal format.  */\n      if (elf_dynversym (abfd) != 0)\n\t{\n\t  Elf_Internal_Shdr *versymhdr;\n\n\t  versymhdr = &elf_tdata (abfd)->dynversym_hdr;\n\t  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);\n\t  if (extversym == NULL)\n\t    goto error_free_sym;\n\t  amt = versymhdr->sh_size;\n\t  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0\n\t      || bfd_bread (extversym, amt, abfd) != amt)\n\t    goto error_free_vers;\n\t}\n    }\n\n  /* If we are loading an as-needed shared lib, save the symbol table\n     state before we start adding symbols.  If the lib turns out\n     to be unneeded, restore the state.  */\n  if ((elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0)\n    {\n      unsigned int i;\n      size_t entsize;\n\n      for (entsize = 0, i = 0; i < htab->root.table.size; i++)\n\t{\n\t  struct bfd_hash_entry *p;\n\t  struct elf_link_hash_entry *h;\n\n\t  for (p = htab->root.table.table[i]; p != NULL; p = p->next)\n\t    {\n\t      h = (struct elf_link_hash_entry *) p;\n\t      entsize += htab->root.table.entsize;\n\t      if (h->root.type == bfd_link_hash_warning)\n\t\tentsize += htab->root.table.entsize;\n\t    }\n\t}\n\n      tabsize = htab->root.table.size * sizeof (struct bfd_hash_entry *);\n      old_tab = bfd_malloc (tabsize + entsize);\n      if (old_tab == NULL)\n\tgoto error_free_vers;\n\n      /* Remember the current objalloc pointer, so that all mem for\n\t symbols added can later be reclaimed.  */\n      alloc_mark = bfd_hash_allocate (&htab->root.table, 1);\n      if (alloc_mark == NULL)\n\tgoto error_free_vers;\n\n      /* Make a special call to the linker \"notice\" function to\n\t tell it that we are about to handle an as-needed lib.  */\n      if (!(*bed->notice_as_needed) (abfd, info, notice_as_needed))\n\tgoto error_free_vers;\n\n      /* Clone the symbol table.  Remember some pointers into the\n\t symbol table, and dynamic symbol count.  */\n      old_ent = (char *) old_tab + tabsize;\n      memcpy (old_tab, htab->root.table.table, tabsize);\n      old_undefs = htab->root.undefs;\n      old_undefs_tail = htab->root.undefs_tail;\n      old_table = htab->root.table.table;\n      old_size = htab->root.table.size;\n      old_count = htab->root.table.count;\n      old_dynsymcount = htab->dynsymcount;\n      old_dynstr_size = _bfd_elf_strtab_size (htab->dynstr);\n\n      for (i = 0; i < htab->root.table.size; i++)\n\t{\n\t  struct bfd_hash_entry *p;\n\t  struct elf_link_hash_entry *h;\n\n\t  for (p = htab->root.table.table[i]; p != NULL; p = p->next)\n\t    {\n\t      memcpy (old_ent, p, htab->root.table.entsize);\n\t      old_ent = (char *) old_ent + htab->root.table.entsize;\n\t      h = (struct elf_link_hash_entry *) p;\n\t      if (h->root.type == bfd_link_hash_warning)\n\t\t{\n\t\t  memcpy (old_ent, h->root.u.i.link, htab->root.table.entsize);\n\t\t  old_ent = (char *) old_ent + htab->root.table.entsize;\n\t\t}\n\t    }\n\t}\n    }\n\n  weaks = NULL;\n  ever = extversym != NULL ? extversym + extsymoff : NULL;\n  for (isym = isymbuf, isymend = isymbuf + extsymcount;\n       isym < isymend;\n       isym++, sym_hash++, ever = (ever != NULL ? ever + 1 : NULL))\n    {\n      int bind;\n      bfd_vma value;\n      asection *sec, *new_sec;\n      flagword flags;\n      const char *name;\n      struct elf_link_hash_entry *h;\n      struct elf_link_hash_entry *hi;\n      bfd_boolean definition;\n      bfd_boolean size_change_ok;\n      bfd_boolean type_change_ok;\n      bfd_boolean new_weakdef;\n      bfd_boolean new_weak;\n      bfd_boolean old_weak;\n      bfd_boolean override;\n      bfd_boolean common;\n      unsigned int old_alignment;\n      bfd *old_bfd;\n\n      override = FALSE;\n\n      flags = BSF_NO_FLAGS;\n      sec = NULL;\n      value = isym->st_value;\n      common = bed->common_definition (isym);\n\n      bind = ELF_ST_BIND (isym->st_info);\n      switch (bind)\n\t{\n\tcase STB_LOCAL:\n\t  /* This should be impossible, since ELF requires that all\n\t     global symbols follow all local symbols, and that sh_info\n\t     point to the first global symbol.  Unfortunately, Irix 5\n\t     screws this up.  */\n\t  continue;\n\n\tcase STB_GLOBAL:\n\t  if (isym->st_shndx != SHN_UNDEF && !common)\n\t    flags = BSF_GLOBAL;\n\t  break;\n\n\tcase STB_WEAK:\n\t  flags = BSF_WEAK;\n\t  break;\n\n\tcase STB_GNU_UNIQUE:\n\t  flags = BSF_GNU_UNIQUE;\n\t  break;\n\n\tdefault:\n\t  /* Leave it up to the processor backend.  */\n\t  break;\n\t}\n\n      if (isym->st_shndx == SHN_UNDEF)\n\tsec = bfd_und_section_ptr;\n      else if (isym->st_shndx == SHN_ABS)\n\tsec = bfd_abs_section_ptr;\n      else if (isym->st_shndx == SHN_COMMON)\n\t{\n\t  sec = bfd_com_section_ptr;\n\t  /* What ELF calls the size we call the value.  What ELF\n\t     calls the value we call the alignment.  */\n\t  value = isym->st_size;\n\t}\n      else\n\t{\n\t  sec = bfd_section_from_elf_index (abfd, isym->st_shndx);\n\t  if (sec == NULL)\n\t    sec = bfd_abs_section_ptr;\n\t  else if (discarded_section (sec))\n\t    {\n\t      /* Symbols from discarded section are undefined.  We keep\n\t\t its visibility.  */\n\t      sec = bfd_und_section_ptr;\n\t      isym->st_shndx = SHN_UNDEF;\n\t    }\n\t  else if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)\n\t    value -= sec->vma;\n\t}\n\n      name = bfd_elf_string_from_elf_section (abfd, hdr->sh_link,\n\t\t\t\t\t      isym->st_name);\n      if (name == NULL)\n\tgoto error_free_vers;\n\n      if (isym->st_shndx == SHN_COMMON\n\t  && (abfd->flags & BFD_PLUGIN) != 0)\n\t{\n\t  asection *xc = bfd_get_section_by_name (abfd, \"COMMON\");\n\n\t  if (xc == NULL)\n\t    {\n\t      flagword sflags = (SEC_ALLOC | SEC_IS_COMMON | SEC_KEEP\n\t\t\t\t | SEC_EXCLUDE);\n\t      xc = bfd_make_section_with_flags (abfd, \"COMMON\", sflags);\n\t      if (xc == NULL)\n\t\tgoto error_free_vers;\n\t    }\n\t  sec = xc;\n\t}\n      else if (isym->st_shndx == SHN_COMMON\n\t       && ELF_ST_TYPE (isym->st_info) == STT_TLS\n\t       && !info->relocatable)\n\t{\n\t  asection *tcomm = bfd_get_section_by_name (abfd, \".tcommon\");\n\n\t  if (tcomm == NULL)\n\t    {\n\t      flagword sflags = (SEC_ALLOC | SEC_THREAD_LOCAL | SEC_IS_COMMON\n\t\t\t\t | SEC_LINKER_CREATED);\n\t      tcomm = bfd_make_section_with_flags (abfd, \".tcommon\", sflags);\n\t      if (tcomm == NULL)\n\t\tgoto error_free_vers;\n\t    }\n\t  sec = tcomm;\n\t}\n      else if (bed->elf_add_symbol_hook)\n\t{\n\t  if (! (*bed->elf_add_symbol_hook) (abfd, info, isym, &name, &flags,\n\t\t\t\t\t     &sec, &value))\n\t    goto error_free_vers;\n\n\t  /* The hook function sets the name to NULL if this symbol\n\t     should be skipped for some reason.  */\n\t  if (name == NULL)\n\t    continue;\n\t}\n\n      /* Sanity check that all possibilities were handled.  */\n      if (sec == NULL)\n\t{\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto error_free_vers;\n\t}\n\n      /* Silently discard TLS symbols from --just-syms.  There's\n\t no way to combine a static TLS block with a new TLS block\n\t for this executable.  */\n      if (ELF_ST_TYPE (isym->st_info) == STT_TLS\n\t  && sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)\n\tcontinue;\n\n      if (bfd_is_und_section (sec)\n\t  || bfd_is_com_section (sec))\n\tdefinition = FALSE;\n      else\n\tdefinition = TRUE;\n\n      size_change_ok = FALSE;\n      type_change_ok = bed->type_change_ok;\n      old_weak = FALSE;\n      old_alignment = 0;\n      old_bfd = NULL;\n      new_sec = sec;\n\n      if (is_elf_hash_table (htab))\n\t{\n\t  Elf_Internal_Versym iver;\n\t  unsigned int vernum = 0;\n\t  bfd_boolean skip;\n\n\t  if (ever == NULL)\n\t    {\n\t      if (info->default_imported_symver)\n\t\t/* Use the default symbol version created earlier.  */\n\t\tiver.vs_vers = elf_tdata (abfd)->cverdefs;\n\t      else\n\t\tiver.vs_vers = 0;\n\t    }\n\t  else\n\t    _bfd_elf_swap_versym_in (abfd, ever, &iver);\n\n\t  vernum = iver.vs_vers & VERSYM_VERSION;\n\n\t  /* If this is a hidden symbol, or if it is not version\n\t     1, we append the version name to the symbol name.\n\t     However, we do not modify a non-hidden absolute symbol\n\t     if it is not a function, because it might be the version\n\t     symbol itself.  FIXME: What if it isn't?  */\n\t  if ((iver.vs_vers & VERSYM_HIDDEN) != 0\n\t      || (vernum > 1\n\t\t  && (!bfd_is_abs_section (sec)\n\t\t      || bed->is_function_type (ELF_ST_TYPE (isym->st_info)))))\n\t    {\n\t      const char *verstr;\n\t      size_t namelen, verlen, newlen;\n\t      char *newname, *p;\n\n\t      if (isym->st_shndx != SHN_UNDEF)\n\t\t{\n\t\t  if (vernum > elf_tdata (abfd)->cverdefs)\n\t\t    verstr = NULL;\n\t\t  else if (vernum > 1)\n\t\t    verstr =\n\t\t      elf_tdata (abfd)->verdef[vernum - 1].vd_nodename;\n\t\t  else\n\t\t    verstr = \"\";\n\n\t\t  if (verstr == NULL)\n\t\t    {\n\t\t      (*_bfd_error_handler)\n\t\t\t(_(\"%B: %s: invalid version %u (max %d)\"),\n\t\t\t abfd, name, vernum,\n\t\t\t elf_tdata (abfd)->cverdefs);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      goto error_free_vers;\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  /* We cannot simply test for the number of\n\t\t     entries in the VERNEED section since the\n\t\t     numbers for the needed versions do not start\n\t\t     at 0.  */\n\t\t  Elf_Internal_Verneed *t;\n\n\t\t  verstr = NULL;\n\t\t  for (t = elf_tdata (abfd)->verref;\n\t\t       t != NULL;\n\t\t       t = t->vn_nextref)\n\t\t    {\n\t\t      Elf_Internal_Vernaux *a;\n\n\t\t      for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr)\n\t\t\t{\n\t\t\t  if (a->vna_other == vernum)\n\t\t\t    {\n\t\t\t      verstr = a->vna_nodename;\n\t\t\t      break;\n\t\t\t    }\n\t\t\t}\n\t\t      if (a != NULL)\n\t\t\tbreak;\n\t\t    }\n\t\t  if (verstr == NULL)\n\t\t    {\n\t\t      (*_bfd_error_handler)\n\t\t\t(_(\"%B: %s: invalid needed version %d\"),\n\t\t\t abfd, name, vernum);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      goto error_free_vers;\n\t\t    }\n\t\t}\n\n\t      namelen = strlen (name);\n\t      verlen = strlen (verstr);\n\t      newlen = namelen + verlen + 2;\n\t      if ((iver.vs_vers & VERSYM_HIDDEN) == 0\n\t\t  && isym->st_shndx != SHN_UNDEF)\n\t\t++newlen;\n\n\t      newname = (char *) bfd_hash_allocate (&htab->root.table, newlen);\n\t      if (newname == NULL)\n\t\tgoto error_free_vers;\n\t      memcpy (newname, name, namelen);\n\t      p = newname + namelen;\n\t      *p++ = ELF_VER_CHR;\n\t      /* If this is a defined non-hidden version symbol,\n\t\t we add another @ to the name.  This indicates the\n\t\t default version of the symbol.  */\n\t      if ((iver.vs_vers & VERSYM_HIDDEN) == 0\n\t\t  && isym->st_shndx != SHN_UNDEF)\n\t\t*p++ = ELF_VER_CHR;\n\t      memcpy (p, verstr, verlen + 1);\n\n\t      name = newname;\n\t    }\n\n\t  /* If this symbol has default visibility and the user has\n\t     requested we not re-export it, then mark it as hidden.  */\n\t  if (definition\n\t      && !dynamic\n\t      && (abfd->no_export\n\t\t  || (abfd->my_archive && abfd->my_archive->no_export))\n\t      && ELF_ST_VISIBILITY (isym->st_other) != STV_INTERNAL)\n\t    isym->st_other = (STV_HIDDEN\n\t\t\t      | (isym->st_other & ~ELF_ST_VISIBILITY (-1)));\n\n\t  if (!_bfd_elf_merge_symbol (abfd, info, name, isym, &sec, &value,\n\t\t\t\t      sym_hash, &old_bfd, &old_weak,\n\t\t\t\t      &old_alignment, &skip, &override,\n\t\t\t\t      &type_change_ok, &size_change_ok))\n\t    goto error_free_vers;\n\n\t  if (skip)\n\t    continue;\n\n\t  if (override)\n\t    definition = FALSE;\n\n\t  h = *sym_hash;\n\t  while (h->root.type == bfd_link_hash_indirect\n\t\t || h->root.type == bfd_link_hash_warning)\n\t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\n\t  if (elf_tdata (abfd)->verdef != NULL\n\t      && vernum > 1\n\t      && definition)\n\t    h->verinfo.verdef = &elf_tdata (abfd)->verdef[vernum - 1];\n\t}\n\n      if (! (_bfd_generic_link_add_one_symbol\n\t     (info, abfd, name, flags, sec, value, NULL, FALSE, bed->collect,\n\t      (struct bfd_link_hash_entry **) sym_hash)))\n\tgoto error_free_vers;\n\n      h = *sym_hash;\n      /* We need to make sure that indirect symbol dynamic flags are\n\t updated.  */\n      hi = h;\n      while (h->root.type == bfd_link_hash_indirect\n\t     || h->root.type == bfd_link_hash_warning)\n\th = (struct elf_link_hash_entry *) h->root.u.i.link;\n\n      *sym_hash = h;\n\n      new_weak = (flags & BSF_WEAK) != 0;\n      new_weakdef = FALSE;\n      if (dynamic\n\t  && definition\n\t  && new_weak\n\t  && !bed->is_function_type (ELF_ST_TYPE (isym->st_info))\n\t  && is_elf_hash_table (htab)\n\t  && h->u.weakdef == NULL)\n\t{\n\t  /* Keep a list of all weak defined non function symbols from\n\t     a dynamic object, using the weakdef field.  Later in this\n\t     function we will set the weakdef field to the correct\n\t     value.  We only put non-function symbols from dynamic\n\t     objects on this list, because that happens to be the only\n\t     time we need to know the normal symbol corresponding to a\n\t     weak symbol, and the information is time consuming to\n\t     figure out.  If the weakdef field is not already NULL,\n\t     then this symbol was already defined by some previous\n\t     dynamic object, and we will be using that previous\n\t     definition anyhow.  */\n\n\t  h->u.weakdef = weaks;\n\t  weaks = h;\n\t  new_weakdef = TRUE;\n\t}\n\n      /* Set the alignment of a common symbol.  */\n      if ((common || bfd_is_com_section (sec))\n\t  && h->root.type == bfd_link_hash_common)\n\t{\n\t  unsigned int align;\n\n\t  if (common)\n\t    align = bfd_log2 (isym->st_value);\n\t  else\n\t    {\n\t      /* The new symbol is a common symbol in a shared object.\n\t\t We need to get the alignment from the section.  */\n\t      align = new_sec->alignment_power;\n\t    }\n\t  if (align > old_alignment)\n\t    h->root.u.c.p->alignment_power = align;\n\t  else\n\t    h->root.u.c.p->alignment_power = old_alignment;\n\t}\n\n      if (is_elf_hash_table (htab))\n\t{\n\t  /* Set a flag in the hash table entry indicating the type of\n\t     reference or definition we just found.  A dynamic symbol\n\t     is one which is referenced or defined by both a regular\n\t     object and a shared object.  */\n\t  bfd_boolean dynsym = FALSE;\n\n\t  /* Plugin symbols aren't normal.  Don't set def_regular or\n\t     ref_regular for them, or make them dynamic.  */\n\t  if ((abfd->flags & BFD_PLUGIN) != 0)\n\t    ;\n\t  else if (! dynamic)\n\t    {\n\t      if (! definition)\n\t\t{\n\t\t  h->ref_regular = 1;\n\t\t  if (bind != STB_WEAK)\n\t\t    h->ref_regular_nonweak = 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  h->def_regular = 1;\n\t\t  if (h->def_dynamic)\n\t\t    {\n\t\t      h->def_dynamic = 0;\n\t\t      h->ref_dynamic = 1;\n\t\t    }\n\t\t}\n\n\t      /* If the indirect symbol has been forced local, don't\n\t\t make the real symbol dynamic.  */\n\t      if ((h == hi || !hi->forced_local)\n\t\t  && (! info->executable\n\t\t      || h->def_dynamic\n\t\t      || h->ref_dynamic))\n\t\tdynsym = TRUE;\n\t    }\n\t  else\n\t    {\n\t      if (! definition)\n\t\t{\n\t\t  h->ref_dynamic = 1;\n\t\t  hi->ref_dynamic = 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  h->def_dynamic = 1;\n\t\t  hi->def_dynamic = 1;\n\t\t}\n\n\t      /* If the indirect symbol has been forced local, don't\n\t\t make the real symbol dynamic.  */\n\t      if ((h == hi || !hi->forced_local)\n\t\t  && (h->def_regular\n\t\t      || h->ref_regular\n\t\t      || (h->u.weakdef != NULL\n\t\t\t  && ! new_weakdef\n\t\t\t  && h->u.weakdef->dynindx != -1)))\n\t\tdynsym = TRUE;\n\t    }\n\n\t  /* Check to see if we need to add an indirect symbol for\n\t     the default name.  */\n\t  if (definition\n\t      || (!override && h->root.type == bfd_link_hash_common))\n\t    if (!_bfd_elf_add_default_symbol (abfd, info, h, name, isym,\n\t\t\t\t\t      sec, value, &old_bfd, &dynsym))\n\t      goto error_free_vers;\n\n\t  /* Check the alignment when a common symbol is involved. This\n\t     can change when a common symbol is overridden by a normal\n\t     definition or a common symbol is ignored due to the old\n\t     normal definition. We need to make sure the maximum\n\t     alignment is maintained.  */\n\t  if ((old_alignment || common)\n\t      && h->root.type != bfd_link_hash_common)\n\t    {\n\t      unsigned int common_align;\n\t      unsigned int normal_align;\n\t      unsigned int symbol_align;\n\t      bfd *normal_bfd;\n\t      bfd *common_bfd;\n\n\t      BFD_ASSERT (h->root.type == bfd_link_hash_defined\n\t\t\t  || h->root.type == bfd_link_hash_defweak);\n\n\t      symbol_align = ffs (h->root.u.def.value) - 1;\n\t      if (h->root.u.def.section->owner != NULL\n\t\t  && (h->root.u.def.section->owner->flags & DYNAMIC) == 0)\n\t\t{\n\t\t  normal_align = h->root.u.def.section->alignment_power;\n\t\t  if (normal_align > symbol_align)\n\t\t    normal_align = symbol_align;\n\t\t}\n\t      else\n\t\tnormal_align = symbol_align;\n\n\t      if (old_alignment)\n\t\t{\n\t\t  common_align = old_alignment;\n\t\t  common_bfd = old_bfd;\n\t\t  normal_bfd = abfd;\n\t\t}\n\t      else\n\t\t{\n\t\t  common_align = bfd_log2 (isym->st_value);\n\t\t  common_bfd = abfd;\n\t\t  normal_bfd = old_bfd;\n\t\t}\n\n\t      if (normal_align < common_align)\n\t\t{\n\t\t  /* PR binutils/2735 */\n\t\t  if (normal_bfd == NULL)\n\t\t    (*_bfd_error_handler)\n\t\t      (_(\"Warning: alignment %u of common symbol `%s' in %B is\"\n\t\t\t \" greater than the alignment (%u) of its section %A\"),\n\t\t       common_bfd, h->root.u.def.section,\n\t\t       1 << common_align, name, 1 << normal_align);\n\t\t  else\n\t\t    (*_bfd_error_handler)\n\t\t      (_(\"Warning: alignment %u of symbol `%s' in %B\"\n\t\t\t \" is smaller than %u in %B\"),\n\t\t       normal_bfd, common_bfd,\n\t\t       1 << normal_align, name, 1 << common_align);\n\t\t}\n\t    }\n\n\t  /* Remember the symbol size if it isn't undefined.  */\n\t  if (isym->st_size != 0\n\t      && isym->st_shndx != SHN_UNDEF\n\t      && (definition || h->size == 0))\n\t    {\n\t      if (h->size != 0\n\t\t  && h->size != isym->st_size\n\t\t  && ! size_change_ok)\n\t\t(*_bfd_error_handler)\n\t\t  (_(\"Warning: size of symbol `%s' changed\"\n\t\t     \" from %lu in %B to %lu in %B\"),\n\t\t   old_bfd, abfd,\n\t\t   name, (unsigned long) h->size,\n\t\t   (unsigned long) isym->st_size);\n\n\t      h->size = isym->st_size;\n\t    }\n\n\t  /* If this is a common symbol, then we always want H->SIZE\n\t     to be the size of the common symbol.  The code just above\n\t     won't fix the size if a common symbol becomes larger.  We\n\t     don't warn about a size change here, because that is\n\t     covered by --warn-common.  Allow changes between different\n\t     function types.  */\n\t  if (h->root.type == bfd_link_hash_common)\n\t    h->size = h->root.u.c.size;\n\n\t  if (ELF_ST_TYPE (isym->st_info) != STT_NOTYPE\n\t      && ((definition && !new_weak)\n\t\t  || (old_weak && h->root.type == bfd_link_hash_common)\n\t\t  || h->type == STT_NOTYPE))\n\t    {\n\t      unsigned int type = ELF_ST_TYPE (isym->st_info);\n\n\t      /* Turn an IFUNC symbol from a DSO into a normal FUNC\n\t\t symbol.  */\n\t      if (type == STT_GNU_IFUNC\n\t\t  && (abfd->flags & DYNAMIC) != 0)\n\t\ttype = STT_FUNC;\n\n\t      if (h->type != type)\n\t\t{\n\t\t  if (h->type != STT_NOTYPE && ! type_change_ok)\n\t\t    (*_bfd_error_handler)\n\t\t      (_(\"Warning: type of symbol `%s' changed\"\n\t\t\t \" from %d to %d in %B\"),\n\t\t       abfd, name, h->type, type);\n\n\t\t  h->type = type;\n\t\t}\n\t    }\n\n\t  /* Merge st_other field.  */\n\t  elf_merge_st_other (abfd, h, isym, sec, definition, dynamic);\n\n\t  /* We don't want to make debug symbol dynamic.  */\n\t  if (definition && (sec->flags & SEC_DEBUGGING) && !info->relocatable)\n\t    dynsym = FALSE;\n\n\t  /* Nor should we make plugin symbols dynamic.  */\n\t  if ((abfd->flags & BFD_PLUGIN) != 0)\n\t    dynsym = FALSE;\n\n\t  if (definition)\n\t    {\n\t      h->target_internal = isym->st_target_internal;\n\t      h->unique_global = (flags & BSF_GNU_UNIQUE) != 0;\n\t    }\n\n\t  if (definition && !dynamic)\n\t    {\n\t      char *p = strchr (name, ELF_VER_CHR);\n\t      if (p != NULL && p[1] != ELF_VER_CHR)\n\t\t{\n\t\t  /* Queue non-default versions so that .symver x, x@FOO\n\t\t     aliases can be checked.  */\n\t\t  if (!nondeflt_vers)\n\t\t    {\n\t\t      amt = ((isymend - isym + 1)\n\t\t\t     * sizeof (struct elf_link_hash_entry *));\n\t\t      nondeflt_vers =\n                          (struct elf_link_hash_entry **) bfd_malloc (amt);\n\t\t      if (!nondeflt_vers)\n\t\t\tgoto error_free_vers;\n\t\t    }\n\t\t  nondeflt_vers[nondeflt_vers_cnt++] = h;\n\t\t}\n\t    }\n\n\t  if (dynsym && h->dynindx == -1)\n\t    {\n\t      if (! bfd_elf_link_record_dynamic_symbol (info, h))\n\t\tgoto error_free_vers;\n\t      if (h->u.weakdef != NULL\n\t\t  && ! new_weakdef\n\t\t  && h->u.weakdef->dynindx == -1)\n\t\t{\n\t\t  if (!bfd_elf_link_record_dynamic_symbol (info, h->u.weakdef))\n\t\t    goto error_free_vers;\n\t\t}\n\t    }\n\t  else if (dynsym && h->dynindx != -1)\n\t    /* If the symbol already has a dynamic index, but\n\t       visibility says it should not be visible, turn it into\n\t       a local symbol.  */\n\t    switch (ELF_ST_VISIBILITY (h->other))\n\t      {\n\t      case STV_INTERNAL:\n\t      case STV_HIDDEN:\n\t\t(*bed->elf_backend_hide_symbol) (info, h, TRUE);\n\t\tdynsym = FALSE;\n\t\tbreak;\n\t      }\n\n\t  /* Don't add DT_NEEDED for references from the dummy bfd.  */\n\t  if (!add_needed\n\t      && definition\n\t      && ((dynsym\n\t\t   && h->ref_regular_nonweak\n\t\t   && (old_bfd == NULL\n\t\t       || (old_bfd->flags & BFD_PLUGIN) == 0))\n\t\t  || (h->ref_dynamic_nonweak\n\t\t      && (elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0\n\t\t      && !on_needed_list (elf_dt_name (abfd), htab->needed))))\n\t    {\n\t      int ret;\n\t      const char *soname = elf_dt_name (abfd);\n\n\t      info->callbacks->minfo (\"%!\", soname, old_bfd,\n\t\t\t\t      h->root.root.s"
}