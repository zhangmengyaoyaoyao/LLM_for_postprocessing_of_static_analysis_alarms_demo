{
    "project": "gawk",
    "tool": "CSA",
    "category": "core.DivideZero",
    "file": "str_array.c",
    "message": "Division by zero",
    "warning_function_name": "awk_hash",
    "warning_line": "h %= hsize;",
    "warning_context": "static unsigned long\nawk_hash(const char *s, size_t len, unsigned long hsize, size_t *code)\n{\n\tunsigned long h = 0;\n\tunsigned long htmp;\n\n\t/*\n\t * Ozan Yigit's original sdbm hash, copied from Margo Seltzers\n\t * db package.\n\t *\n\t * This is INCREDIBLY ugly, but fast.  We break the string up into\n\t * 8 byte units.  On the first time through the loop we get the\n\t * \"leftover bytes\" (strlen % 8).  On every other iteration, we\n\t * perform 8 HASHC's so we handle all 8 bytes.  Essentially, this\n\t * saves us 7 cmp & branch instructions.  If this routine is\n\t * heavily used enough, it's worth the ugly coding.\n\t */\n\n\t/*\n\t * Even more speed:\n\t * #define HASHC   h = *s++ + 65599 * h\n\t * Because 65599 = pow(2, 6) + pow(2, 16) - 1 we multiply by shifts\n\t *\n\t * 4/2011: Force the results to 32 bits, to get the same\n\t * result on both 32- and 64-bit systems. This may be a\n\t * bad idea.\n\t */\n#define HASHC   htmp = (h << 6);  \\\n\t\th = *s++ + htmp + (htmp << 10) - h ; \\\n\t\thtmp &= 0xFFFFFFFF; \\\n\t\th &= 0xFFFFFFFF\n\n\th = 0;\n\n\t/* \"Duff's Device\" */\n\tif (len > 0) {\n\t\tsize_t loop = (len + 8 - 1) >> 3;\n\n\t\tswitch (len & (8 - 1)) {\n\t\tcase 0:\n\t\t\tdo {\t/* All fall throughs */\n\t\t\t\tHASHC;\n\t\tcase 7:\t\tHASHC;\n\t\tcase 6:\t\tHASHC;\n\t\tcase 5:\t\tHASHC;\n\t\tcase 4:\t\tHASHC;\n\t\tcase 3:\t\tHASHC;\n\t\tcase 2:\t\tHASHC;\n\t\tcase 1:\t\tHASHC;\n\t\t\t} while (--loop);\n\t\t}\n\t}\n\n\tif (code != NULL)\n\t\t*code = h;\n\n\tif (h >= hsize)\n\t\th %= hsize;\n\treturn h;\n}\n"
}