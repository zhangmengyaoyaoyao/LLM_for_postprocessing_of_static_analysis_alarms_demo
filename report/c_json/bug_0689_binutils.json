{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "gas/config/tc-i386.c",
    "message": "Offset added: 10 Size: 1.",
    "warning_function_name": "i386_align_code",
    "warning_line": "memcpy (fragP->fr_literal + fragP->fr_fix + padding,",
    "warning_context": "      else\n\t{\n\t  switch (fragP->tc_frag_data.tune)\n\t    {\n\t    case PROCESSOR_UNKNOWN:\n\t      /* When cpu_arch_isa is set, cpu_arch_tune shouldn't be\n\t\t PROCESSOR_UNKNOWN.  */\n\t      abort ();\n\t      break;\n\n\t    case PROCESSOR_I386:\n\t    case PROCESSOR_I486:\n\t    case PROCESSOR_PENTIUM:\n\t    case PROCESSOR_K6:\n\t    case PROCESSOR_ATHLON:\n\t    case PROCESSOR_K8:\n\t    case PROCESSOR_AMDFAM10:\n\t    case PROCESSOR_BD:\n\t    case PROCESSOR_BT:\n\t    case PROCESSOR_GENERIC32:\n\t      /* We use cpu_arch_isa_flags to check if we CAN optimize\n\t\t with nops.  */\n\t      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)\n\t\tpatt = alt_patt;\n\t      else\n\t\tpatt = f32_patt;\n\t      break;\n\t    case PROCESSOR_PENTIUMPRO:\n\t    case PROCESSOR_PENTIUM4:\n\t    case PROCESSOR_NOCONA:\n\t    case PROCESSOR_CORE:\n\t    case PROCESSOR_CORE2:\n\t    case PROCESSOR_COREI7:\n\t    case PROCESSOR_L1OM:\n\t    case PROCESSOR_K1OM:\n\t      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)\n\t\tpatt = alt_patt;\n\t      else\n\t\tpatt = f32_patt;\n\t      break;\n\t    case PROCESSOR_GENERIC64:\n\t      patt = alt_patt;\n\t      break;\n\t    }\n\t}\n\n      if (patt == f32_patt)\n\t{\n\t  /* If the padding is less than 15 bytes, we use the normal\n\t     ones.  Otherwise, we use a jump instruction and adjust\n\t     its offset.   */\n\t  int limit;\n\n\t  /* For 64bit, the limit is 3 bytes.  */\n\t  if (flag_code == CODE_64BIT\n\t      && fragP->tc_frag_data.isa_flags.bitfield.cpulm)\n\t    limit = 3;\n\t  else\n\t    limit = 15;\n\t  if (count < limit)\n\t    memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t    patt[count - 1], count);\n\t  else\n\t    {\n\t      memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t      jump_31, count);\n\t      /* Adjust jump offset.  */\n\t      fragP->fr_literal[fragP->fr_fix + 1] = count - 2;\n\t    }\n\t}\n      else\n\t{\n\t  /* Maximum length of an instruction is 10 byte.  If the\n\t     padding is greater than 10 bytes and we don't use jump,\n\t     we have to break it into smaller pieces.  */\n\t  int padding = count;\n\t  while (padding > 10)\n\t    {\n\t      padding -= 10;\n\t      memcpy (fragP->fr_literal + fragP->fr_fix + padding,\n\t\t      patt [9], 10);\n\t    }\n\n\t  if (padding)\n\t    memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t    patt [padding - 1], padding);\n\t}\n    }\n  fragP->fr_var = count;\n}\n\nstatic INLINE int\noperand_type_all_zero (const union i386_operand_type *x)\n{\n  switch (ARRAY_SIZE(x->array))\n    {\n    case 3:\n      if (x->array[2])\n\treturn 0;\n    case 2:\n      if (x->array[1])\n"
}