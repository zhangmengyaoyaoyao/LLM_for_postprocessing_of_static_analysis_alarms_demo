{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "subst.c",
    "message": "Array access (from variable 'ret') results in a null pointer dereference",
    "warning_function_name": "string_extract_double_quoted",
    "warning_line": "for (t = 0; ret[t]; t++, j++)",
    "warning_context": "\t     expand_word_internal handle the rest.  If STRIPDQ is non-zero,\n\t     we have already been through one round of backslash stripping,\n\t     and want to strip these backslashes only if DQUOTE is non-zero,\n\t     indicating that we are inside an embedded double-quoted string. */\n\n\t     /* If we are in an embedded quoted string, then don't strip\n\t\tbackslashes before characters for which the backslash\n\t\tretains its special meaning, but remove backslashes in\n\t\tfront of other characters.  If we are not in an\n\t\tembedded quoted string, don't strip backslashes at all.\n\t\tThis mess is necessary because the string was already\n\t\tsurrounded by double quotes (and sh has some really weird\n\t\tquoting rules).\n\t\tThe returned string will be run through expansion as if\n\t\tit were double-quoted. */\n\t  if ((stripdq == 0 && c != '\"') ||\n\t      (stripdq && ((dquote && (sh_syntaxtab[c] & CBSDQUOTE)) || dquote == 0)))\n\t    temp[j++] = '\\\\';\n\t  pass_next = 0;\n\nadd_one_character:\n\t  COPY_CHAR_I (temp, j, string, send, i);\n\t  continue;\n\t}\n\n      /* A backslash protects the next character.  The code just above\n\t handles preserving the backslash in front of any character but\n\t a double quote. */\n      if (c == '\\\\')\n\t{\n\t  pass_next++;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Inside backquotes, ``the portion of the quoted string from the\n\t initial backquote and the characters up to the next backquote\n\t that is not preceded by a backslash, having escape characters\n\t removed, defines that command''. */\n      if (backquote)\n\t{\n\t  if (c == '`')\n\t    backquote = 0;\n\t  temp[j++] = c;\n\t  i++;\n\t  continue;\n\t}\n\n      if (c == '`')\n\t{\n\t  temp[j++] = c;\n\t  backquote++;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Pass everything between `$(' and the matching `)' or a quoted\n\t ${ ... } pair through according to the Posix.2 specification. */\n      if (c == '$' && ((string[i + 1] == LPAREN) || (string[i + 1] == LBRACE)))\n\t{\n\t  int free_ret = 1;\n\n\t  si = i + 2;\n\t  if (string[i + 1] == LPAREN)\n\t    ret = extract_command_subst (string, &si, 0);\n\t  else\n\t    ret = extract_dollar_brace_string (string, &si, Q_DOUBLE_QUOTES, 0);\n\n\t  temp[j++] = '$';\n\t  temp[j++] = string[i + 1];\n\n\t  /* Just paranoia; ret will not be 0 unless no_longjmp_on_fatal_error\n\t     is set. */\n\t  if (ret == 0 && no_longjmp_on_fatal_error)\n\t    {\n\t      free_ret = 0;\n\t      ret = string + i + 2;\n\t    }\n\n\t  for (t = 0; ret[t]; t++, j++)\n\t    temp[j] = ret[t];\n\t  temp[j] = string[si];\n\n\t  if (string[si])\n\t    {\n\t      j++;\n\t      i = si + 1;\n\t    }\n\t  else\n\t    i = si;\n\n\t  if (free_ret)\n\t    free (ret);\n\t  continue;\n\t}\n\n      /* Add any character but a double quote to the quoted string we're\n\t accumulating. */\n      if (c != '\"')\n\tgoto add_one_character;\n\n"
}