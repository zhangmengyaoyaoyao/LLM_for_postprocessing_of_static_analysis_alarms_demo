{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [3, +oo] Size: [1, +oo].",
    "Code_line": "\t      temp2[len2] = '/';",
    "Code_function": "bash_directory_completion_hook (dirname)\n     char **dirname;\n{\n  char *local_dirname, *new_dirname, *t;\n  int return_value, should_expand_dirname, nextch, closer;\n  WORD_LIST *wl;\n  struct stat sb;\n\n  return_value = should_expand_dirname = nextch = closer = 0;\n  local_dirname = *dirname;\n\n  if (t = mbschr (local_dirname, '$'))\n    {\n      should_expand_dirname = '$';\n      nextch = t[1];\n      /* Deliberately does not handle the deprecated $[...] arithmetic\n\t expansion syntax */\n      if (nextch == '(')\n\tcloser = ')';\n      else if (nextch == '{')\n\tcloser = '}';\n      else\n\tnextch = 0;\n    }\n  else if (local_dirname[0] == '~')\n    should_expand_dirname = '~';\n  else\n    {\n      t = mbschr (local_dirname, '`');\n      if (t && unclosed_pair (local_dirname, strlen (local_dirname), \"`\") == 0)\n\tshould_expand_dirname = '`';\n    }\n\n#if defined (HAVE_LSTAT)\n  if (should_expand_dirname && lstat (local_dirname, &sb) == 0)\n#else\n  if (should_expand_dirname && stat (local_dirname, &sb) == 0)\n#endif\n    should_expand_dirname = 0;\n\n  if (should_expand_dirname)\n    {\n      new_dirname = savestring (local_dirname);\n      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB);\t/* does the right thing */\n      if (wl)\n\t{\n\t  *dirname = string_list (wl);\n\t  /* Tell the completer to replace the directory name only if we\n\t     actually expanded something. */\n\t  return_value = STREQ (local_dirname, *dirname) == 0;\n\t  free (local_dirname);\n\t  free (new_dirname);\n\t  dispose_words (wl);\n\t  local_dirname = *dirname;\n\t  /* XXX - change rl_filename_quote_characters here based on\n\t     should_expand_dirname/nextch/closer.  This is the only place\n\t     custom_filename_quote_characters is modified. */\n\t  if (rl_filename_quote_characters && *rl_filename_quote_characters)\n\t    {\n\t      int i, j, c;\n\t      i = strlen (default_filename_quote_characters);\n\t      custom_filename_quote_characters = xrealloc (custom_filename_quote_characters, i+1);\n\t      for (i = j = 0; c = default_filename_quote_characters[i]; i++)\n\t\t{\n\t\t  if (c == should_expand_dirname || c == nextch || c == closer)\n\t\t    continue;\n\t\t  custom_filename_quote_characters[j++] = c;\n\t\t}\n\t      custom_filename_quote_characters[j] = '\\0';\n\t      rl_filename_quote_characters = custom_filename_quote_characters;\n\t      set_filename_bstab (rl_filename_quote_characters);\n\t    }\n\t}\n      else\n\t{\n\t  free (new_dirname);\n\t  free (local_dirname);\n\t  *dirname = (char *)xmalloc (1);\n\t  **dirname = '\\0';\n\t  return 1;\n\t}\n    }\n  else\n    {\n      /* Dequote the filename even if we don't expand it. */\n      new_dirname = bash_dequote_filename (local_dirname, rl_completion_quote_character);\n      return_value = STREQ (local_dirname, new_dirname) == 0;\n      free (local_dirname);\n      local_dirname = *dirname = new_dirname;\n    }\n\n  /* no_symbolic_links == 0 -> use (default) logical view of the file system.\n     local_dirname[0] == '.' && local_dirname[1] == '/' means files in the\n     current directory (./).\n     local_dirname[0] == '.' && local_dirname[1] == 0 means relative pathnames\n     in the current directory (e.g., lib/sh).\n     XXX - should we do spelling correction on these? */\n\n  /* This is test as it was in bash-4.2: skip relative pathnames in current\n     directory.  Change test to\n      (local_dirname[0] != '.' || (local_dirname[1] && local_dirname[1] != '/'))\n     if we want to skip paths beginning with ./ also. */\n  if (no_symbolic_links == 0 && (local_dirname[0] != '.' || local_dirname[1]))\n    {\n      char *temp1, *temp2;\n      int len1, len2;\n\n      /* If we have a relative path\n      \t\t(local_dirname[0] != '/' && local_dirname[0] != '.')\n\t that is canonical after appending it to the current directory, then\n\t \ttemp1 = temp2+'/'\n\t That is,\n\t \tstrcmp (temp1, temp2) == 0\n\t after adding a slash to temp2 below.  It should be safe to not\n\t change those.\n      */\n      t = get_working_directory (\"symlink-hook\");\n      temp1 = make_absolute (local_dirname, t);\n      free (t);\n      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\n      /* Try spelling correction if initial canonicalization fails.  Make\n\t sure we are set to replace the directory name with the results so\n\t subsequent directory checks don't fail. */\n      if (temp2 == 0 && dircomplete_spelling && dircomplete_expand)\n\t{\n\t  temp2 = dirspell (temp1);\n\t  if (temp2)\n\t    {\n\t      free (temp1);\n\t      temp1 = temp2;\n\t      temp2 = sh_canonpath (temp1, PATH_CHECKDOTDOT|PATH_CHECKEXISTS);\n\t      return_value |= temp2 != 0;\n\t    }\n\t}\n      /* If we can't canonicalize, bail. */\n      if (temp2 == 0)\n\t{\n\t  free (temp1);\n\t  return return_value;\n\t}\n      len1 = strlen (temp1);\n      if (temp1[len1 - 1] == '/')\n\t{\n\t  len2 = strlen (temp2);\n\t  if (len2 > 2)\t\t/* don't append `/' to `/' or `//' */\n\t    {\n\t      temp2 = (char *)xrealloc (temp2, len2 + 2);\n\t      temp2[len2] = '/';\n\t      temp2[len2 + 1] = '\\0';\n\t    }\n\t}\n\n      /* dircomplete_expand_relpath == 0 means we want to leave relative\n\t pathnames that are unchanged by canonicalization alone.\n\t *local_dirname != '/' && *local_dirname != '.' == relative pathname\n\t (consistent with general.c:absolute_pathname())\n\t temp1 == temp2 (after appending a slash to temp2) means the pathname\n\t is not changed by canonicalization as described above. */\n      if (dircomplete_expand_relpath || ((local_dirname[0] != '/' && local_dirname[0] != '.') && STREQ (temp1, temp2) == 0))\n\treturn_value |= STREQ (local_dirname, temp2) == 0;\n      free (local_dirname);\n      *dirname = temp2;\n      free (temp1);\n    }\n\n  return (return_value);\n}"
}