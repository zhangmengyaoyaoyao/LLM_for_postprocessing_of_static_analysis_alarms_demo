{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "gas/config/atof-ieee.c",
    "message": "Offset: [-1, 15] Size: 33 by call to `gen_to_words`.",
    "warning_function_name": "atof_ieee",
    "warning_line": "gen_to_words (words, precision, exponent_bits);",
    "warning_context": "char *\natof_ieee (char *str,\t\t\t/* Text to convert to binary.  */\n\t   int what_kind,\t\t/* 'd', 'f', 'x', 'p'.  */\n\t   LITTLENUM_TYPE *words)\t/* Build the binary here.  */\n{\n  /* Extra bits for zeroed low-order bits.\n     The 1st MAX_PRECISION are zeroed, the last contain flonum bits.  */\n  static LITTLENUM_TYPE bits[MAX_PRECISION + MAX_PRECISION + GUARD];\n  char *return_value;\n  /* Number of 16-bit words in the format.  */\n  int precision;\n  long exponent_bits;\n  FLONUM_TYPE save_gen_flonum;\n\n  /* We have to save the generic_floating_point_number because it\n     contains storage allocation about the array of LITTLENUMs where\n     the value is actually stored.  We will allocate our own array of\n     littlenums below, but have to restore the global one on exit.  */\n  save_gen_flonum = generic_floating_point_number;\n\n  return_value = str;\n  generic_floating_point_number.low = bits + MAX_PRECISION;\n  generic_floating_point_number.high = NULL;\n  generic_floating_point_number.leader = NULL;\n  generic_floating_point_number.exponent = 0;\n  generic_floating_point_number.sign = '\\0';\n\n  /* Use more LittleNums than seems necessary: the highest flonum may\n     have 15 leading 0 bits, so could be useless.  */\n\n  memset (bits, '\\0', sizeof (LITTLENUM_TYPE) * MAX_PRECISION);\n\n  switch (what_kind)\n    {\n    case 'f':\n    case 'F':\n    case 's':\n    case 'S':\n      precision = F_PRECISION;\n      exponent_bits = 8;\n      break;\n\n    case 'd':\n    case 'D':\n    case 'r':\n    case 'R':\n      precision = D_PRECISION;\n      exponent_bits = 11;\n      break;\n\n    case 'x':\n    case 'X':\n    case 'e':\n    case 'E':\n      precision = X_PRECISION;\n      exponent_bits = 15;\n      break;\n\n    case 'p':\n    case 'P':\n      precision = P_PRECISION;\n      exponent_bits = -1;\n      break;\n\n    default:\n      make_invalid_floating_point_number (words);\n      return (NULL);\n    }\n\n  generic_floating_point_number.high\n    = generic_floating_point_number.low + precision - 1 + GUARD;\n\n  if (atof_generic (&return_value, \".\", EXP_CHARS,\n\t\t    &generic_floating_point_number))\n    {\n      make_invalid_floating_point_number (words);\n      return NULL;\n    }\n  gen_to_words (words, precision, exponent_bits);\n\n  /* Restore the generic_floating_point_number's storage alloc (and\n     everything else).  */\n  generic_floating_point_number = save_gen_flonum;\n\n  return return_value;\n}\n"
}