{
    "project": "gawk",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "array.c",
    "message": "pointer `val` last assigned on line 542 could be null and is dereferenced at line 607, column 6.",
    "warning_function_name": NaN,
    "warning_line": "if (val->type == Node_var_array) {",
    "warning_context": "/* do_delete --- perform `delete array[s]' */\n\n/*\n * `symbol' is array\n * `nsubs' is no of subscripts\n */\n\nvoid\ndo_delete(NODE *symbol, int nsubs)\n{\n\tNODE *val, *subs;\n\tint i;\n\n\tassert(symbol->type == Node_var_array);\n\tsubs = val = NULL;\t/* silence the compiler */\n\n\t/*\n\t * The force_string() call is needed to make sure that\n\t * the string subscript is reasonable.  For example, with it:\n\t *\n\t * $ ./gawk --posix 'BEGIN { CONVFMT=\"%ld\"; delete a[1.233]}'\n\t * gawk: cmd. line:1: fatal: `%l' is not permitted in POSIX awk formats\n\t *\n\t * Without it, the code does not fail.\n\t */\n\n#define free_subs(n)    do {                                    \\\n    NODE *s = PEEK(n - 1);                                      \\\n    if (s->type == Node_val) {                                  \\\n        (void) force_string(s);\t/* may have side effects. */    \\\n        DEREF(s);                                               \\\n    }                                                           \\\n} while (--n > 0)\n\n\tif (nsubs == 0) {\n\t\t/* delete array */\n\n\t\tadjust_fcall_stack(symbol, 0);\t/* fix function call stack; See above. */\n\t\tassoc_clear(symbol);\n\t\treturn;\n\t}\n\n\t/* NB: subscripts are in reverse order on stack */\n\n\tfor (i = nsubs; i > 0; i--) {\n\t\tsubs = PEEK(i - 1);\n\t\tif (subs->type != Node_val) {\n\t\t\tfree_subs(i);\n\t\t\tfatal(_(\"attempt to use array `%s' in a scalar context\"), array_vname(subs));\n\t\t}\n\n\t\tval = in_array(symbol, subs);\n\t\tif (val == NULL) {\n\t\t\tif (do_lint) {\n\t\t\t\tsubs = force_string(subs);\n\t\t\t\tlintwarn(_(\"delete: index `%s' not in array `%s'\"),\n\t\t\t\t\tsubs->stptr, array_vname(symbol));\n\t\t\t}\n\t\t\t/* avoid memory leak, free all subs */\n\t\t\tfree_subs(i);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i > 1) {\n\t\t\tif (val->type != Node_var_array) {\n\t\t\t\t/* e.g.: a[1] = 1; delete a[1][1] */\n\n\t\t\t\tfree_subs(i);\n\t\t\t\tsubs = force_string(subs);\n\t\t\t\tfatal(_(\"attempt to use scalar `%s[\\\"%.*s\\\"]' as an array\"),\n\t\t\t\t\tarray_vname(symbol),\n\t\t\t\t\t(int) subs->stlen,\n\t\t\t\t\tsubs->stptr);\n\t\t\t}\n\t\t\tsymbol = val;\n\t\t\tDEREF(subs);\n\t\t}\n\t}\n\n\tif (val->type == Node_var_array) {\n\t\tadjust_fcall_stack(val, nsubs);  /* fix function call stack; See above. */\n\t\tassoc_clear(val);\n\t\t/* cleared a sub-array, free Node_var_array */\n\t\tefree(val->vname);\n\t\tfreenode(val);\n\t} else\n\t\tunref(val);\n\n\t(void) assoc_remove(symbol, subs);\n\tDEREF(subs);\n\n#undef free_subs\n}\n\n\n/* do_delete_loop --- simulate ``for (iggy in foo) delete foo[iggy]'' */\n\n/*\n * The primary hassle here is that `iggy' needs to have some arbitrary\n * array index put in it before we can clear the array, we can't\n * just replace the loop with `delete foo'.\n"
}