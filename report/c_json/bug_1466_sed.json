{
    "Project": "sed",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "sed/compile.c",
    "message": "Offset added: 32 Size: [1, 32] by call to `ck_memdup`.",
    "warning_function_name": "compile_program",
    "warning_line": "cur_cmd->a1 = MEMDUP(&a, 1, struct addr);",
    "warning_context": "static struct vector *\ncompile_program(vector)\n  struct vector *vector;\n{\n  struct sed_cmd *cur_cmd;\n  struct buffer *b;\n  int ch;\n\n  if (!vector)\n    {\n      vector = MALLOC(1, struct vector);\n      vector->v = NULL;\n      vector->v_allocated = 0;\n      vector->v_length = 0;\n\n      obstack_init (&obs);\n    }\n  if (pending_text)\n    read_text(NULL, '\\n');\n\n  for (;;)\n    {\n      struct addr a;\n\n      while ((ch=inchar()) == ';' || ISSPACE(ch))\n\t;\n      if (ch == EOF)\n\tbreak;\n\n      cur_cmd = next_cmd_entry(&vector);\n      if (compile_address(&a, ch))\n\t{\n\t  if (a.addr_type == ADDR_IS_STEP\n\t      || a.addr_type == ADDR_IS_STEP_MOD)\n\t    bad_prog(_(BAD_STEP));\n\n\t  cur_cmd->a1 = MEMDUP(&a, 1, struct addr);\n\t  ch = in_nonblank();\n\t  if (ch == ',')\n\t    {\n\t      if (!compile_address(&a, in_nonblank()))\n\t\tbad_prog(_(BAD_COMMA));\n\n\t      cur_cmd->a2 = MEMDUP(&a, 1, struct addr);\n\t      ch = in_nonblank();\n\t    }\n\n\t  if ((cur_cmd->a1->addr_type == ADDR_IS_NUM\n\t       && cur_cmd->a1->addr_number == 0)\n\t      && ((!cur_cmd->a2 || cur_cmd->a2->addr_type != ADDR_IS_REGEX)\n\t\t  || posixicity == POSIXLY_BASIC))\n\t    bad_prog(_(INVALID_LINE_0));\n\t}\n      if (ch == '!')\n\t{\n\t  cur_cmd->addr_bang = true;\n\t  ch = in_nonblank();\n\t  if (ch == '!')\n\t    bad_prog(_(BAD_BANG));\n\t}\n\n      /* Do not accept extended commands in --posix mode.  Also,\n\t a few commands only accept one address in that mode.  */\n      if (posixicity == POSIXLY_BASIC)\n\tswitch (ch)\n\t  {\n\t    case 'e': case 'v': case 'z': case 'L':\n\t    case 'Q': case 'T': case 'R': case 'W':\n\t      bad_command(ch);\n\n\t    case 'a': case 'i': case 'l':\n\t    case '=': case 'r':\n\t      if (cur_cmd->a2)\n\t        bad_prog(_(ONE_ADDR));\n\t  }\n\n      cur_cmd->cmd = ch;\n      switch (ch)\n\t{\n\tcase '#':\n\t  if (cur_cmd->a1)\n\t    bad_prog(_(NO_SHARP_ADDR));\n\t  ch = inchar();\n\t  if (ch=='n' && first_script && cur_input.line < 2)\n\t    if (   (prog.base && prog.cur==2+prog.base)\n\t\t|| (prog.file && !prog.base && 2==ftell(prog.file)))\n\t      no_default_output = true;\n\t  while (ch != EOF && ch != '\\n')\n\t    ch = inchar();\n\t  continue;\t/* restart the for (;;) loop */\n\n\tcase 'v':\n\t  /* This is an extension.  Programs needing GNU sed might start\n\t   * with a `v' command so that other seds will stop.\n\t   * We compare the version and ignore POSIXLY_CORRECT.\n\t   */\n\t  {\n\t    char *version = read_label ();\n\t    char *compared_version;\n\t    compared_version = (*version == '\\0') ? \"4.0\" : version;\n\t    if (strverscmp (compared_version, SED_FEATURE_VERSION) > 0)\n"
}