{
    "project": "binutils",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "ld/lexsup.c",
    "message": "pointer `really_longopts` last assigned on line 536 could be null and is dereferenced at line 569, column 8.",
    "warning_function_name": "parse_args",
    "warning_line": "really_longopts[irl] = ld_options[i].opt;",
    "warning_context": "void\nparse_args (unsigned argc, char **argv)\n{\n  unsigned i;\n  int is, il, irl;\n  int ingroup = 0;\n  char *default_dirlist = NULL;\n  char *shortopts;\n  struct option *longopts;\n  struct option *really_longopts;\n  int last_optind;\n  enum report_method how_to_report_unresolved_symbols = RM_GENERATE_ERROR;\n\n  shortopts = (char *) xmalloc (OPTION_COUNT * 3 + 2);\n  longopts = (struct option *)\n      xmalloc (sizeof (*longopts) * (OPTION_COUNT + 1));\n  really_longopts = (struct option *)\n      malloc (sizeof (*really_longopts) * (OPTION_COUNT + 1));\n\n  /* Starting the short option string with '-' is for programs that\n     expect options and other ARGV-elements in any order and that care about\n     the ordering of the two.  We describe each non-option ARGV-element\n     as if it were the argument of an option with character code 1.  */\n  shortopts[0] = '-';\n  is = 1;\n  il = 0;\n  irl = 0;\n  for (i = 0; i < OPTION_COUNT; i++)\n    {\n      if (ld_options[i].shortopt != '\\0')\n\t{\n\t  shortopts[is] = ld_options[i].shortopt;\n\t  ++is;\n\t  if (ld_options[i].opt.has_arg == required_argument\n\t      || ld_options[i].opt.has_arg == optional_argument)\n\t    {\n\t      shortopts[is] = ':';\n\t      ++is;\n\t      if (ld_options[i].opt.has_arg == optional_argument)\n\t\t{\n\t\t  shortopts[is] = ':';\n\t\t  ++is;\n\t\t}\n\t    }\n\t}\n      if (ld_options[i].opt.name != NULL)\n\t{\n\t  if (ld_options[i].control == EXACTLY_TWO_DASHES)\n\t    {\n\t      really_longopts[irl] = ld_options[i].opt;\n\t      ++irl;\n\t    }\n\t  else\n\t    {\n\t      longopts[il] = ld_options[i].opt;\n\t      ++il;\n\t    }\n\t}\n    }\n  shortopts[is] = '\\0';\n  longopts[il].name = NULL;\n  really_longopts[irl].name = NULL;\n\n  ldemul_add_options (is, &shortopts, il, &longopts, irl, &really_longopts);\n\n  /* The -G option is ambiguous on different platforms.  Sometimes it\n     specifies the largest data size to put into the small data\n     section.  Sometimes it is equivalent to --shared.  Unfortunately,\n     the first form takes an argument, while the second does not.\n\n     We need to permit the --shared form because on some platforms,\n     such as Solaris, gcc -shared will pass -G to the linker.\n\n     To permit either usage, we look through the argument list.  If we\n     find -G not followed by a number, we change it into --shared.\n     This will work for most normal cases.  */\n  for (i = 1; i < argc; i++)\n    if (strcmp (argv[i], \"-G\") == 0\n\t&& (i + 1 >= argc\n\t    || ! ISDIGIT (argv[i + 1][0])))\n      argv[i] = (char *) \"--shared\";\n\n  /* Because we permit long options to start with a single dash, and\n     we have a --library option, and the -l option is conventionally\n     used with an immediately following argument, we can have bad\n     results if somebody tries to use -l with a library whose name\n     happens to start with \"ibrary\", as in -li.  We avoid problems by\n     simply turning -l into --library.  This means that users will\n     have to use two dashes in order to use --library, which is OK\n     since that's how it is documented.\n\n     FIXME: It's possible that this problem can arise for other short\n     options as well, although the user does always have the recourse\n     of adding a space between the option and the argument.  */\n  for (i = 1; i < argc; i++)\n    {\n      if (argv[i][0] == '-'\n\t  && argv[i][1] == 'l'\n\t  && argv[i][2] != '\\0')\n\t{\n\t  char *n;\n"
}