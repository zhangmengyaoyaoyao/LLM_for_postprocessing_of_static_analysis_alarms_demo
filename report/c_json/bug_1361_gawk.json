{
    "project": "gawk",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "builtin.c",
    "message": "Dereference of null pointer (loaded from variable 'cp')",
    "warning_function_name": "do_substr",
    "warning_line": "*cp = '\\0';",
    "warning_context": "\t\td_index = 1;\n\t}\n\tif (do_lint && double_to_int(d_index) != d_index)\n\t\tlintwarn(_(\"substr: non-integer start index %g will be truncated\"),\n\t\t\t d_index);\n\n\t/* awk indices are from 1, C's are from 0 */\n\tif (d_index <= SIZE_MAX)\n\t\tindx = d_index - 1;\n\telse\n\t\tindx = SIZE_MAX;\n\n\tif (nargs == 2) {\t/* third arg. missing */\n\t\t/* use remainder of string */\n\t\tlength = t1->stlen - indx;\t/* default to bytes */\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tt1 = force_wstring(t1);\n\t\t\tif (t1->wstlen > 0)\t/* use length of wide char string if we have one */\n\t\t\t\tlength = t1->wstlen - indx;\n\t\t}\n\t\td_length = length;\t/* set here in case used in diagnostics, below */\n\t}\n\n\tif (t1->stlen == 0) {\n\t\t/* substr(\"\", 1, 0) produces a warning only if LINT_ALL */\n\t\tif (do_lint && (do_lint == DO_LINT_ALL || ((indx | length) != 0)))\n\t\t\tlintwarn(_(\"substr: source string is zero length\"));\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\n\t/* get total len of input string, for following checks */\n\tif (gawk_mb_cur_max > 1) {\n\t\tt1 = force_wstring(t1);\n\t\tsrc_len = t1->wstlen;\n\t} else\n\t\tsrc_len = t1->stlen;\n\n\tif (indx >= src_len) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is past end of string\"),\n\t\t\t\td_index);\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\tif (length > src_len - indx) {\n\t\tif (do_lint)\n\t\t\tlintwarn(\n\t_(\"substr: length %g at start index %g exceeds length of first argument (%lu)\"),\n\t\t\td_length, d_index, (unsigned long int) src_len);\n\t\tlength = src_len - indx;\n\t}\n\n\t/* force_wstring() already called */\n\tif (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)\n\t\t/* single byte case */\n\t\tr = make_string(t1->stptr + indx, length);\n\telse {\n\t\t/* multibyte case, more work */\n\t\tsize_t result;\n\t\twchar_t *wp;\n\t\tmbstate_t mbs;\n\t\tchar *substr, *cp;\n\n\t\t/*\n\t\t * Convert the wide chars in t1->wstptr back into m.b. chars.\n\t\t * This is pretty grotty, but it's the most straightforward\n\t\t * way to do things.\n\t\t */\n\t\tmemset(& mbs, 0, sizeof(mbs));\n\t\temalloc(substr, char *, (length * gawk_mb_cur_max) + 2, \"do_substr\");\n\t\twp = t1->wstptr + indx;\n\t\tfor (cp = substr; length > 0; length--) {\n\t\t\tresult = wcrtomb(cp, *wp, & mbs);\n\t\t\tif (result == (size_t) -1)\t/* what to do? break seems best */\n\t\t\t\tbreak;\n\t\t\tcp += result;\n\t\t\twp++;\n\t\t}\n\t\t*cp = '\\0';\n\t\tr = make_str_node(substr, cp - substr, ALREADY_MALLOCED);\n\t}\n\n\tDEREF(t1);\n\treturn r;\n}\n\n/* do_strftime --- format a time stamp */\n\nNODE *\ndo_strftime(int nargs)\n{\n\tNODE *t1, *t2, *t3, *ret;\n\tstruct tm *tm;\n\ttime_t fclock;\n\tdouble clock_val;\n\tchar *bufp;\n\tsize_t buflen, bufsize;\n\tchar buf[BUFSIZ];\n\tconst char *format;\n\tint formatlen;\n"
}