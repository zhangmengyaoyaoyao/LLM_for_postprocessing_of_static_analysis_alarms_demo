{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: [8, 9] (⇐ [7, 8] + 1) Size: 2 by call to `exp_nameop`.",
    "Code_line": "\t\t\t\t\t    exp_nameop (NAME, \".\"),",
    "Code_function": "lang_insert_orphan (asection *s,\n\t\t    const char *secname,\n\t\t    int constraint,\n\t\t    lang_output_section_statement_type *after,\n\t\t    struct orphan_save *place,\n\t\t    etree_type *address,\n\t\t    lang_statement_list_type *add_child)\n{\n  lang_statement_list_type add;\n  const char *ps;\n  lang_output_section_statement_type *os;\n  lang_output_section_statement_type **os_tail;\n\n  /* If we have found an appropriate place for the output section\n     statements for this orphan, add them to our own private list,\n     inserting them later into the global statement list.  */\n  if (after != NULL)\n    {\n      lang_list_init (&add);\n      push_stat_ptr (&add);\n    }\n\n  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)\n    address = exp_intop (0);\n\n  os_tail = ((lang_output_section_statement_type **)\n\t     lang_output_section_statement.tail);\n  os = lang_enter_output_section_statement (secname, address, normal_section,\n\t\t\t\t\t    NULL, NULL, NULL, constraint, 0);\n\n  ps = NULL;\n  if (config.build_constructors && *os_tail == os)\n    {\n      /* If the name of the section is representable in C, then create\n\t symbols to mark the start and the end of the section.  */\n      for (ps = secname; *ps != '\\0'; ps++)\n\tif (! ISALNUM ((unsigned char) *ps) && *ps != '_')\n\t  break;\n      if (*ps == '\\0')\n\t{\n\t  char *symname;\n\n\t  symname = (char *) xmalloc (ps - secname + sizeof \"__start_\" + 1);\n\t  symname[0] = bfd_get_symbol_leading_char (link_info.output_bfd);\n\t  sprintf (symname + (symname[0] != 0), \"__start_%s\", secname);\n\t  lang_add_assignment (exp_provide (symname,\n\t\t\t\t\t    exp_nameop (NAME, \".\"),\n\t\t\t\t\t    FALSE));\n\t}\n    }\n\n  if (add_child == NULL)\n    add_child = &os->children;\n  lang_add_section (add_child, s, NULL, os);\n\n  if (after && (s->flags & (SEC_LOAD | SEC_ALLOC)) != 0)\n    {\n      const char *region = (after->region\n\t\t\t    ? after->region->name_list.name\n\t\t\t    : DEFAULT_MEMORY_REGION);\n      const char *lma_region = (after->lma_region\n\t\t\t\t? after->lma_region->name_list.name\n\t\t\t\t: NULL);\n      lang_leave_output_section_statement (NULL, region, after->phdrs,\n\t\t\t\t\t   lma_region);\n    }\n  else\n    lang_leave_output_section_statement (NULL, DEFAULT_MEMORY_REGION, NULL,\n\t\t\t\t\t NULL);\n\n  if (ps != NULL && *ps == '\\0')\n    {\n      char *symname;\n\n      symname = (char *) xmalloc (ps - secname + sizeof \"__stop_\" + 1);\n      symname[0] = bfd_get_symbol_leading_char (link_info.output_bfd);\n      sprintf (symname + (symname[0] != 0), \"__stop_%s\", secname);\n      lang_add_assignment (exp_provide (symname,\n\t\t\t\t\texp_nameop (NAME, \".\"),\n\t\t\t\t\tFALSE));\n    }\n\n  /* Restore the global list pointer.  */\n  if (after != NULL)\n    pop_stat_ptr ();\n\n  if (after != NULL && os->bfd_section != NULL)\n    {\n      asection *snew, *as;\n\n      snew = os->bfd_section;\n\n      /* Shuffle the bfd section list to make the output file look\n\t neater.  This is really only cosmetic.  */\n      if (place->section == NULL\n\t  && after != (&lang_output_section_statement.head\n\t\t       ->output_section_statement))\n\t{\n\t  asection *bfd_section = after->bfd_section;\n\n\t  /* If the output statement hasn't been used to place any input\n\t     sections (and thus doesn't have an output bfd_section),\n\t     look for the closest prior output statement having an\n\t     output section.  */\n\t  if (bfd_section == NULL)\n\t    bfd_section = output_prev_sec_find (after);\n\n\t  if (bfd_section != NULL && bfd_section != snew)\n\t    place->section = &bfd_section->next;\n\t}\n\n      if (place->section == NULL)\n\tplace->section = &link_info.output_bfd->sections;\n\n      as = *place->section;\n\n      if (!as)\n\t{\n\t  /* Put the section at the end of the list.  */\n\n\t  /* Unlink the section.  */\n\t  bfd_section_list_remove (link_info.output_bfd, snew);\n\n\t  /* Now tack it back on in the right place.  */\n\t  bfd_section_list_append (link_info.output_bfd, snew);\n\t}\n      else if (as != snew && as->prev != snew)\n\t{\n\t  /* Unlink the section.  */\n\t  bfd_section_list_remove (link_info.output_bfd, snew);\n\n\t  /* Now tack it back on in the right place.  */\n\t  bfd_section_list_insert_before (link_info.output_bfd, as, snew);\n\t}\n\n      /* Save the end of this list.  Further ophans of this type will\n\t follow the one we've just added.  */\n      place->section = &snew->next;\n\n      /* The following is non-cosmetic.  We try to put the output\n\t statements in some sort of reasonable order here, because they\n\t determine the final load addresses of the orphan sections.\n\t In addition, placing output statements in the wrong order may\n\t require extra segments.  For instance, given a typical\n\t situation of all read-only sections placed in one segment and\n\t following that a segment containing all the read-write\n\t sections, we wouldn't want to place an orphan read/write\n\t section before or amongst the read-only ones.  */\n      if (add.head != NULL)\n\t{\n\t  lang_output_section_statement_type *newly_added_os;\n\n\t  if (place->stmt == NULL)\n\t    {\n\t      lang_statement_union_type **where = insert_os_after (after);\n\n\t      *add.tail = *where;\n\t      *where = add.head;\n\n\t      place->os_tail = &after->next;\n\t    }\n\t  else\n\t    {\n\t      /* Put it after the last orphan statement we added.  */\n\t      *add.tail = *place->stmt;\n\t      *place->stmt = add.head;\n\t    }\n\n\t  /* Fix the global list pointer if we happened to tack our\n\t     new list at the tail.  */\n\t  if (*stat_ptr->tail == add.head)\n\t    stat_ptr->tail = add.tail;\n\n\t  /* Save the end of this list.  */\n\t  place->stmt = add.tail;\n\n\t  /* Do the same for the list of output section statements.  */\n\t  newly_added_os = *os_tail;\n\t  *os_tail = NULL;\n\t  newly_added_os->prev = (lang_output_section_statement_type *)\n\t    ((char *) place->os_tail\n\t     - offsetof (lang_output_section_statement_type, next));\n\t  newly_added_os->next = *place->os_tail;\n\t  if (newly_added_os->next != NULL)\n\t    newly_added_os->next->prev = newly_added_os;\n\t  *place->os_tail = newly_added_os;\n\t  place->os_tail = &newly_added_os->next;\n\n\t  /* Fixing the global list pointer here is a little different.\n\t     We added to the list in lang_enter_output_section_statement,\n\t     trimmed off the new output_section_statment above when\n\t     assigning *os_tail = NULL, but possibly added it back in\n\t     the same place when assigning *place->os_tail.  */\n\t  if (*os_tail == NULL)\n\t    lang_output_section_statement.tail\n\t      = (lang_statement_union_type **) os_tail;\n\t}\n    }\n  return os;\n}"
}