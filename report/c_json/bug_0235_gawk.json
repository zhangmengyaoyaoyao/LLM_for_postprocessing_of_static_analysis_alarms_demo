{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from wc was never initialized.",
    "Code_line": "  s1 = state_index (d, &d->mb_follows, wchar_context (wc));",
    "Code_function": "transit_state (struct dfa *d, state_num s, unsigned char const **pp,\n               unsigned char const *end)\n{\n  state_num s1;\n  int mbclen;  /* The length of current input multibyte character.  */\n  int maxlen = 0;\n  size_t i, j;\n  int *match_lens = NULL;\n  size_t nelem = d->states[s].mbps.nelem;       /* Just a alias.  */\n  unsigned char const *p1 = *pp;\n  wint_t wc;\n\n  if (nelem > 0)\n    /* This state has (a) multibyte operator(s).\n       We check whether each of them can match or not.  */\n    {\n      /* Note: caller must free the return value of this function.  */\n      mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);\n      match_lens = check_matching_with_multibyte_ops (d, s, (char const *) *pp,\n                                                      wc, mbclen);\n\n      for (i = 0; i < nelem; i++)\n        /* Search the operator which match the longest string,\n           in this state.  */\n        {\n          if (match_lens[i] > maxlen)\n            maxlen = match_lens[i];\n        }\n    }\n\n  if (nelem == 0 || maxlen == 0)\n    /* This state has no multibyte operator which can match.\n       We need to check only one single byte character.  */\n    {\n      status_transit_state rs;\n      rs = transit_state_singlebyte (d, s, *pp, &s1);\n\n      /* We must update the pointer if state transition succeeded.  */\n      if (rs == TRANSIT_STATE_DONE)\n        ++*pp;\n\n      return s1;\n    }\n\n  /* This state has some operators which can match a multibyte character.  */\n  d->mb_follows.nelem = 0;\n\n  /* 'maxlen' may be longer than the length of a character, because it may\n     not be a character but a (multi character) collating element.\n     We enumerate all of the positions which 's' can reach by consuming\n     'maxlen' bytes.  */\n  transit_state_consume_1char (d, s, pp, wc, mbclen, match_lens);\n\n  s1 = state_index (d, &d->mb_follows, wchar_context (wc));\n  realloc_trans_if_necessary (d, s1);\n\n  while (*pp - p1 < maxlen)\n    {\n      mbclen = mbs_to_wchar (&wc, (char const *) *pp, end - *pp, d);\n      transit_state_consume_1char (d, s1, pp, wc, mbclen, NULL);\n\n      for (i = 0; i < nelem; i++)\n        {\n          if (match_lens[i] == *pp - p1)\n            for (j = 0;\n                 j < d->follows[d->states[s1].mbps.elems[i].index].nelem; j++)\n              insert (d->follows[d->states[s1].mbps.elems[i].index].elems[j],\n                      &d->mb_follows);\n        }\n\n      s1 = state_index (d, &d->mb_follows, wchar_context (wc));\n      realloc_trans_if_necessary (d, s1);\n    }\n  return s1;\n}"
}