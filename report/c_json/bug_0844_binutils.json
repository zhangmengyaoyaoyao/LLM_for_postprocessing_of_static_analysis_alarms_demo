{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/config/tc-i386.c",
    "message": "The value read from mnem_p was never initialized.",
    "warning_function_name": "parse_insn",
    "warning_line": "if (mnem_p - 2 == dot_p && dot_p[1] == 's')",
    "warning_context": "\t      as_bad (_(\"no such instruction: `%s'\"), token_start);\n\t      return NULL;\n\t    }\n\t  l++;\n\t}\n      if (!is_space_char (*l)\n\t  && *l != END_OF_INSN\n\t  && (intel_syntax\n\t      || (*l != PREFIX_SEPARATOR\n\t\t  && *l != ',')))\n\t{\n\t  as_bad (_(\"invalid character %s in mnemonic\"),\n\t\t  output_invalid (*l));\n\t  return NULL;\n\t}\n      if (token_start == l)\n\t{\n\t  if (!intel_syntax && *l == PREFIX_SEPARATOR)\n\t    as_bad (_(\"expecting prefix; got nothing\"));\n\t  else\n\t    as_bad (_(\"expecting mnemonic; got nothing\"));\n\t  return NULL;\n\t}\n\n      /* Look up instruction (or prefix) via hash table.  */\n      current_templates = (const templates *) hash_find (op_hash, mnemonic);\n\n      if (*l != END_OF_INSN\n\t  && (!is_space_char (*l) || l[1] != END_OF_INSN)\n\t  && current_templates\n\t  && current_templates->start->opcode_modifier.isprefix)\n\t{\n\t  if (!cpu_flags_check_cpu64 (current_templates->start->cpu_flags))\n\t    {\n\t      as_bad ((flag_code != CODE_64BIT\n\t\t       ? _(\"`%s' is only supported in 64-bit mode\")\n\t\t       : _(\"`%s' is not supported in 64-bit mode\")),\n\t\t      current_templates->start->name);\n\t      return NULL;\n\t    }\n\t  /* If we are in 16-bit mode, do not allow addr16 or data16.\n\t     Similarly, in 32-bit mode, do not allow addr32 or data32.  */\n\t  if ((current_templates->start->opcode_modifier.size16\n\t       || current_templates->start->opcode_modifier.size32)\n\t      && flag_code != CODE_64BIT\n\t      && (current_templates->start->opcode_modifier.size32\n\t\t  ^ (flag_code == CODE_16BIT)))\n\t    {\n\t      as_bad (_(\"redundant %s prefix\"),\n\t\t      current_templates->start->name);\n\t      return NULL;\n\t    }\n\t  /* Add prefix, checking for repeated prefixes.  */\n\t  switch (add_prefix (current_templates->start->base_opcode))\n\t    {\n\t    case PREFIX_EXIST:\n\t      return NULL;\n\t    case PREFIX_REP:\n\t      if (current_templates->start->cpu_flags.bitfield.cpuhle)\n\t\ti.hle_prefix = current_templates->start->name;\n\t      else if (current_templates->start->cpu_flags.bitfield.cpumpx)\n\t\ti.bnd_prefix = current_templates->start->name;\n\t      else\n\t\ti.rep_prefix = current_templates->start->name;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t  /* Skip past PREFIX_SEPARATOR and reset token_start.  */\n\t  token_start = ++l;\n\t}\n      else\n\tbreak;\n    }\n\n  if (!current_templates)\n    {\n      /* Check if we should swap operand or force 32bit displacement in\n\t encoding.  */\n      if (mnem_p - 2 == dot_p && dot_p[1] == 's')\n\ti.swap_operand = 1;\n      else if (mnem_p - 3 == dot_p\n\t       && dot_p[1] == 'd'\n\t       && dot_p[2] == '8')\n\ti.disp_encoding = disp_encoding_8bit;\n      else if (mnem_p - 4 == dot_p\n\t       && dot_p[1] == 'd'\n\t       && dot_p[2] == '3'\n\t       && dot_p[3] == '2')\n\ti.disp_encoding = disp_encoding_32bit;\n      else\n\tgoto check_suffix;\n      mnem_p = dot_p;\n      *dot_p = '\\0';\n      current_templates = (const templates *) hash_find (op_hash, mnemonic);\n    }\n\n  if (!current_templates)\n    {\ncheck_suffix:\n      /* See if we can get a match by trimming off a suffix.  */\n"
}