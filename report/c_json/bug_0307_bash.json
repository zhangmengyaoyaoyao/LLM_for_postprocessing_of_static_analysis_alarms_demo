{
    "Project": "bash",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "y.tab.c",
    "message": "Offset: [-61, 37] Size: 38.",
    "warning_function_name": "YYID",
    "warning_line": "yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;",
    "warning_context": "\t\t\t  (yyval.command) = make_simple_command (x, (COMMAND *)NULL);\n\t\t\t  (yyval.command)->flags |= CMD_INVERT_RETURN;\n\t\t\t  /* XXX - let's cheat and push a newline back */\n\t\t\t  if ((yyvsp[(2) - (2)].number) == '\\n')\n\t\t\t    token_to_read = '\\n';\n\t\t\t}\n    break;\n\n  case 162:\n#line 1244 \"/usr/homes/chet/src/bash/src/parse.y\"\n    { (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), '|'); }\n    break;\n\n  case 163:\n#line 1246 \"/usr/homes/chet/src/bash/src/parse.y\"\n    {\n\t\t\t  /* Make cmd1 |& cmd2 equivalent to cmd1 2>&1 | cmd2 */\n\t\t\t  COMMAND *tc;\n\t\t\t  REDIRECTEE rd, sd;\n\t\t\t  REDIRECT *r;\n\n\t\t\t  tc = (yyvsp[(1) - (4)].command)->type == cm_simple ? (COMMAND *)(yyvsp[(1) - (4)].command)->value.Simple : (yyvsp[(1) - (4)].command);\n\t\t\t  sd.dest = 2;\n\t\t\t  rd.dest = 1;\n\t\t\t  r = make_redirection (sd, r_duplicating_output, rd, 0);\n\t\t\t  if (tc->redirects)\n\t\t\t    {\n\t\t\t      register REDIRECT *t;\n\t\t\t      for (t = tc->redirects; t->next; t = t->next)\n\t\t\t\t;\n\t\t\t      t->next = r;\n\t\t\t    }\n\t\t\t  else\n\t\t\t    tc->redirects = r;\n\n\t\t\t  (yyval.command) = command_connect ((yyvsp[(1) - (4)].command), (yyvsp[(4) - (4)].command), '|');\n\t\t\t}\n    break;\n\n  case 164:\n#line 1269 \"/usr/homes/chet/src/bash/src/parse.y\"\n    { (yyval.command) = (yyvsp[(1) - (1)].command); }\n    break;\n\n  case 165:\n#line 1273 \"/usr/homes/chet/src/bash/src/parse.y\"\n    { (yyval.number) = CMD_TIME_PIPELINE; }\n    break;\n\n  case 166:\n#line 1275 \"/usr/homes/chet/src/bash/src/parse.y\"\n    { (yyval.number) = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }\n    break;\n\n  case 167:\n#line 1277 \"/usr/homes/chet/src/bash/src/parse.y\"\n    { (yyval.number) = CMD_TIME_PIPELINE|CMD_TIME_POSIX; }\n    break;\n\n\n/* Line 1267 of yacc.c.  */\n#line 3377 \"y.tab.c\"\n      default: break;\n    }\n  YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n\n  YYPOPSTACK (yylen);\n  yylen = 0;\n  YY_STACK_PRINT (yyss, yyssp);\n\n  *++yyvsp = yyval;\n\n\n  /* Now `shift' the result of the reduction.  Determine what state\n     that goes to, based on the state we popped back to and the rule\n     number reduced by.  */\n\n  yyn = yyr1[yyn];\n\n  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;\n  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)\n    yystate = yytable[yystate];\n  else\n    yystate = yydefgoto[yyn - YYNTOKENS];\n\n  goto yynewstate;\n\n\n/*------------------------------------.\n| yyerrlab -- here on detecting error |\n`------------------------------------*/\nyyerrlab:\n  /* If not already recovering from an error, report this error.  */\n  if (!yyerrstatus)\n    {\n      ++yynerrs;\n#if ! YYERROR_VERBOSE\n      yyerror (YY_(\"syntax error\"));\n#else\n      {\n\tYYSIZE_T yysize = yysyntax_error (0, yystate, yychar);\n"
}