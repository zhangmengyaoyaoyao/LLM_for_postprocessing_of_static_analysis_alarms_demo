{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/complete.c",
    "message": "The value read from ps1.__count was never initialized.",
    "warning_function_name": "print_filename",
    "warning_line": "ps_back = ps1;",
    "warning_context": "}\n\n/* Find the common prefix of the list of matches, and put it into\n   matches[0]. */\nstatic int\ncompute_lcd_of_matches (match_list, matches, text)\n     char **match_list;\n     int matches;\n     const char *text;\n{\n  register int i, c1, c2, si;\n  int low;\t\t/* Count of max-matched characters. */\n  int lx;\n  char *dtext;\t\t/* dequoted TEXT, if needed */\n#if defined (HANDLE_MULTIBYTE)\n  int v;\n  size_t v1, v2;\n  mbstate_t ps1, ps2;\n  wchar_t wc1, wc2;\n#endif\n\n  /* If only one match, just use that.  Otherwise, compare each\n     member of the list with the next, finding out where they\n     stop matching. */\n  if (matches == 1)\n    {\n      match_list[0] = match_list[1];\n      match_list[1] = (char *)NULL;\n      return 1;\n    }\n\n  for (i = 1, low = 100000; i < matches; i++)\n    {\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  memset (&ps1, 0, sizeof (mbstate_t));\n\t  memset (&ps2, 0, sizeof (mbstate_t));\n\t}\n#endif\n      if (_rl_completion_case_fold)\n\t{\n\t  for (si = 0;\n\t       (c1 = _rl_to_lower(match_list[i][si])) &&\n\t       (c2 = _rl_to_lower(match_list[i + 1][si]));\n\t       si++)\n#if defined (HANDLE_MULTIBYTE)\n\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t      {\n\t\tv1 = mbrtowc(&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);\n\t\tv2 = mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);\n\t\tif (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n\t\t  {\n\t\t    if (c1 != c2)\t/* do byte comparison */\n\t\t      break;\n\t\t    continue;\n\t\t  }\n\t\twc1 = towlower (wc1);\n\t\twc2 = towlower (wc2);\n\t\tif (wc1 != wc2)\n\t\t  break;\n\t\telse if (v1 > 1)\n\t\t  si += v1 - 1;\n\t      }\n\t    else\n#endif\n\t    if (c1 != c2)\n\t      break;\n\t}\n      else\n\t{\n\t  for (si = 0;\n\t       (c1 = match_list[i][si]) &&\n\t       (c2 = match_list[i + 1][si]);\n\t       si++)\n#if defined (HANDLE_MULTIBYTE)\n\t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t      {\n\t\tmbstate_t ps_back;\n\t\tps_back = ps1;\n\t\tif (!_rl_compare_chars (match_list[i], si, &ps1, match_list[i+1], si, &ps2))\n\t\t  break;\n\t\telse if ((v = _rl_get_char_len (&match_list[i][si], &ps_back)) > 1)\n\t\t  si += v - 1;\n\t      }\n\t    else\n#endif\n\t    if (c1 != c2)\n\t      break;\n\t}\n\n      if (low > si)\n\tlow = si;\n    }\n\n  /* If there were multiple matches, but none matched up to even the\n     first character, and the user typed something, use that as the\n     value of matches[0]. */\n  if (low == 0 && text && *text)\n    {\n      match_list[0] = (char *)xmalloc (strlen (text) + 1);\n"
}