{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: 5 Size: [0, 7] by call to `lookup`.",
    "Code_line": "\tf = lookup(\"@eval\");",
    "Code_function": "do_eval(CMDARG *arg, int cmd ATTRIBUTE_UNUSED)\n{\n\tNODE *r, *ret_val;\n\tNODE *f = NULL;\n\tNODE *this_frame = NULL, *this_func = NULL;\n\tNODE **sp;\n\tINSTRUCTION *eval, *code = NULL;\n\tAWK_CONTEXT *ctxt;\n\tint ecount = 0, pcount = 0;\n\tint ret;\n\tint save_flags = do_flags;\n\tSRCFILE *the_source;\n\n\tif (prog_running) {\n\t\tthis_frame = find_frame(0);\n\t\tthis_func = this_frame->func_node;\n\t}\n\n\tinstall_params(this_func);\t/* expose current function parameters to eval */\n\tctxt = new_context();\n\tctxt->install_func = append_symbol;\t/* keep track of newly installed globals */\n\tpush_context(ctxt);\n\tthe_source = add_srcfile(SRC_CMDLINE, arg->a_string, srcfiles, NULL, NULL);\n\tdo_flags = false;\n\tret = parse_program(&code);\n\tdo_flags = save_flags;\n\tremove_params(this_func);\n\tif (ret != 0) {\n\t\tpop_context();\t/* switch to prev context */\n\t\tfree_context(ctxt, false /* keep_globals */);\n\t\treturn false;\n\t}\n\n\tf = lookup(\"@eval\");\n\tassert(f != NULL);\n\tif (this_func == NULL) {\t/* in main */\n\t\t/* do a function call */\n\t\teval = bcalloc(Op_func_call, 2, 0);\n\t\teval->source_file = cur_srcfile->src;\n\t\teval->func_body = f;\n\t\teval->func_name = NULL;\t/* not needed, func_body already assigned */\n\t\t(eval + 1)->expr_count = 0;\n\t\teval->nexti = bcalloc(Op_stop, 1, 0);\n\n\t} else {\n\t\t/* execute as a part of the current function */\n\t\tint i;\n\t\tINSTRUCTION *t;\n\n\t\teval = f->code_ptr;\t/* Op_func */\n\t\teval->source_file = cur_srcfile->src;\n\t\t/* turn implicit Op_K_return into Op_stop */\n\t\tt = (eval + 1)->lasti;\t/* Op_K_return */\n\t\tt->opcode = Op_stop;\n\n\t\t/* add or append eval locals to the current frame stack */\n\t\tecount = f->param_cnt;\t/* eval local count */\n\t\tpcount = this_func->param_cnt;\n\n\t\tif (ecount > 0) {\n\t\t\tif (pcount == 0)\n\t\t\t\temalloc(this_frame->stack, NODE **, ecount * sizeof(NODE *), \"do_eval\");\n\t\t\telse\n\t\t\t\terealloc(this_frame->stack, NODE **, (pcount + ecount) * sizeof(NODE *), \"do_eval\");\n\n\t\t\tsp = this_frame->stack + pcount;\n\t\t\tfor (i = 0; i < ecount; i++) {\n\t\t\t\tNODE *np;\n\n\t\t\t\tnp = f->fparms + i;\n\t\t\t\tnp->param_cnt += pcount;\t/* appending eval locals: fixup param_cnt */\n\n\t\t\t\tgetnode(r);\n\t\t\t\tmemset(r, 0, sizeof(NODE));\n\t\t\t\t*sp++ = r;\n\t\t\t\t/* local variable */\n\t\t\t\tr->type = Node_var_new;\n\t\t\t\tr->vname = np->param;\n\t\t\t}\n\n\t\t\tthis_func->param_cnt += ecount;\n\t\t}\n\t}\n\n#if 0\n\tpf_data.print_func = fprintf;\n\tpf_data.fp = out_fp;\n\tpf_data.defn = false;\t/* in_dump = false */\n\t(void) print_code(f->code_ptr, &pf_data);\n#endif\n\n\tret_val = execute_code((volatile INSTRUCTION *) eval);\n\n\tif (ret_val != NULL)\n\t\tDEREF(ret_val);\t/* throw away return value */\n\t/* else\n\t\tfatal error */\n\n\tif (this_func != NULL && ecount > 0) {\n\t\tint i;\n\n\t\t/* undo frame manipulation from above */\n\n\t\t/* free eval locals */\n\t\tsp = this_frame->stack + pcount;\n\t\tfor (i = ecount; i > 0; i--) {\n\t\t\tr = *sp;\n\t\t\tif (r->type == Node_var)     /* eval local variable */\n\t\t\t\tDEREF(r->var_value);\n\t\t\telse if (r->type == Node_var_array)     /* eval local array */\n\t\t\t\tassoc_clear(r);\n\t\t\tfreenode(r);\n\t\t\t*sp++ = (NODE *) 0;\n\t\t}\n\t\tif (pcount == 0) {\n\t\t\tefree(this_frame->stack);\n\t\t\tthis_frame->stack = NULL;\n\t\t} /* else\n\t\t\t\trestore_frame() will free it */\n\n\t\tthis_func->param_cnt -= ecount;\n\t}\n\n\t/*\n\t * Always destroy symbol \"@eval\", however destroy all newly installed\n\t * globals only if fatal error (execute_code() returing NULL).\n\t */\n\n\tpop_context();\t/* switch to prev context */\n\tfree_context(ctxt, (ret_val != NULL));   /* free all instructions and optionally symbols */\n\n\tif (ret_val != NULL) {\n\t\t/*\n\t\t * Remove @eval from FUNCTAB, so that above code\n\t\t * will work the next time around.\n\t\t */\n\t\tNODE *s = make_string(\"@eval\", 5);\n\n\t\t(void) assoc_remove(func_table, s);\n\t\tunref(s);\n\t}\n\n\tfree_srcfile(the_source);\n\n\treturn false;\n}"
}