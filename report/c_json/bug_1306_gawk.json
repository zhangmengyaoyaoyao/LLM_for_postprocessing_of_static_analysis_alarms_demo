{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "awkgram.y",
    "message": "Offset added: 33 (⇐ 1 + 32) Size: [0, +oo] by call to `bcalloc`.",
    "warning_function_name": "snode",
    "warning_line": "expr = list_create(instruction(Op_push_i));",
    "warning_context": "static INSTRUCTION *\nsnode(INSTRUCTION *subn, INSTRUCTION *r)\n{\n\tINSTRUCTION *arg;\n\tINSTRUCTION *ip;\n\tNODE *n;\n\tint nexp = 0;\n\tint args_allowed;\n\tint idx = r->builtin_idx;\n\n\tif (subn != NULL) {\n\t\tINSTRUCTION *tp;\n\t\tfor (tp = subn->nexti; tp; tp = tp->nexti) {\n\t\t\ttp = tp->lasti;\n\t\t\tnexp++;\n\t\t}\n\t\tassert(nexp > 0);\n\t}\t\t\n\n\t/* check against how many args. are allowed for this builtin */\n\targs_allowed = tokentab[idx].flags & ARGS;\n\tif (args_allowed && (args_allowed & A(nexp)) == 0) {\n\t\tyyerror(_(\"%d is invalid as number of arguments for %s\"),\n\t\t\t\tnexp, tokentab[idx].operator);\n\t\treturn NULL;\n\t}\n\n\t/* special processing for sub, gsub and gensub */\n\n\tif (tokentab[idx].value == Op_sub_builtin) {\n\t\tconst char *operator = tokentab[idx].operator;\n\n\t\tr->sub_flags = 0;\n\n\t\targ = subn->nexti;\t\t/* first arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (strcmp(operator, \"gensub\") != 0) {\n\t\t\t/* sub and gsub */\n\n\t\t\tif (strcmp(operator, \"gsub\") == 0)\n\t\t\t\tr->sub_flags |= GSUB;\n\n\t\t\targ = arg->lasti->nexti;\t/* 2nd arg list */\n\t\t\tif (nexp == 2) {\n\t\t\t\tINSTRUCTION *expr;\n\n\t\t\t\texpr = list_create(instruction(Op_push_i));\n\t\t\t\texpr->nexti->memory = make_number(0.0);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(expr, instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push_i) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"%s: string literal as last arg of substitute has no effect\"),\n\t\t\t\t\t\toperator);\n\t\t\t\tr->sub_flags |=\tLITERAL;\n\t\t\t} else {\n\t\t\t\tif (make_assignable(ip) == NULL)\n\t\t\t\t\tyyerror(_(\"%s third parameter is not a changeable object\"),\n\t\t\t\t\t\toperator);\n\t\t\t\telse\n\t\t\t\t\tip->do_reference = true;\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\tip = subn->lasti;\n\n\t\t\t(void) list_append(subn, r);\n\n\t\t\t/* add after_assign code */\n\t\t\tif (ip->opcode == Op_push_lhs && ip->memory->type == Node_var && ip->memory->var_assign) {\n\t\t\t\t(void) list_append(subn, instruction(Op_var_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->assign_var = ip->memory->var_assign;\n\t\t\t} else if (ip->opcode == Op_field_spec_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_field_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->field_assign = (Func_ptr) 0;\n\t\t\t\tip->target_assign = subn->lasti;\n\t\t\t} else if (ip->opcode == Op_subscript_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_subscript_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t}\n\n\t\t\treturn subn;\t\n\n\t\t} else {\n\t\t\t/* gensub */\n\n\t\t\tr->sub_flags |= GENSUB;\n\t\t\tif (nexp == 3) {\n\t\t\t\tip = instruction(Op_push_i);\n\t\t\t\tip->memory = make_number(0.0);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(list_create(ip), instruction(Op_field_spec)));\n\t\t\t}\n\n"
}