{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [-34359738348, +oo] (⇐ [-34359738348, 34359738371] + [0, +oo]) Size: [528, 34359738358] by call to `_bfd_elf_strtab_add`.",
    "Code_line": "    (unsigned int) _bfd_elf_strtab_add (shstrtab, \".strtab\", FALSE);",
    "Code_function": "prep_headers (bfd *abfd)\n{\n  Elf_Internal_Ehdr *i_ehdrp;\t/* Elf file header, internal form.  */\n  struct elf_strtab_hash *shstrtab;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n\n  i_ehdrp = elf_elfheader (abfd);\n\n  shstrtab = _bfd_elf_strtab_init ();\n  if (shstrtab == NULL)\n    return FALSE;\n\n  elf_shstrtab (abfd) = shstrtab;\n\n  i_ehdrp->e_ident[EI_MAG0] = ELFMAG0;\n  i_ehdrp->e_ident[EI_MAG1] = ELFMAG1;\n  i_ehdrp->e_ident[EI_MAG2] = ELFMAG2;\n  i_ehdrp->e_ident[EI_MAG3] = ELFMAG3;\n\n  i_ehdrp->e_ident[EI_CLASS] = bed->s->elfclass;\n  i_ehdrp->e_ident[EI_DATA] =\n    bfd_big_endian (abfd) ? ELFDATA2MSB : ELFDATA2LSB;\n  i_ehdrp->e_ident[EI_VERSION] = bed->s->ev_current;\n\n  if ((abfd->flags & DYNAMIC) != 0)\n    i_ehdrp->e_type = ET_DYN;\n  else if ((abfd->flags & EXEC_P) != 0)\n    i_ehdrp->e_type = ET_EXEC;\n  else if (bfd_get_format (abfd) == bfd_core)\n    i_ehdrp->e_type = ET_CORE;\n  else\n    i_ehdrp->e_type = ET_REL;\n\n  switch (bfd_get_arch (abfd))\n    {\n    case bfd_arch_unknown:\n      i_ehdrp->e_machine = EM_NONE;\n      break;\n\n      /* There used to be a long list of cases here, each one setting\n\t e_machine to the same EM_* macro #defined as ELF_MACHINE_CODE\n\t in the corresponding bfd definition.  To avoid duplication,\n\t the switch was removed.  Machines that need special handling\n\t can generally do it in elf_backend_final_write_processing(),\n\t unless they need the information earlier than the final write.\n\t Such need can generally be supplied by replacing the tests for\n\t e_machine with the conditions used to determine it.  */\n    default:\n      i_ehdrp->e_machine = bed->elf_machine_code;\n    }\n\n  i_ehdrp->e_version = bed->s->ev_current;\n  i_ehdrp->e_ehsize = bed->s->sizeof_ehdr;\n\n  /* No program header, for now.  */\n  i_ehdrp->e_phoff = 0;\n  i_ehdrp->e_phentsize = 0;\n  i_ehdrp->e_phnum = 0;\n\n  /* Each bfd section is section header entry.  */\n  i_ehdrp->e_entry = bfd_get_start_address (abfd);\n  i_ehdrp->e_shentsize = bed->s->sizeof_shdr;\n\n  /* If we're building an executable, we'll need a program header table.  */\n  if (abfd->flags & EXEC_P)\n    /* It all happens later.  */\n    ;\n  else\n    {\n      i_ehdrp->e_phentsize = 0;\n      i_ehdrp->e_phoff = 0;\n    }\n\n  elf_tdata (abfd)->symtab_hdr.sh_name =\n    (unsigned int) _bfd_elf_strtab_add (shstrtab, \".symtab\", FALSE);\n  elf_tdata (abfd)->strtab_hdr.sh_name =\n    (unsigned int) _bfd_elf_strtab_add (shstrtab, \".strtab\", FALSE);\n  elf_tdata (abfd)->shstrtab_hdr.sh_name =\n    (unsigned int) _bfd_elf_strtab_add (shstrtab, \".shstrtab\", FALSE);\n  if (elf_tdata (abfd)->symtab_hdr.sh_name == (unsigned int) -1\n      || elf_tdata (abfd)->strtab_hdr.sh_name == (unsigned int) -1\n      || elf_tdata (abfd)->shstrtab_hdr.sh_name == (unsigned int) -1)\n    return FALSE;\n\n  return TRUE;\n}"
}