{
    "Project": "sed",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "  sub->replacement = root.next;",
    "Code_function": "setup_replacement(sub, text, length)\n     struct subst *sub;\n     const char *text;\n     size_t length;\n{\n  char *base;\n  char *p;\n  char *text_end;\n  enum replacement_types repl_type = REPL_ASIS, save_type = REPL_ASIS;\n  struct replacement root;\n  struct replacement *tail;\n\n  sub->max_id = 0;\n  base = MEMDUP(text, length, char);\n  length = normalize_text(base, length, TEXT_REPLACEMENT);\n\n  text_end = base + length;\n  tail = &root;\n\n  for (p=base; p<text_end; ++p)\n    {\n      if (*p == '\\\\')\n\t{\n\t  /* Preceding the backslash may be some literal text: */\n\t  tail = tail->next =\n\t    new_replacement(base, CAST(size_t)(p - base), repl_type);\n\n\t  repl_type = save_type;\n\n\t  /* Skip the backslash and look for a numeric back-reference,\n\t     or a case-munging escape if not in POSIX mode: */\n\t  ++p;\n\t  if (p == text_end)\n\t    ++tail->prefix_length;\n\n\t  else if (posixicity == POSIXLY_BASIC && !ISDIGIT (*p))\n\t    {\n\t      p[-1] = *p;\n\t      ++tail->prefix_length;\n\t    }\n\n\t  else\n\t    switch (*p)\n\t      {\n\t      case '0': case '1': case '2': case '3': case '4':\n\t      case '5': case '6': case '7': case '8': case '9':\n\t\ttail->subst_id = *p - '0';\n\t\tif (sub->max_id < tail->subst_id)\n\t\t  sub->max_id = tail->subst_id;\n\t\tbreak;\n\n\t      case 'L':\n\t\trepl_type = REPL_LOWERCASE;\n\t\tsave_type = REPL_LOWERCASE;\n\t\tbreak;\n\n\t      case 'U':\n\t\trepl_type = REPL_UPPERCASE;\n\t\tsave_type = REPL_UPPERCASE;\n\t\tbreak;\n\n\t      case 'E':\n\t\trepl_type = REPL_ASIS;\n\t\tsave_type = REPL_ASIS;\n\t\tbreak;\n\n\t      case 'l':\n\t\tsave_type = repl_type;\n\t\trepl_type |= REPL_LOWERCASE_FIRST;\n\t\tbreak;\n\n\t      case 'u':\n\t\tsave_type = repl_type;\n\t\trepl_type |= REPL_UPPERCASE_FIRST;\n\t\tbreak;\n\n\t      default:\n\t\tp[-1] = *p;\n\t\t++tail->prefix_length;\n\t      }\n\n\t  base = p + 1;\n\t}\n      else if (*p == '&')\n\t{\n\t  /* Preceding the ampersand may be some literal text: */\n\t  tail = tail->next =\n\t    new_replacement(base, CAST(size_t)(p - base), repl_type);\n\n\t  repl_type = save_type;\n\t  tail->subst_id = 0;\n\t  base = p + 1;\n\t}\n  }\n  /* There may be some trailing literal text: */\n  if (base < text_end)\n    tail = tail->next =\n      new_replacement(base, CAST(size_t)(text_end - base), repl_type);\n\n  tail->next = NULL;\n  sub->replacement = root.next;\n}"
}