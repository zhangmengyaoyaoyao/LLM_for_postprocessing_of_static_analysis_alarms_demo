{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "      rstat = _bfd_relocate_contents (howto, output_bfd,",
    "Code_function": "_bfd_coff_reloc_link_order (bfd *output_bfd,\n\t\t\t    struct coff_final_link_info *flaginfo,\n\t\t\t    asection *output_section,\n\t\t\t    struct bfd_link_order *link_order)\n{\n  reloc_howto_type *howto;\n  struct internal_reloc *irel;\n  struct coff_link_hash_entry **rel_hash_ptr;\n\n  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);\n  if (howto == NULL)\n    {\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  if (link_order->u.reloc.p->addend != 0)\n    {\n      bfd_size_type size;\n      bfd_byte *buf;\n      bfd_reloc_status_type rstat;\n      bfd_boolean ok;\n      file_ptr loc;\n\n      size = bfd_get_reloc_size (howto);\n      buf = (bfd_byte *) bfd_zmalloc (size);\n      if (buf == NULL && size != 0)\n\treturn FALSE;\n\n      rstat = _bfd_relocate_contents (howto, output_bfd,\n\t\t\t\t      (bfd_vma) link_order->u.reloc.p->addend,\\\n\t\t\t\t      buf);\n      switch (rstat)\n\t{\n\tcase bfd_reloc_ok:\n\t  break;\n\tdefault:\n\tcase bfd_reloc_outofrange:\n\t  abort ();\n\tcase bfd_reloc_overflow:\n\t  if (! ((*flaginfo->info->callbacks->reloc_overflow)\n\t\t (flaginfo->info, NULL,\n\t\t  (link_order->type == bfd_section_reloc_link_order\n\t\t   ? bfd_section_name (output_bfd,\n\t\t\t\t       link_order->u.reloc.p->u.section)\n\t\t   : link_order->u.reloc.p->u.name),\n\t\t  howto->name, link_order->u.reloc.p->addend,\n\t\t  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))\n\t    {\n\t      free (buf);\n\t      return FALSE;\n\t    }\n\t  break;\n\t}\n      loc = link_order->offset * bfd_octets_per_byte (output_bfd);\n      ok = bfd_set_section_contents (output_bfd, output_section, buf,\n                                     loc, size);\n      free (buf);\n      if (! ok)\n\treturn FALSE;\n    }\n\n  /* Store the reloc information in the right place.  It will get\n     swapped and written out at the end of the final_link routine.  */\n  irel = (flaginfo->section_info[output_section->target_index].relocs\n\t  + output_section->reloc_count);\n  rel_hash_ptr = (flaginfo->section_info[output_section->target_index].rel_hashes\n\t\t  + output_section->reloc_count);\n\n  memset (irel, 0, sizeof (struct internal_reloc));\n  *rel_hash_ptr = NULL;\n\n  irel->r_vaddr = output_section->vma + link_order->offset;\n\n  if (link_order->type == bfd_section_reloc_link_order)\n    {\n      /* We need to somehow locate a symbol in the right section.  The\n         symbol must either have a value of zero, or we must adjust\n         the addend by the value of the symbol.  FIXME: Write this\n         when we need it.  The old linker couldn't handle this anyhow.  */\n      abort ();\n      *rel_hash_ptr = NULL;\n      irel->r_symndx = 0;\n    }\n  else\n    {\n      struct coff_link_hash_entry *h;\n\n      h = ((struct coff_link_hash_entry *)\n\t   bfd_wrapped_link_hash_lookup (output_bfd, flaginfo->info,\n\t\t\t\t\t link_order->u.reloc.p->u.name,\n\t\t\t\t\t FALSE, FALSE, TRUE));\n      if (h != NULL)\n\t{\n\t  if (h->indx >= 0)\n\t    irel->r_symndx = h->indx;\n\t  else\n\t    {\n\t      /* Set the index to -2 to force this symbol to get\n\t\t written out.  */\n\t      h->indx = -2;\n\t      *rel_hash_ptr = h;\n\t      irel->r_symndx = 0;\n\t    }\n\t}\n      else\n\t{\n\t  if (! ((*flaginfo->info->callbacks->unattached_reloc)\n\t\t (flaginfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,\n\t\t  (asection *) NULL, (bfd_vma) 0)))\n\t    return FALSE;\n\t  irel->r_symndx = 0;\n\t}\n    }\n\n  /* FIXME: Is this always right?  */\n  irel->r_type = howto->type;\n\n  /* r_size is only used on the RS/6000, which needs its own linker\n     routines anyhow.  r_extern is only used for ECOFF.  */\n\n  /* FIXME: What is the right value for r_offset?  Is zero OK?  */\n  ++output_section->reloc_count;\n\n  return TRUE;\n}"
}