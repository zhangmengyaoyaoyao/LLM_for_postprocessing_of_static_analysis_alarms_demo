{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "libiberty/cplus-dem.c",
    "message": "Offset: [max(1, `work->ntypes`), +oo] Size: [1, +oo] by call to `do_arg`.",
    "warning_function_name": "demangle_args",
    "warning_line": "if (!do_arg (work, &tem, &arg))",
    "warning_context": "static int\ndemangle_args (struct work_stuff *work, const char **mangled,\n               string *declp)\n{\n  string arg;\n  int need_comma = 0;\n  int r;\n  int t;\n  const char *tem;\n  char temptype;\n\n  if (PRINT_ARG_TYPES)\n    {\n      string_append (declp, \"(\");\n      if (**mangled == '\\0')\n\t{\n\t  string_append (declp, \"void\");\n\t}\n    }\n\n  while ((**mangled != '_' && **mangled != '\\0' && **mangled != 'e')\n\t || work->nrepeats > 0)\n    {\n      if ((**mangled == 'N') || (**mangled == 'T'))\n\t{\n\t  temptype = *(*mangled)++;\n\n\t  if (temptype == 'N')\n\t    {\n\t      if (!get_count (mangled, &r))\n\t\t{\n\t\t  return (0);\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      r = 1;\n\t    }\n          if ((HP_DEMANGLING || ARM_DEMANGLING || EDG_DEMANGLING) && work -> ntypes >= 10)\n            {\n              /* If we have 10 or more types we might have more than a 1 digit\n                 index so we'll have to consume the whole count here. This\n                 will lose if the next thing is a type name preceded by a\n                 count but it's impossible to demangle that case properly\n                 anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n                 Pc, ...)\"  or \"(..., type12, char *, ...)\" */\n              if ((t = consume_count(mangled)) <= 0)\n                {\n                  return (0);\n                }\n            }\n          else\n\t    {\n\t      if (!get_count (mangled, &t))\n\t    \t{\n\t          return (0);\n\t    \t}\n\t    }\n\t  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n\t    {\n\t      t--;\n\t    }\n\t  /* Validate the type index.  Protect against illegal indices from\n\t     malformed type strings.  */\n\t  if ((t < 0) || (t >= work -> ntypes))\n\t    {\n\t      return (0);\n\t    }\n\t  while (work->nrepeats > 0 || --r >= 0)\n\t    {\n\t      tem = work -> typevec[t];\n\t      if (need_comma && PRINT_ARG_TYPES)\n\t\t{\n\t\t  string_append (declp, \", \");\n\t\t}\n\t      if (!do_arg (work, &tem, &arg))\n\t\t{\n\t\t  return (0);\n\t\t}\n\t      if (PRINT_ARG_TYPES)\n\t\t{\n\t\t  string_appends (declp, &arg);\n\t\t}\n\t      string_delete (&arg);\n\t      need_comma = 1;\n\t    }\n\t}\n      else\n\t{\n\t  if (need_comma && PRINT_ARG_TYPES)\n\t    string_append (declp, \", \");\n\t  if (!do_arg (work, mangled, &arg))\n\t    return (0);\n\t  if (PRINT_ARG_TYPES)\n\t    string_appends (declp, &arg);\n\t  string_delete (&arg);\n\t  need_comma = 1;\n\t}\n    }\n\n  if (**mangled == 'e')\n"
}