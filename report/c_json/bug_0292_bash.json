{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "extract_dollar_brace_string",
    "warning_line": "ADVANCE_CHAR (string, slen, i);",
    "warning_context": "\n  i = *sindex;\n  while (c = string[i])\n    {\n      if (pass_character)\n\t{\n\t  pass_character = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n\n      /* CTLESCs and backslashes quote the next character. */\n      if (c == CTLESC || c == '\\\\')\n\t{\n\t  pass_character++;\n\t  i++;\n\t  continue;\n\t}\n\n      if (string[i] == '$' && string[i+1] == LBRACE)\n\t{\n\t  nesting_level++;\n\t  i += 2;\n\t  continue;\n\t}\n\n      if (c == RBRACE)\n\t{\n\t  nesting_level--;\n\t  if (nesting_level == 0)\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Pass the contents of old-style command substitutions through\n\t verbatim. */\n      if (c == '`')\n\t{\n\t  si = i + 1;\n\t  t = string_extract (string, &si, \"`\", flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* Pass the contents of new-style command substitutions and\n\t arithmetic substitutions through verbatim. */\n      if (string[i] == '$' && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  t = extract_command_subst (string, &si, flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* Pass the contents of double-quoted strings through verbatim. */\n      if (c == '\"')\n\t{\n\t  si = i + 1;\n\t  i = skip_double_quoted (string, slen, si);\n\t  /* skip_XXX_quoted leaves index one past close quote */\n\t  continue;\n\t}\n\n      if (c == '\\'')\n\t{\n/*itrace(\"extract_dollar_brace_string: c == single quote flags = %d quoted = %d dolbrace_state = %d\", flags, quoted, dolbrace_state);*/\n\t  if (posixly_correct && shell_compatibility_level > 42 && dolbrace_state != DOLBRACE_QUOTE && (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)))\n\t    ADVANCE_CHAR (string, slen, i);\n\t  else\n\t    {\n\t      si = i + 1;\n\t      i = skip_single_quoted (string, slen, si);\n\t    }\n\n          continue;\n\t}\n\n      /* move past this character, which was not special. */\n      ADVANCE_CHAR (string, slen, i);\n\n      /* This logic must agree with parse.y:parse_matched_pair, since they\n\t share the same defines. */\n      if (dolbrace_state == DOLBRACE_PARAM && c == '%' && (i - *sindex) > 1)\n\tdolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '#' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '/' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE2;\t/* XXX */\n      else if (dolbrace_state == DOLBRACE_PARAM && c == '^' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && c == ',' && (i - *sindex) > 1)\n        dolbrace_state = DOLBRACE_QUOTE;\n      else if (dolbrace_state == DOLBRACE_PARAM && strchr (\"#%^,~:-=?+/\", c) != 0)\n\tdolbrace_state = DOLBRACE_OP;\n      else if (dolbrace_state == DOLBRACE_OP && strchr (\"#%^,~:-=?+/\", c) == 0)\n\tdolbrace_state = DOLBRACE_WORD;\n    }\n\n  if (c == 0 && nesting_level)\n    {\n"
}