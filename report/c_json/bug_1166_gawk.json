{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "extension/filefuncs.c",
    "message": "pointer `pathvector` last assigned on line 830 could be null and is dereferenced by call to `memset()` at line 831, column 2.",
    "warning_function_name": "do_fts",
    "warning_line": "memset(pathvector, 0, count * sizeof(char *));",
    "warning_context": "static awk_value_t *\ndo_fts(int nargs, awk_value_t *result)\n{\n\tawk_value_t pathlist, flagval, dest;\n\tawk_flat_array_t *path_array = NULL;\n\tchar **pathvector = NULL;\n\tFTS *heirarchy;\n\tint flags;\n\tsize_t i, count;\n\tint ret = -1;\n\tstatic const int mask = (\n\t\t  FTS_COMFOLLOW | FTS_LOGICAL | FTS_NOCHDIR | FTS_PHYSICAL\n\t\t| FTS_SEEDOT | FTS_XDEV);\n\n\tassert(result != NULL);\n\tfts_errors = 0;\t\t/* ensure a fresh start */\n\n\tif (do_lint && nargs != 3)\n\t\tlintwarn(ext_id, _(\"fts: called with incorrect number of arguments, expecting 3\"));\n\n\tif (! get_argument(0, AWK_ARRAY, & pathlist)) {\n\t\twarning(ext_id, _(\"fts: bad first parameter\"));\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(1, AWK_NUMBER, & flagval)) {\n\t\twarning(ext_id, _(\"fts: bad second parameter\"));\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\n\tif (! get_argument(2, AWK_ARRAY, & dest)) {\n\t\twarning(ext_id, _(\"fts: bad third parameter\"));\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\n\t/* flatten pathlist */\n\tif (! flatten_array(pathlist.array_cookie, & path_array)) {\n\t\twarning(ext_id, _(\"fts: could not flatten array\\n\"));\n\t\tgoto out;\n\t}\n\n\t/* check the flags first, before the array flattening */\n\n\t/* get flags */\n\tflags = flagval.num_value;\n\n\t/* enforce physical or logical but not both, and not no_stat */\n\tif ((flags & (FTS_PHYSICAL|FTS_LOGICAL)) == 0\n\t    || (flags & (FTS_PHYSICAL|FTS_LOGICAL)) == (FTS_PHYSICAL|FTS_LOGICAL)) {\n\t\tupdate_ERRNO_int(EINVAL);\n\t\tgoto out;\n\t}\n\tif ((flags & FTS_NOSTAT) != 0) {\n\t\tflags &= ~FTS_NOSTAT;\n\t\tif (do_lint)\n\t\t\tlintwarn(ext_id, _(\"fts: ignoring sneaky FTS_NOSTAT flag. nyah, nyah, nyah.\"));\n\t}\n\tflags &= mask;\t/* turn off anything else */\n\n\t/* make pathvector */\n\tcount = path_array->count + 1;\n\temalloc(pathvector, char **, count * sizeof(char *), \"do_fts\");\n\tmemset(pathvector, 0, count * sizeof(char *));\n\n\t/* fill it in */\n\tcount--;\t/* ignore final NULL at end of vector */\n\tfor (i = 0; i < count; i++)\n\t\tpathvector[i] = path_array->elements[i].value.str_value.str;\n\n\n\t/* clear dest array */\n\tif (! clear_array(dest.array_cookie)) {\n\t\twarning(ext_id, _(\"fts: clear_array() failed\\n\"));\n\t\tgoto out;\n\t}\n\n\t/* let's do it! */\n\tif ((heirarchy = fts_open(pathvector, flags, NULL)) != NULL) {\n\t\tprocess(heirarchy, dest.array_cookie, (flags & FTS_SEEDOT) != 0);\n\t\tfts_close(heirarchy);\n\n\t\tif (fts_errors == 0)\n\t\t\tret = 0;\n\t} else\n\t\tupdate_ERRNO_int(errno);\n\nout:\n\tif (pathvector != NULL)\n\t\tgawk_free(pathvector);\n\tif (path_array != NULL)\n\t\t(void) release_flattened_array(pathlist.array_cookie, path_array);\n\n\treturn make_number(ret, result);\n}\n"
}