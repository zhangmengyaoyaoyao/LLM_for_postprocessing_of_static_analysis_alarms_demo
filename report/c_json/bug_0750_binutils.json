{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "\t      memcpy (fragP->fr_literal + fragP->fr_fix + padding,",
    "Code_function": "i386_align_code (fragS *fragP, int count)\n{\n  /* Various efficient no-op patterns for aligning code labels.\n     Note: Don't try to assemble the instructions in the comments.\n     0L and 0w are not legal.  */\n  static const char f32_1[] =\n    {0x90};\t\t\t\t\t/* nop\t\t\t*/\n  static const char f32_2[] =\n    {0x66,0x90};\t\t\t\t/* xchg %ax,%ax */\n  static const char f32_3[] =\n    {0x8d,0x76,0x00};\t\t\t\t/* leal 0(%esi),%esi\t*/\n  static const char f32_4[] =\n    {0x8d,0x74,0x26,0x00};\t\t\t/* leal 0(%esi,1),%esi\t*/\n  static const char f32_5[] =\n    {0x90,\t\t\t\t\t/* nop\t\t\t*/\n     0x8d,0x74,0x26,0x00};\t\t\t/* leal 0(%esi,1),%esi\t*/\n  static const char f32_6[] =\n    {0x8d,0xb6,0x00,0x00,0x00,0x00};\t\t/* leal 0L(%esi),%esi\t*/\n  static const char f32_7[] =\n    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};\t/* leal 0L(%esi,1),%esi */\n  static const char f32_8[] =\n    {0x90,\t\t\t\t\t/* nop\t\t\t*/\n     0x8d,0xb4,0x26,0x00,0x00,0x00,0x00};\t/* leal 0L(%esi,1),%esi */\n  static const char f32_9[] =\n    {0x89,0xf6,\t\t\t\t\t/* movl %esi,%esi\t*/\n     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};\t/* leal 0L(%edi,1),%edi */\n  static const char f32_10[] =\n    {0x8d,0x76,0x00,\t\t\t\t/* leal 0(%esi),%esi\t*/\n     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};\t/* leal 0L(%edi,1),%edi */\n  static const char f32_11[] =\n    {0x8d,0x74,0x26,0x00,\t\t\t/* leal 0(%esi,1),%esi\t*/\n     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};\t/* leal 0L(%edi,1),%edi */\n  static const char f32_12[] =\n    {0x8d,0xb6,0x00,0x00,0x00,0x00,\t\t/* leal 0L(%esi),%esi\t*/\n     0x8d,0xbf,0x00,0x00,0x00,0x00};\t\t/* leal 0L(%edi),%edi\t*/\n  static const char f32_13[] =\n    {0x8d,0xb6,0x00,0x00,0x00,0x00,\t\t/* leal 0L(%esi),%esi\t*/\n     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};\t/* leal 0L(%edi,1),%edi */\n  static const char f32_14[] =\n    {0x8d,0xb4,0x26,0x00,0x00,0x00,0x00,\t/* leal 0L(%esi,1),%esi */\n     0x8d,0xbc,0x27,0x00,0x00,0x00,0x00};\t/* leal 0L(%edi,1),%edi */\n  static const char f16_3[] =\n    {0x8d,0x74,0x00};\t\t\t\t/* lea 0(%esi),%esi\t*/\n  static const char f16_4[] =\n    {0x8d,0xb4,0x00,0x00};\t\t\t/* lea 0w(%si),%si\t*/\n  static const char f16_5[] =\n    {0x90,\t\t\t\t\t/* nop\t\t\t*/\n     0x8d,0xb4,0x00,0x00};\t\t\t/* lea 0w(%si),%si\t*/\n  static const char f16_6[] =\n    {0x89,0xf6,\t\t\t\t\t/* mov %si,%si\t\t*/\n     0x8d,0xbd,0x00,0x00};\t\t\t/* lea 0w(%di),%di\t*/\n  static const char f16_7[] =\n    {0x8d,0x74,0x00,\t\t\t\t/* lea 0(%si),%si\t*/\n     0x8d,0xbd,0x00,0x00};\t\t\t/* lea 0w(%di),%di\t*/\n  static const char f16_8[] =\n    {0x8d,0xb4,0x00,0x00,\t\t\t/* lea 0w(%si),%si\t*/\n     0x8d,0xbd,0x00,0x00};\t\t\t/* lea 0w(%di),%di\t*/\n  static const char jump_31[] =\n    {0xeb,0x1d,0x90,0x90,0x90,0x90,0x90,\t/* jmp .+31; lotsa nops\t*/\n     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,\n     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,\n     0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90};\n  static const char *const f32_patt[] = {\n    f32_1, f32_2, f32_3, f32_4, f32_5, f32_6, f32_7, f32_8,\n    f32_9, f32_10, f32_11, f32_12, f32_13, f32_14\n  };\n  static const char *const f16_patt[] = {\n    f32_1, f32_2, f16_3, f16_4, f16_5, f16_6, f16_7, f16_8\n  };\n  /* nopl (%[re]ax) */\n  static const char alt_3[] =\n    {0x0f,0x1f,0x00};\n  /* nopl 0(%[re]ax) */\n  static const char alt_4[] =\n    {0x0f,0x1f,0x40,0x00};\n  /* nopl 0(%[re]ax,%[re]ax,1) */\n  static const char alt_5[] =\n    {0x0f,0x1f,0x44,0x00,0x00};\n  /* nopw 0(%[re]ax,%[re]ax,1) */\n  static const char alt_6[] =\n    {0x66,0x0f,0x1f,0x44,0x00,0x00};\n  /* nopl 0L(%[re]ax) */\n  static const char alt_7[] =\n    {0x0f,0x1f,0x80,0x00,0x00,0x00,0x00};\n  /* nopl 0L(%[re]ax,%[re]ax,1) */\n  static const char alt_8[] =\n    {0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};\n  /* nopw 0L(%[re]ax,%[re]ax,1) */\n  static const char alt_9[] =\n    {0x66,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};\n  /* nopw %cs:0L(%[re]ax,%[re]ax,1) */\n  static const char alt_10[] =\n    {0x66,0x2e,0x0f,0x1f,0x84,0x00,0x00,0x00,0x00,0x00};\n  static const char *const alt_patt[] = {\n    f32_1, f32_2, alt_3, alt_4, alt_5, alt_6, alt_7, alt_8,\n    alt_9, alt_10\n  };\n\n  /* Only align for at least a positive non-zero boundary. */\n  if (count <= 0 || count > MAX_MEM_FOR_RS_ALIGN_CODE)\n    return;\n\n  /* We need to decide which NOP sequence to use for 32bit and\n     64bit. When -mtune= is used:\n\n     1. For PROCESSOR_I386, PROCESSOR_I486, PROCESSOR_PENTIUM and\n     PROCESSOR_GENERIC32, f32_patt will be used.\n     2. For the rest, alt_patt will be used.\n\n     When -mtune= isn't used, alt_patt will be used if\n     cpu_arch_isa_flags has CpuNop.  Otherwise, f32_patt will\n     be used.\n\n     When -march= or .arch is used, we can't use anything beyond\n     cpu_arch_isa_flags.   */\n\n  if (flag_code == CODE_16BIT)\n    {\n      if (count > 8)\n\t{\n\t  memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t  jump_31, count);\n\t  /* Adjust jump offset.  */\n\t  fragP->fr_literal[fragP->fr_fix + 1] = count - 2;\n\t}\n      else\n\tmemcpy (fragP->fr_literal + fragP->fr_fix,\n\t\tf16_patt[count - 1], count);\n    }\n  else\n    {\n      const char *const *patt = NULL;\n\n      if (fragP->tc_frag_data.isa == PROCESSOR_UNKNOWN)\n\t{\n\t  /* PROCESSOR_UNKNOWN means that all ISAs may be used.  */\n\t  switch (cpu_arch_tune)\n\t    {\n\t    case PROCESSOR_UNKNOWN:\n\t      /* We use cpu_arch_isa_flags to check if we SHOULD\n\t\t optimize with nops.  */\n\t      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)\n\t\tpatt = alt_patt;\n\t      else\n\t\tpatt = f32_patt;\n\t      break;\n\t    case PROCESSOR_PENTIUM4:\n\t    case PROCESSOR_NOCONA:\n\t    case PROCESSOR_CORE:\n\t    case PROCESSOR_CORE2:\n\t    case PROCESSOR_COREI7:\n\t    case PROCESSOR_L1OM:\n\t    case PROCESSOR_K1OM:\n\t    case PROCESSOR_GENERIC64:\n\t    case PROCESSOR_K6:\n\t    case PROCESSOR_ATHLON:\n\t    case PROCESSOR_K8:\n\t    case PROCESSOR_AMDFAM10:\n\t    case PROCESSOR_BD:\n\t    case PROCESSOR_BT:\n\t      patt = alt_patt;\n\t      break;\n\t    case PROCESSOR_I386:\n\t    case PROCESSOR_I486:\n\t    case PROCESSOR_PENTIUM:\n\t    case PROCESSOR_PENTIUMPRO:\n\t    case PROCESSOR_GENERIC32:\n\t      patt = f32_patt;\n\t      break;\n\t    }\n\t}\n      else\n\t{\n\t  switch (fragP->tc_frag_data.tune)\n\t    {\n\t    case PROCESSOR_UNKNOWN:\n\t      /* When cpu_arch_isa is set, cpu_arch_tune shouldn't be\n\t\t PROCESSOR_UNKNOWN.  */\n\t      abort ();\n\t      break;\n\n\t    case PROCESSOR_I386:\n\t    case PROCESSOR_I486:\n\t    case PROCESSOR_PENTIUM:\n\t    case PROCESSOR_K6:\n\t    case PROCESSOR_ATHLON:\n\t    case PROCESSOR_K8:\n\t    case PROCESSOR_AMDFAM10:\n\t    case PROCESSOR_BD:\n\t    case PROCESSOR_BT:\n\t    case PROCESSOR_GENERIC32:\n\t      /* We use cpu_arch_isa_flags to check if we CAN optimize\n\t\t with nops.  */\n\t      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)\n\t\tpatt = alt_patt;\n\t      else\n\t\tpatt = f32_patt;\n\t      break;\n\t    case PROCESSOR_PENTIUMPRO:\n\t    case PROCESSOR_PENTIUM4:\n\t    case PROCESSOR_NOCONA:\n\t    case PROCESSOR_CORE:\n\t    case PROCESSOR_CORE2:\n\t    case PROCESSOR_COREI7:\n\t    case PROCESSOR_L1OM:\n\t    case PROCESSOR_K1OM:\n\t      if (fragP->tc_frag_data.isa_flags.bitfield.cpunop)\n\t\tpatt = alt_patt;\n\t      else\n\t\tpatt = f32_patt;\n\t      break;\n\t    case PROCESSOR_GENERIC64:\n\t      patt = alt_patt;\n\t      break;\n\t    }\n\t}\n\n      if (patt == f32_patt)\n\t{\n\t  /* If the padding is less than 15 bytes, we use the normal\n\t     ones.  Otherwise, we use a jump instruction and adjust\n\t     its offset.   */\n\t  int limit;\n\n\t  /* For 64bit, the limit is 3 bytes.  */\n\t  if (flag_code == CODE_64BIT\n\t      && fragP->tc_frag_data.isa_flags.bitfield.cpulm)\n\t    limit = 3;\n\t  else\n\t    limit = 15;\n\t  if (count < limit)\n\t    memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t    patt[count - 1], count);\n\t  else\n\t    {\n\t      memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t      jump_31, count);\n\t      /* Adjust jump offset.  */\n\t      fragP->fr_literal[fragP->fr_fix + 1] = count - 2;\n\t    }\n\t}\n      else\n\t{\n\t  /* Maximum length of an instruction is 10 byte.  If the\n\t     padding is greater than 10 bytes and we don't use jump,\n\t     we have to break it into smaller pieces.  */\n\t  int padding = count;\n\t  while (padding > 10)\n\t    {\n\t      padding -= 10;\n\t      memcpy (fragP->fr_literal + fragP->fr_fix + padding,\n\t\t      patt [9], 10);\n\t    }\n\n\t  if (padding)\n\t    memcpy (fragP->fr_literal + fragP->fr_fix,\n\t\t    patt [padding - 1], padding);\n\t}\n    }\n  fragP->fr_var = count;\n}"
}