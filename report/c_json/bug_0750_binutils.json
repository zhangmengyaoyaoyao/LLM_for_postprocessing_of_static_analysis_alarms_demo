{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/dwarf2.c",
    "message": "Offset: [-275, 298] Size: 4064.",
    "warning_function_name": "decode_line_info",
    "warning_line": "lh.standard_opcode_lengths[0] = 1;",
    "warning_context": "      offset_size = 8;\n    }\n\n  if (lh.total_length > stash->dwarf_line_size)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Line info data is bigger (0x%lx) than the section (0x%lx)\"),\n\t (long) lh.total_length, (long) stash->dwarf_line_size);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  line_end = line_ptr + lh.total_length;\n\n  lh.version = read_2_bytes (abfd, line_ptr, line_end);\n  if (lh.version < 2 || lh.version > 4)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Unhandled .debug_line version %d.\"), lh.version);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr += 2;\n\n  if (line_ptr + offset_size + (lh.version >=4 ? 6 : 5) >= line_end)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Ran out of room reading prologue\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  if (offset_size == 4)\n    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);\n  else\n    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);\n  line_ptr += offset_size;\n\n  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (lh.version >= 4)\n    {\n      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n  else\n    lh.maximum_ops_per_insn = 1;\n\n  if (lh.maximum_ops_per_insn == 0)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: Invalid maximum operations per instruction.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_range = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (line_ptr + (lh.opcode_base - 1) >= line_end)\n    {\n      (*_bfd_error_handler) (_(\"Dwarf Error: Ran out of room reading opcodes\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  amt = lh.opcode_base * sizeof (unsigned char);\n  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);\n\n  lh.standard_opcode_lengths[0] = 1;\n\n  for (i = 1; i < lh.opcode_base; ++i)\n    {\n      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n\n  /* Read directory table.  */\n  while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n    {\n      line_ptr += bytes_read;\n\n      if ((table->num_dirs % DIR_ALLOC_CHUNK) == 0)\n\t{\n\t  char **tmp;\n\n\t  amt = table->num_dirs + DIR_ALLOC_CHUNK;\n\t  amt *= sizeof (char *);\n\n\t  tmp = (char **) bfd_realloc (table->dirs, amt);\n\t  if (tmp == NULL)\n"
}