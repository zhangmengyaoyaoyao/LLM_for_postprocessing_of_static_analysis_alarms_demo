{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t  dirs[dir] = (char *) xmalloc (dir_len + 1);",
    "Code_function": "get_filenum (const char *filename, unsigned int num)\n{\n  static unsigned int last_used, last_used_dir_len;\n  const char *file;\n  size_t dir_len;\n  unsigned int i, dir;\n\n  if (num == 0 && last_used)\n    {\n      if (! files[last_used].dir\n\t  && filename_cmp (filename, files[last_used].filename) == 0)\n\treturn last_used;\n      if (files[last_used].dir\n\t  && filename_ncmp (filename, dirs[files[last_used].dir],\n\t\t\t    last_used_dir_len) == 0\n\t  && IS_DIR_SEPARATOR (filename [last_used_dir_len])\n\t  && filename_cmp (filename + last_used_dir_len + 1,\n\t\t\t   files[last_used].filename) == 0)\n\treturn last_used;\n    }\n\n  file = lbasename (filename);\n  /* Don't make empty string from / or A: from A:/ .  */\n#ifdef HAVE_DOS_BASED_FILE_SYSTEM\n  if (file <= filename + 3)\n    file = filename;\n#else\n  if (file == filename + 1)\n    file = filename;\n#endif\n  dir_len = file - filename;\n\n  dir = 0;\n  if (dir_len)\n    {\n#ifndef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR\n      --dir_len;\n#endif\n      for (dir = 1; dir < dirs_in_use; ++dir)\n\tif (filename_ncmp (filename, dirs[dir], dir_len) == 0\n\t    && dirs[dir][dir_len] == '\\0')\n\t  break;\n\n      if (dir >= dirs_in_use)\n\t{\n\t  if (dir >= dirs_allocated)\n\t    {\n\t      dirs_allocated = dir + 32;\n\t      dirs = (char **)\n\t\t     xrealloc (dirs, (dir + 32) * sizeof (const char *));\n\t    }\n\n\t  dirs[dir] = (char *) xmalloc (dir_len + 1);\n\t  memcpy (dirs[dir], filename, dir_len);\n\t  dirs[dir][dir_len] = '\\0';\n\t  dirs_in_use = dir + 1;\n\t}\n    }\n\n  if (num == 0)\n    {\n      for (i = 1; i < files_in_use; ++i)\n\tif (files[i].dir == dir\n\t    && files[i].filename\n\t    && filename_cmp (file, files[i].filename) == 0)\n\t  {\n\t    last_used = i;\n\t    last_used_dir_len = dir_len;\n\t    return i;\n\t  }\n    }\n  else\n    i = num;\n\n  if (i >= files_allocated)\n    {\n      unsigned int old = files_allocated;\n\n      files_allocated = i + 32;\n      files = (struct file_entry *)\n\txrealloc (files, (i + 32) * sizeof (struct file_entry));\n\n      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));\n    }\n\n  files[i].filename = num ? file : xstrdup (file);\n  files[i].dir = dir;\n  if (files_in_use < i + 1)\n    files_in_use = i + 1;\n  last_used = i;\n  last_used_dir_len = dir_len;\n\n  return i;\n}"
}