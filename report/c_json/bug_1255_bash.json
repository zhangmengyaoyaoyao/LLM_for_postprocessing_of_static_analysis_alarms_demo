{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset: [-64, 63] Size: 33 by call to `tgetst1`.",
    "Code_line": "      indirect = tgetst1 (find_capability (termcap_name, \"tc\"), (char **) 0);",
    "Code_function": "tgetent (bp, name)\n     char *bp, *name;\n{\n  register char *termcap_name;\n  register int fd;\n  struct buffer buf;\n  register char *bp1;\n  char *bp2;\n  char *term;\n  int malloc_size = 0;\n  register int c;\n  char *tcenv;\t\t\t/* TERMCAP value, if it contains :tc=.  */\n  char *indirect = NULL;\t/* Terminal type in :tc= in TERMCAP value.  */\n  int filep;\n\n#ifdef INTERNAL_TERMINAL\n  /* For the internal terminal we don't want to read any termcap file,\n     so fake it.  */\n  if (!strcmp (name, \"internal\"))\n    {\n      term = INTERNAL_TERMINAL;\n      if (!bp)\n\t{\n\t  malloc_size = 1 + strlen (term);\n\t  bp = (char *) xmalloc (malloc_size);\n\t}\n      strcpy (bp, term);\n      goto ret;\n    }\n#endif /* INTERNAL_TERMINAL */\n\n  /* For compatibility with programs like `less' that want to\n     put data in the termcap buffer themselves as a fallback.  */\n  if (bp)\n    term_entry = bp;\n\n  termcap_name = getenv (\"TERMCAP\");\n  if (termcap_name && *termcap_name == '\\0')\n    termcap_name = NULL;\n#if 0\n#if defined (MSDOS) && !defined (TEST)\n  if (termcap_name && (*termcap_name == '\\\\'\n\t\t       || *termcap_name == '/'\n\t\t       || termcap_name[1] == ':'))\n    dostounix_filename(termcap_name);\n#endif\n#endif\n\n  filep = termcap_name && valid_filename_p (termcap_name);\n\n  /* If termcap_name is non-null and starts with / (in the un*x case, that is),\n     it is a file name to use instead of /etc/termcap.\n     If it is non-null and does not start with /,\n     it is the entry itself, but only if\n     the name the caller requested matches the TERM variable.  */\n\n  if (termcap_name && !filep && !strcmp (name, getenv (\"TERM\")))\n    {\n      indirect = tgetst1 (find_capability (termcap_name, \"tc\"), (char **) 0);\n      if (!indirect)\n\t{\n\t  if (!bp)\n\t    bp = termcap_name;\n\t  else\n\t    strcpy (bp, termcap_name);\n\t  goto ret;\n\t}\n      else\n\t{\t\t\t/* It has tc=.  Need to read /etc/termcap.  */\n\t  tcenv = termcap_name;\n \t  termcap_name = NULL;\n\t}\n    }\n\n  if (!termcap_name || !filep)\n    termcap_name = TERMCAP_FILE;\n\n  /* Here we know we must search a file and termcap_name has its name.  */\n\n#ifdef MSDOS\n  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);\n#else\n  fd = open (termcap_name, O_RDONLY, 0);\n#endif\n  if (fd < 0)\n    return -1;\n\n  buf.size = BUFSIZE;\n  /* Add 1 to size to ensure room for terminating null.  */\n  buf.beg = (char *) xmalloc (buf.size + 1);\n  term = indirect ? indirect : name;\n\n  if (!bp)\n    {\n      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;\n      bp = (char *) xmalloc (malloc_size);\n    }\n  bp1 = bp;\n\n  if (indirect)\n    /* Copy the data from the environment variable.  */\n    {\n      strcpy (bp, tcenv);\n      bp1 += strlen (tcenv);\n    }\n\n  while (term)\n    {\n      /* Scan the file, reading it via buf, till find start of main entry.  */\n      if (scan_file (term, fd, &buf) == 0)\n\t{\n\t  close (fd);\n\t  free (buf.beg);\n\t  if (malloc_size)\n\t    free (bp);\n\t  return 0;\n\t}\n\n      /* Free old `term' if appropriate.  */\n      if (term != name)\n\tfree (term);\n\n      /* If BP is malloc'd by us, make sure it is big enough.  */\n      if (malloc_size)\n\t{\n\t  malloc_size = bp1 - bp + buf.size;\n\t  termcap_name = (char *) xrealloc (bp, malloc_size);\n\t  bp1 += termcap_name - bp;\n\t  bp = termcap_name;\n\t}\n\n      bp2 = bp1;\n\n      /* Copy the line of the entry from buf into bp.  */\n      termcap_name = buf.ptr;\n      while ((*bp1++ = c = *termcap_name++) && c != '\\n')\n\t/* Drop out any \\ newline sequence.  */\n\tif (c == '\\\\' && *termcap_name == '\\n')\n\t  {\n\t    bp1--;\n\t    termcap_name++;\n\t  }\n      *bp1 = '\\0';\n\n      /* Does this entry refer to another terminal type's entry?\n\t If something is found, copy it into heap and null-terminate it.  */\n      term = tgetst1 (find_capability (bp2, \"tc\"), (char **) 0);\n    }\n\n  close (fd);\n  free (buf.beg);\n\n  if (malloc_size)\n    bp = (char *) xrealloc (bp, bp1 - bp + 1);\n\n ret:\n  term_entry = bp;\n  return 1;\n}"
}