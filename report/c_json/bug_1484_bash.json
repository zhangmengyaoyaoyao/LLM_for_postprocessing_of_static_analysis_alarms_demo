{
    "Project": "bash",
    "Tool": "CSA",
    "Bug Type": "core.uninitialized.Assign",
    "Message": "Assigned value is garbage or undefined",
    "Code_line": "      executing_builtin = old_builtin;",
    "Code_function": "execute_simple_command (simple_command, pipe_in, pipe_out, async, fds_to_close)\n     SIMPLE_COM *simple_command;\n     int pipe_in, pipe_out, async;\n     struct fd_bitmap *fds_to_close;\n{\n  WORD_LIST *words, *lastword;\n  char *command_line, *lastarg, *temp;\n  int first_word_quoted, result, builtin_is_special, already_forked, dofork;\n  pid_t old_last_async_pid;\n  sh_builtin_func_t *builtin;\n  SHELL_VAR *func;\n  volatile int old_builtin, old_command_builtin;\n\n  result = EXECUTION_SUCCESS;\n  special_builtin_failed = builtin_is_special = 0;\n  command_line = (char *)0;\n\n  QUIT;\n\n  /* If we're in a function, update the line number information. */\n  if (variable_context && interactive_shell && sourcelevel == 0)\n    line_number -= function_line_number;\n\n  /* Remember what this command line looks like at invocation. */\n  command_string_index = 0;\n  print_simple_command (simple_command);\n\n#if 0\n  if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, \"trap\") == 0)))\n#else\n  if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)\n#endif\n    {\n      FREE (the_printed_command_except_trap);\n      the_printed_command_except_trap = the_printed_command ? savestring (the_printed_command) : (char *)0;\n    }\n\n  /* Run the debug trap before each simple command, but do it after we\n     update the line number information. */\n  result = run_debug_trap ();\n#if defined (DEBUGGER)\n  /* In debugging mode, if the DEBUG trap returns a non-zero status, we\n     skip the command. */\n  if (debugging_mode && result != EXECUTION_SUCCESS)\n    return (EXECUTION_SUCCESS);\n#endif\n\n  first_word_quoted =\n    simple_command->words ? (simple_command->words->word->flags & W_QUOTED) : 0;\n\n  last_command_subst_pid = NO_PID;\n  old_last_async_pid = last_asynchronous_pid;\n\n  already_forked = dofork = 0;\n\n  /* If we're in a pipeline or run in the background, set DOFORK so we\n     make the child early, before word expansion.  This keeps assignment\n     statements from affecting the parent shell's environment when they\n     should not. */\n  dofork = pipe_in != NO_PIPE || pipe_out != NO_PIPE || async;\n\n  /* Something like `%2 &' should restart job 2 in the background, not cause\n     the shell to fork here. */\n  if (dofork && pipe_in == NO_PIPE && pipe_out == NO_PIPE &&\n\tsimple_command->words && simple_command->words->word &&\n\tsimple_command->words->word->word &&\n\t(simple_command->words->word->word[0] == '%'))\n    dofork = 0;\n\n  if (dofork)\n    {\n      /* Do this now, because execute_disk_command will do it anyway in the\n\t vast majority of cases. */\n      maybe_make_export_env ();\n\n      /* Don't let a DEBUG trap overwrite the command string to be saved with\n\t the process/job associated with this child. */\n      if (make_child (savestring (the_printed_command_except_trap), async) == 0)\n\t{\n\t  already_forked = 1;\n\t  simple_command->flags |= CMD_NO_FORK;\n\n\t  subshell_environment = SUBSHELL_FORK;\n\t  if (pipe_in != NO_PIPE || pipe_out != NO_PIPE)\n\t    subshell_environment |= SUBSHELL_PIPE;\n\t  if (async)\n\t    subshell_environment |= SUBSHELL_ASYNC;\n\n\t  /* We need to do this before piping to handle some really\n\t     pathological cases where one of the pipe file descriptors\n\t     is < 2. */\n\t  if (fds_to_close)\n\t    close_fd_bitmap (fds_to_close);\n\n\t  do_piping (pipe_in, pipe_out);\n\t  pipe_in = pipe_out = NO_PIPE;\n#if defined (COPROCESS_SUPPORT)\n\t  coproc_closeall ();\n#endif\n\n\t  last_asynchronous_pid = old_last_async_pid;\n\n\t  CHECK_SIGTERM;\n\t}\n      else\n\t{\n\t  /* Don't let simple commands that aren't the last command in a\n\t     pipeline change $? for the rest of the pipeline (or at all). */\n\t  if (pipe_out != NO_PIPE)\n\t    result = last_command_exit_value;\n\t  close_pipes (pipe_in, pipe_out);\n#if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)\n\t  /* Close /dev/fd file descriptors in the parent after forking the\n\t     last child in a (possibly one-element) pipeline.  Defer this\n\t     until any running shell function completes. */\n\t  if (pipe_out == NO_PIPE && variable_context == 0)\t/* XXX */\n\t    unlink_fifo_list ();\t\t/* XXX */\n#endif\n\t  command_line = (char *)NULL;      /* don't free this. */\n\t  bind_lastarg ((char *)NULL);\n\t  return (result);\n\t}\n    }\n\n  /* If we are re-running this as the result of executing the `command'\n     builtin, do not expand the command words a second time. */\n  if ((simple_command->flags & CMD_INHIBIT_EXPANSION) == 0)\n    {\n      current_fds_to_close = fds_to_close;\n      fix_assignment_words (simple_command->words);\n      /* Pass the ignore return flag down to command substitutions */\n      if (simple_command->flags & CMD_IGNORE_RETURN)\t/* XXX */\n\tcomsub_ignore_return++;\n      words = expand_words (simple_command->words);\n      if (simple_command->flags & CMD_IGNORE_RETURN)\n\tcomsub_ignore_return--;\n      current_fds_to_close = (struct fd_bitmap *)NULL;\n    }\n  else\n    words = copy_word_list (simple_command->words);\n\n  /* It is possible for WORDS not to have anything left in it.\n     Perhaps all the words consisted of `$foo', and there was\n     no variable `$foo'. */\n  if (words == 0)\n    {\n      this_command_name = 0;\n      result = execute_null_command (simple_command->redirects,\n\t\t\t\t     pipe_in, pipe_out,\n\t\t\t\t     already_forked ? 0 : async);\n      if (already_forked)\n\texit (result);\n      else\n\t{\n\t  bind_lastarg ((char *)NULL);\n\t  set_pipestatus_from_exit (result);\n\t  return (result);\n\t}\n    }\n\n  lastarg = (char *)NULL;\n\n  begin_unwind_frame (\"simple-command\");\n\n  if (echo_command_at_execute)\n    xtrace_print_word_list (words, 1);\n\n  builtin = (sh_builtin_func_t *)NULL;\n  func = (SHELL_VAR *)NULL;\n  if ((simple_command->flags & CMD_NO_FUNCTIONS) == 0)\n    {\n      /* Posix.2 says special builtins are found before functions.  We\n\t don't set builtin_is_special anywhere other than here, because\n\t this path is followed only when the `command' builtin is *not*\n\t being used, and we don't want to exit the shell if a special\n\t builtin executed with `command builtin' fails.  `command' is not\n\t a special builtin. */\n      if (posixly_correct)\n\t{\n\t  builtin = find_special_builtin (words->word->word);\n\t  if (builtin)\n\t    builtin_is_special = 1;\n\t}\n      if (builtin == 0)\n\tfunc = find_function (words->word->word);\n    }\n\n  /* In POSIX mode, assignment errors in the temporary environment cause a\n     non-interactive shell to exit. */\n  if (posixly_correct && builtin_is_special && interactive_shell == 0 && tempenv_assign_error)\n    {\n      last_command_exit_value = EXECUTION_FAILURE;\n      jump_to_top_level (ERREXIT);\n    }\n  tempenv_assign_error = 0;\t/* don't care about this any more */\n\n  add_unwind_protect (dispose_words, words);\n  QUIT;\n\n  /* Bind the last word in this command to \"$_\" after execution. */\n  for (lastword = words; lastword->next; lastword = lastword->next)\n    ;\n  lastarg = lastword->word->word;\n\n#if defined (JOB_CONTROL)\n  /* Is this command a job control related thing? */\n  if (words->word->word[0] == '%' && already_forked == 0)\n    {\n      this_command_name = async ? \"bg\" : \"fg\";\n      last_shell_builtin = this_shell_builtin;\n      this_shell_builtin = builtin_address (this_command_name);\n      result = (*this_shell_builtin) (words);\n      goto return_result;\n    }\n\n  /* One other possibililty.  The user may want to resume an existing job.\n     If they do, find out whether this word is a candidate for a running\n     job. */\n  if (job_control && already_forked == 0 && async == 0 &&\n\t!first_word_quoted &&\n\t!words->next &&\n\twords->word->word[0] &&\n\t!simple_command->redirects &&\n\tpipe_in == NO_PIPE &&\n\tpipe_out == NO_PIPE &&\n\t(temp = get_string_value (\"auto_resume\")))\n    {\n      int job, jflags, started_status;\n\n      jflags = JM_STOPPED|JM_FIRSTMATCH;\n      if (STREQ (temp, \"exact\"))\n\tjflags |= JM_EXACT;\n      else if (STREQ (temp, \"substring\"))\n\tjflags |= JM_SUBSTRING;\n      else\n\tjflags |= JM_PREFIX;\n      job = get_job_by_name (words->word->word, jflags);\n      if (job != NO_JOB)\n\t{\n\t  run_unwind_frame (\"simple-command\");\n\t  this_command_name = \"fg\";\n\t  last_shell_builtin = this_shell_builtin;\n\t  this_shell_builtin = builtin_address (\"fg\");\n\n\t  started_status = start_job (job, 1);\n\t  return ((started_status < 0) ? EXECUTION_FAILURE : started_status);\n\t}\n    }\n#endif /* JOB_CONTROL */\n\nrun_builtin:\n  /* Remember the name of this command globally. */\n  this_command_name = words->word->word;\n\n  QUIT;\n\n  /* This command could be a shell builtin or a user-defined function.\n     We have already found special builtins by this time, so we do not\n     set builtin_is_special.  If this is a function or builtin, and we\n     have pipes, then fork a subshell in here.  Otherwise, just execute\n     the command directly. */\n  if (func == 0 && builtin == 0)\n    builtin = find_shell_builtin (this_command_name);\n\n  last_shell_builtin = this_shell_builtin;\n  this_shell_builtin = builtin;\n\n  if (builtin || func)\n    {\n      if (builtin)\n        {\n\t  old_builtin = executing_builtin;\n\t  old_command_builtin = executing_command_builtin;\n\t  unwind_protect_int (executing_builtin);\t/* modified in execute_builtin */\n\t  unwind_protect_int (executing_command_builtin);\t/* ditto */\n        }\n      if (already_forked)\n\t{\n\t  /* reset_terminating_signals (); */\t/* XXX */\n\t  /* Reset the signal handlers in the child, but don't free the\n\t     trap strings.  Set a flag noting that we have to free the\n\t     trap strings if we run trap to change a signal disposition. */\n\t  reset_signal_handlers ();\n\t  subshell_environment |= SUBSHELL_RESETTRAP;\n\n\t  if (async)\n\t    {\n\t      if ((simple_command->flags & CMD_STDIN_REDIR) &&\n\t\t    pipe_in == NO_PIPE &&\n\t\t    (stdin_redirects (simple_command->redirects) == 0))\n\t\tasync_redirect_stdin ();\n\t      setup_async_signals ();\n\t    }\n\n\t  subshell_level++;\n\t  execute_subshell_builtin_or_function\n\t    (words, simple_command->redirects, builtin, func,\n\t     pipe_in, pipe_out, async, fds_to_close,\n\t     simple_command->flags);\n\t  subshell_level--;\n\t}\n      else\n\t{\n\t  result = execute_builtin_or_function\n\t    (words, builtin, func, simple_command->redirects, fds_to_close,\n\t     simple_command->flags);\n\t  if (builtin)\n\t    {\n\t      if (result > EX_SHERRBASE)\n\t\t{\n\t\t  switch (result)\n\t\t    {\n\t\t    case EX_REDIRFAIL:\n\t\t    case EX_BADASSIGN:\n\t\t    case EX_EXPFAIL:\n\t\t      /* These errors cause non-interactive posix mode shells to exit */\n\t\t      if (posixly_correct && builtin_is_special && interactive_shell == 0)\n\t\t\t{\n\t\t\t  last_command_exit_value = EXECUTION_FAILURE;\n\t\t\t  jump_to_top_level (ERREXIT);\n\t\t\t}\n\t\t    }\n\t\t  result = builtin_status (result);\n\t\t  if (builtin_is_special)\n\t\t    special_builtin_failed = 1;\n\t\t}\n\t      /* In POSIX mode, if there are assignment statements preceding\n\t\t a special builtin, they persist after the builtin\n\t\t completes. */\n\t      if (posixly_correct && builtin_is_special && temporary_env)\n\t\tmerge_temporary_env ();\n\t    }\n\t  else\t\t/* function */\n\t    {\n\t      if (result == EX_USAGE)\n\t\tresult = EX_BADUSAGE;\n\t      else if (result > EX_SHERRBASE)\n\t\tresult = EXECUTION_FAILURE;\n\t    }\n\n\t  set_pipestatus_from_exit (result);\n\n\t  goto return_result;\n\t}\n    }\n\n  if (autocd && interactive && words->word && is_dirname (words->word->word))\n    {\n      words = make_word_list (make_word (\"cd\"), words);\n      xtrace_print_word_list (words, 0);\n      goto run_builtin;\n    }\n\n  if (command_line == 0)\n    command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : \"\");\n\n#if defined (PROCESS_SUBSTITUTION)\n  if ((subshell_environment & SUBSHELL_COMSUB) && (simple_command->flags & CMD_NO_FORK) && fifos_pending() > 0)\n    simple_command->flags &= ~CMD_NO_FORK;\n#endif\n\n  result = execute_disk_command (words, simple_command->redirects, command_line,\n\t\t\tpipe_in, pipe_out, async, fds_to_close,\n\t\t\tsimple_command->flags);\n\n return_result:\n  bind_lastarg (lastarg);\n  FREE (command_line);\n  dispose_words (words);\n  if (builtin)\n    {\n      executing_builtin = old_builtin;\n      executing_command_builtin = old_command_builtin;\n    }\n  discard_unwind_frame (\"simple-command\");\n  this_command_name = (char *)NULL;\t/* points to freed memory now */\n  return (result);\n}"
}