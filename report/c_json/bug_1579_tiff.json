{
    "Project": "tiff",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "tools/tiffcrop.c",
    "message": "Offset: [0, max(65, `out->tif_fieldinfo->field_bit`)] Size: 4 by call to `TIFFClose`.",
    "warning_function_name": "writeSingleSection",
    "warning_line": "TIFFClose(out);",
    "warning_context": "\telse\n\t  CopyField(TIFFTAG_PREDICTOR, predictor);\n\tbreak;\n   case COMPRESSION_CCITTFAX3:\n   case COMPRESSION_CCITTFAX4:\n\tif (compression == COMPRESSION_CCITTFAX3) {\n          if (g3opts != (uint32) -1)\n\t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n\t  else\n\t    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n\t} else\n\t    CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n\t    CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n\t    CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n\t    CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n\t    CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n\t    CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n\t    CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n\tbreak;\n   }\n   { uint32 len32;\n     void** data;\n     if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n       TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n   }\n   { uint16 ninks;\n     const char* inknames;\n     if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {\n       TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n       if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {\n\t int inknameslen = strlen(inknames) + 1;\n\t const char* cp = inknames;\n\t while (ninks > 1) {\n\t   cp = strchr(cp, '\\0');\n\t   if (cp) {\n\t     cp++;\n\t     inknameslen += (strlen(cp) + 1);\n\t   }\n\t   ninks--;\n         }\n\t TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n       }\n     }\n   }\n   {\n   unsigned short pg0, pg1;\n   if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {\n     if (pageNum < 0) /* only one input file */\n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n     else \n\tTIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n     }\n   }\n\n  for (p = tags; p < &tags[NTAGS]; p++)\n\t\tCopyTag(p->tag, p->count, p->type);\n\n  /* Update these since they are overwritten from input res by loop above */\n  TIFFSetField(out, TIFFTAG_XRESOLUTION, (float)hres);\n  TIFFSetField(out, TIFFTAG_YRESOLUTION, (float)vres);\n\n  /* Compute the tile or strip dimensions and write to disk */\n  if (outtiled)\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);\n    else\n      writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);\n    }\n  else\n    {\n    if (config == PLANARCONFIG_CONTIG)\n      writeBufferToContigStrips (out, sect_buff, length);\n    else\n      writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);\n    }\n\n  if (!TIFFWriteDirectory(out))\n    {\n    TIFFClose(out);\n    return (-1);\n    }\n\n  return (0);\n  } /* end writeSingleSection */\n\n\n/* Create a buffer to write one section at a time */\nstatic int\ncreateImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);\n    *sect_buff_ptr = sect_buff;\n"
}