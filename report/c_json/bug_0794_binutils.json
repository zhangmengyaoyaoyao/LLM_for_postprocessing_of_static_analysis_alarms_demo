{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\tif (! ieee_read_type_index (info, pp, &ele_type)",
    "Code_function": "parse_ieee_ty (struct ieee_info *info, const bfd_byte **pp)\n{\n  const bfd_byte *ty_start, *ty_var_start, *ty_code_start;\n  bfd_vma typeindx, varindx, tc;\n  void *dhandle;\n  bfd_boolean tag, typdef;\n  debug_type *arg_slots;\n  unsigned long type_bitsize;\n  debug_type type;\n\n  ty_start = *pp;\n\n  if (! ieee_read_number (info, pp, &typeindx))\n    return FALSE;\n\n  if (typeindx < 256)\n    {\n      ieee_error (info, ty_start, _(\"illegal type index\"));\n      return FALSE;\n    }\n\n  typeindx -= 256;\n  if (! ieee_alloc_type (info, typeindx, FALSE))\n    return FALSE;\n\n  if (**pp != 0xce)\n    {\n      ieee_error (info, *pp, _(\"unknown TY code\"));\n      return FALSE;\n    }\n  ++*pp;\n\n  ty_var_start = *pp;\n\n  if (! ieee_read_number (info, pp, &varindx))\n    return FALSE;\n\n  if (varindx < 32)\n    {\n      ieee_error (info, ty_var_start, _(\"illegal variable index\"));\n      return FALSE;\n    }\n  varindx -= 32;\n\n  if (varindx >= info->vars.alloc || info->vars.vars[varindx].name == NULL)\n    {\n      ieee_error (info, ty_var_start, _(\"undefined variable in TY\"));\n      return FALSE;\n    }\n\n  ty_code_start = *pp;\n\n  if (! ieee_read_number (info, pp, &tc))\n    return FALSE;\n\n  dhandle = info->dhandle;\n\n  tag = FALSE;\n  typdef = FALSE;\n  arg_slots = NULL;\n  type_bitsize = 0;\n  switch (tc)\n    {\n    default:\n      ieee_error (info, ty_code_start, _(\"unknown TY code\"));\n      return FALSE;\n\n    case '!':\n      /* Unknown type, with size.  We treat it as int.  FIXME.  */\n      {\n\tbfd_vma size;\n\n\tif (! ieee_read_number (info, pp, &size))\n\t  return FALSE;\n\ttype = debug_make_int_type (dhandle, size, FALSE);\n      }\n      break;\n\n    case 'A': /* Array.  */\n    case 'a': /* FORTRAN array in column/row order.  FIXME: Not\n\t\t distinguished from normal array.  */\n      {\n\tdebug_type ele_type;\n\tbfd_vma lower, upper;\n\n\tif (! ieee_read_type_index (info, pp, &ele_type)\n\t    || ! ieee_read_number (info, pp, &lower)\n\t    || ! ieee_read_number (info, pp, &upper))\n\t  return FALSE;\n\ttype = debug_make_array_type (dhandle, ele_type,\n\t\t\t\t      ieee_builtin_type (info, ty_code_start,\n\t\t\t\t\t\t\t ((unsigned int)\n\t\t\t\t\t\t\t  builtin_int)),\n\t\t\t\t      (bfd_signed_vma) lower,\n\t\t\t\t      (bfd_signed_vma) upper,\n\t\t\t\t      FALSE);\n      }\n      break;\n\n    case 'E':\n      /* Simple enumeration.  */\n      {\n\tbfd_vma size;\n\tunsigned int alloc;\n\tconst char **names;\n\tunsigned int c;\n\tbfd_signed_vma *vals;\n\tunsigned int i;\n\n\tif (! ieee_read_number (info, pp, &size))\n\t  return FALSE;\n\t/* FIXME: we ignore the enumeration size.  */\n\n\talloc = 10;\n\tnames = (const char **) xmalloc (alloc * sizeof *names);\n\tmemset (names, 0, alloc * sizeof *names);\n\tc = 0;\n\twhile (1)\n\t  {\n\t    const char *name;\n\t    unsigned long namlen;\n\t    bfd_boolean present;\n\n\t    if (! ieee_read_optional_id (info, pp, &name, &namlen, &present))\n\t      return FALSE;\n\t    if (! present)\n\t      break;\n\n\t    if (c + 1 >= alloc)\n\t      {\n\t\talloc += 10;\n\t\tnames = ((const char **)\n\t\t\t xrealloc (names, alloc * sizeof *names));\n\t      }\n\n\t    names[c] = savestring (name, namlen);\n\t    if (names[c] == NULL)\n\t      return FALSE;\n\t    ++c;\n\t  }\n\n\tnames[c] = NULL;\n\n\tvals = (bfd_signed_vma *) xmalloc (c * sizeof *vals);\n\tfor (i = 0; i < c; i++)\n\t  vals[i] = i;\n\n\ttype = debug_make_enum_type (dhandle, names, vals);\n\ttag = TRUE;\n      }\n      break;\n\n    case 'G':\n      /* Struct with bit fields.  */\n      {\n\tbfd_vma size;\n\tunsigned int alloc;\n\tdebug_field *fields;\n\tunsigned int c;\n\n\tif (! ieee_read_number (info, pp, &size))\n\t  return FALSE;\n\n\talloc = 10;\n\tfields = (debug_field *) xmalloc (alloc * sizeof *fields);\n\tc = 0;\n\twhile (1)\n\t  {\n\t    const char *name;\n\t    unsigned long namlen;\n\t    bfd_boolean present;\n\t    debug_type ftype;\n\t    bfd_vma bitpos, bitsize;\n\n\t    if (! ieee_read_optional_id (info, pp, &name, &namlen, &present))\n\t      return FALSE;\n\t    if (! present)\n\t      break;\n\t    if (! ieee_read_type_index (info, pp, &ftype)\n\t\t|| ! ieee_read_number (info, pp, &bitpos)\n\t\t|| ! ieee_read_number (info, pp, &bitsize))\n\t      return FALSE;\n\n\t    if (c + 1 >= alloc)\n\t      {\n\t\talloc += 10;\n\t\tfields = ((debug_field *)\n\t\t\t  xrealloc (fields, alloc * sizeof *fields));\n\t      }\n\n\t    fields[c] = debug_make_field (dhandle, savestring (name, namlen),\n\t\t\t\t\t  ftype, bitpos, bitsize,\n\t\t\t\t\t  DEBUG_VISIBILITY_PUBLIC);\n\t    if (fields[c] == NULL)\n\t      return FALSE;\n\t    ++c;\n\t  }\n\n\tfields[c] = NULL;\n\n\ttype = debug_make_struct_type (dhandle, TRUE, size, fields);\n\ttag = TRUE;\n      }\n      break;\n\n    case 'N':\n      /* Enumeration.  */\n      {\n\tunsigned int alloc;\n\tconst char **names;\n\tbfd_signed_vma *vals;\n\tunsigned int c;\n\n\talloc = 10;\n\tnames = (const char **) xmalloc (alloc * sizeof *names);\n\tvals = (bfd_signed_vma *) xmalloc (alloc * sizeof *names);\n\tc = 0;\n\twhile (1)\n\t  {\n\t    const char *name;\n\t    unsigned long namlen;\n\t    bfd_boolean present;\n\t    bfd_vma val;\n\n\t    if (! ieee_read_optional_id (info, pp, &name, &namlen, &present))\n\t      return FALSE;\n\t    if (! present)\n\t      break;\n\t    if (! ieee_read_number (info, pp, &val))\n\t      return FALSE;\n\n\t    /* If the length of the name is zero, then the value is\n               actually the size of the enum.  We ignore this\n               information.  FIXME.  */\n\t    if (namlen == 0)\n\t      continue;\n\n\t    if (c + 1 >= alloc)\n\t      {\n\t\talloc += 10;\n\t\tnames = ((const char **)\n\t\t\t xrealloc (names, alloc * sizeof *names));\n\t\tvals = ((bfd_signed_vma *)\n\t\t\txrealloc (vals, alloc * sizeof *vals));\n\t      }\n\n\t    names[c] = savestring (name, namlen);\n\t    if (names[c] == NULL)\n\t      return FALSE;\n\t    vals[c] = (bfd_signed_vma) val;\n\t    ++c;\n\t  }\n\n\tnames[c] = NULL;\n\n\ttype = debug_make_enum_type (dhandle, names, vals);\n\ttag = TRUE;\n      }\n      break;\n\n    case 'O': /* Small pointer.  We don't distinguish small and large\n\t\t pointers.  FIXME.  */\n    case 'P': /* Large pointer.  */\n      {\n\tdebug_type t;\n\n\tif (! ieee_read_type_index (info, pp, &t))\n\t  return FALSE;\n\ttype = debug_make_pointer_type (dhandle, t);\n      }\n      break;\n\n    case 'R':\n      /* Range.  */\n      {\n\tbfd_vma low, high, signedp, size;\n\n\tif (! ieee_read_number (info, pp, &low)\n\t    || ! ieee_read_number (info, pp, &high)\n\t    || ! ieee_read_number (info, pp, &signedp)\n\t    || ! ieee_read_number (info, pp, &size))\n\t  return FALSE;\n\n\ttype = debug_make_range_type (dhandle,\n\t\t\t\t      debug_make_int_type (dhandle, size,\n\t\t\t\t\t\t\t   ! signedp),\n\t\t\t\t      (bfd_signed_vma) low,\n\t\t\t\t      (bfd_signed_vma) high);\n      }\n      break;\n\n    case 'S': /* Struct.  */\n    case 'U': /* Union.  */\n      {\n\tbfd_vma size;\n\tunsigned int alloc;\n\tdebug_field *fields;\n\tunsigned int c;\n\n\tif (! ieee_read_number (info, pp, &size))\n\t  return FALSE;\n\n\talloc = 10;\n\tfields = (debug_field *) xmalloc (alloc * sizeof *fields);\n\tc = 0;\n\twhile (1)\n\t  {\n\t    const char *name;\n\t    unsigned long namlen;\n\t    bfd_boolean present;\n\t    bfd_vma tindx;\n\t    bfd_vma offset;\n\t    debug_type ftype;\n\t    bfd_vma bitsize;\n\n\t    if (! ieee_read_optional_id (info, pp, &name, &namlen, &present))\n\t      return FALSE;\n\t    if (! present)\n\t      break;\n\t    if (! ieee_read_number (info, pp, &tindx)\n\t\t|| ! ieee_read_number (info, pp, &offset))\n\t      return FALSE;\n\n\t    if (tindx < 256)\n\t      {\n\t\tftype = ieee_builtin_type (info, ty_code_start, tindx);\n\t\tbitsize = 0;\n\t\toffset *= 8;\n\t      }\n\t    else\n\t      {\n\t\tstruct ieee_type *t;\n\n\t\ttindx -= 256;\n\t\tif (! ieee_alloc_type (info, tindx, TRUE))\n\t\t  return FALSE;\n\t\tt = info->types.types + tindx;\n\t\tftype = t->type;\n\t\tbitsize = t->bitsize;\n\t\tif (bitsize == 0)\n\t\t  offset *= 8;\n\t      }\n\n\t    if (c + 1 >= alloc)\n\t      {\n\t\talloc += 10;\n\t\tfields = ((debug_field *)\n\t\t\t  xrealloc (fields, alloc * sizeof *fields));\n\t      }\n\n\t    fields[c] = debug_make_field (dhandle, savestring (name, namlen),\n\t\t\t\t\t  ftype, offset, bitsize,\n\t\t\t\t\t  DEBUG_VISIBILITY_PUBLIC);\n\t    if (fields[c] == NULL)\n\t      return FALSE;\n\t    ++c;\n\t  }\n\n\tfields[c] = NULL;\n\n\ttype = debug_make_struct_type (dhandle, tc == 'S', size, fields);\n\ttag = TRUE;\n      }\n      break;\n\n    case 'T':\n      /* Typedef.  */\n      if (! ieee_read_type_index (info, pp, &type))\n\treturn FALSE;\n      typdef = TRUE;\n      break;\n\n    case 'X':\n      /* Procedure.  FIXME: This is an extern declaration, which we\n         have no way of representing.  */\n      {\n\tbfd_vma attr;\n\tdebug_type rtype;\n\tbfd_vma nargs;\n\tbfd_boolean present;\n\tstruct ieee_var *pv;\n\n\t/* FIXME: We ignore the attribute and the argument names.  */\n\n\tif (! ieee_read_number (info, pp, &attr)\n\t    || ! ieee_read_type_index (info, pp, &rtype)\n\t    || ! ieee_read_number (info, pp, &nargs))\n\t  return FALSE;\n\tdo\n\t  {\n\t    const char *name;\n\t    unsigned long namlen;\n\n\t    if (! ieee_read_optional_id (info, pp, &name, &namlen, &present))\n\t      return FALSE;\n\t  }\n\twhile (present);\n\n\tpv = info->vars.vars + varindx;\n\tpv->kind = IEEE_EXTERNAL;\n\tif (pv->namlen > 0\n\t    && debug_get_type_kind (dhandle, rtype) == DEBUG_KIND_POINTER)\n\t  {\n\t    /* Set up the return type as an indirect type pointing to\n               the variable slot, so that we can change it to a\n               reference later if appropriate.  */\n\t    pv->pslot = (debug_type *) xmalloc (sizeof *pv->pslot);\n\t    *pv->pslot = rtype;\n\t    rtype = debug_make_indirect_type (dhandle, pv->pslot,\n\t\t\t\t\t      (const char *) NULL);\n\t  }\n\n\ttype = debug_make_function_type (dhandle, rtype, (debug_type *) NULL,\n\t\t\t\t\t FALSE);\n      }\n      break;\n\n    case 'V':\n    case 'v':\n      /* Void.  This is not documented, but the MRI compiler emits it.  */\n      type = debug_make_void_type (dhandle);\n      break;\n\n    case 'Z':\n      /* Array with 0 lower bound.  */\n      {\n\tdebug_type etype;\n\tbfd_vma high;\n\n\tif (! ieee_read_type_index (info, pp, &etype)\n\t    || ! ieee_read_number (info, pp, &high))\n\t  return FALSE;\n\n\ttype = debug_make_array_type (dhandle, etype,\n\t\t\t\t      ieee_builtin_type (info, ty_code_start,\n\t\t\t\t\t\t\t ((unsigned int)\n\t\t\t\t\t\t\t  builtin_int)),\n\t\t\t\t      0, (bfd_signed_vma) high, FALSE);\n      }\n      break;\n\n    case 'c': /* Complex.  */\n    case 'd': /* Double complex.  */\n      {\n\tconst char *name;\n\tunsigned long namlen;\n\n\t/* FIXME: I don't know what the name means.  */\n\n\tif (! ieee_read_id (info, pp, &name, &namlen))\n\t  return FALSE;\n\n\ttype = debug_make_complex_type (dhandle, tc == 'c' ? 4 : 8);\n      }\n      break;\n\n    case 'f':\n      /* Pascal file name.  FIXME.  */\n      ieee_error (info, ty_code_start, _(\"Pascal file name not supported\"));\n      return FALSE;\n\n    case 'g':\n      /* Bitfield type.  */\n      {\n\tbfd_vma signedp, bitsize, dummy;\n\tconst bfd_byte *hold;\n\tbfd_boolean present;\n\n\tif (! ieee_read_number (info, pp, &signedp)\n\t    || ! ieee_read_number (info, pp, &bitsize))\n\t  return FALSE;\n\n\t/* I think the documentation says that there is a type index,\n           but some actual files do not have one.  */\n\thold = *pp;\n\tif (! ieee_read_optional_number (info, pp, &dummy, &present))\n\t  return FALSE;\n\tif (! present)\n\t  {\n\t    /* FIXME: This is just a guess.  */\n\t    type = debug_make_int_type (dhandle, 4,\n\t\t\t\t\tsignedp ? FALSE : TRUE);\n\t  }\n\telse\n\t  {\n\t    *pp = hold;\n\t    if (! ieee_read_type_index (info, pp, &type))\n\t      return FALSE;\n\t  }\n\ttype_bitsize = bitsize;\n      }\n      break;\n\n    case 'n':\n      /* Qualifier.  */\n      {\n\tbfd_vma kind;\n\tdebug_type t;\n\n\tif (! ieee_read_number (info, pp, &kind)\n\t    || ! ieee_read_type_index (info, pp, &t))\n\t  return FALSE;\n\n\tswitch (kind)\n\t  {\n\t  default:\n\t    ieee_error (info, ty_start, _(\"unsupported qualifier\"));\n\t    return FALSE;\n\n\t  case 1:\n\t    type = debug_make_const_type (dhandle, t);\n\t    break;\n\n\t  case 2:\n\t    type = debug_make_volatile_type (dhandle, t);\n\t    break;\n\t  }\n      }\n      break;\n\n    case 's':\n      /* Set.  */\n      {\n\tbfd_vma size;\n\tdebug_type etype;\n\n\tif (! ieee_read_number (info, pp, &size)\n\t    || ! ieee_read_type_index (info, pp, &etype))\n\t  return FALSE;\n\n\t/* FIXME: We ignore the size.  */\n\n\ttype = debug_make_set_type (dhandle, etype, FALSE);\n      }\n      break;\n\n    case 'x':\n      /* Procedure with compiler dependencies.  */\n      {\n\tstruct ieee_var *pv;\n\tbfd_vma attr, frame_type, push_mask, nargs, level, father;\n\tdebug_type rtype;\n\tdebug_type *arg_types;\n\tbfd_boolean varargs;\n\tbfd_boolean present;\n\n\t/* FIXME: We ignore some of this information.  */\n\n\tpv = info->vars.vars + varindx;\n\n\tif (! ieee_read_number (info, pp, &attr)\n\t    || ! ieee_read_number (info, pp, &frame_type)\n\t    || ! ieee_read_number (info, pp, &push_mask)\n\t    || ! ieee_read_type_index (info, pp, &rtype)\n\t    || ! ieee_read_number (info, pp, &nargs))\n\t  return FALSE;\n\tif (nargs == (bfd_vma) -1)\n\t  {\n\t    arg_types = NULL;\n\t    varargs = FALSE;\n\t  }\n\telse\n\t  {\n\t    unsigned int i;\n\n\t    arg_types = ((debug_type *)\n\t\t\t xmalloc ((nargs + 1) * sizeof *arg_types));\n\t    for (i = 0; i < nargs; i++)\n\t      if (! ieee_read_type_index (info, pp, arg_types + i))\n\t\treturn FALSE;\n\n\t    /* If the last type is pointer to void, this is really a\n               varargs function.  */\n\t    varargs = FALSE;\n\t    if (nargs > 0)\n\t      {\n\t\tdebug_type last;\n\n\t\tlast = arg_types[nargs - 1];\n\t\tif (debug_get_type_kind (dhandle, last) == DEBUG_KIND_POINTER\n\t\t    && (debug_get_type_kind (dhandle,\n\t\t\t\t\t     debug_get_target_type (dhandle,\n\t\t\t\t\t\t\t\t    last))\n\t\t\t== DEBUG_KIND_VOID))\n\t\t  {\n\t\t    --nargs;\n\t\t    varargs = TRUE;\n\t\t  }\n\t      }\n\n\t    /* If there are any pointer arguments, turn them into\n               indirect types in case we later need to convert them to\n               reference types.  */\n\t    for (i = 0; i < nargs; i++)\n\t      {\n\t\tif (debug_get_type_kind (dhandle, arg_types[i])\n\t\t    == DEBUG_KIND_POINTER)\n\t\t  {\n\t\t    if (arg_slots == NULL)\n\t\t      {\n\t\t\targ_slots = ((debug_type *)\n\t\t\t\t     xmalloc (nargs * sizeof *arg_slots));\n\t\t\tmemset (arg_slots, 0, nargs * sizeof *arg_slots);\n\t\t      }\n\t\t    arg_slots[i] = arg_types[i];\n\t\t    arg_types[i] =\n\t\t      debug_make_indirect_type (dhandle,\n\t\t\t\t\t\targ_slots + i,\n\t\t\t\t\t\t(const char *) NULL);\n\t\t  }\n\t      }\n\n\t    arg_types[nargs] = DEBUG_TYPE_NULL;\n\t  }\n\tif (! ieee_read_number (info, pp, &level)\n\t    || ! ieee_read_optional_number (info, pp, &father, &present))\n\t  return FALSE;\n\n\t/* We can't distinguish between a global function and a static\n           function.  */\n\tpv->kind = IEEE_FUNCTION;\n\n\tif (pv->namlen > 0\n\t    && debug_get_type_kind (dhandle, rtype) == DEBUG_KIND_POINTER)\n\t  {\n\t    /* Set up the return type as an indirect type pointing to\n               the variable slot, so that we can change it to a\n               reference later if appropriate.  */\n\t    pv->pslot = (debug_type *) xmalloc (sizeof *pv->pslot);\n\t    *pv->pslot = rtype;\n\t    rtype = debug_make_indirect_type (dhandle, pv->pslot,\n\t\t\t\t\t      (const char *) NULL);\n\t  }\n\n\ttype = debug_make_function_type (dhandle, rtype, arg_types, varargs);\n      }\n      break;\n    }\n\n  /* Record the type in the table.  */\n\n  if (type == DEBUG_TYPE_NULL)\n    return FALSE;\n\n  info->vars.vars[varindx].type = type;\n\n  if ((tag || typdef)\n      && info->vars.vars[varindx].namlen > 0)\n    {\n      const char *name;\n\n      name = savestring (info->vars.vars[varindx].name,\n\t\t\t info->vars.vars[varindx].namlen);\n      if (typdef)\n\ttype = debug_name_type (dhandle, name, type);\n      else if (tc == 'E' || tc == 'N')\n\ttype = debug_tag_type (dhandle, name, type);\n      else\n\t{\n\t  struct ieee_tag *it;\n\n\t  /* We must allocate all struct tags as indirect types, so\n             that if we later see a definition of the tag as a C++\n             record we can update the indirect slot and automatically\n             change all the existing references.  */\n\t  it = (struct ieee_tag *) xmalloc (sizeof *it);\n\t  memset (it, 0, sizeof *it);\n\t  it->next = info->tags;\n\t  info->tags = it;\n\t  it->name = name;\n\t  it->slot = type;\n\n\t  type = debug_make_indirect_type (dhandle, &it->slot, name);\n\t  type = debug_tag_type (dhandle, name, type);\n\n\t  it->type = type;\n\t}\n      if (type == NULL)\n\treturn FALSE;\n    }\n\n  info->types.types[typeindx].type = type;\n  info->types.types[typeindx].arg_slots = arg_slots;\n  info->types.types[typeindx].bitsize = type_bitsize;\n\n  /* We may have already allocated type as an indirect type pointing\n     to slot.  It does no harm to replace the indirect type with the\n     real type.  Filling in slot as well handles the indirect types\n     which are already hanging around.  */\n  if (info->types.types[typeindx].pslot != NULL)\n    *info->types.types[typeindx].pslot = type;\n\n  return TRUE;\n}"
}