{
    "Project": "bash",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "lib/readline/util.c",
    "message": "pointer `_rl_tracefp` last assigned on line 503 could be null and is dereferenced by call to `vfprintf()` at line 504, column 3.",
    "warning_function_name": NaN,
    "warning_line": "vfprintf (_rl_tracefp, format, args);",
    "warning_context": "\n  return (d);\n}\n#endif /* !HAVE_STRCASECMP */\n\n/* Stupid comparison routine for qsort () ing strings. */\nint\n_rl_qsort_string_compare (s1, s2)\n  char **s1, **s2;\n{\n#if defined (HAVE_STRCOLL)\n  return (strcoll (*s1, *s2));\n#else\n  int result;\n\n  result = **s1 - **s2;\n  if (result == 0)\n    result = strcmp (*s1, *s2);\n\n  return result;\n#endif\n}\n\n/* Function equivalents for the macros defined in chardefs.h. */\n#define FUNCTION_FOR_MACRO(f)\tint (f) (c) int c; { return f (c); }\n\nFUNCTION_FOR_MACRO (_rl_digit_p)\nFUNCTION_FOR_MACRO (_rl_digit_value)\nFUNCTION_FOR_MACRO (_rl_lowercase_p)\nFUNCTION_FOR_MACRO (_rl_pure_alphabetic)\nFUNCTION_FOR_MACRO (_rl_to_lower)\nFUNCTION_FOR_MACRO (_rl_to_upper)\nFUNCTION_FOR_MACRO (_rl_uppercase_p)\n\n/* A convenience function, to force memory deallocation to be performed\n   by readline.  DLLs on Windows apparently require this. */\nvoid\nrl_free (mem)\n     void *mem;\n{\n  if (mem)\n    free (mem);\n}\n\n/* Backwards compatibility, now that savestring has been removed from\n   all `public' readline header files. */\n#undef _rl_savestring\nchar *\n_rl_savestring (s)\n     const char *s;\n{\n  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));\n}\n\n#if defined (USE_VARARGS)\nstatic FILE *_rl_tracefp;\n\nvoid\n#if defined (PREFER_STDARG)\n_rl_trace (const char *format, ...)\n#else\n_rl_trace (va_alist)\n     va_dcl\n#endif\n{\n  va_list args;\n#if defined (PREFER_VARARGS)\n  char *format;\n#endif\n\n#if defined (PREFER_STDARG)\n  va_start (args, format);\n#else\n  va_start (args);\n  format = va_arg (args, char *);\n#endif\n\n  if (_rl_tracefp == 0)\n    _rl_tropen ();\n  vfprintf (_rl_tracefp, format, args);\n  fprintf (_rl_tracefp, \"\\n\");\n  fflush (_rl_tracefp);\n\n  va_end (args);\n}\n\nint\n_rl_tropen ()\n{\n  char fnbuf[128];\n\n  if (_rl_tracefp)\n    fclose (_rl_tracefp);\n  sprintf (fnbuf, \"/var/tmp/rltrace.%ld\", (long)getpid());\n  unlink(fnbuf);\n  _rl_tracefp = fopen (fnbuf, \"w+\");\n  return _rl_tracefp != 0;\n}\n\nint\n_rl_trclose ()\n"
}