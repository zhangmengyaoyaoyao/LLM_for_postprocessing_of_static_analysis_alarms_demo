{
    "Project": "Zephyr",
    "Tool": "Cppcheck",
    "category": "Null Pointer Dereference",
    "file": "subsys/bluetooth/controller/ll_sw/ull_conn.c",
    "message": "Either the condition 'rx' is redundant or there is possible null pointer dereference: rx.",
    "warning_function_name": "event_conn_upd_prep",
    "warning_line": "conn->llcp_rx = rx->hdr.link->mem;",
    "warning_context": "\t\trx = ll_pdu_rx_alloc_peek(1);\n\t\tif (!rx) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\ttx = mem_acquire(&mem_conn_tx_ctrl.free);\n\t\tif (!tx) {\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t(void)ll_pdu_rx_alloc();\n\t\trx->hdr.link->mem = conn->llcp_rx;\n\t\tconn->llcp_rx = rx;\n\n\t\tpdu_ctrl_tx = (void *)tx->pdu;\n\n#if defined(CONFIG_BT_CTLR_SCHED_ADVANCED)\n\t\tswitch (conn->llcp_cu.state) {\n\t\tcase LLCP_CUI_STATE_USE:\n\t\t\tfp_mfy_select_or_use = ull_sched_mfy_win_offset_use;\n\t\t\tbreak;\n\n#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)\n\t\tcase LLCP_CUI_STATE_SELECT:\n\t\t\tfp_mfy_select_or_use = ull_sched_mfy_win_offset_select;\n\t\t\tbreak;\n#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */\n\n\t\tdefault:\n\t\t\tLL_ASSERT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tevent_conn_upd_init(conn, event_counter, ticks_at_expire,\n\t\t\t\t    pdu_ctrl_tx, &s_mfy_sched_offset,\n\t\t\t\t    fp_mfy_select_or_use);\n#else /* !CONFIG_BT_CTLR_SCHED_ADVANCED */\n\t\tevent_conn_upd_init(conn, event_counter, ticks_at_expire,\n\t\t\t\t    pdu_ctrl_tx, NULL, NULL);\n#endif /* !CONFIG_BT_CTLR_SCHED_ADVANCED */\n\n\t\tctrl_tx_enqueue(conn, tx);\n\n\t} else if (instant_latency <= 0x7FFF) {\n\t\tu32_t ticks_win_offset = 0;\n\t\tu32_t ticks_slot_overhead;\n\t\tu16_t conn_interval_old;\n\t\tu16_t conn_interval_new;\n\t\tu32_t conn_interval_us;\n\t\tstruct node_rx_pdu *rx;\n\t\tu8_t ticker_id_conn;\n\t\tu32_t ticker_status;\n\t\tu32_t periodic_us;\n\t\tu16_t latency;\n\n\t\t/* procedure request acked */\n\t\tconn->llcp_cu.ack = conn->llcp_cu.req;\n\t\tconn->llcp_ack = conn->llcp_req;\n\n#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)\n\t\tif ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&\n\t\t    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {\n\t\t\tconn->llcp_conn_param.ack = conn->llcp_conn_param.req;\n\n\t\t\t/* Stop procedure timeout */\n\t\t\tconn->procedure_expire = 0U;\n\t\t}\n#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */\n\n\t\t/* reset mutex */\n\t\tif (conn_upd_curr == conn) {\n\t\t\tconn_upd_curr = NULL;\n\t\t}\n\n\t\tlll = &conn->lll;\n\n\t\t/* Acquire Rx node */\n\t\trx = conn->llcp_rx;\n\t\tLL_ASSERT(rx && rx->hdr.link);\n\t\tconn->llcp_rx = rx->hdr.link->mem;\n\n\t\t/* Prepare the rx packet structure */\n\t\tif ((conn->llcp_cu.interval != lll->interval) ||\n\t\t    (conn->llcp_cu.latency != lll->latency) ||\n\t\t    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,\n\t\t\t\t       lll->interval * 1250) !=\n\t\t     conn->supervision_reload)) {\n\t\t\tstruct node_rx_cu *cu;\n\n\t\t\trx->hdr.handle = lll->handle;\n\t\t\trx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;\n\n\t\t\t/* prepare connection update complete structure */\n\t\t\tcu = (void *)rx->pdu;\n\t\t\tcu->status = 0x00;\n\t\t\tcu->interval = conn->llcp_cu.interval;\n\t\t\tcu->latency = conn->llcp_cu.latency;\n\t\t\tcu->timeout = conn->llcp_cu.timeout;\n\t\t} else {\n\t\t\t/* Mark for buffer for release */\n\t\t\trx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;\n"
}