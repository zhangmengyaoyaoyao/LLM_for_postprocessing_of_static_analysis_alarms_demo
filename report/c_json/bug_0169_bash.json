{
    "project": "bash",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "bashline.c",
    "message": "Offset: [2, +oo] Size: 2 by call to `rl_bind_keyseq_in_map`.",
    "warning_function_name": "initialize_readline",
    "warning_line": "rl_bind_keyseq_in_map (kseq, bash_complete_username, emacs_meta_keymap);",
    "warning_context": "#  ifdef BANG_HISTORY\n  rl_add_defun (\"history-and-alias-expand-line\", history_and_alias_expand_line, -1);\n#  endif\n#endif\n\n  /* Backwards compatibility. */\n  rl_add_defun (\"insert-last-argument\", rl_yank_last_arg, -1);\n\n  rl_add_defun (\"operate-and-get-next\", operate_and_get_next, -1);\n  rl_add_defun (\"display-shell-version\", display_shell_version, -1);\n  rl_add_defun (\"edit-and-execute-command\", emacs_edit_and_execute_command, -1);\n\n#if defined (BRACE_COMPLETION)\n  rl_add_defun (\"complete-into-braces\", bash_brace_completion, -1);\n#endif\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  rl_add_defun (\"complete-filename\", bash_complete_filename, -1);\n  rl_add_defun (\"possible-filename-completions\", bash_possible_filename_completions, -1);\n  rl_add_defun (\"complete-username\", bash_complete_username, -1);\n  rl_add_defun (\"possible-username-completions\", bash_possible_username_completions, -1);\n  rl_add_defun (\"complete-hostname\", bash_complete_hostname, -1);\n  rl_add_defun (\"possible-hostname-completions\", bash_possible_hostname_completions, -1);\n  rl_add_defun (\"complete-variable\", bash_complete_variable, -1);\n  rl_add_defun (\"possible-variable-completions\", bash_possible_variable_completions, -1);\n  rl_add_defun (\"complete-command\", bash_complete_command, -1);\n  rl_add_defun (\"possible-command-completions\", bash_possible_command_completions, -1);\n  rl_add_defun (\"glob-complete-word\", bash_glob_complete_word, -1);\n  rl_add_defun (\"glob-expand-word\", bash_glob_expand_word, -1);\n  rl_add_defun (\"glob-list-expansions\", bash_glob_list_expansions, -1);\n#endif\n\n  rl_add_defun (\"dynamic-complete-history\", dynamic_complete_history, -1);\n  rl_add_defun (\"dabbrev-expand\", bash_dabbrev_expand, -1);\n\n  /* Bind defaults before binding our custom shell keybindings. */\n  if (RL_ISSTATE(RL_STATE_INITIALIZED) == 0)\n    rl_initialize ();\n\n  /* Bind up our special shell functions. */\n  rl_bind_key_if_unbound_in_map (CTRL('E'), shell_expand_line, emacs_meta_keymap);\n\n#ifdef BANG_HISTORY\n  rl_bind_key_if_unbound_in_map ('^', history_expand_line, emacs_meta_keymap);\n#endif\n\n  rl_bind_key_if_unbound_in_map (CTRL ('O'), operate_and_get_next, emacs_standard_keymap);\n  rl_bind_key_if_unbound_in_map (CTRL ('V'), display_shell_version, emacs_ctlx_keymap);\n\n  /* In Bash, the user can switch editing modes with \"set -o [vi emacs]\",\n     so it is not necessary to allow C-M-j for context switching.  Turn\n     off this occasionally confusing behaviour. */\n  kseq[0] = CTRL('J');\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == rl_vi_editing_mode)\n    rl_unbind_key_in_map (CTRL('J'), emacs_meta_keymap);\n  kseq[0] = CTRL('M');\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == rl_vi_editing_mode)\n    rl_unbind_key_in_map (CTRL('M'), emacs_meta_keymap);\n#if defined (VI_MODE)\n  rl_unbind_key_in_map (CTRL('E'), vi_movement_keymap);\n#endif\n\n#if defined (BRACE_COMPLETION)\n  rl_bind_key_if_unbound_in_map ('{', bash_brace_completion, emacs_meta_keymap); /*}*/\n#endif /* BRACE_COMPLETION */\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  rl_bind_key_if_unbound_in_map ('/', bash_complete_filename, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('/', bash_possible_filename_completions, emacs_ctlx_keymap);\n\n  /* Have to jump through hoops here because there is a default binding for\n     M-~ (rl_tilde_expand) */\n  kseq[0] = '~';\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == 0 || func == rl_tilde_expand)\n    rl_bind_keyseq_in_map (kseq, bash_complete_username, emacs_meta_keymap);\n\n  rl_bind_key_if_unbound_in_map ('~', bash_possible_username_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('@', bash_complete_hostname, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('@', bash_possible_hostname_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('$', bash_complete_variable, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('$', bash_possible_variable_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('!', bash_complete_command, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('!', bash_possible_command_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('g', bash_glob_complete_word, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('*', bash_glob_expand_word, emacs_ctlx_keymap);\n  rl_bind_key_if_unbound_in_map ('g', bash_glob_list_expansions, emacs_ctlx_keymap);\n\n#endif /* SPECIFIC_COMPLETION_FUNCTIONS */\n\n  kseq[0] = TAB;\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n"
}