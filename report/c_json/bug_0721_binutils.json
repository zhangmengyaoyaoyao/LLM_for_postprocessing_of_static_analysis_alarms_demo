{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "  if (! bfd_check_format_matches (arch, bfd_archive, &matching))",
    "Code_function": "open_inarch (const char *archive_filename, const char *file)\n{\n  bfd **last_one;\n  bfd *next_one;\n  struct stat sbuf;\n  bfd *arch;\n  char **matching;\n\n  bfd_set_error (bfd_error_no_error);\n\n  if (target == NULL)\n    target = plugin_target;\n\n  if (stat (archive_filename, &sbuf) != 0)\n    {\n#if !defined(__GO32__) || defined(__DJGPP__)\n\n      /* FIXME: I don't understand why this fragment was ifndef'ed\n\t away for __GO32__; perhaps it was in the days of DJGPP v1.x.\n\t stat() works just fine in v2.x, so I think this should be\n\t removed.  For now, I enable it for DJGPP v2. -- EZ.  */\n\n      /* KLUDGE ALERT! Temporary fix until I figger why\n\t stat() is wrong ... think it's buried in GO32's IDT - Jax */\n      if (errno != ENOENT)\n\tbfd_fatal (archive_filename);\n#endif\n\n      if (!operation_alters_arch)\n\t{\n\t  fprintf (stderr, \"%s: \", program_name);\n\t  perror (archive_filename);\n\t  maybequit ();\n\t  return NULL;\n\t}\n\n      /* If the target isn't set, try to figure out the target to use\n\t for the archive from the first object on the list.  */\n      if (target == NULL && file != NULL)\n\t{\n\t  bfd *obj;\n\n\t  obj = bfd_openr (file, target);\n\t  if (obj != NULL)\n\t    {\n\t      if (bfd_check_format (obj, bfd_object))\n\t\ttarget = bfd_get_target (obj);\n\t      (void) bfd_close (obj);\n\t    }\n\t}\n\n      /* Create an empty archive.  */\n      arch = bfd_openw (archive_filename, target);\n      if (arch == NULL\n\t  || ! bfd_set_format (arch, bfd_archive)\n\t  || ! bfd_close (arch))\n\tbfd_fatal (archive_filename);\n      else if (!silent_create)\n        non_fatal (_(\"creating %s\"), archive_filename);\n\n      /* If we die creating a new archive, don't leave it around.  */\n      output_filename = archive_filename;\n    }\n\n  arch = bfd_openr (archive_filename, target);\n  if (arch == NULL)\n    {\n    bloser:\n      bfd_fatal (archive_filename);\n    }\n\n  if (! bfd_check_format_matches (arch, bfd_archive, &matching))\n    {\n      bfd_nonfatal (archive_filename);\n      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)\n\t{\n\t  list_matching_formats (matching);\n\t  free (matching);\n\t}\n      xexit (1);\n    }\n\n  if ((operation == replace || operation == quick_append)\n      && bfd_openr_next_archived_file (arch, NULL) != NULL)\n    {\n      /* PR 15140: Catch attempts to convert a normal\n\t archive into a thin archive or vice versa.  */\n      if (make_thin_archive && ! bfd_is_thin_archive (arch))\n\t{\n\t  fatal (_(\"Cannot convert existing library %s to thin format\"),\n\t\t bfd_get_filename (arch));\n\t  goto bloser;\n\t}\n      else if (! make_thin_archive && bfd_is_thin_archive (arch))\n\t{\n\t  fatal (_(\"Cannot convert existing thin library %s to normal format\"),\n\t\t bfd_get_filename (arch));\n\t  goto bloser;\n\t}\n    }\n\n  last_one = &(arch->archive_next);\n  /* Read all the contents right away, regardless.  */\n  for (next_one = bfd_openr_next_archived_file (arch, NULL);\n       next_one;\n       next_one = bfd_openr_next_archived_file (arch, next_one))\n    {\n      PROGRESS (1);\n      *last_one = next_one;\n      last_one = &next_one->archive_next;\n    }\n  *last_one = (bfd *) NULL;\n  if (bfd_get_error () != bfd_error_no_more_archived_files)\n    goto bloser;\n  return arch;\n}"
}