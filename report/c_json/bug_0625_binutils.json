{
    "project": "binutils",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "bfd/i386linux.c",
    "message": "pointer `s` last assigned on line 584 could be null and is dereferenced at line 587, column 8.",
    "warning_function_name": "linux_finish_dynamic_link",
    "warning_line": "os = s->output_section;",
    "warning_context": "static bfd_boolean\nlinux_finish_dynamic_link (bfd *output_bfd,\n\t\t\t   struct bfd_link_info *info)\n{\n  asection *s, *os, *is;\n  bfd_byte *fixup_table;\n  struct linux_link_hash_entry *h;\n  struct fixup *f;\n  unsigned int new_addr;\n  int section_offset;\n  unsigned int fixups_written;\n\n  if (linux_hash_table (info)->dynobj == NULL)\n    return TRUE;\n\n  s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,\n\t\t\t       \".linux-dynamic\");\n  BFD_ASSERT (s != NULL);\n  os = s->output_section;\n  fixups_written = 0;\n\n#ifdef LINUX_LINK_DEBUG\n  printf (\"Fixup table file offset: %x  VMA: %x\\n\",\n\t  os->filepos + s->output_offset,\n\t  os->vma + s->output_offset);\n#endif\n\n  fixup_table = s->contents;\n  bfd_put_32 (output_bfd,\n\t      (bfd_vma) linux_hash_table (info)->fixup_count, fixup_table);\n  fixup_table += 4;\n\n  /* Fill in fixup table.  */\n  for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)\n    {\n      if (f->builtin)\n\tcontinue;\n\n      if (f->h->root.root.type != bfd_link_hash_defined\n\t  && f->h->root.root.type != bfd_link_hash_defweak)\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"Symbol %s not defined for fixups\\n\"),\n\t     f->h->root.root.root.string);\n\t  continue;\n\t}\n\n      is = f->h->root.root.u.def.section;\n      section_offset = is->output_section->vma + is->output_offset;\n      new_addr = f->h->root.root.u.def.value + section_offset;\n\n#ifdef LINUX_LINK_DEBUG\n      printf (\"Fixup(%d) %s: %x %x\\n\",f->jump, f->h->root.root.string,\n\t      new_addr, f->value);\n#endif\n\n      if (f->jump)\n\t{\n\t  /* Relative address */\n\t  new_addr = new_addr - (f->value + 5);\n\t  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);\n\t  fixup_table += 4;\n\t  bfd_put_32 (output_bfd, f->value + 1, fixup_table);\n\t  fixup_table += 4;\n\t}\n      else\n\t{\n\t  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);\n\t  fixup_table += 4;\n\t  bfd_put_32 (output_bfd, f->value, fixup_table);\n\t  fixup_table += 4;\n\t}\n      ++fixups_written;\n    }\n\n  if (linux_hash_table (info)->local_builtins != 0)\n    {\n      /* Special marker so we know to switch to the other type of fixup */\n      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n      fixup_table += 4;\n      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n      fixup_table += 4;\n      ++fixups_written;\n      for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)\n\t{\n\t  if (! f->builtin)\n\t    continue;\n\n\t  if (f->h->root.root.type != bfd_link_hash_defined\n\t      && f->h->root.root.type != bfd_link_hash_defweak)\n\t    {\n\t      (*_bfd_error_handler)\n\t\t(_(\"Symbol %s not defined for fixups\\n\"),\n\t\t f->h->root.root.root.string);\n\t      continue;\n\t    }\n\n\t  is = f->h->root.root.u.def.section;\n\t  section_offset = is->output_section->vma + is->output_offset;\n\t  new_addr = f->h->root.root.u.def.value + section_offset;\n\n"
}