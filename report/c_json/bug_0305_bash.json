{
    "project": "bash",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "y.tab.c",
    "message": "Offset: [-oo, 9999] Size: 200.",
    "warning_function_name": "YYID",
    "warning_line": "*yyssp = yystate;",
    "warning_context": "yyparse ()\n\n#endif\n#endif\n{\n  \n  int yystate;\n  int yyn;\n  int yyresult;\n  /* Number of tokens to shift before error messages enabled.  */\n  int yyerrstatus;\n  /* Look-ahead token as an internal (translated) token number.  */\n  int yytoken = 0;\n#if YYERROR_VERBOSE\n  /* Buffer for error messages, and its allocated size.  */\n  char yymsgbuf[128];\n  char *yymsg = yymsgbuf;\n  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;\n#endif\n\n  /* Three stacks and their tools:\n     `yyss': related to states,\n     `yyvs': related to semantic values,\n     `yyls': related to locations.\n\n     Refer to the stacks thru separate pointers, to allow yyoverflow\n     to reallocate them elsewhere.  */\n\n  /* The state stack.  */\n  yytype_int16 yyssa[YYINITDEPTH];\n  yytype_int16 *yyss = yyssa;\n  yytype_int16 *yyssp;\n\n  /* The semantic value stack.  */\n  YYSTYPE yyvsa[YYINITDEPTH];\n  YYSTYPE *yyvs = yyvsa;\n  YYSTYPE *yyvsp;\n\n\n\n#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))\n\n  YYSIZE_T yystacksize = YYINITDEPTH;\n\n  /* The variables used to return semantic value and location from the\n     action routines.  */\n  YYSTYPE yyval;\n\n\n  /* The number of symbols on the RHS of the reduced rule.\n     Keep to zero when no symbol should be popped.  */\n  int yylen = 0;\n\n  YYDPRINTF ((stderr, \"Starting parse\\n\"));\n\n  yystate = 0;\n  yyerrstatus = 0;\n  yynerrs = 0;\n  yychar = YYEMPTY;\t\t/* Cause a token to be read.  */\n\n  /* Initialize stack pointers.\n     Waste one element of value and location stack\n     so that they stay on the same level as the state stack.\n     The wasted elements are never initialized.  */\n\n  yyssp = yyss;\n  yyvsp = yyvs;\n\n  goto yysetstate;\n\n/*------------------------------------------------------------.\n| yynewstate -- Push a new state, which is found in yystate.  |\n`------------------------------------------------------------*/\n yynewstate:\n  /* In all cases, when you get here, the value and location stacks\n     have just been pushed.  So pushing a state here evens the stacks.  */\n  yyssp++;\n\n yysetstate:\n  *yyssp = yystate;\n\n  if (yyss + yystacksize - 1 <= yyssp)\n    {\n      /* Get the current used size of the three stacks, in elements.  */\n      YYSIZE_T yysize = yyssp - yyss + 1;\n\n#ifdef yyoverflow\n      {\n\t/* Give user a chance to reallocate the stack.  Use copies of\n\t   these so that the &'s don't force the real ones into\n\t   memory.  */\n\tYYSTYPE *yyvs1 = yyvs;\n\tyytype_int16 *yyss1 = yyss;\n\n\n\t/* Each stack pointer address is followed by the size of the\n\t   data in use in that stack, in bytes.  This used to be a\n\t   conditional around just the two extra args, but that might\n\t   be undefined if yyoverflow is a macro.  */\n\tyyoverflow (YY_(\"memory exhausted\"),\n\t\t    &yyss1, yysize * sizeof (*yyssp),\n"
}