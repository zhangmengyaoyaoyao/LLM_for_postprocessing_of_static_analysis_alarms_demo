{
    "Project": "bash",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "lib/readline/histexpand.c",
    "message": "Offset: [min(1, `mb.strlen`), max(16, `mb.strlen`)] Size: 16.",
    "warning_function_name": "history_expand",
    "warning_line": "ADD_STRING (mb);",
    "warning_context": "\t\tcontinue;\n\t      /* If the calling application has set\n\t\t history_inhibit_expansion_function to a function that checks\n\t\t for special cases that should not be history expanded,\n\t\t call the function and skip the expansion if it returns a\n\t\t non-zero value. */\n\t      else if (history_inhibit_expansion_function &&\n\t\t\t(*history_inhibit_expansion_function) (string, i))\n\t\tcontinue;\n\t      else\n\t\tbreak;\n\t    }\n\t  /* Shell-like quoting: allow backslashes to quote double quotes\n\t     inside a double-quoted string. */\n\t  else if (dquote && string[i] == '\\\\' && cc == '\"')\n\t    i++;\n\t  /* More shell-like quoting:  if we're paying attention to single\n\t     quotes and letting them quote the history expansion character,\n\t     then we need to pay attention to double quotes, because single\n\t     quotes are not special inside double-quoted strings. */\n\t  else if (history_quotes_inhibit_expansion && string[i] == '\"')\n\t    {\n\t      dquote = 1 - dquote;\n\t    }\n\t  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\\'')\n\t    {\n\t      /* If this is bash, single quotes inhibit history expansion. */\n\t      flag = (i > 0 && string[i - 1] == '$');\n\t      i++;\n\t      hist_string_extract_single_quoted (string, &i, flag);\n\t    }\n\t  else if (history_quotes_inhibit_expansion && string[i] == '\\\\')\n\t    {\n\t      /* If this is bash, allow backslashes to quote single\n\t\t quotes and the history expansion character. */\n\t      if (cc == '\\'' || cc == history_expansion_char)\n\t\ti++;\n\t    }\n\t  \n\t}\n\t  \n      if (string[i] != history_expansion_char)\n\t{\n\t  xfree (result);\n\t  *output = savestring (string);\n\t  return (0);\n\t}\n    }\n\n  /* Extract and perform the substitution. */\n  for (passc = dquote = squote = i = j = 0; i < l; i++)\n    {\n      int qc, tchar = string[i];\n\n      if (passc)\n\t{\n\t  passc = 0;\n\t  ADD_CHAR (tchar);\n\t  continue;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  int k, c;\n\n\t  c = tchar;\n\t  memset (mb, 0, sizeof (mb));\n\t  for (k = 0; k < MB_LEN_MAX; k++)\n\t    {\n\t      mb[k] = (char)c;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t      if (_rl_get_char_len (mb, &ps) == -2)\n\t\tc = string[++i];\n\t      else\n\t\tbreak;\n\t    }\n\t  if (strlen (mb) > 1)\n\t    {\n\t      ADD_STRING (mb);\n\t      continue;\n\t    }\n\t}\n#endif /* HANDLE_MULTIBYTE */\n\n      if (tchar == history_expansion_char)\n\ttchar = -3;\n      else if (tchar == history_comment_char)\n\ttchar = -2;\n\n      switch (tchar)\n\t{\n\tdefault:\n\t  ADD_CHAR (string[i]);\n\t  break;\n\n\tcase '\\\\':\n\t  passc++;\n\t  ADD_CHAR (tchar);\n\t  break;\n\n"
}