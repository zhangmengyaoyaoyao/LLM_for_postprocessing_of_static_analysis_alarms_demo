{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from addr.section was never initialized.",
    "Code_line": "\t  && addr.section == SHN_UNDEF && addr.offset == 0",
    "Code_function": "decode_arm_unwind (struct arm_unw_aux_info *  aux,\n\t\t   unsigned int               word,\n\t\t   unsigned int               remaining,\n\t\t   bfd_vma                    data_offset,\n\t\t   Elf_Internal_Shdr *        data_sec,\n\t\t   struct arm_section *       data_arm_sec)\n{\n  int per_index;\n  unsigned int more_words = 0;\n  struct absaddr addr;\n  bfd_vma sym_name = (bfd_vma) -1;\n\n  if (remaining == 0)\n    {\n      /* Fetch the first word.\n\t Note - when decoding an object file the address extracted\n\t here will always be 0.  So we also pass in the sym_name\n\t parameter so that we can find the symbol associated with\n\t the personality routine.  */\n      if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset,\n\t\t\t\t     & word, & addr, & sym_name))\n\treturn;\n\n      remaining = 4;\n    }\n\n  if ((word & 0x80000000) == 0)\n    {\n      /* Expand prel31 for personality routine.  */\n      bfd_vma fn;\n      const char *procname;\n\n      fn = arm_expand_prel31 (word, data_sec->sh_addr + data_offset);\n      printf (_(\"  Personality routine: \"));\n      if (fn == 0\n\t  && addr.section == SHN_UNDEF && addr.offset == 0\n\t  && sym_name != (bfd_vma) -1 && sym_name < aux->strtab_size)\n\t{\n\t  procname = aux->strtab + sym_name;\n\t  print_vma (fn, PREFIX_HEX);\n\t  if (procname)\n\t    {\n\t      fputs (\" <\", stdout);\n\t      fputs (procname, stdout);\n\t      fputc ('>', stdout);\n\t    }\n\t}\n      else\n\tprocname = arm_print_vma_and_name (aux, fn, addr);\n      fputc ('\\n', stdout);\n\n      /* The GCC personality routines use the standard compact\n\t encoding, starting with one byte giving the number of\n\t words.  */\n      if (procname != NULL\n\t  && (const_strneq (procname, \"__gcc_personality_v0\")\n\t      || const_strneq (procname, \"__gxx_personality_v0\")\n\t      || const_strneq (procname, \"__gcj_personality_v0\")\n\t      || const_strneq (procname, \"__gnu_objc_personality_v0\")))\n\t{\n\t  remaining = 0;\n\t  more_words = 1;\n\t  ADVANCE;\n\t  if (!remaining)\n\t    {\n\t      printf (_(\"  [Truncated data]\\n\"));\n\t      return;\n\t    }\n\t  more_words = word >> 24;\n\t  word <<= 8;\n\t  remaining--;\n\t  per_index = -1;\n\t}\n      else\n\treturn;\n    }\n  else\n    {\n      /* ARM EHABI Section 6.3:\n\n\t An exception-handling table entry for the compact model looks like:\n\n           31 30-28 27-24 23-0\n\t   -- ----- ----- ----\n            1   0   index Data for personalityRoutine[index]    */\n\n      if (elf_header.e_machine == EM_ARM\n\t  && (word & 0x70000000))\n\twarn (_(\"Corrupt ARM compact model table entry: %x \\n\"), word);\n\n      per_index = (word >> 24) & 0x7f;\n      printf (_(\"  Compact model index: %d\\n\"), per_index);\n      if (per_index == 0)\n\t{\n\t  more_words = 0;\n\t  word <<= 8;\n\t  remaining--;\n\t}\n      else if (per_index < 3)\n\t{\n\t  more_words = (word >> 16) & 0xff;\n\t  word <<= 16;\n\t  remaining -= 2;\n\t}\n    }\n\n  switch (elf_header.e_machine)\n    {\n    case EM_ARM:\n      if (per_index < 3)\n\t{\n\t  decode_arm_unwind_bytecode (aux, word, remaining, more_words,\n\t\t\t\t      data_offset, data_sec, data_arm_sec);\n\t}\n      else\n\t{\n\t  warn (_(\"Unknown ARM compact model index encountered\\n\"));\n\t  printf (_(\"  [reserved]\\n\"));\n\t}\n      break;\n\n    case EM_TI_C6000:\n      if (per_index < 3)\n\t{\n\t  decode_tic6x_unwind_bytecode (aux, word, remaining, more_words,\n\t\t\t\t\tdata_offset, data_sec, data_arm_sec);\n\t}\n      else if (per_index < 5)\n\t{\n\t  if (((word >> 17) & 0x7f) == 0x7f)\n\t    printf (_(\"  Restore stack from frame pointer\\n\"));\n\t  else\n\t    printf (_(\"  Stack increment %d\\n\"), (word >> 14) & 0x1fc);\n\t  printf (_(\"  Registers restored: \"));\n\t  if (per_index == 4)\n\t    printf (\" (compact) \");\n\t  decode_tic6x_unwind_regmask ((word >> 4) & 0x1fff);\n\t  putchar ('\\n');\n\t  printf (_(\"  Return register: %s\\n\"),\n\t\t  tic6x_unwind_regnames[word & 0xf]);\n\t}\n      else\n\tprintf (_(\"  [reserved (%d)]\\n\"), per_index);\n      break;\n\n    default:\n      error (_(\"Unsupported architecture type %d encountered when decoding unwind table\\n\"),\n\t     elf_header.e_machine);\n    }\n\n  /* Decode the descriptors.  Not implemented.  */\n}"
}