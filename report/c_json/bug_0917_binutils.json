{
    "project": "binutils",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "bfd/elflink.c",
    "message": "pointer `reldata` last assigned on line 10259 could be null and is dereferenced at line 10264, column 18.",
    "warning_function_name": "elf_reloc_link_order",
    "warning_line": "rel_hash_ptr = reldata->hashes + reldata->count;",
    "warning_context": "static bfd_boolean\nelf_reloc_link_order (bfd *output_bfd,\n\t\t      struct bfd_link_info *info,\n\t\t      asection *output_section,\n\t\t      struct bfd_link_order *link_order)\n{\n  reloc_howto_type *howto;\n  long indx;\n  bfd_vma offset;\n  bfd_vma addend;\n  struct bfd_elf_section_reloc_data *reldata;\n  struct elf_link_hash_entry **rel_hash_ptr;\n  Elf_Internal_Shdr *rel_hdr;\n  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);\n  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];\n  bfd_byte *erel;\n  unsigned int i;\n  struct bfd_elf_section_data *esdo = elf_section_data (output_section);\n\n  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);\n  if (howto == NULL)\n    {\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  addend = link_order->u.reloc.p->addend;\n\n  if (esdo->rel.hdr)\n    reldata = &esdo->rel;\n  else if (esdo->rela.hdr)\n    reldata = &esdo->rela;\n  else\n    {\n      reldata = NULL;\n      BFD_ASSERT (0);\n    }\n\n  /* Figure out the symbol index.  */\n  rel_hash_ptr = reldata->hashes + reldata->count;\n  if (link_order->type == bfd_section_reloc_link_order)\n    {\n      indx = link_order->u.reloc.p->u.section->target_index;\n      BFD_ASSERT (indx != 0);\n      *rel_hash_ptr = NULL;\n    }\n  else\n    {\n      struct elf_link_hash_entry *h;\n\n      /* Treat a reloc against a defined symbol as though it were\n\t actually against the section.  */\n      h = ((struct elf_link_hash_entry *)\n\t   bfd_wrapped_link_hash_lookup (output_bfd, info,\n\t\t\t\t\t link_order->u.reloc.p->u.name,\n\t\t\t\t\t FALSE, FALSE, TRUE));\n      if (h != NULL\n\t  && (h->root.type == bfd_link_hash_defined\n\t      || h->root.type == bfd_link_hash_defweak))\n\t{\n\t  asection *section;\n\n\t  section = h->root.u.def.section;\n\t  indx = section->output_section->target_index;\n\t  *rel_hash_ptr = NULL;\n\t  /* It seems that we ought to add the symbol value to the\n\t     addend here, but in practice it has already been added\n\t     because it was passed to constructor_callback.  */\n\t  addend += section->output_section->vma + section->output_offset;\n\t}\n      else if (h != NULL)\n\t{\n\t  /* Setting the index to -2 tells elf_link_output_extsym that\n\t     this symbol is used by a reloc.  */\n\t  h->indx = -2;\n\t  *rel_hash_ptr = h;\n\t  indx = 0;\n\t}\n      else\n\t{\n\t  if (! ((*info->callbacks->unattached_reloc)\n\t\t (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))\n\t    return FALSE;\n\t  indx = 0;\n\t}\n    }\n\n  /* If this is an inplace reloc, we must write the addend into the\n     object file.  */\n  if (howto->partial_inplace && addend != 0)\n    {\n      bfd_size_type size;\n      bfd_reloc_status_type rstat;\n      bfd_byte *buf;\n      bfd_boolean ok;\n      const char *sym_name;\n\n      size = (bfd_size_type) bfd_get_reloc_size (howto);\n      buf = (bfd_byte *) bfd_zmalloc (size);\n      if (buf == NULL && size != 0)\n\treturn FALSE;\n"
}