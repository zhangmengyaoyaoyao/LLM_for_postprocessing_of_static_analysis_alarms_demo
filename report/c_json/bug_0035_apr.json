{
    "project": "apr",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "tables/apr_skiplist.c",
    "message": "Access to field 'data' results in a dereference of a null pointer (loaded from variable 'ret')",
    "warning_function_name": "apr_skiplist_insert_compare",
    "warning_line": "ni = apr_skiplist_insert_compare(sli, ret->data, sli->compare);",
    "warning_context": "                /* Keep the existing element(s) */\n                skiplist_qclear(&sl->stack_q);\n                return NULL;\n            }\n            if (compared > 0) {\n                m = m->next;\n                continue;\n            }\n        }\n        if (ch <= nh) {\n            /* push on stack */\n            skiplist_qpush(&sl->stack_q, m);\n        }\n        m = m->down;\n        ch--;\n    }\n    /* Pop the stack and insert nodes */\n    p = NULL;\n    while ((m = skiplist_qpop(&sl->stack_q))) {\n        tmp = skiplist_new_node(sl);\n        tmp->next = m->next;\n        if (m->next) {\n            m->next->prev = tmp;\n        }\n        m->next = tmp;\n        tmp->prev = m;\n        tmp->up = NULL;\n        tmp->nextindex = tmp->previndex = NULL;\n        tmp->down = p;\n        if (p) {\n            p->up = tmp;\n        }\n        else {\n            /* This sets ret to the bottom-most node we are inserting */\n            ret = tmp;\n        }\n        tmp->data = data;\n        tmp->sl = sl;\n        p = tmp;\n    }\n\n    /* Now we are sure the node is inserted, grow our tree to 'nh' tall */\n    for (; sl->height < nh; sl->height++) {\n        m = skiplist_new_node(sl);\n        tmp = skiplist_new_node(sl);\n        m->up = m->prev = m->nextindex = m->previndex = NULL;\n        m->next = tmp;\n        m->down = sl->top;\n        m->data = NULL;\n        m->sl = sl;\n        if (sl->top) {\n            sl->top->up = m;\n        }\n        else {\n            sl->bottom = sl->bottomend = m;\n        }\n        sl->top = sl->topend = tmp->prev = m;\n        tmp->up = tmp->next = tmp->nextindex = tmp->previndex = NULL;\n        tmp->down = p;\n        tmp->data = data;\n        tmp->sl = sl;\n        if (p) {\n            p->up = tmp;\n        }\n        else {\n            /* This sets ret to the bottom-most node we are inserting */\n            ret = tmp;\n        }\n        p = tmp;\n    }\n    if (sl->index != NULL) {\n        /*\n         * this is a external insertion, we must insert into each index as\n         * well\n         */\n        apr_skiplistnode *ni, *li;\n        li = ret;\n        for (p = apr_skiplist_getlist(sl->index); p; apr_skiplist_next(sl->index, &p)) {\n            apr_skiplist *sli = (apr_skiplist *)p->data;\n            ni = apr_skiplist_insert_compare(sli, ret->data, sli->compare);\n            li->nextindex = ni;\n            ni->previndex = li;\n            li = ni;\n        }\n    }\n    sl->size++;\n    return ret;\n}\n\nAPR_DECLARE(apr_skiplistnode *) apr_skiplist_insert(apr_skiplist *sl, void *data)\n{\n    return apr_skiplist_insert_compare(sl, data, sl->compare);\n}\n\n#if 0\nvoid skiplist_print_struct(apr_skiplist * sl, char *prefix)\n{\n    apr_skiplistnode *p, *q;\n    fprintf(stderr, \"Skiplist Structure (height: %d)\\n\", sl->height);\n    p = sl->bottom;\n    while (p) {\n"
}