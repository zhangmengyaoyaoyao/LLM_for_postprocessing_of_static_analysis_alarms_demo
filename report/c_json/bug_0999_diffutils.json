{
    "Project": "diffutils",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/diffseq.h",
    "message": "The value read from bxbest was never initialized.",
    "warning_function_name": "diag",
    "warning_line": "part->xmid = bxbest;",
    "warning_context": "                           that it end with a significant snake.  */\n                        int k;\n\n                        for (k = 0; XREF_YREF_EQUAL (x + k, y + k); k++)\n                          if (k == SNAKE_LIMIT - 1)\n                            {\n                              best = v;\n                              part->xmid = x;\n                              part->ymid = y;\n                              break;\n                            }\n                      }\n                  }\n              }\n            if (best > 0)\n              {\n                part->lo_minimal = false;\n                part->hi_minimal = true;\n                return;\n              }\n          }\n        }\n#endif /* USE_HEURISTIC */\n\n      /* Heuristic: if we've gone well beyond the call of duty, give up\n         and report halfway between our best results so far.  */\n      if (c >= ctxt->too_expensive)\n        {\n          OFFSET fxybest;\n          OFFSET fxbest IF_LINT (= 0);\n          OFFSET bxybest;\n          OFFSET bxbest IF_LINT (= 0);\n\n          /* Find forward diagonal that maximizes X + Y.  */\n          fxybest = -1;\n          for (d = fmax; d >= fmin; d -= 2)\n            {\n              OFFSET x = MIN (fd[d], xlim);\n              OFFSET y = x - d;\n              if (ylim < y)\n                {\n                  x = ylim + d;\n                  y = ylim;\n                }\n              if (fxybest < x + y)\n                {\n                  fxybest = x + y;\n                  fxbest = x;\n                }\n            }\n\n          /* Find backward diagonal that minimizes X + Y.  */\n          bxybest = OFFSET_MAX;\n          for (d = bmax; d >= bmin; d -= 2)\n            {\n              OFFSET x = MAX (xoff, bd[d]);\n              OFFSET y = x - d;\n              if (y < yoff)\n                {\n                  x = yoff + d;\n                  y = yoff;\n                }\n              if (x + y < bxybest)\n                {\n                  bxybest = x + y;\n                  bxbest = x;\n                }\n            }\n\n          /* Use the better of the two diagonals.  */\n          if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff))\n            {\n              part->xmid = fxbest;\n              part->ymid = fxybest - fxbest;\n              part->lo_minimal = true;\n              part->hi_minimal = false;\n            }\n          else\n            {\n              part->xmid = bxbest;\n              part->ymid = bxybest - bxbest;\n              part->lo_minimal = false;\n              part->hi_minimal = true;\n            }\n          return;\n        }\n    }\n  #undef XREF_YREF_EQUAL\n}\n\n\n/* Compare in detail contiguous subsequences of the two vectors\n   which are known, as a whole, to match each other.\n\n   The subsequence of vector 0 is [XOFF, XLIM) and likewise for vector 1.\n\n   Note that XLIM, YLIM are exclusive bounds.  All indices into the vectors\n   are origin-0.\n\n   If FIND_MINIMAL, find a minimal difference no matter how\n   expensive it is.\n"
}