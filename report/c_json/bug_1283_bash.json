{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      rhs_v = tr;",
    "Code_function": "expand_seqterm (text, tlen)\n     char *text;\n     size_t tlen;\n{\n  char *t, *lhs, *rhs;\n  int i, lhs_t, rhs_t, lhs_l, rhs_l, width;\n  intmax_t lhs_v, rhs_v, incr;\n  intmax_t tl, tr;\n  char **result, *ep, *oep;\n\n  t = strstr (text, BRACE_SEQ_SPECIFIER);\n  if (t == 0)\n    return ((char **)NULL);\n\n  lhs_l = t - text;\t\t/* index of start of BRACE_SEQ_SPECIFIER */\n  lhs = substring (text, 0, lhs_l);\n  rhs = substring (text, lhs_l + sizeof(BRACE_SEQ_SPECIFIER) - 1, tlen);\n\n  if (lhs[0] == 0 || rhs[0] == 0)\n    {\n      free (lhs);\n      free (rhs);\n      return ((char **)NULL);\n    }\n\n  /* Now figure out whether LHS and RHS are integers or letters.  Both\n     sides have to match. */\n  lhs_t = (legal_number (lhs, &tl)) ? ST_INT :\n  \t\t((ISALPHA (lhs[0]) && lhs[1] == 0) ?  ST_CHAR : ST_BAD);\n\n  /* Decide on rhs and whether or not it looks like the user specified\n     an increment */\n  ep = 0;\n  if (ISDIGIT (rhs[0]) || ((rhs[0] == '+' || rhs[0] == '-') && ISDIGIT (rhs[1])))\n    {\n      rhs_t = ST_INT;\n      errno = 0;\n      tr = strtoimax (rhs, &ep, 10);\n      if (errno == ERANGE || (ep && *ep != 0 && *ep != '.'))\n\trhs_t = ST_BAD;\t\t\t/* invalid */\n    }\n  else if (ISALPHA (rhs[0]) && (rhs[1] == 0 || rhs[1] == '.'))\n    {\n      rhs_t = ST_CHAR;\n      ep = rhs + 1;\n    }\n  else\n    {\n      rhs_t = ST_BAD;\n      ep = 0;\n    }\n\n  incr = 1;\n  if (rhs_t != ST_BAD)\n    {\n      oep = ep;\n      errno = 0;\n      if (ep && *ep == '.' && ep[1] == '.' && ep[2])\n\tincr = strtoimax (ep + 2, &ep, 10);\n      if (*ep != 0 || errno == ERANGE)\n\trhs_t = ST_BAD;\t\t\t/* invalid incr or overflow */\n      tlen -= ep - oep;\n    }\n\n  if (lhs_t != rhs_t || lhs_t == ST_BAD || rhs_t == ST_BAD)\n    {\n      free (lhs);\n      free (rhs);\n      return ((char **)NULL);\n    }\n\n  /* OK, we have something.  It's either a sequence of integers, ascending\n     or descending, or a sequence or letters, ditto.  Generate the sequence,\n     put it into a string vector, and return it. */\n\n  if (lhs_t == ST_CHAR)\n    {\n      lhs_v = (unsigned char)lhs[0];\n      rhs_v = (unsigned char)rhs[0];\n      width = 1;\n    }\n  else\n    {\n      lhs_v = tl;\t\t/* integer truncation */\n      rhs_v = tr;\n\n      /* Decide whether or not the terms need zero-padding */\n      rhs_l = tlen - lhs_l - sizeof (BRACE_SEQ_SPECIFIER) + 1;\n      width = 0;\n      if (lhs_l > 1 && lhs[0] == '0')\n\twidth = lhs_l, lhs_t = ST_ZINT;\n      if (lhs_l > 2 && lhs[0] == '-' && lhs[1] == '0')\n\twidth = lhs_l, lhs_t = ST_ZINT;\n      if (rhs_l > 1 && rhs[0] == '0' && width < rhs_l)\n\twidth = rhs_l, lhs_t = ST_ZINT;\n      if (rhs_l > 2 && rhs[0] == '-' && rhs[1] == '0' && width < rhs_l)\n\twidth = rhs_l, lhs_t = ST_ZINT;\n\n      if (width < lhs_l && lhs_t == ST_ZINT)\n        width = lhs_l;\n      if (width < rhs_l && lhs_t == ST_ZINT)\n        width = rhs_l;\n    }\n\n  result = mkseq (lhs_v, rhs_v, incr, lhs_t, width);\n\n  free (lhs);\n  free (rhs);\n\n  return (result);\n}"
}