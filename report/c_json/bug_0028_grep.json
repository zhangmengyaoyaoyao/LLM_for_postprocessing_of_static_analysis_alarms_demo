{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [-1, +oo] Size: 3.",
    "Code_line": "        directories = XARGMATCH (\"--directories\", optarg,",
    "Code_function": "main (int argc, char **argv)\n{\n  char *keys;\n  size_t keycc, oldcc, keyalloc;\n  bool with_filenames, ok;\n  size_t cc;\n  int opt, prepended;\n  int prev_optind, last_recursive;\n  int fread_errno;\n  intmax_t default_context;\n  FILE *fp;\n  exit_failure = EXIT_TROUBLE;\n  initialize_main (&argc, &argv);\n  set_program_name (argv[0]);\n  program_name = argv[0];\n\n  keys = NULL;\n  keycc = 0;\n  with_filenames = false;\n  eolbyte = '\\n';\n  filename_mask = ~0;\n\n  max_count = INTMAX_MAX;\n\n  /* The value -1 means to use DEFAULT_CONTEXT. */\n  out_after = out_before = -1;\n  /* Default before/after context: changed by -C/-NUM options */\n  default_context = -1;\n  /* Changed by -o option */\n  only_matching = false;\n\n  /* Internationalization. */\n#if defined HAVE_SETLOCALE\n  setlocale (LC_ALL, \"\");\n#endif\n#if defined ENABLE_NLS\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n#endif\n\n  exit_failure = EXIT_TROUBLE;\n  atexit (clean_up_stdout);\n\n  last_recursive = 0;\n\n  prepended = prepend_default_options (getenv (\"GREP_OPTIONS\"), &argc, &argv);\n  if (prepended)\n    error (0, 0, _(\"warning: GREP_OPTIONS is deprecated;\"\n                   \" please use an alias or script\"));\n\n  compile = matchers[0].compile;\n  execute = matchers[0].execute;\n\n  while (prev_optind = optind,\n         (opt = get_nondigit_option (argc, argv, &default_context)) != -1)\n    switch (opt)\n      {\n      case 'A':\n        context_length_arg (optarg, &out_after);\n        break;\n\n      case 'B':\n        context_length_arg (optarg, &out_before);\n        break;\n\n      case 'C':\n        /* Set output match context, but let any explicit leading or\n           trailing amount specified with -A or -B stand. */\n        context_length_arg (optarg, &default_context);\n        break;\n\n      case 'D':\n        if (STREQ (optarg, \"read\"))\n          devices = READ_DEVICES;\n        else if (STREQ (optarg, \"skip\"))\n          devices = SKIP_DEVICES;\n        else\n          error (EXIT_TROUBLE, 0, _(\"unknown devices method\"));\n        break;\n\n      case 'E':\n        setmatcher (\"egrep\");\n        break;\n\n      case 'F':\n        setmatcher (\"fgrep\");\n        break;\n\n      case 'P':\n        setmatcher (\"perl\");\n        break;\n\n      case 'G':\n        setmatcher (\"grep\");\n        break;\n\n      case 'X': /* undocumented on purpose */\n        setmatcher (optarg);\n        break;\n\n      case 'H':\n        with_filenames = true;\n        no_filenames = false;\n        break;\n\n      case 'I':\n        binary_files = WITHOUT_MATCH_BINARY_FILES;\n        break;\n\n      case 'T':\n        align_tabs = true;\n        break;\n\n      case 'U':\n        dos_binary ();\n        break;\n\n      case 'u':\n        dos_unix_byte_offsets ();\n        break;\n\n      case 'V':\n        show_version = true;\n        break;\n\n      case 'a':\n        binary_files = TEXT_BINARY_FILES;\n        break;\n\n      case 'b':\n        out_byte = true;\n        break;\n\n      case 'c':\n        count_matches = true;\n        break;\n\n      case 'd':\n        directories = XARGMATCH (\"--directories\", optarg,\n                                 directories_args, directories_types);\n        if (directories == RECURSE_DIRECTORIES)\n          last_recursive = prev_optind;\n        break;\n\n      case 'e':\n        cc = strlen (optarg);\n        keys = xrealloc (keys, keycc + cc + 1);\n        strcpy (&keys[keycc], optarg);\n        keycc += cc;\n        keys[keycc++] = '\\n';\n        break;\n\n      case 'f':\n        fp = STREQ (optarg, \"-\") ? stdin : fopen (optarg, O_TEXT ? \"rt\" : \"r\");\n        if (!fp)\n          error (EXIT_TROUBLE, errno, \"%s\", optarg);\n        for (keyalloc = 1; keyalloc <= keycc + 1; keyalloc *= 2)\n          ;\n        keys = xrealloc (keys, keyalloc);\n        oldcc = keycc;\n        while ((cc = fread (keys + keycc, 1, keyalloc - 1 - keycc, fp)) != 0)\n          {\n            keycc += cc;\n            if (keycc == keyalloc - 1)\n              keys = x2nrealloc (keys, &keyalloc, sizeof *keys);\n          }\n        fread_errno = errno;\n        if (ferror (fp))\n          error (EXIT_TROUBLE, fread_errno, \"%s\", optarg);\n        if (fp != stdin)\n          fclose (fp);\n        /* Append final newline if file ended in non-newline. */\n        if (oldcc != keycc && keys[keycc - 1] != '\\n')\n          keys[keycc++] = '\\n';\n        break;\n\n      case 'h':\n        with_filenames = false;\n        no_filenames = true;\n        break;\n\n      case 'i':\n      case 'y':\t\t\t/* For old-timers . . . */\n        match_icase = true;\n        break;\n\n      case 'L':\n        /* Like -l, except list files that don't contain matches.\n           Inspired by the same option in Hume's gre. */\n        list_files = -1;\n        break;\n\n      case 'l':\n        list_files = 1;\n        break;\n\n      case 'm':\n        switch (xstrtoimax (optarg, 0, 10, &max_count, \"\"))\n          {\n          case LONGINT_OK:\n          case LONGINT_OVERFLOW:\n            break;\n\n          default:\n            error (EXIT_TROUBLE, 0, _(\"invalid max count\"));\n          }\n        break;\n\n      case 'n':\n        out_line = true;\n        break;\n\n      case 'o':\n        only_matching = true;\n        break;\n\n      case 'q':\n        exit_on_match = true;\n        exit_failure = 0;\n        break;\n\n      case 'R':\n        fts_options = basic_fts_options | FTS_LOGICAL;\n        /* Fall through.  */\n      case 'r':\n        directories = RECURSE_DIRECTORIES;\n        last_recursive = prev_optind;\n        break;\n\n      case 's':\n        suppress_errors = true;\n        break;\n\n      case 'v':\n        out_invert = true;\n        break;\n\n      case 'w':\n        match_words = true;\n        break;\n\n      case 'x':\n        match_lines = true;\n        break;\n\n      case 'Z':\n        filename_mask = 0;\n        break;\n\n      case 'z':\n        eolbyte = '\\0';\n        break;\n\n      case BINARY_FILES_OPTION:\n        if (STREQ (optarg, \"binary\"))\n          binary_files = BINARY_BINARY_FILES;\n        else if (STREQ (optarg, \"text\"))\n          binary_files = TEXT_BINARY_FILES;\n        else if (STREQ (optarg, \"without-match\"))\n          binary_files = WITHOUT_MATCH_BINARY_FILES;\n        else\n          error (EXIT_TROUBLE, 0, _(\"unknown binary-files type\"));\n        break;\n\n      case COLOR_OPTION:\n        if (optarg)\n          {\n            if (!strcasecmp (optarg, \"always\") || !strcasecmp (optarg, \"yes\")\n                || !strcasecmp (optarg, \"force\"))\n              color_option = 1;\n            else if (!strcasecmp (optarg, \"never\") || !strcasecmp (optarg, \"no\")\n                     || !strcasecmp (optarg, \"none\"))\n              color_option = 0;\n            else if (!strcasecmp (optarg, \"auto\") || !strcasecmp (optarg, \"tty\")\n                     || !strcasecmp (optarg, \"if-tty\"))\n              color_option = 2;\n            else\n              show_help = 1;\n          }\n        else\n          color_option = 2;\n        break;\n\n      case EXCLUDE_OPTION:\n      case INCLUDE_OPTION:\n        if (!excluded_patterns)\n          excluded_patterns = new_exclude ();\n        add_exclude (excluded_patterns, optarg,\n                     (EXCLUDE_WILDCARDS\n                      | (opt == INCLUDE_OPTION ? EXCLUDE_INCLUDE : 0)));\n        break;\n      case EXCLUDE_FROM_OPTION:\n        if (!excluded_patterns)\n          excluded_patterns = new_exclude ();\n        if (add_exclude_file (add_exclude, excluded_patterns, optarg,\n                              EXCLUDE_WILDCARDS, '\\n') != 0)\n          {\n            error (EXIT_TROUBLE, errno, \"%s\", optarg);\n          }\n        break;\n\n      case EXCLUDE_DIRECTORY_OPTION:\n        if (!excluded_directory_patterns)\n          excluded_directory_patterns = new_exclude ();\n        strip_trailing_slashes (optarg);\n        add_exclude (excluded_directory_patterns, optarg, EXCLUDE_WILDCARDS);\n        break;\n\n      case GROUP_SEPARATOR_OPTION:\n        group_separator = optarg;\n        break;\n\n      case LINE_BUFFERED_OPTION:\n        line_buffered = true;\n        break;\n\n      case LABEL_OPTION:\n        label = optarg;\n        break;\n\n      case 0:\n        /* long options */\n        break;\n\n      default:\n        usage (EXIT_TROUBLE);\n        break;\n\n      }\n\n  if (color_option == 2)\n    color_option = isatty (STDOUT_FILENO) && should_colorize ();\n  init_colorize ();\n\n  /* POSIX says that -q overrides -l, which in turn overrides the\n     other output options.  */\n  if (exit_on_match)\n    list_files = 0;\n  if (exit_on_match | list_files)\n    {\n      count_matches = false;\n      done_on_match = true;\n    }\n  out_quiet = count_matches | done_on_match;\n\n  if (out_after < 0)\n    out_after = default_context;\n  if (out_before < 0)\n    out_before = default_context;\n\n  if (color_option)\n    {\n      /* Legacy.  */\n      char *userval = getenv (\"GREP_COLOR\");\n      if (userval != NULL && *userval != '\\0')\n        selected_match_color = context_match_color = userval;\n\n      /* New GREP_COLORS has priority.  */\n      parse_grep_colors ();\n    }\n\n  if (show_version)\n    {\n      version_etc (stdout, program_name, PACKAGE_NAME, VERSION, AUTHORS,\n                   (char *) NULL);\n      exit (EXIT_SUCCESS);\n    }\n\n  if (show_help)\n    usage (EXIT_SUCCESS);\n\n  struct stat tmp_stat;\n  if (fstat (STDOUT_FILENO, &tmp_stat) == 0 && S_ISREG (tmp_stat.st_mode))\n    out_stat = tmp_stat;\n\n  if (keys)\n    {\n      if (keycc == 0)\n        {\n          /* No keys were specified (e.g. -f /dev/null).  Match nothing.  */\n          out_invert ^= true;\n          match_lines = match_words = false;\n        }\n      else\n        /* Strip trailing newline. */\n        --keycc;\n    }\n  else if (optind < argc)\n    {\n      /* A copy must be made in case of an xrealloc() or free() later.  */\n      keycc = strlen (argv[optind]);\n      keys = xmemdup (argv[optind++], keycc + 1);\n    }\n  else\n    usage (EXIT_TROUBLE);\n\n  build_mbclen_cache ();\n  init_easy_encoding ();\n\n  /* If fgrep in a multibyte locale, then use grep if either\n     (1) case is ignored (where grep is typically faster), or\n     (2) the pattern has an encoding error (where fgrep might not work).  */\n  if (compile == Fcompile && MB_CUR_MAX > 1\n      && (match_icase || contains_encoding_error (keys, keycc)))\n    {\n      size_t new_keycc;\n      char *new_keys;\n      fgrep_to_grep_pattern (keycc, keys, &new_keycc, &new_keys);\n      free (keys);\n      keys = new_keys;\n      keycc = new_keycc;\n      matcher = \"grep\";\n      compile = Gcompile;\n      execute = EGexecute;\n    }\n\n  compile (keys, keycc);\n  free (keys);\n  /* We need one byte prior and one after.  */\n  char eolbytes[3] = { 0, eolbyte, 0 };\n  size_t match_size;\n  skip_empty_lines = ((execute (eolbytes + 1, 1, &match_size, NULL) == 0)\n                      == out_invert);\n\n  if ((argc - optind > 1 && !no_filenames) || with_filenames)\n    out_file = 1;\n\n#ifdef SET_BINARY\n  /* Output is set to binary mode because we shouldn't convert\n     NL to CR-LF pairs, especially when grepping binary files.  */\n  if (!isatty (1))\n    SET_BINARY (1);\n#endif\n\n  if (max_count == 0)\n    exit (EXIT_FAILURE);\n\n  if (fts_options & FTS_LOGICAL && devices == READ_COMMAND_LINE_DEVICES)\n    devices = READ_DEVICES;\n\n  if (optind < argc)\n    {\n      ok = true;\n      do\n        ok &= grep_command_line_arg (argv[optind]);\n      while (++optind < argc);\n    }\n  else if (directories == RECURSE_DIRECTORIES && prepended < last_recursive)\n    {\n      /* Grep through \".\", omitting leading \"./\" from diagnostics.  */\n      filename_prefix_len = 2;\n      ok = grep_command_line_arg (\".\");\n    }\n  else\n    ok = grep_command_line_arg (\"-\");\n\n  /* We register via atexit() to test stdout.  */\n  exit (errseen ? EXIT_TROUBLE : ok);\n}"
}