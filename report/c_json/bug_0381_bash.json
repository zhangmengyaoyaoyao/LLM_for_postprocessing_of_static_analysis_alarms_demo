{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "param_expand",
    "warning_line": "SADD_MBCHAR (temp, string, sindex, string_size);",
    "warning_context": "\t      /* Add NULL arg. */\n\t      c = CTLNUL;\n\t      sindex--;\t\t/* add_character: label increments sindex */\n\t      goto add_character;\n\t    }\n\n\t  /* break; */\n\n\tcase '\\'':\n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    goto add_character;\n\n\t  t_index = ++sindex;\n\t  temp = string_extract_single_quoted (string, &sindex);\n\n\t  /* If the entire STRING was surrounded by single quotes,\n\t     then the string is wholly quoted. */\n\t  quoted_state = (t_index == 1 && string[sindex] == '\\0')\n\t\t\t    ? WHOLLY_QUOTED\n\t\t\t    : PARTIALLY_QUOTED;\n\n\t  /* If all we had was '', it is a null expansion. */\n\t  if (*temp == '\\0')\n\t    {\n\t      free (temp);\n\t      temp = (char *)NULL;\n\t    }\n\t  else\n\t    remove_quoted_escapes (temp);\t/* ??? */\n\n\t  /* We do not want to add quoted nulls to strings that are only\n\t     partially quoted; such nulls are discarded. */\n\t  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED))\n\t    continue;\n\n\t  /* If we have a quoted null expansion, add a quoted NULL to istring. */\n\t  if (temp == 0)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\t\t/* add_character: label increments sindex */\n\t      goto add_character;\n\t    }\n\t  else\n\t    goto add_quoted_string;\n\n\t  /* break; */\n\n\tdefault:\n\t  /* This is the fix for \" $@ \" */\n\tadd_ifs_character:\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c)))\n\t    {\n\t      if (string[sindex])\t/* from old goto dollar_add_string */\n\t\tsindex++;\n\t      if (c == 0)\n\t\t{\n\t\t  c = CTLNUL;\n\t\t  goto add_character;\n\t\t}\n\t      else\n\t\t{\n#if HANDLE_MULTIBYTE\n\t\t  if (MB_CUR_MAX > 1)\n\t\t    sindex--;\n\n\t\t  if (MB_CUR_MAX > 1)\n\t\t    {\n\t\t      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);\n\t\t    }\n\t\t  else\n#endif\n\t\t    {\n\t\t      twochars[0] = CTLESC;\n\t\t      twochars[1] = c;\n\t\t      goto add_twochars;\n\t\t    }\n\t\t}\n\t    }\n\n\t  SADD_MBCHAR (temp, string, sindex, string_size);\n\n\tadd_character:\n\t  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,\n\t\t\t\t  DEFAULT_ARRAY_SIZE);\n\t  istring[istring_index++] = c;\n\t  istring[istring_index] = '\\0';\n\n\t  /* Next character. */\n\t  sindex++;\n\t}\n    }\n\nfinished_with_string:\n  /* OK, we're ready to return.  If we have a quoted string, and\n     quoted_dollar_at is not set, we do no splitting at all; otherwise\n     we split on ' '.  The routines that call this will handle what to\n     do if nothing has been expanded. */\n\n  /* Partially and wholly quoted strings which expand to the empty\n     string are retained as an empty arguments.  Unquoted strings\n     which expand to the empty string are discarded.  The single\n"
}