{
    "Project": "RIOT",
    "Tool": "Infer",
    "Bug Type": "Buffer Overrun L2",
    "Code_line": "                    break;",
    "Code_function": "static void _handle_nbr_sol(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6,\n                            const ndp_nbr_sol_t *nbr_sol, size_t icmpv6_len)\n{\n    size_t tmp_len = icmpv6_len - sizeof(ndp_nbr_sol_t);\n    int tgt_idx;\n    ndp_opt_t *opt;\n\n    /* check validity, see: https://tools.ietf.org/html/rfc4861#section-7.1.1 */\n    /* checksum is checked by GNRC's ICMPv6 module */\n    if ((ipv6->hl != NDP_HOP_LIMIT) || (nbr_sol->code != 0U) ||\n        (icmpv6_len < sizeof(ndp_nbr_sol_t)) ||\n        ipv6_addr_is_multicast(&nbr_sol->tgt) ||\n        (ipv6_addr_is_unspecified(&ipv6->src) &&\n         !ipv6_addr_is_solicited_node(&ipv6->dst))) {\n        DEBUG(\"nib: Received neighbor solicitation is invalid. Discarding silently\\n\");\n        DEBUG(\"     - IP Hop Limit: %u (should be %u)\\n\", ipv6->hl,\n              NDP_HOP_LIMIT);\n        DEBUG(\"     - ICMP code: %u (should be 0)\\n\", nbr_sol->code);\n        DEBUG(\"     - ICMP length: %u (should > %u)\\n\", (unsigned)icmpv6_len,\n              (unsigned)sizeof(ndp_nbr_sol_t));\n        DEBUG(\"     - Target address: %s (should not be multicast)\\n\",\n              ipv6_addr_to_str(addr_str, &nbr_sol->tgt, sizeof(addr_str)));\n        DEBUG(\"     - Source address: %s\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6->src, sizeof(addr_str)));\n        DEBUG(\"     - Destination address: %s (should be of format \"\n              \"ff02::1:ffxx:xxxx if source address is ::)\\n\",\n              ipv6_addr_to_str(addr_str, &ipv6->dst, sizeof(addr_str)));\n        return;\n    }\n    /* check if target is assigned only now in case the length was wrong */\n    tgt_idx = gnrc_netif_ipv6_addr_idx(netif, &nbr_sol->tgt);\n    if (tgt_idx < 0) {\n        DEBUG(\"nib: Target address %s is not assigned to the local interface\\n\",\n              ipv6_addr_to_str(addr_str, &nbr_sol->tgt, sizeof(addr_str)));\n        return;\n    }\n    /* pre-check option length */\n    FOREACH_OPT(nbr_sol, opt, tmp_len) {\n        if (tmp_len > icmpv6_len) {\n            DEBUG(\"nib: Payload length (%u) of NS doesn't align with options\\n\",\n                  (unsigned)icmpv6_len);\n            return;\n        }\n        if (opt->len == 0U) {\n            DEBUG(\"nib: Option of length 0 detected. \"\n                  \"Discarding neighbor solicitation silently\\n\");\n            return;\n        }\n    }\n    DEBUG(\"nib: Received valid neighbor solicitation:\\n\");\n    DEBUG(\"     - Target address: %s\\n\",\n          ipv6_addr_to_str(addr_str, &nbr_sol->tgt, sizeof(addr_str)));\n    DEBUG(\"     - Source address: %s\\n\",\n          ipv6_addr_to_str(addr_str, &ipv6->src, sizeof(addr_str)));\n    DEBUG(\"     - Destination address: %s\\n\",\n          ipv6_addr_to_str(addr_str, &ipv6->dst, sizeof(addr_str)));\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_SLAAC)\n    gnrc_netif_t *tgt_netif = gnrc_netif_get_by_ipv6_addr(&nbr_sol->tgt);\n\n    if (tgt_netif != NULL) {\n        int idx;\n\n        gnrc_netif_acquire(tgt_netif);\n        idx = gnrc_netif_ipv6_addr_idx(tgt_netif, &nbr_sol->tgt);\n        /* if idx < 0:\n         * nbr_sol->tgt was removed between getting tgt_netif by nbr_sol->tgt\n         * and gnrc_netif_acquire(tgt_netif). This is like `tgt_netif` would\n         * have been NULL in the first place so just continue as if it would\n         * have. */\n        if ((idx >= 0) && gnrc_netif_ipv6_addr_dad_trans(tgt_netif, idx)) {\n            if (!ipv6_addr_is_unspecified(&ipv6->src)) {\n                /* (see https://tools.ietf.org/html/rfc4862#section-5.4.3) */\n                DEBUG(\"nib: Neighbor is performing AR, but target address is \"\n                      \"still TENTATIVE for us => Ignoring NS\\n\");\n                gnrc_netif_release(tgt_netif);\n                return;\n            }\n            /* cancel validation timer */\n            evtimer_del(&_nib_evtimer,\n                        &tgt_netif->ipv6.addrs_timers[idx].event);\n            /* _remove_tentative_addr() context switches to `tgt_netif->pid` so\n             * release `tgt_netif`. We are done here anyway. */\n            gnrc_netif_release(tgt_netif);\n            _remove_tentative_addr(tgt_netif, &nbr_sol->tgt);\n            return;\n        }\n        gnrc_netif_release(tgt_netif);\n    }\n#endif  /* CONFIG_GNRC_IPV6_NIB_SLAAC */\n    if (ipv6_addr_is_unspecified(&ipv6->src)) {\n        gnrc_ndp_nbr_adv_send(&nbr_sol->tgt, netif, &ipv6->src, false, NULL);\n    }\n    else {\n        gnrc_pktsnip_t *reply_aro = NULL;\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR)\n        ndp_opt_t *sl2ao = NULL;\n        sixlowpan_nd_opt_ar_t *aro = NULL;\n#else   /* CONFIG_GNRC_IPV6_NIB_6LR */\n#define sl2ao   (NULL)\n#define aro     (NULL)\n#endif  /* CONFIG_GNRC_IPV6_NIB_6LR */\n        tmp_len = icmpv6_len - sizeof(ndp_nbr_sol_t);\n\n        if (!(netif->flags & GNRC_NETIF_FLAGS_HAS_L2ADDR)) {\n            /* Set STALE NCE if link-layer has no addresses */\n            _nib_nc_add(&ipv6->src, netif->pid,\n                        GNRC_IPV6_NIB_NC_INFO_NUD_STATE_STALE);\n        }\n        FOREACH_OPT(nbr_sol, opt, tmp_len) {\n            switch (opt->type) {\n                case NDP_OPT_SL2A:\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR)\n                    if (gnrc_netif_is_6lr(netif)) {\n                        DEBUG(\"nib: Storing SL2AO for later handling\\n\");\n                        sl2ao = opt;\n                        break;\n                    }\n#endif  /* CONFIG_GNRC_IPV6_NIB_6LR */\n                    _handle_sl2ao(netif, ipv6, (const icmpv6_hdr_t *)nbr_sol,\n                                  opt);\n                    break;\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR)\n                case NDP_OPT_AR:\n                    DEBUG(\"nib: Storing ARO for later handling\\n\");\n                    aro = (sixlowpan_nd_opt_ar_t *)opt;\n                    break;\n#endif  /* CONFIG_GNRC_IPV6_NIB_6LR */\n                default:\n                    DEBUG(\"nib: Ignoring unrecognized option type %u for NS\\n\",\n                          opt->type);\n                    break;\n            }\n        }\n        reply_aro = _copy_and_handle_aro(netif, ipv6, nbr_sol, aro, sl2ao);\n        /* check if target address is anycast */\n        if (netif->ipv6.addrs_flags[tgt_idx] & GNRC_NETIF_IPV6_ADDRS_FLAGS_ANYCAST) {\n            _send_delayed_nbr_adv(netif, &nbr_sol->tgt, ipv6, reply_aro);\n        }\n        else {\n            gnrc_ndp_nbr_adv_send(&nbr_sol->tgt, netif, &ipv6->src,\n                                  ipv6_addr_is_multicast(&ipv6->dst),\n                                  reply_aro);\n        }\n    }\n}"
}