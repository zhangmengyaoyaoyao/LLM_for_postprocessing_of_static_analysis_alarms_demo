{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "\t\t    str[c1] = '\\0';",
    "Code_function": "static reg_errcode_t byte_regex_compile (const char *pattern, size_t size,\n                                         reg_syntax_t syntax,\n                                         struct re_pattern_buffer *bufp);\n\nstatic int byte_re_match_2_internal (struct re_pattern_buffer *bufp,\n                                     const char *string1, int size1,\n                                     const char *string2, int size2,\n                                     int pos,\n                                     struct re_registers *regs,\n                                     int stop);\nstatic int byte_re_search_2 (struct re_pattern_buffer *bufp,\n                             const char *string1, int size1,\n                             const char *string2, int size2,\n                             int startpos, int range,\n                             struct re_registers *regs, int stop);\nstatic int byte_re_compile_fastmap (struct re_pattern_buffer *bufp);\n\n#ifdef MBS_SUPPORT\nstatic reg_errcode_t wcs_regex_compile (const char *pattern, size_t size,\n                                        reg_syntax_t syntax,\n                                        struct re_pattern_buffer *bufp);\n\n\nstatic int wcs_re_match_2_internal (struct re_pattern_buffer *bufp,\n                                    const char *cstring1, int csize1,\n                                    const char *cstring2, int csize2,\n                                    int pos,\n                                    struct re_registers *regs,\n                                    int stop,\n                                    wchar_t *string1, int size1,\n                                    wchar_t *string2, int size2,\n                                    int *mbs_offset1, int *mbs_offset2);\nstatic int wcs_re_search_2 (struct re_pattern_buffer *bufp,\n                            const char *string1, int size1,\n                            const char *string2, int size2,\n                            int startpos, int range,\n                            struct re_registers *regs, int stop);\nstatic int wcs_re_compile_fastmap (struct re_pattern_buffer *bufp);\n#endif\n\n/* These are the command codes that appear in compiled regular\n   expressions.  Some opcodes are followed by argument bytes.  A\n   command code can specify any interpretation whatsoever for its\n   arguments.  Zero bytes may appear in the compiled regular expression.  */\n\ntypedef enum\n{\n  no_op = 0,\n\n  /* Succeed right away--no more backtracking.  */\n  succeed,\n\n        /* Followed by one byte giving n, then by n literal bytes.  */\n  exactn,\n\n# ifdef MBS_SUPPORT\n\t/* Same as exactn, but contains binary data.  */\n  exactn_bin,\n# endif\n\n        /* Matches any (more or less) character.  */\n  anychar,\n\n        /* Matches any one char belonging to specified set.  First\n           following byte is number of bitmap bytes.  Then come bytes\n           for a bitmap saying which chars are in.  Bits in each byte\n           are ordered low-bit-first.  A character is in the set if its\n           bit is 1.  A character too large to have a bit in the map is\n           automatically not in the set.  */\n        /* ifdef MBS_SUPPORT, following element is length of character\n\t   classes, length of collating symbols, length of equivalence\n\t   classes, length of character ranges, and length of characters.\n\t   Next, character class element, collating symbols elements,\n\t   equivalence class elements, range elements, and character\n\t   elements follow.\n\t   See regex_compile function.  */\n  charset,\n\n        /* Same parameters as charset, but match any character that is\n           not one of those specified.  */\n  charset_not,\n\n        /* Start remembering the text that is matched, for storing in a\n           register.  Followed by one byte with the register number, in\n           the range 0 to one less than the pattern buffer's re_nsub\n           field.  Then followed by one byte with the number of groups\n           inner to this one.  (This last has to be part of the\n           start_memory only because we need it in the on_failure_jump\n           of re_match_2.)  */\n  start_memory,\n\n        /* Stop remembering the text that is matched and store it in a\n           memory register.  Followed by one byte with the register\n           number, in the range 0 to one less than `re_nsub' in the\n           pattern buffer, and one byte with the number of inner groups,\n           just like `start_memory'.  (We need the number of inner\n           groups here because we don't have any easy way of finding the\n           corresponding start_memory when we're at a stop_memory.)  */\n  stop_memory,\n\n        /* Match a duplicate of something remembered. Followed by one\n           byte containing the register number.  */\n  duplicate,\n\n        /* Fail unless at beginning of line.  */\n  begline,\n\n        /* Fail unless at end of line.  */\n  endline,\n\n        /* Succeeds if at beginning of buffer (if emacs) or at beginning\n           of string to be matched (if not).  */\n  begbuf,\n\n        /* Analogously, for end of buffer/string.  */\n  endbuf,\n\n        /* Followed by two byte relative address to which to jump.  */\n  jump,\n\n\t/* Same as jump, but marks the end of an alternative.  */\n  jump_past_alt,\n\n        /* Followed by two-byte relative address of place to resume at\n           in case of failure.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  on_failure_jump,\n\n        /* Like on_failure_jump, but pushes a placeholder instead of the\n           current string position when executed.  */\n  on_failure_keep_string_jump,\n\n        /* Throw away latest failure point and then jump to following\n           two-byte relative address.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  pop_failure_jump,\n\n        /* Change to pop_failure_jump if know won't have to backtrack to\n           match; otherwise change to jump.  This is used to jump\n           back to the beginning of a repeat.  If what follows this jump\n           clearly won't match what the repeat does, such that we can be\n           sure that there is no use backtracking out of repetitions\n           already matched, then we change it to a pop_failure_jump.\n           Followed by two-byte address.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  maybe_pop_jump,\n\n        /* Jump to following two-byte address, and push a dummy failure\n           point. This failure point will be thrown away if an attempt\n           is made to use it for a failure.  A `+' construct makes this\n           before the first repeat.  Also used as an intermediary kind\n           of jump when compiling an alternative.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  dummy_failure_jump,\n\n\t/* Push a dummy failure point and continue.  Used at the end of\n\t   alternatives.  */\n  push_dummy_failure,\n\n        /* Followed by two-byte relative address and two-byte number n.\n           After matching N times, jump to the address upon failure.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  succeed_n,\n\n        /* Followed by two-byte relative address, and two-byte number n.\n           Jump to the address N times, then fail.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  jump_n,\n\n        /* Set the following two-byte relative address to the\n           subsequent two-byte number.  The address *includes* the two\n           bytes of number.  */\n        /* ifdef MBS_SUPPORT, the size of address is 1.  */\n  set_number_at,\n\n  wordchar,\t/* Matches any word-constituent character.  */\n  notwordchar,\t/* Matches any char that is not a word-constituent.  */\n\n  wordbeg,\t/* Succeeds if at word beginning.  */\n  wordend,\t/* Succeeds if at word end.  */\n\n  wordbound,\t/* Succeeds if at a word boundary.  */\n  notwordbound\t/* Succeeds if not at a word boundary.  */\n\n# ifdef emacs\n  ,before_dot,\t/* Succeeds if before point.  */\n  at_dot,\t/* Succeeds if at point.  */\n  after_dot,\t/* Succeeds if after point.  */\n\n\t/* Matches any character whose syntax is specified.  Followed by\n           a byte which contains a syntax code, e.g., Sword.  */\n  syntaxspec,\n\n\t/* Matches any character whose syntax is not that specified.  */\n  notsyntaxspec\n# endif /* emacs */\n} re_opcode_t;\n#endif /* not INSIDE_RECURSION */\n\n\n#ifdef BYTE\n# define CHAR_T char\n# define UCHAR_T unsigned char\n# define COMPILED_BUFFER_VAR bufp->buffer\n# define OFFSET_ADDRESS_SIZE 2\n# define PREFIX(name) byte_##name\n# define ARG_PREFIX(name) name\n# define PUT_CHAR(c) putchar (c)\n#else\n# ifdef WCHAR\n#  define CHAR_T wchar_t\n#  define UCHAR_T wchar_t\n#  define COMPILED_BUFFER_VAR wc_buffer\n#  define OFFSET_ADDRESS_SIZE 1 /* the size which STORE_NUMBER macro use */\n#  define CHAR_CLASS_SIZE ((__alignof__(wctype_t)+sizeof(wctype_t))/sizeof(CHAR_T)+1)\n#  define PREFIX(name) wcs_##name\n#  define ARG_PREFIX(name) c##name\n/* Should we use wide stream??  */\n#  define PUT_CHAR(c) printf (\"%C\", c);\n#  define TRUE 1\n#  define FALSE 0\n# else\n#  ifdef MBS_SUPPORT\n#   define WCHAR\n#   define INSIDE_RECURSION\n#   include \"regex.c\"\n#   undef INSIDE_RECURSION\n#  endif\n#  define BYTE\n#  define INSIDE_RECURSION\n#  include \"regex.c\"\n#  undef INSIDE_RECURSION\n# endif\n#endif\n\n#ifdef INSIDE_RECURSION\n/* Common operations on the compiled pattern.  */\n\n/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */\n/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */\n\n# ifdef WCHAR\n#  define STORE_NUMBER(destination, number)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    *(destination) = (UCHAR_T)(number);\t\t\t\t\\\n  } while (0)\n# else /* BYTE */\n#  define STORE_NUMBER(destination, number)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    (destination)[0] = (number) & 0377;\t\t\t\t\t\\\n    (destination)[1] = (number) >> 8;\t\t\t\t\t\\\n  } while (0)\n# endif /* WCHAR */\n\n/* Same as STORE_NUMBER, except increment DESTINATION to\n   the byte after where the number is stored.  Therefore, DESTINATION\n   must be an lvalue.  */\n/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */\n\n# define STORE_NUMBER_AND_INCR(destination, number)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    STORE_NUMBER (destination, number);\t\t\t\t\t\\\n    (destination) += OFFSET_ADDRESS_SIZE;\t\t\t\t\\\n  } while (0)\n\n/* Put into DESTINATION a number stored in two contiguous bytes starting\n   at SOURCE.  */\n/* ifdef MBS_SUPPORT, we store NUMBER in 1 element.  */\n\n# ifdef WCHAR\n#  define EXTRACT_NUMBER(destination, source)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    (destination) = *(source);\t\t\t\t\t\t\\\n  } while (0)\n# else /* BYTE */\n#  define EXTRACT_NUMBER(destination, source)\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    (destination) = *(source) & 0377;\t\t\t\t\t\\\n    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;\t\t\\\n  } while (0)\n# endif\n\n# ifdef DEBUG\nstatic void PREFIX(extract_number) (int *dest, UCHAR_T *source);\nstatic void\nPREFIX(extract_number) (int *dest, UCHAR_T *source)\n{\n#  ifdef WCHAR\n  *dest = *source;\n#  else /* BYTE */\n  int temp = SIGN_EXTEND_CHAR (*(source + 1));\n  *dest = *source & 0377;\n  *dest += temp << 8;\n#  endif\n}\n\n#  ifndef EXTRACT_MACROS /* To debug the macros.  */\n#   undef EXTRACT_NUMBER\n#   define EXTRACT_NUMBER(dest, src) PREFIX(extract_number) (&dest, src)\n#  endif /* not EXTRACT_MACROS */\n\n# endif /* DEBUG */\n\n/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.\n   SOURCE must be an lvalue.  */\n\n# define EXTRACT_NUMBER_AND_INCR(destination, source)\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    EXTRACT_NUMBER (destination, source);\t\t\t\t\\\n    (source) += OFFSET_ADDRESS_SIZE; \t\t\t\t\t\\\n  } while (0)\n\n# ifdef DEBUG\nstatic void PREFIX(extract_number_and_incr) (int *destination,\n                                             UCHAR_T **source);\nstatic void\nPREFIX(extract_number_and_incr) (int *destination, UCHAR_T **source)\n{\n  PREFIX(extract_number) (destination, *source);\n  *source += OFFSET_ADDRESS_SIZE;\n}\n\n#  ifndef EXTRACT_MACROS\n#   undef EXTRACT_NUMBER_AND_INCR\n#   define EXTRACT_NUMBER_AND_INCR(dest, src) \\\n  PREFIX(extract_number_and_incr) (&dest, &src)\n#  endif /* not EXTRACT_MACROS */\n\n# endif /* DEBUG */\n\n\n\n/* If DEBUG is defined, Regex prints many voluminous messages about what\n   it is doing (if the variable `debug' is nonzero).  If linked with the\n   main program in `iregex.c', you can enter patterns and strings\n   interactively.  And if linked with the main program in `main.c' and\n   the other test files, you can run the already-written tests.  */\n\n# ifdef DEBUG\n\n#  ifndef DEFINED_ONCE\n\n/* We use standard I/O for debugging.  */\n#   include <stdio.h>\n\n/* It is useful to test things that ``must'' be true when debugging.  */\n#   include <assert.h>\n\nstatic int debug;\n\n#   define DEBUG_STATEMENT(e) e\n#   define DEBUG_PRINT1(x) if (debug) printf (x)\n#   define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)\n#   define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)\n#   define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)\n#  endif /* not DEFINED_ONCE */\n\n#  define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) \t\t\t\\\n  if (debug) PREFIX(print_partial_compiled_pattern) (s, e)\n#  define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)\t\t\\\n  if (debug) PREFIX(print_double_string) (w, s1, sz1, s2, sz2)\n\n\n/* Print the fastmap in human-readable form.  */\n\n#  ifndef DEFINED_ONCE\nvoid\nprint_fastmap (char *fastmap)\n{\n  unsigned was_a_range = 0;\n  unsigned i = 0;\n\n  while (i < (1 << BYTEWIDTH))\n    {\n      if (fastmap[i++])\n\t{\n\t  was_a_range = 0;\n          putchar (i - 1);\n          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])\n            {\n              was_a_range = 1;\n              i++;\n            }\n\t  if (was_a_range)\n            {\n              printf (\"-\");\n              putchar (i - 1);\n            }\n        }\n    }\n  putchar ('\\n');\n}\n#  endif /* not DEFINED_ONCE */\n\n\n/* Print a compiled pattern string in human-readable form, starting at\n   the START pointer into it and ending just before the pointer END.  */\n\nvoid\nPREFIX(print_partial_compiled_pattern) (UCHAR_T *start, UCHAR_T *end)\n{\n  int mcnt, mcnt2;\n  UCHAR_T *p1;\n  UCHAR_T *p = start;\n  UCHAR_T *pend = end;\n\n  if (start == NULL)\n    {\n      printf (\"(null)\\n\");\n      return;\n    }\n\n  /* Loop over pattern commands.  */\n  while (p < pend)\n    {\n#  ifdef _LIBC\n      printf (\"%td:\\t\", p - start);\n#  else\n      printf (\"%ld:\\t\", (long int) (p - start));\n#  endif\n\n      switch ((re_opcode_t) *p++)\n\t{\n        case no_op:\n          printf (\"/no_op\");\n          break;\n\n\tcase exactn:\n\t  mcnt = *p++;\n          printf (\"/exactn/%d\", mcnt);\n          do\n\t    {\n              putchar ('/');\n\t      PUT_CHAR (*p++);\n            }\n          while (--mcnt);\n          break;\n\n#  ifdef MBS_SUPPORT\n\tcase exactn_bin:\n\t  mcnt = *p++;\n\t  printf (\"/exactn_bin/%d\", mcnt);\n          do\n\t    {\n\t      printf(\"/%lx\", (long int) *p++);\n            }\n          while (--mcnt);\n          break;\n#  endif /* MBS_SUPPORT */\n\n\tcase start_memory:\n          mcnt = *p++;\n          printf (\"/start_memory/%d/%ld\", mcnt, (long int) *p++);\n          break;\n\n\tcase stop_memory:\n          mcnt = *p++;\n\t  printf (\"/stop_memory/%d/%ld\", mcnt, (long int) *p++);\n          break;\n\n\tcase duplicate:\n\t  printf (\"/duplicate/%ld\", (long int) *p++);\n\t  break;\n\n\tcase anychar:\n\t  printf (\"/anychar\");\n\t  break;\n\n\tcase charset:\n        case charset_not:\n          {\n#  ifdef WCHAR\n\t    int i, length;\n\t    wchar_t *workp = p;\n\t    printf (\"/charset [%s\",\n\t            (re_opcode_t) *(workp - 1) == charset_not ? \"^\" : \"\");\n\t    p += 5;\n\t    length = *workp++; /* the length of char_classes */\n\t    for (i=0 ; i<length ; i++)\n\t      printf(\"[:%lx:]\", (long int) *p++);\n\t    length = *workp++; /* the length of collating_symbol */\n\t    for (i=0 ; i<length ;)\n\t      {\n\t\tprintf(\"[.\");\n\t\twhile(*p != 0)\n\t\t  PUT_CHAR((i++,*p++));\n\t\ti++,p++;\n\t\tprintf(\".]\");\n\t      }\n\t    length = *workp++; /* the length of equivalence_class */\n\t    for (i=0 ; i<length ;)\n\t      {\n\t\tprintf(\"[=\");\n\t\twhile(*p != 0)\n\t\t  PUT_CHAR((i++,*p++));\n\t\ti++,p++;\n\t\tprintf(\"=]\");\n\t      }\n\t    length = *workp++; /* the length of char_range */\n\t    for (i=0 ; i<length ; i++)\n\t      {\n\t\twchar_t range_start = *p++;\n\t\twchar_t range_end = *p++;\n\t\tprintf(\"%C-%C\", range_start, range_end);\n\t      }\n\t    length = *workp++; /* the length of char */\n\t    for (i=0 ; i<length ; i++)\n\t      printf(\"%C\", *p++);\n\t    putchar (']');\n#  else\n            register int c, last = -100;\n\t    register int in_range = 0;\n\n\t    printf (\"/charset [%s\",\n\t            (re_opcode_t) *(p - 1) == charset_not ? \"^\" : \"\");\n\n            assert (p + *p < pend);\n\n            for (c = 0; c < 256; c++)\n\t      if (c / 8 < *p\n\t\t  && (p[1 + (c/8)] & (1 << (c % 8))))\n\t\t{\n\t\t  /* Are we starting a range?  */\n\t\t  if (last + 1 == c && ! in_range)\n\t\t    {\n\t\t      putchar ('-');\n\t\t      in_range = 1;\n\t\t    }\n\t\t  /* Have we broken a range?  */\n\t\t  else if (last + 1 != c && in_range)\n              {\n\t\t      putchar (last);\n\t\t      in_range = 0;\n\t\t    }\n\n\t\t  if (! in_range)\n\t\t    putchar (c);\n\n\t\t  last = c;\n              }\n\n\t    if (in_range)\n\t      putchar (last);\n\n\t    putchar (']');\n\n\t    p += 1 + *p;\n#  endif /* WCHAR */\n\t  }\n\t  break;\n\n\tcase begline:\n\t  printf (\"/begline\");\n          break;\n\n\tcase endline:\n          printf (\"/endline\");\n          break;\n\n\tcase on_failure_jump:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/on_failure_jump to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/on_failure_jump to %ld\", (long int) (p + mcnt - start));\n#  endif\n          break;\n\n\tcase on_failure_keep_string_jump:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/on_failure_keep_string_jump to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/on_failure_keep_string_jump to %ld\",\n\t\t  (long int) (p + mcnt - start));\n#  endif\n          break;\n\n\tcase dummy_failure_jump:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/dummy_failure_jump to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/dummy_failure_jump to %ld\", (long int) (p + mcnt - start));\n#  endif\n          break;\n\n\tcase push_dummy_failure:\n          printf (\"/push_dummy_failure\");\n          break;\n\n        case maybe_pop_jump:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/maybe_pop_jump to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/maybe_pop_jump to %ld\", (long int) (p + mcnt - start));\n#  endif\n\t  break;\n\n        case pop_failure_jump:\n\t  PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/pop_failure_jump to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/pop_failure_jump to %ld\", (long int) (p + mcnt - start));\n#  endif\n\t  break;\n\n        case jump_past_alt:\n\t  PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/jump_past_alt to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/jump_past_alt to %ld\", (long int) (p + mcnt - start));\n#  endif\n\t  break;\n\n        case jump:\n\t  PREFIX(extract_number_and_incr) (&mcnt, &p);\n#  ifdef _LIBC\n  \t  printf (\"/jump to %td\", p + mcnt - start);\n#  else\n  \t  printf (\"/jump to %ld\", (long int) (p + mcnt - start));\n#  endif\n\t  break;\n\n        case succeed_n:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n\t  p1 = p + mcnt;\n          PREFIX(extract_number_and_incr) (&mcnt2, &p);\n#  ifdef _LIBC\n\t  printf (\"/succeed_n to %td, %d times\", p1 - start, mcnt2);\n#  else\n\t  printf (\"/succeed_n to %ld, %d times\",\n\t\t  (long int) (p1 - start), mcnt2);\n#  endif\n          break;\n\n        case jump_n:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n\t  p1 = p + mcnt;\n          PREFIX(extract_number_and_incr) (&mcnt2, &p);\n\t  printf (\"/jump_n to %d, %d times\", p1 - start, mcnt2);\n          break;\n\n        case set_number_at:\n          PREFIX(extract_number_and_incr) (&mcnt, &p);\n\t  p1 = p + mcnt;\n          PREFIX(extract_number_and_incr) (&mcnt2, &p);\n#  ifdef _LIBC\n\t  printf (\"/set_number_at location %td to %d\", p1 - start, mcnt2);\n#  else\n\t  printf (\"/set_number_at location %ld to %d\",\n\t\t  (long int) (p1 - start), mcnt2);\n#  endif\n          break;\n\n        case wordbound:\n\t  printf (\"/wordbound\");\n\t  break;\n\n\tcase notwordbound:\n\t  printf (\"/notwordbound\");\n          break;\n\n\tcase wordbeg:\n\t  printf (\"/wordbeg\");\n\t  break;\n\n\tcase wordend:\n\t  printf (\"/wordend\");\n\t  break;\n\n#  ifdef emacs\n\tcase before_dot:\n\t  printf (\"/before_dot\");\n          break;\n\n\tcase at_dot:\n\t  printf (\"/at_dot\");\n          break;\n\n\tcase after_dot:\n\t  printf (\"/after_dot\");\n          break;\n\n\tcase syntaxspec:\n          printf (\"/syntaxspec\");\n\t  mcnt = *p++;\n\t  printf (\"/%d\", mcnt);\n          break;\n\n\tcase notsyntaxspec:\n          printf (\"/notsyntaxspec\");\n\t  mcnt = *p++;\n\t  printf (\"/%d\", mcnt);\n\t  break;\n#  endif /* emacs */\n\n\tcase wordchar:\n\t  printf (\"/wordchar\");\n          break;\n\n\tcase notwordchar:\n\t  printf (\"/notwordchar\");\n          break;\n\n\tcase begbuf:\n\t  printf (\"/begbuf\");\n          break;\n\n\tcase endbuf:\n\t  printf (\"/endbuf\");\n          break;\n\n        default:\n          printf (\"?%ld\", (long int) *(p-1));\n\t}\n\n      putchar ('\\n');\n    }\n\n#  ifdef _LIBC\n  printf (\"%td:\\tend of pattern.\\n\", p - start);\n#  else\n  printf (\"%ld:\\tend of pattern.\\n\", (long int) (p - start));\n#  endif\n}\n\n\nvoid\nPREFIX(print_compiled_pattern) (struct re_pattern_buffer *bufp)\n{\n  UCHAR_T *buffer = (UCHAR_T*) bufp->buffer;\n\n  PREFIX(print_partial_compiled_pattern) (buffer, buffer\n\t\t\t\t  + bufp->used / sizeof(UCHAR_T));\n  printf (\"%ld bytes used/%ld bytes allocated.\\n\",\n\t  bufp->used, bufp->allocated);\n\n  if (bufp->fastmap_accurate && bufp->fastmap)\n    {\n      printf (\"fastmap: \");\n      print_fastmap (bufp->fastmap);\n    }\n\n#  ifdef _LIBC\n  printf (\"re_nsub: %Zd\\t\", bufp->re_nsub);\n#  else\n  printf (\"re_nsub: %ld\\t\", (long int) bufp->re_nsub);\n#  endif\n  printf (\"regs_alloc: %d\\t\", bufp->regs_allocated);\n  printf (\"can_be_null: %d\\t\", bufp->can_be_null);\n  printf (\"newline_anchor: %d\\n\", bufp->newline_anchor);\n  printf (\"no_sub: %d\\t\", bufp->no_sub);\n  printf (\"not_bol: %d\\t\", bufp->not_bol);\n  printf (\"not_eol: %d\\t\", bufp->not_eol);\n  printf (\"syntax: %lx\\n\", bufp->syntax);\n  /* Perhaps we should print the translate table?  */\n}\n\n\nvoid\nPREFIX(print_double_string) (const CHAR_T *where, const CHAR_T *string1,\n                             int size1, const CHAR_T *string2, int size2)\n{\n  int this_char;\n\n  if (where == NULL)\n    printf (\"(null)\");\n  else\n    {\n      int cnt;\n\n      if (FIRST_STRING_P (where))\n        {\n          for (this_char = where - string1; this_char < size1; this_char++)\n\t    PUT_CHAR (string1[this_char]);\n\n          where = string2;\n        }\n\n      cnt = 0;\n      for (this_char = where - string2; this_char < size2; this_char++)\n\t{\n\t  PUT_CHAR (string2[this_char]);\n\t  if (++cnt > 100)\n\t    {\n\t      fputs (\"...\", stdout);\n\t      break;\n\t    }\n\t}\n    }\n}\n\n#  ifndef DEFINED_ONCE\nvoid\nprintchar (int c)\n{\n  putc (c, stderr);\n}\n#  endif\n\n# else /* not DEBUG */\n\n#  ifndef DEFINED_ONCE\n#   undef assert\n#   define assert(e)\n\n#   define DEBUG_STATEMENT(e)\n#   define DEBUG_PRINT1(x)\n#   define DEBUG_PRINT2(x1, x2)\n#   define DEBUG_PRINT3(x1, x2, x3)\n#   define DEBUG_PRINT4(x1, x2, x3, x4)\n#  endif /* not DEFINED_ONCE */\n#  define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)\n#  define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)\n\n# endif /* not DEBUG */\n\n\n\n# ifdef WCHAR\n/* This  convert a multibyte string to a wide character string.\n   And write their correspondances to offset_buffer(see below)\n   and write whether each wchar_t is binary data to is_binary.\n   This assume invalid multibyte sequences as binary data.\n   We assume offset_buffer and is_binary is already allocated\n   enough space.  */\n\nstatic size_t convert_mbs_to_wcs (CHAR_T *dest, const unsigned char* src,\n\t\t\t\t  size_t len, int *offset_buffer,\n\t\t\t\t  char *is_binary);\nstatic size_t\nconvert_mbs_to_wcs (CHAR_T *dest, const unsigned char*src, size_t len,\n                    int *offset_buffer, char *is_binary)\n     /* It hold correspondances between src(char string) and\n\tdest(wchar_t string) for optimization.\n\te.g. src  = \"xxxyzz\"\n             dest = {'X', 'Y', 'Z'}\n\t      (each \"xxx\", \"y\" and \"zz\" represent one multibyte character\n\t       corresponding to 'X', 'Y' and 'Z'.)\n\t  offset_buffer = {0, 0+3(\"xxx\"), 0+3+1(\"y\"), 0+3+1+2(\"zz\")}\n\t  \t        = {0, 3, 4, 6}\n     */\n{\n  wchar_t *pdest = dest;\n  const unsigned char *psrc = src;\n  size_t wc_count = 0;\n\n  mbstate_t mbs;\n  int i, consumed;\n  size_t mb_remain = len;\n  size_t mb_count = 0;\n\n  /* Initialize the conversion state.  */\n  memset (&mbs, 0, sizeof (mbstate_t));\n\n  offset_buffer[0] = 0;\n  for( ; mb_remain > 0 ; ++wc_count, ++pdest, mb_remain -= consumed,\n\t psrc += consumed)\n    {\n#ifdef _LIBC\n      consumed = __mbrtowc (pdest, psrc, mb_remain, &mbs);\n#else\n      consumed = mbrtowc (pdest, psrc, mb_remain, &mbs);\n#endif\n\n      if (consumed <= 0)\n\t/* failed to convert. maybe src contains binary data.\n\t   So we consume 1 byte manualy.  */\n\t{\n\t  *pdest = *psrc;\n\t  consumed = 1;\n\t  is_binary[wc_count] = TRUE;\n\t}\n      else\n\tis_binary[wc_count] = FALSE;\n      /* In sjis encoding, we use yen sign as escape character in\n\t place of reverse solidus. So we convert 0x5c(yen sign in\n\t sjis) to not 0xa5(yen sign in UCS2) but 0x5c(reverse\n\t solidus in UCS2).  */\n      if (consumed == 1 && (int) *psrc == 0x5c && (int) *pdest == 0xa5)\n\t*pdest = (wchar_t) *psrc;\n\n      offset_buffer[wc_count + 1] = mb_count += consumed;\n    }\n\n  /* Fill remain of the buffer with sentinel.  */\n  for (i = wc_count + 1 ; i <= len ; i++)\n    offset_buffer[i] = mb_count + 1;\n\n  return wc_count;\n}\n\n# endif /* WCHAR */\n\n#else /* not INSIDE_RECURSION */\n\n/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can\n   also be assigned to arbitrarily: each pattern buffer stores its own\n   syntax, so it can be changed between regex compilations.  */\n/* This has no initializer because initialized variables in Emacs\n   become read-only after dumping.  */\nreg_syntax_t re_syntax_options;\n\n\n/* Specify the precise syntax of regexps for compilation.  This provides\n   for compatibility for various utilities which historically have\n   different, incompatible syntaxes.\n\n   The argument SYNTAX is a bit mask comprised of the various bits\n   defined in regex.h.  We return the old syntax.  */\n\nreg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n# ifdef DEBUG\n  if (syntax & RE_DEBUG)\n    debug = 1;\n  else if (debug) /* was on but now is not */\n    debug = 0;\n# endif /* DEBUG */\n  return ret;\n}\n# ifdef _LIBC\nweak_alias (__re_set_syntax, re_set_syntax)\n# endif\n\n/* This table gives an error message for each of the error codes listed\n   in regex.h.  Obviously the order here has to be same as there.\n   POSIX doesn't require that we do anything for REG_NOERROR,\n   but why not be nice?  */\n\nstatic const char *re_error_msgid[] =\n  {\n    gettext_noop (\"Success\"),\t/* REG_NOERROR */\n    gettext_noop (\"No match\"),\t/* REG_NOMATCH */\n    gettext_noop (\"Invalid regular expression\"), /* REG_BADPAT */\n    gettext_noop (\"Invalid collation character\"), /* REG_ECOLLATE */\n    gettext_noop (\"Invalid character class name\"), /* REG_ECTYPE */\n    gettext_noop (\"Trailing backslash\"), /* REG_EESCAPE */\n    gettext_noop (\"Invalid back reference\"), /* REG_ESUBREG */\n    gettext_noop (\"Unmatched [ or [^\"),\t/* REG_EBRACK */\n    gettext_noop (\"Unmatched ( or \\\\(\"), /* REG_EPAREN */\n    gettext_noop (\"Unmatched \\\\{\"), /* REG_EBRACE */\n    gettext_noop (\"Invalid content of \\\\{\\\\}\"), /* REG_BADBR */\n    gettext_noop (\"Invalid range end\"),\t/* REG_ERANGE */\n    gettext_noop (\"Memory exhausted\"), /* REG_ESPACE */\n    gettext_noop (\"Invalid preceding regular expression\"), /* REG_BADRPT */\n    gettext_noop (\"Premature end of regular expression\"), /* REG_EEND */\n    gettext_noop (\"Regular expression too big\"), /* REG_ESIZE */\n    gettext_noop (\"Unmatched ) or \\\\)\") /* REG_ERPAREN */\n  };\n\n#endif /* INSIDE_RECURSION */\n\n#ifndef DEFINED_ONCE\n/* Avoiding alloca during matching, to placate r_alloc.  */\n\n/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the\n   searching and matching functions should not call alloca.  On some\n   systems, alloca is implemented in terms of malloc, and if we're\n   using the relocating allocator routines, then malloc could cause a\n   relocation, which might (if the strings being searched are in the\n   ralloc heap) shift the data out from underneath the regexp\n   routines.\n\n   Here's another reason to avoid allocation: Emacs\n   processes input from X in a signal handler; processing X input may\n   call malloc; if input arrives while a matching routine is calling\n   malloc, then we're scrod.  But Emacs can't just block input while\n   calling matching routines; then we don't notice interrupts when\n   they come in.  So, Emacs blocks input around all regexp calls\n   except the matching calls, which it leaves unprotected, in the\n   faith that they will not malloc.  */\n\n/* Normally, this is fine.  */\n# define MATCH_MAY_ALLOCATE\n\n/* When using GNU C, we are not REALLY using the C alloca, no matter\n   what config.h may say.  So don't take precautions for it.  */\n# ifdef __GNUC__\n#  undef C_ALLOCA\n# endif\n\n/* The match routines may not allocate if (1) they would do it with malloc\n   and (2) it's not safe for them to use malloc.\n   Note that if REL_ALLOC is defined, matching would not use malloc for the\n   failure stack, but we would still use it for the register vectors;\n   so REL_ALLOC should not affect this.  */\n# if (defined C_ALLOCA || defined REGEX_MALLOC) && defined emacs\n#  undef MATCH_MAY_ALLOCATE\n# endif\n#endif /* not DEFINED_ONCE */\n\n#ifdef INSIDE_RECURSION\n/* Failure stack declarations and macros; both re_compile_fastmap and\n   re_match_2 use a failure stack.  These have to be macros because of\n   REGEX_ALLOCATE_STACK.  */\n\n\n/* Number of failure points for which to initially allocate space\n   when matching.  If this number is exceeded, we allocate more\n   space, so it is not a hard limit.  */\n# ifndef INIT_FAILURE_ALLOC\n#  define INIT_FAILURE_ALLOC 5\n# endif\n\n/* Roughly the maximum number of failure points on the stack.  Would be\n   exactly that if always used MAX_FAILURE_ITEMS items each time we failed.\n   This is a variable only so users of regex can assign to it; we never\n   change it ourselves.  */\n\n# ifdef INT_IS_16BIT\n\n#  ifndef DEFINED_ONCE\n#   if defined MATCH_MAY_ALLOCATE\n/* 4400 was enough to cause a crash on Alpha OSF/1,\n   whose default stack limit is 2mb.  */\nlong int re_max_failures = 4000;\n#   else\nlong int re_max_failures = 2000;\n#   endif\n#  endif\n\nunion PREFIX(fail_stack_elt)\n{\n  UCHAR_T *pointer;\n  long int integer;\n};\n\ntypedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);\n\ntypedef struct\n{\n  PREFIX(fail_stack_elt_t) *stack;\n  unsigned long int size;\n  unsigned long int avail;\t\t/* Offset of next open position.  */\n} PREFIX(fail_stack_type);\n\n# else /* not INT_IS_16BIT */\n\n#  ifndef DEFINED_ONCE\n#   if defined MATCH_MAY_ALLOCATE\n/* 4400 was enough to cause a crash on Alpha OSF/1,\n   whose default stack limit is 2mb.  */\nint re_max_failures = 4000;\n#   else\nint re_max_failures = 2000;\n#   endif\n#  endif\n\nunion PREFIX(fail_stack_elt)\n{\n  UCHAR_T *pointer;\n  int integer;\n};\n\ntypedef union PREFIX(fail_stack_elt) PREFIX(fail_stack_elt_t);\n\ntypedef struct\n{\n  PREFIX(fail_stack_elt_t) *stack;\n  unsigned size;\n  unsigned avail;\t\t\t/* Offset of next open position.  */\n} PREFIX(fail_stack_type);\n\n# endif /* INT_IS_16BIT */\n\n# ifndef DEFINED_ONCE\n#  define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)\n#  define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)\n#  define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)\n# endif\n\n\n/* Define macros to initialize and free the failure stack.\n   Do `return -2' if the alloc fails.  */\n\n# ifdef MATCH_MAY_ALLOCATE\n#  define INIT_FAIL_STACK()\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    fail_stack.stack = (PREFIX(fail_stack_elt_t) *)\t\t\\\n      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (PREFIX(fail_stack_elt_t))); \\\n\t\t\t\t\t\t\t\t\t\\\n    if (fail_stack.stack == NULL)\t\t\t\t\\\n      return -2;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n    fail_stack.size = INIT_FAILURE_ALLOC;\t\t\t\\\n    fail_stack.avail = 0;\t\t\t\t\t\\\n  } while (0)\n\n#  define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)\n# else\n#  define INIT_FAIL_STACK()\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    fail_stack.avail = 0;\t\t\t\t\t\\\n  } while (0)\n\n#  define RESET_FAIL_STACK()\n# endif\n\n\n/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.\n\n   Return 1 if succeeds, and 0 if either ran out of memory\n   allocating space for it or it was already too large.\n\n   REGEX_REALLOCATE_STACK requires `destination' be declared.   */\n\n# define DOUBLE_FAIL_STACK(fail_stack)\t\t\t\t\t\\\n  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)\t\\\n   ? 0\t\t\t\t\t\t\t\t\t\\\n   : ((fail_stack).stack = (PREFIX(fail_stack_elt_t) *)\t\t\t\\\n        REGEX_REAL"
}