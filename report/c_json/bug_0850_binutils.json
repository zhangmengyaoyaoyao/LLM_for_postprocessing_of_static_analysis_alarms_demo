{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/dwarf2.c",
    "message": "Offset: [3, +oo] Size: [0, +oo] by call to `parse_comp_unit`.",
    "warning_function_name": "_bfd_dwarf2_find_nearest_line",
    "warning_line": "each = parse_comp_unit (stash, length, info_ptr_unit,",
    "warning_context": "\t\t This does mean that we scan through all of the CUs associated\n\t\t with the bfd each time this function is called.  But this does\n\t\t have the benefit of producing consistent results every time the\n\t\t function is called.  */\n\t      if (range <= min_range)\n\t\t{\n\t\t  if (filename_ptr && local_filename)\n\t\t    * filename_ptr = local_filename;\n\t\t  if (local_function)\n\t\t    function = local_function;\n\t\t  if (discriminator_ptr && local_discriminator)\n\t\t    * discriminator_ptr = local_discriminator;\n\t\t  if (local_linenumber)\n\t\t    * linenumber_ptr = local_linenumber;\n\t\t  min_range = range;\n\t\t}\n\t    }\n\t}\n\n      if (* linenumber_ptr)\n\t{\n\t  found = TRUE;\n\t  goto done;\n\t}\n    }\n\n  /* The DWARF2 spec says that the initial length field, and the\n     offset of the abbreviation table, should both be 4-byte values.\n     However, some compilers do things differently.  */\n  if (addr_size == 0)\n    addr_size = 4;\n  BFD_ASSERT (addr_size == 4 || addr_size == 8);\n\n  /* Read each remaining comp. units checking each as they are read.  */\n  while (stash->info_ptr < stash->info_ptr_end)\n    {\n      bfd_vma length;\n      unsigned int offset_size = addr_size;\n      bfd_byte *info_ptr_unit = stash->info_ptr;\n\n      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr, stash->info_ptr_end);\n      /* A 0xffffff length is the DWARF3 way of indicating\n\t we use 64-bit offsets, instead of 32-bit offsets.  */\n      if (length == 0xffffffff)\n\t{\n\t  offset_size = 8;\n\t  length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);\n\t  stash->info_ptr += 12;\n\t}\n      /* A zero length is the IRIX way of indicating 64-bit offsets,\n\t mostly because the 64-bit length will generally fit in 32\n\t bits, and the endianness helps.  */\n      else if (length == 0)\n\t{\n\t  offset_size = 8;\n\t  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);\n\t  stash->info_ptr += 8;\n\t}\n      /* In the absence of the hints above, we assume 32-bit DWARF2\n\t offsets even for targets with 64-bit addresses, because:\n\t   a) most of the time these targets will not have generated\n\t      more than 2Gb of debug info and so will not need 64-bit\n\t      offsets,\n\t and\n\t   b) if they do use 64-bit offsets but they are not using\n\t      the size hints that are tested for above then they are\n\t      not conforming to the DWARF3 standard anyway.  */\n      else if (addr_size == 8)\n\t{\n\t  offset_size = 4;\n\t  stash->info_ptr += 4;\n\t}\n      else\n\tstash->info_ptr += 4;\n\n      if (length > 0)\n\t{\n\t  bfd_byte * new_ptr;\n\n\t  each = parse_comp_unit (stash, length, info_ptr_unit,\n\t\t\t\t  offset_size);\n\t  if (!each)\n\t    /* The dwarf information is damaged, don't trust it any\n\t       more.  */\n\t    break;\n\n\t  new_ptr = stash->info_ptr + length;\n\t  /* PR 17512: file: 1500698c.  */\n\t  if (new_ptr < stash->info_ptr)\n\t    {\n\t      /* A corrupt length value - do not trust the info any more.  */\n\t      found = FALSE;\n\t      break;\n\t    }\n\t  else\n\t    stash->info_ptr = new_ptr;\n\n\t  if (stash->all_comp_units)\n\t    stash->all_comp_units->prev_unit = each;\n\t  else\n\t    stash->last_comp_unit = each;\n"
}