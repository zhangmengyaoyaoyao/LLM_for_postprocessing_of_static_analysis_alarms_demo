{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf.c",
    "message": "Offset added: 5 Size: [0, +oo].",
    "warning_function_name": "_bfd_elf_get_synthetic_symtab",
    "warning_line": "memcpy (names, \"@plt\", sizeof (\"@plt\"));",
    "warning_context": "\n  relplt_name = bed->relplt_name;\n  if (relplt_name == NULL)\n    relplt_name = bed->rela_plts_and_copies_p ? \".rela.plt\" : \".rel.plt\";\n  relplt = bfd_get_section_by_name (abfd, relplt_name);\n  if (relplt == NULL)\n    return 0;\n\n  hdr = &elf_section_data (relplt)->this_hdr;\n  if (hdr->sh_link != elf_dynsymtab (abfd)\n      || (hdr->sh_type != SHT_REL && hdr->sh_type != SHT_RELA))\n    return 0;\n\n  plt = bfd_get_section_by_name (abfd, \".plt\");\n  if (plt == NULL)\n    return 0;\n\n  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;\n  if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))\n    return -1;\n\n  count = relplt->size / hdr->sh_entsize;\n  size = count * sizeof (asymbol);\n  p = relplt->relocation;\n  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)\n    {\n      size += strlen ((*p->sym_ptr_ptr)->name) + sizeof (\"@plt\");\n      if (p->addend != 0)\n\t{\n#ifdef BFD64\n\t  size += sizeof (\"+0x\") - 1 + 8 + 8 * (bed->s->elfclass == ELFCLASS64);\n#else\n\t  size += sizeof (\"+0x\") - 1 + 8;\n#endif\n\t}\n    }\n\n  s = *ret = (asymbol *) bfd_malloc (size);\n  if (s == NULL)\n    return -1;\n\n  names = (char *) (s + count);\n  p = relplt->relocation;\n  n = 0;\n  for (i = 0; i < count; i++, p += bed->s->int_rels_per_ext_rel)\n    {\n      size_t len;\n      bfd_vma addr;\n\n      addr = bed->plt_sym_val (i, plt, p);\n      if (addr == (bfd_vma) -1)\n\tcontinue;\n\n      *s = **p->sym_ptr_ptr;\n      /* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL set.  Since\n\t we are defining a symbol, ensure one of them is set.  */\n      if ((s->flags & BSF_LOCAL) == 0)\n\ts->flags |= BSF_GLOBAL;\n      s->flags |= BSF_SYNTHETIC;\n      s->section = plt;\n      s->value = addr - plt->vma;\n      s->name = names;\n      s->udata.p = NULL;\n      len = strlen ((*p->sym_ptr_ptr)->name);\n      memcpy (names, (*p->sym_ptr_ptr)->name, len);\n      names += len;\n      if (p->addend != 0)\n\t{\n\t  char buf[30], *a;\n\n\t  memcpy (names, \"+0x\", sizeof (\"+0x\") - 1);\n\t  names += sizeof (\"+0x\") - 1;\n\t  bfd_sprintf_vma (abfd, buf, p->addend);\n\t  for (a = buf; *a == '0'; ++a)\n\t    ;\n\t  len = strlen (a);\n\t  memcpy (names, a, len);\n\t  names += len;\n\t}\n      memcpy (names, \"@plt\", sizeof (\"@plt\"));\n      names += sizeof (\"@plt\");\n      ++s, ++n;\n    }\n\n  return n;\n}\n\n/* It is only used by x86-64 so far.  */\nasection _bfd_elf_large_com_section\n  = BFD_FAKE_SECTION (_bfd_elf_large_com_section,\n\t\t      SEC_IS_COMMON, NULL, \"LARGE_COMMON\", 0);\n\nvoid\n_bfd_elf_post_process_headers (bfd * abfd,\n\t\t\t       struct bfd_link_info * link_info ATTRIBUTE_UNUSED)\n{\n  Elf_Internal_Ehdr * i_ehdrp;\t/* ELF file header, internal form.  */\n\n  i_ehdrp = elf_elfheader (abfd);\n\n  i_ehdrp->e_ident[EI_OSABI] = get_elf_backend_data (abfd)->elf_osabi;\n"
}