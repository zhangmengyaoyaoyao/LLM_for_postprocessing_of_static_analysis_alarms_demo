{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [-1, +oo] (⇐ [0, +oo] + -1) Size: [1, +oo].",
    "Code_line": "\t    || (from[1] == '>' && from > s3 && from[-1] == '>'))",
    "Code_function": "stab_demangle_template (struct stab_demangle_info *minfo, const char **pp,\n\t\t\tchar **pname)\n{\n  const char *orig;\n  unsigned int r, i;\n\n  orig = *pp;\n\n  ++*pp;\n\n  /* Skip the template name.  */\n  r = stab_demangle_count (pp);\n  if (r == 0 || strlen (*pp) < r)\n    {\n      stab_bad_demangle (orig);\n      return FALSE;\n    }\n  *pp += r;\n\n  /* Get the size of the parameter list.  */\n  if (stab_demangle_get_count (pp, &r) == 0)\n    {\n      stab_bad_demangle (orig);\n      return FALSE;\n    }\n\n  for (i = 0; i < r; i++)\n    {\n      if (**pp == 'Z')\n\t{\n\t  /* This is a type parameter.  */\n\t  ++*pp;\n\t  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))\n\t    return FALSE;\n\t}\n      else\n\t{\n\t  const char *old_p;\n\t  bfd_boolean pointerp, realp, integralp, charp, boolp;\n\t  bfd_boolean done;\n\n\t  old_p = *pp;\n\t  pointerp = FALSE;\n\t  realp = FALSE;\n\t  integralp = FALSE;\n\t  charp = FALSE;\n\t  boolp = FALSE;\n\t  done = FALSE;\n\n\t  /* This is a value parameter.  */\n\n\t  if (! stab_demangle_type (minfo, pp, (debug_type *) NULL))\n\t    return FALSE;\n\n\t  while (*old_p != '\\0' && ! done)\n\t    {\n\t      switch (*old_p)\n\t\t{\n\t\tcase 'P':\n\t\tcase 'p':\n\t\tcase 'R':\n\t\t  pointerp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\tcase 'C':\t/* Const.  */\n\t\tcase 'S':\t/* Signed.  */\n\t\tcase 'U':\t/* Unsigned.  */\n\t\tcase 'V':\t/* Volatile.  */\n\t\tcase 'F':\t/* Function.  */\n\t\tcase 'M':\t/* Member function.  */\n\t\tcase 'O':\t/* ??? */\n\t\t  ++old_p;\n\t\t  break;\n\t\tcase 'Q':\t/* Qualified name.  */\n\t\t  integralp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\tcase 'T':\t/* Remembered type.  */\n\t\t  abort ();\n\t\tcase 'v':\t/* Void.  */\n\t\t  abort ();\n\t\tcase 'x':\t/* Long long.  */\n\t\tcase 'l':\t/* Long.  */\n\t\tcase 'i':\t/* Int.  */\n\t\tcase 's':\t/* Short.  */\n\t\tcase 'w':\t/* Wchar_t.  */\n\t\t  integralp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\tcase 'b':\t/* Bool.  */\n\t\t  boolp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\tcase 'c':\t/* Char.  */\n\t\t  charp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\tcase 'r':\t/* Long double.  */\n\t\tcase 'd':\t/* Double.  */\n\t\tcase 'f':\t/* Float.  */\n\t\t  realp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\tdefault:\n\t\t  /* Assume it's a user defined integral type.  */\n\t\t  integralp = TRUE;\n\t\t  done = TRUE;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if (integralp)\n\t    {\n\t      if (**pp == 'm')\n\t\t++*pp;\n\t      while (ISDIGIT (**pp))\n\t\t++*pp;\n\t    }\n\t  else if (charp)\n\t    {\n\t      unsigned int val;\n\n\t      if (**pp == 'm')\n\t\t++*pp;\n\t      val = stab_demangle_count (pp);\n\t      if (val == 0)\n\t\t{\n\t\t  stab_bad_demangle (orig);\n\t\t  return FALSE;\n\t\t}\n\t    }\n\t  else if (boolp)\n\t    {\n\t      unsigned int val;\n\n\t      val = stab_demangle_count (pp);\n\t      if (val != 0 && val != 1)\n\t\t{\n\t\t  stab_bad_demangle (orig);\n\t\t  return FALSE;\n\t\t}\n\t    }\n\t  else if (realp)\n\t    {\n\t      if (**pp == 'm')\n\t\t++*pp;\n\t      while (ISDIGIT (**pp))\n\t\t++*pp;\n\t      if (**pp == '.')\n\t\t{\n\t\t  ++*pp;\n\t\t  while (ISDIGIT (**pp))\n\t\t    ++*pp;\n\t\t}\n\t      if (**pp == 'e')\n\t\t{\n\t\t  ++*pp;\n\t\t  while (ISDIGIT (**pp))\n\t\t    ++*pp;\n\t\t}\n\t    }\n\t  else if (pointerp)\n\t    {\n\t      unsigned int len;\n\n\t      len = stab_demangle_count (pp);\n\t      if (len == 0)\n\t\t{\n\t\t  stab_bad_demangle (orig);\n\t\t  return FALSE;\n\t\t}\n\t      *pp += len;\n\t    }\n\t}\n    }\n\n  /* We can translate this to a string fairly easily by invoking the\n     regular demangling routine.  */\n  if (pname != NULL)\n    {\n      char *s1, *s2, *s3, *s4 = NULL;\n      char *from, *to;\n\n      s1 = savestring (orig, *pp - orig);\n\n      s2 = concat (\"NoSuchStrinG__\", s1, (const char *) NULL);\n\n      free (s1);\n\n      s3 = cplus_demangle (s2, DMGL_ANSI);\n\n      free (s2);\n\n      if (s3 != NULL)\n\ts4 = strstr (s3, \"::NoSuchStrinG\");\n      if (s3 == NULL || s4 == NULL)\n\t{\n\t  stab_bad_demangle (orig);\n\t  if (s3 != NULL)\n\t    free (s3);\n\t  return FALSE;\n\t}\n\n      /* Eliminating all spaces, except those between > characters,\n         makes it more likely that the demangled name will match the\n         name which g++ used as the structure name.  */\n      for (from = to = s3; from != s4; ++from)\n\tif (*from != ' '\n\t    || (from[1] == '>' && from > s3 && from[-1] == '>'))\n\t  *to++ = *from;\n\n      *pname = savestring (s3, to - s3);\n\n      free (s3);\n    }\n\n  return TRUE;\n}"
}