{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Code_line": "\t      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rela, asect, TRUE))",
    "Code_function": "elf_fake_sections (bfd *abfd, asection *asect, void *fsarg)\n{\n  struct fake_section_arg *arg = (struct fake_section_arg *)fsarg;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  struct bfd_elf_section_data *esd = elf_section_data (asect);\n  Elf_Internal_Shdr *this_hdr;\n  unsigned int sh_type;\n\n  if (arg->failed)\n    {\n      /* We already failed; just get out of the bfd_map_over_sections\n\t loop.  */\n      return;\n    }\n\n  this_hdr = &esd->this_hdr;\n\n  this_hdr->sh_name = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),\n\t\t\t\t\t\t\t  asect->name, FALSE);\n  if (this_hdr->sh_name == (unsigned int) -1)\n    {\n      arg->failed = TRUE;\n      return;\n    }\n\n  /* Don't clear sh_flags. Assembler may set additional bits.  */\n\n  if ((asect->flags & SEC_ALLOC) != 0\n      || asect->user_set_vma)\n    this_hdr->sh_addr = asect->vma;\n  else\n    this_hdr->sh_addr = 0;\n\n  this_hdr->sh_offset = 0;\n  this_hdr->sh_size = asect->size;\n  this_hdr->sh_link = 0;\n  /* PR 17512: file: 0eb809fe, 8b0535ee.  */\n  if (asect->alignment_power >= (sizeof (bfd_vma) * 8) - 1)\n    {\n      (*_bfd_error_handler)\n\t(_(\"%B: error: Alignment power %d of section `%A' is too big\"),\n\t abfd, asect, asect->alignment_power);\n      arg->failed = TRUE;\n      return;\n    }\n  this_hdr->sh_addralign = (bfd_vma) 1 << asect->alignment_power;\n  /* The sh_entsize and sh_info fields may have been set already by\n     copy_private_section_data.  */\n\n  this_hdr->bfd_section = asect;\n  this_hdr->contents = NULL;\n\n  /* If the section type is unspecified, we set it based on\n     asect->flags.  */\n  if ((asect->flags & SEC_GROUP) != 0)\n    sh_type = SHT_GROUP;\n  else\n    sh_type = bfd_elf_get_default_section_type (asect->flags);\n\n  if (this_hdr->sh_type == SHT_NULL)\n    this_hdr->sh_type = sh_type;\n  else if (this_hdr->sh_type == SHT_NOBITS\n\t   && sh_type == SHT_PROGBITS\n\t   && (asect->flags & SEC_ALLOC) != 0)\n    {\n      /* Warn if we are changing a NOBITS section to PROGBITS, but\n\t allow the link to proceed.  This can happen when users link\n\t non-bss input sections to bss output sections, or emit data\n\t to a bss output section via a linker script.  */\n      (*_bfd_error_handler)\n\t(_(\"warning: section `%A' type changed to PROGBITS\"), asect);\n      this_hdr->sh_type = sh_type;\n    }\n\n  switch (this_hdr->sh_type)\n    {\n    default:\n      break;\n\n    case SHT_STRTAB:\n    case SHT_INIT_ARRAY:\n    case SHT_FINI_ARRAY:\n    case SHT_PREINIT_ARRAY:\n    case SHT_NOTE:\n    case SHT_NOBITS:\n    case SHT_PROGBITS:\n      break;\n\n    case SHT_HASH:\n      this_hdr->sh_entsize = bed->s->sizeof_hash_entry;\n      break;\n\n    case SHT_DYNSYM:\n      this_hdr->sh_entsize = bed->s->sizeof_sym;\n      break;\n\n    case SHT_DYNAMIC:\n      this_hdr->sh_entsize = bed->s->sizeof_dyn;\n      break;\n\n    case SHT_RELA:\n      if (get_elf_backend_data (abfd)->may_use_rela_p)\n\tthis_hdr->sh_entsize = bed->s->sizeof_rela;\n      break;\n\n     case SHT_REL:\n      if (get_elf_backend_data (abfd)->may_use_rel_p)\n\tthis_hdr->sh_entsize = bed->s->sizeof_rel;\n      break;\n\n     case SHT_GNU_versym:\n      this_hdr->sh_entsize = sizeof (Elf_External_Versym);\n      break;\n\n     case SHT_GNU_verdef:\n      this_hdr->sh_entsize = 0;\n      /* objcopy or strip will copy over sh_info, but may not set\n\t cverdefs.  The linker will set cverdefs, but sh_info will be\n\t zero.  */\n      if (this_hdr->sh_info == 0)\n\tthis_hdr->sh_info = elf_tdata (abfd)->cverdefs;\n      else\n\tBFD_ASSERT (elf_tdata (abfd)->cverdefs == 0\n\t\t    || this_hdr->sh_info == elf_tdata (abfd)->cverdefs);\n      break;\n\n    case SHT_GNU_verneed:\n      this_hdr->sh_entsize = 0;\n      /* objcopy or strip will copy over sh_info, but may not set\n\t cverrefs.  The linker will set cverrefs, but sh_info will be\n\t zero.  */\n      if (this_hdr->sh_info == 0)\n\tthis_hdr->sh_info = elf_tdata (abfd)->cverrefs;\n      else\n\tBFD_ASSERT (elf_tdata (abfd)->cverrefs == 0\n\t\t    || this_hdr->sh_info == elf_tdata (abfd)->cverrefs);\n      break;\n\n    case SHT_GROUP:\n      this_hdr->sh_entsize = GRP_ENTRY_SIZE;\n      break;\n\n    case SHT_GNU_HASH:\n      this_hdr->sh_entsize = bed->s->arch_size == 64 ? 0 : 4;\n      break;\n    }\n\n  if ((asect->flags & SEC_ALLOC) != 0)\n    this_hdr->sh_flags |= SHF_ALLOC;\n  if ((asect->flags & SEC_READONLY) == 0)\n    this_hdr->sh_flags |= SHF_WRITE;\n  if ((asect->flags & SEC_CODE) != 0)\n    this_hdr->sh_flags |= SHF_EXECINSTR;\n  if ((asect->flags & SEC_MERGE) != 0)\n    {\n      this_hdr->sh_flags |= SHF_MERGE;\n      this_hdr->sh_entsize = asect->entsize;\n      if ((asect->flags & SEC_STRINGS) != 0)\n\tthis_hdr->sh_flags |= SHF_STRINGS;\n    }\n  if ((asect->flags & SEC_GROUP) == 0 && elf_group_name (asect) != NULL)\n    this_hdr->sh_flags |= SHF_GROUP;\n  if ((asect->flags & SEC_THREAD_LOCAL) != 0)\n    {\n      this_hdr->sh_flags |= SHF_TLS;\n      if (asect->size == 0\n\t  && (asect->flags & SEC_HAS_CONTENTS) == 0)\n\t{\n\t  struct bfd_link_order *o = asect->map_tail.link_order;\n\n\t  this_hdr->sh_size = 0;\n\t  if (o != NULL)\n\t    {\n\t      this_hdr->sh_size = o->offset + o->size;\n\t      if (this_hdr->sh_size != 0)\n\t\tthis_hdr->sh_type = SHT_NOBITS;\n\t    }\n\t}\n    }\n  if ((asect->flags & (SEC_GROUP | SEC_EXCLUDE)) == SEC_EXCLUDE)\n    this_hdr->sh_flags |= SHF_EXCLUDE;\n\n  /* If the section has relocs, set up a section header for the\n     SHT_REL[A] section.  If two relocation sections are required for\n     this section, it is up to the processor-specific back-end to\n     create the other.  */\n  if ((asect->flags & SEC_RELOC) != 0)\n    {\n      /* When doing a relocatable link, create both REL and RELA sections if\n\t needed.  */\n      if (arg->link_info\n\t  /* Do the normal setup if we wouldn't create any sections here.  */\n\t  && esd->rel.count + esd->rela.count > 0\n\t  && (arg->link_info->relocatable || arg->link_info->emitrelocations))\n\t{\n\t  if (esd->rel.count && esd->rel.hdr == NULL\n\t      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rel, asect, FALSE))\n\t    {\n\t      arg->failed = TRUE;\n\t      return;\n\t    }\n\t  if (esd->rela.count && esd->rela.hdr == NULL\n\t      && !_bfd_elf_init_reloc_shdr (abfd, &esd->rela, asect, TRUE))\n\t    {\n\t      arg->failed = TRUE;\n\t      return;\n\t    }\n\t}\n      else if (!_bfd_elf_init_reloc_shdr (abfd,\n\t\t\t\t\t  (asect->use_rela_p\n\t\t\t\t\t   ? &esd->rela : &esd->rel),\n\t\t\t\t\t  asect,\n\t\t\t\t\t  asect->use_rela_p))\n\t  arg->failed = TRUE;\n    }\n\n  /* Check for processor-specific section types.  */\n  sh_type = this_hdr->sh_type;\n  if (bed->elf_backend_fake_sections\n      && !(*bed->elf_backend_fake_sections) (abfd, this_hdr, asect))\n    arg->failed = TRUE;\n\n  if (sh_type == SHT_NOBITS && asect->size != 0)\n    {\n      /* Don't change the header type from NOBITS if we are being\n\t called for objcopy --only-keep-debug.  */\n      this_hdr->sh_type = sh_type;\n    }\n}"
}