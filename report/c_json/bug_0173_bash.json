{
    "Project": "bash",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "lib/termcap/termcap.c",
    "message": "Offset: [-64, 63] Size: 33 by call to `tgetst1`.",
    "warning_function_name": "tgetent",
    "warning_line": "indirect = tgetst1 (find_capability (termcap_name, \"tc\"), (char **) 0);",
    "warning_context": "__private_extern__\nint\ntgetent (bp, name)\n     char *bp, *name;\n{\n  register char *termcap_name;\n  register int fd;\n  struct buffer buf;\n  register char *bp1;\n  char *bp2;\n  char *term;\n  int malloc_size = 0;\n  register int c;\n  char *tcenv;\t\t\t/* TERMCAP value, if it contains :tc=.  */\n  char *indirect = NULL;\t/* Terminal type in :tc= in TERMCAP value.  */\n  int filep;\n\n#ifdef INTERNAL_TERMINAL\n  /* For the internal terminal we don't want to read any termcap file,\n     so fake it.  */\n  if (!strcmp (name, \"internal\"))\n    {\n      term = INTERNAL_TERMINAL;\n      if (!bp)\n\t{\n\t  malloc_size = 1 + strlen (term);\n\t  bp = (char *) xmalloc (malloc_size);\n\t}\n      strcpy (bp, term);\n      goto ret;\n    }\n#endif /* INTERNAL_TERMINAL */\n\n  /* For compatibility with programs like `less' that want to\n     put data in the termcap buffer themselves as a fallback.  */\n  if (bp)\n    term_entry = bp;\n\n  termcap_name = getenv (\"TERMCAP\");\n  if (termcap_name && *termcap_name == '\\0')\n    termcap_name = NULL;\n#if 0\n#if defined (MSDOS) && !defined (TEST)\n  if (termcap_name && (*termcap_name == '\\\\'\n\t\t       || *termcap_name == '/'\n\t\t       || termcap_name[1] == ':'))\n    dostounix_filename(termcap_name);\n#endif\n#endif\n\n  filep = termcap_name && valid_filename_p (termcap_name);\n\n  /* If termcap_name is non-null and starts with / (in the un*x case, that is),\n     it is a file name to use instead of /etc/termcap.\n     If it is non-null and does not start with /,\n     it is the entry itself, but only if\n     the name the caller requested matches the TERM variable.  */\n\n  if (termcap_name && !filep && !strcmp (name, getenv (\"TERM\")))\n    {\n      indirect = tgetst1 (find_capability (termcap_name, \"tc\"), (char **) 0);\n      if (!indirect)\n\t{\n\t  if (!bp)\n\t    bp = termcap_name;\n\t  else\n\t    strcpy (bp, termcap_name);\n\t  goto ret;\n\t}\n      else\n\t{\t\t\t/* It has tc=.  Need to read /etc/termcap.  */\n\t  tcenv = termcap_name;\n \t  termcap_name = NULL;\n\t}\n    }\n\n  if (!termcap_name || !filep)\n    termcap_name = TERMCAP_FILE;\n\n  /* Here we know we must search a file and termcap_name has its name.  */\n\n#ifdef MSDOS\n  fd = open (termcap_name, O_RDONLY|O_TEXT, 0);\n#else\n  fd = open (termcap_name, O_RDONLY, 0);\n#endif\n  if (fd < 0)\n    return -1;\n\n  buf.size = BUFSIZE;\n  /* Add 1 to size to ensure room for terminating null.  */\n  buf.beg = (char *) xmalloc (buf.size + 1);\n  term = indirect ? indirect : name;\n\n  if (!bp)\n    {\n      malloc_size = indirect ? strlen (tcenv) + 1 : buf.size;\n      bp = (char *) xmalloc (malloc_size);\n    }\n  bp1 = bp;\n\n"
}