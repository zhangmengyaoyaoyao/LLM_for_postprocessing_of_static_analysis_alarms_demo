{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "subst.c",
    "message": "Array access (from variable 'separators') results in a null pointer dereference",
    "warning_function_name": "list_string",
    "warning_line": "if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))",
    "warning_context": "     long as those characters appear in IFS.  Do not do this if\n     STRING is quoted or if there are no separator characters. */\n  if (!quoted || !separators || !*separators)\n    {\n      for (s = string; *s && spctabnl (*s) && issep (*s); s++);\n\n      if (!*s)\n\treturn ((WORD_LIST *)NULL);\n\n      string = s;\n    }\n\n  /* OK, now STRING points to a word that does not begin with white space.\n     The splitting algorithm is:\n\textract a word, stopping at a separator\n\tskip sequences of spc, tab, or nl as long as they are separators\n     This obeys the field splitting rules in Posix.2. */\n  slen = (MB_CUR_MAX > 1) ? strlen (string) : 1;\n  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )\n    {\n      /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim\n\t unless multibyte chars are possible. */\n      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);\n      if (current_word == 0)\n\tbreak;\n\n      /* If we have a quoted empty string, add a quoted null argument.  We\n\t want to preserve the quoted null character iff this is a quoted\n\t empty string; otherwise the quoted null characters are removed\n\t below. */\n      if (QUOTED_NULL (current_word))\n\t{\n\t  t = alloc_word_desc ();\n\t  t->word = make_quoted_char ('\\0');\n\t  t->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  result = make_word_list (t, result);\n\t}\n      else if (current_word[0] != '\\0')\n\t{\n\t  /* If we have something, then add it regardless.  However,\n\t     perform quoted null character removal on the current word. */\n\t  remove_quoted_nulls (current_word);\n\t  result = add_string_to_list (current_word, result);\n\t  result->word->flags &= ~W_HASQUOTEDNULL;\t/* just to be sure */\n\t  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))\n\t    result->word->flags |= W_QUOTED;\n\t}\n\n      /* If we're not doing sequences of separators in the traditional\n\t Bourne shell style, then add a quoted null argument. */\n      else if (!sh_style_split && !spctabnl (string[sindex]))\n\t{\n\t  t = alloc_word_desc ();\n\t  t->word = make_quoted_char ('\\0');\n\t  t->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  result = make_word_list (t, result);\n\t}\n\n      free (current_word);\n\n      /* Note whether or not the separator is IFS whitespace, used later. */\n      whitesep = string[sindex] && spctabnl (string[sindex]);\n\n      /* Move past the current separator character. */\n      if (string[sindex])\n\t{\n\t  DECLARE_MBSTATE;\n\t  ADVANCE_CHAR (string, slen, sindex);\n\t}\n\n      /* Now skip sequences of space, tab, or newline characters if they are\n\t in the list of separators. */\n      while (string[sindex] && spctabnl (string[sindex]) && issep (string[sindex]))\n\tsindex++;\n\n      /* If the first separator was IFS whitespace and the current character\n\t is a non-whitespace IFS character, it should be part of the current\n\t field delimiter, not a separate delimiter that would result in an\n\t empty field.  Look at POSIX.2, 3.6.5, (3)(b). */\n      if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))\n\t{\n\t  sindex++;\n\t  /* An IFS character that is not IFS white space, along with any\n\t     adjacent IFS white space, shall delimit a field. (SUSv3) */\n\t  while (string[sindex] && spctabnl (string[sindex]) && isifs (string[sindex]))\n\t    sindex++;\n\t}\n    }\n  return (REVERSE_LIST (result, WORD_LIST *));\n}\n\n/* Parse a single word from STRING, using SEPARATORS to separate fields.\n   ENDPTR is set to the first character after the word.  This is used by\n   the `read' builtin.  This is never called with SEPARATORS != $IFS;\n   it should be simplified.\n\n   XXX - this function is very similar to list_string; they should be\n\t combined - XXX */\nchar *\nget_word_from_string (stringp, separators, endptr)\n     char **stringp, *separators, **endptr;\n"
}