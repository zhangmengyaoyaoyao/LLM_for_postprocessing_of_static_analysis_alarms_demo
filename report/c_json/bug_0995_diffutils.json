{
    "Project": "diffutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "lib/careadlinkat.c",
    "message": "Offset: [-oo, -1+max(9223372036854775808, `buffer_size`)] Size: 1024.",
    "warning_function_name": "careadlinkat",
    "warning_line": "buf[link_size++] = '\\0';",
    "warning_context": "char *\ncareadlinkat (int fd, char const *filename,\n              char *buffer, size_t buffer_size,\n              struct allocator const *alloc,\n              ssize_t (*preadlinkat) (int, char const *, char *, size_t))\n{\n  char *buf;\n  size_t buf_size;\n  size_t buf_size_max =\n    SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n  char stack_buf[1024];\n\n  if (! alloc)\n    alloc = &stdlib_allocator;\n\n  if (! buffer_size)\n    {\n      /* Allocate the initial buffer on the stack.  This way, in the\n         common case of a symlink of small size, we get away with a\n         single small malloc() instead of a big malloc() followed by a\n         shrinking realloc().  */\n      buffer = stack_buf;\n      buffer_size = sizeof stack_buf;\n    }\n\n  buf = buffer;\n  buf_size = buffer_size;\n\n  do\n    {\n      /* Attempt to read the link into the current buffer.  */\n      ssize_t link_length = preadlinkat (fd, filename, buf, buf_size);\n      size_t link_size;\n      if (link_length < 0)\n        {\n          /* On AIX 5L v5.3 and HP-UX 11i v2 04/09, readlink returns -1\n             with errno == ERANGE if the buffer is too small.  */\n          int readlinkat_errno = errno;\n          if (readlinkat_errno != ERANGE)\n            {\n              if (buf != buffer)\n                {\n                  alloc->free (buf);\n                  errno = readlinkat_errno;\n                }\n              return NULL;\n            }\n        }\n\n      link_size = link_length;\n\n      if (link_size < buf_size)\n        {\n          buf[link_size++] = '\\0';\n\n          if (buf == stack_buf)\n            {\n              char *b = (char *) alloc->allocate (link_size);\n              buf_size = link_size;\n              if (! b)\n                break;\n              memcpy (b, buf, link_size);\n              buf = b;\n            }\n          else if (link_size < buf_size && buf != buffer && alloc->reallocate)\n            {\n              /* Shrink BUF before returning it.  */\n              char *b = (char *) alloc->reallocate (buf, link_size);\n              if (b)\n                buf = b;\n            }\n\n          return buf;\n        }\n\n      if (buf != buffer)\n        alloc->free (buf);\n\n      if (buf_size <= buf_size_max / 2)\n        buf_size *= 2;\n      else if (buf_size < buf_size_max)\n        buf_size = buf_size_max;\n      else if (buf_size_max < SIZE_MAX)\n        {\n          errno = ENAMETOOLONG;\n          return NULL;\n        }\n      else\n        break;\n      buf = (char *) alloc->allocate (buf_size);\n    }\n  while (buf);\n\n  if (alloc->die)\n    alloc->die (buf_size);\n  errno = ENOMEM;\n  return NULL;\n}\n"
}