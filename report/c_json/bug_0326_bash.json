{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/complete.c",
    "message": "The value read from dentry was never initialized.",
    "warning_function_name": "print_filename",
    "warning_line": "if (convfn != dentry)",
    "warning_context": "\t}\n\n      /* Special case for no filename.  If the user has disabled the\n         `match-hidden-files' variable, skip filenames beginning with `.'.\n\t All other entries except \".\" and \"..\" match. */\n      if (filename_len == 0)\n\t{\n\t  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (convfn))\n\t    continue;\n\n\t  if (convfn[0] != '.' ||\n\t       (convfn[1] && (convfn[1] != '.' || convfn[2])))\n\t    break;\n\t}\n      else\n\t{\n\t  if (complete_fncmp (convfn, convlen, filename, filename_len))\n\t    break;\n\t}\n    }\n\n  if (entry == 0)\n    {\n      if (directory)\n\t{\n\t  closedir (directory);\n\t  directory = (DIR *)NULL;\n\t}\n      if (dirname)\n\t{\n\t  xfree (dirname);\n\t  dirname = (char *)NULL;\n\t}\n      if (filename)\n\t{\n\t  xfree (filename);\n\t  filename = (char *)NULL;\n\t}\n      if (users_dirname)\n\t{\n\t  xfree (users_dirname);\n\t  users_dirname = (char *)NULL;\n\t}\n\n      return (char *)NULL;\n    }\n  else\n    {\n      /* dirname && (strcmp (dirname, \".\") != 0) */\n      if (dirname && (dirname[0] != '.' || dirname[1]))\n\t{\n\t  if (rl_complete_with_tilde_expansion && *users_dirname == '~')\n\t    {\n\t      dirlen = strlen (dirname);\n\t      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));\n\t      strcpy (temp, dirname);\n\t      /* Canonicalization cuts off any final slash present.  We\n\t\t may need to add it back. */\n\t      if (dirname[dirlen - 1] != '/')\n\t        {\n\t          temp[dirlen++] = '/';\n\t          temp[dirlen] = '\\0';\n\t        }\n\t    }\n\t  else\n\t    {\n\t      dirlen = strlen (users_dirname);\n\t      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));\n\t      strcpy (temp, users_dirname);\n\t      /* Make sure that temp has a trailing slash here. */\n\t      if (users_dirname[dirlen - 1] != '/')\n\t\ttemp[dirlen++] = '/';\n\t    }\n\n\t  strcpy (temp + dirlen, convfn);\n\t}\n      else\n\ttemp = savestring (convfn);\n\n      if (convfn != dentry)\n\txfree (convfn);\n\n      return (temp);\n    }\n}\n\n/* An initial implementation of a menu completion function a la tcsh.  The\n   first time (if the last readline command was not rl_old_menu_complete), we\n   generate the list of matches.  This code is very similar to the code in\n   rl_complete_internal -- there should be a way to combine the two.  Then,\n   for each item in the list of matches, we insert the match in an undoable\n   fashion, with the appropriate character appended (this happens on the\n   second and subsequent consecutive calls to rl_old_menu_complete).  When we\n   hit the end of the match list, we restore the original unmatched text,\n   ring the bell, and reset the counter to zero. */\nint\nrl_old_menu_complete (count, invoking_key)\n     int count, invoking_key;\n{\n  rl_compentry_func_t *our_func;\n  int matching_filenames, found_quote;\n"
}