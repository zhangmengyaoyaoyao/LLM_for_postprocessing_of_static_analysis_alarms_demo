{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-20, 171] (⇐ [-84, 107] + 64) Size: 4064 by call to `bfd_zalloc`.",
    "Code_line": "\t= (struct dwarf1_debug *) bfd_zalloc (abfd, size);",
    "Code_function": "_bfd_dwarf1_find_nearest_line (bfd *abfd,\n\t\t\t       asymbol **symbols,\n\t\t\t       asection *section,\n\t\t\t       bfd_vma offset,\n\t\t\t       const char **filename_ptr,\n\t\t\t       const char **functionname_ptr,\n\t\t\t       unsigned int *linenumber_ptr)\n{\n  struct dwarf1_debug *stash = elf_tdata (abfd)->dwarf1_find_line_info;\n\n  struct dwarf1_unit* eachUnit;\n\n  /* What address are we looking for? */\n  unsigned long addr = (unsigned long)(offset + section->vma);\n\n  *filename_ptr = NULL;\n  *functionname_ptr = NULL;\n  *linenumber_ptr = 0;\n\n  if (! stash)\n    {\n      asection *msec;\n      bfd_size_type size = sizeof (struct dwarf1_debug);\n\n      stash = elf_tdata (abfd)->dwarf1_find_line_info\n\t= (struct dwarf1_debug *) bfd_zalloc (abfd, size);\n\n      if (! stash)\n\treturn FALSE;\n\n      msec = bfd_get_section_by_name (abfd, \".debug\");\n      if (! msec)\n\t/* No dwarf1 info.  Note that at this point the stash\n\t   has been allocated, but contains zeros, this lets\n\t   future calls to this function fail quicker.  */\n\treturn FALSE;\n\n      size = msec->rawsize ? msec->rawsize : msec->size;\n      stash->debug_section\n\t= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,\n\t\t\t\t\t\t     symbols);\n\n      if (! stash->debug_section)\n\treturn FALSE;\n\n      stash->debug_section_end = stash->debug_section + size;\n      stash->currentDie = stash->debug_section;\n      stash->abfd = abfd;\n      stash->syms = symbols;\n    }\n\n  /* A null debug_section indicates that there was no dwarf1 info\n     or that an error occured while setting up the stash.  */\n\n  if (! stash->debug_section)\n    return FALSE;\n\n  /* Look at the previously parsed units to see if any contain\n     the addr.  */\n  for (eachUnit = stash->lastUnit; eachUnit; eachUnit = eachUnit->prev)\n    if (eachUnit->low_pc <= addr && addr < eachUnit->high_pc)\n      return dwarf1_unit_find_nearest_line (stash, eachUnit, addr,\n\t\t\t\t\t    filename_ptr,\n\t\t\t\t\t    functionname_ptr,\n\t\t\t\t\t    linenumber_ptr);\n\n  while (stash->currentDie < stash->debug_section_end)\n    {\n      struct die_info aDieInfo;\n\n      if (! parse_die (stash->abfd, &aDieInfo, stash->currentDie,\n\t\t       stash->debug_section_end))\n\treturn FALSE;\n\n      if (aDieInfo.tag == TAG_compile_unit)\n\t{\n\t  struct dwarf1_unit* aUnit\n\t    = alloc_dwarf1_unit (stash);\n\t  if (!aUnit)\n\t    return FALSE;\n\n\t  aUnit->name = aDieInfo.name;\n\t  aUnit->low_pc = aDieInfo.low_pc;\n\t  aUnit->high_pc = aDieInfo.high_pc;\n\t  aUnit->has_stmt_list = aDieInfo.has_stmt_list;\n\t  aUnit->stmt_list_offset = aDieInfo.stmt_list_offset;\n\n\t  /* A die has a child if it's followed by a die that is\n\t     not it's sibling.  */\n\t  if (aDieInfo.sibling\n\t      && stash->currentDie + aDieInfo.length\n                    < stash->debug_section_end\n\t      && stash->currentDie + aDieInfo.length\n\t            != stash->debug_section + aDieInfo.sibling)\n\t    aUnit->first_child = stash->currentDie + aDieInfo.length;\n\t  else\n\t    aUnit->first_child = 0;\n\n\t  if (aUnit->low_pc <= addr && addr < aUnit->high_pc)\n\t    return dwarf1_unit_find_nearest_line (stash, aUnit, addr,\n\t\t\t\t\t\t  filename_ptr,\n\t\t\t\t\t\t  functionname_ptr,\n\t\t\t\t\t\t  linenumber_ptr);\n\t}\n\n      if (aDieInfo.sibling != 0)\n\tstash->currentDie = stash->debug_section + aDieInfo.sibling;\n      else\n\tstash->currentDie += aDieInfo.length;\n    }\n\n  return FALSE;\n}"
}