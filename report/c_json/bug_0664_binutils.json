{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/dwarf2.c",
    "message": "Offset added: [968, 991] (⇐ [0, 23] + 968) Size: [528, 998] by call to `bfd_zalloc`.",
    "warning_function_name": "read_abbrevs",
    "warning_line": "abbrevs = (struct abbrev_info **) bfd_zalloc (abfd, amt);",
    "warning_context": "static struct abbrev_info**\nread_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)\n{\n  struct abbrev_info **abbrevs;\n  bfd_byte *abbrev_ptr;\n  bfd_byte *abbrev_end;\n  struct abbrev_info *cur_abbrev;\n  unsigned int abbrev_number, bytes_read, abbrev_name;\n  unsigned int abbrev_form, hash_number;\n  bfd_size_type amt;\n\n  if (! read_section (abfd, &stash->debug_sections[debug_abbrev],\n\t\t      stash->syms, offset,\n\t\t      &stash->dwarf_abbrev_buffer, &stash->dwarf_abbrev_size))\n    return NULL;\n\n  if (offset >= stash->dwarf_abbrev_size)\n    return NULL;\n\n  amt = sizeof (struct abbrev_info*) * ABBREV_HASH_SIZE;\n  abbrevs = (struct abbrev_info **) bfd_zalloc (abfd, amt);\n  if (abbrevs == NULL)\n    return NULL;\n\n  abbrev_ptr = stash->dwarf_abbrev_buffer + offset;\n  abbrev_end = stash->dwarf_abbrev_buffer + stash->dwarf_abbrev_size;\n  abbrev_number = safe_read_leb128 (abfd, abbrev_ptr, &bytes_read, FALSE, abbrev_end);\n  abbrev_ptr += bytes_read;\n\n  /* Loop until we reach an abbrev number of 0.  */\n  while (abbrev_number)\n    {\n      amt = sizeof (struct abbrev_info);\n      cur_abbrev = (struct abbrev_info *) bfd_zalloc (abfd, amt);\n      if (cur_abbrev == NULL)\n\treturn NULL;\n\n      /* Read in abbrev header.  */\n      cur_abbrev->number = abbrev_number;\n      cur_abbrev->tag = (enum dwarf_tag)\n\tsafe_read_leb128 (abfd, abbrev_ptr, &bytes_read, FALSE, abbrev_end);\n      abbrev_ptr += bytes_read;\n      cur_abbrev->has_children = read_1_byte (abfd, abbrev_ptr, abbrev_end);\n      abbrev_ptr += 1;\n\n      /* Now read in declarations.  */\n      abbrev_name = safe_read_leb128 (abfd, abbrev_ptr, &bytes_read, FALSE, abbrev_end);\n      abbrev_ptr += bytes_read;\n      abbrev_form = safe_read_leb128 (abfd, abbrev_ptr, &bytes_read, FALSE, abbrev_end);\n      abbrev_ptr += bytes_read;\n\n      while (abbrev_name)\n\t{\n\t  if ((cur_abbrev->num_attrs % ATTR_ALLOC_CHUNK) == 0)\n\t    {\n\t      struct attr_abbrev *tmp;\n\n\t      amt = cur_abbrev->num_attrs + ATTR_ALLOC_CHUNK;\n\t      amt *= sizeof (struct attr_abbrev);\n\t      tmp = (struct attr_abbrev *) bfd_realloc (cur_abbrev->attrs, amt);\n\t      if (tmp == NULL)\n\t\t{\n\t\t  size_t i;\n\n\t\t  for (i = 0; i < ABBREV_HASH_SIZE; i++)\n\t\t    {\n\t\t      struct abbrev_info *abbrev = abbrevs[i];\n\n\t\t      while (abbrev)\n\t\t\t{\n\t\t\t  free (abbrev->attrs);\n\t\t\t  abbrev = abbrev->next;\n\t\t\t}\n\t\t    }\n\t\t  return NULL;\n\t\t}\n\t      cur_abbrev->attrs = tmp;\n\t    }\n\n\t  cur_abbrev->attrs[cur_abbrev->num_attrs].name\n\t    = (enum dwarf_attribute) abbrev_name;\n\t  cur_abbrev->attrs[cur_abbrev->num_attrs++].form\n\t    = (enum dwarf_form) abbrev_form;\n\t  abbrev_name = safe_read_leb128 (abfd, abbrev_ptr, &bytes_read, FALSE, abbrev_end);\n\t  abbrev_ptr += bytes_read;\n\t  abbrev_form = safe_read_leb128 (abfd, abbrev_ptr, &bytes_read, FALSE, abbrev_end);\n\t  abbrev_ptr += bytes_read;\n\t}\n\n      hash_number = abbrev_number % ABBREV_HASH_SIZE;\n      cur_abbrev->next = abbrevs[hash_number];\n      abbrevs[hash_number] = cur_abbrev;\n\n      /* Get next abbreviation.\n\t Under Irix6 the abbreviations for a compilation unit are not\n\t always properly terminated with an abbrev number of 0.\n\t Exit loop if we encounter an abbreviation which we have\n\t already read (which means we are about to read the abbreviations\n\t for the next compile unit) or if the end of the abbreviation\n\t table is reached.  */\n      if ((unsigned int) (abbrev_ptr - stash->dwarf_abbrev_buffer)\n"
}