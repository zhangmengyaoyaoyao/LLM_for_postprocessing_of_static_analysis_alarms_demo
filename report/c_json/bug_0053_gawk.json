{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [1, +oo] (⇐ [0, +oo] + [1, +oo]) Size: [0, +oo] by call to `pp_group3`.",
    "Code_line": "\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);",
    "Code_function": "pprint(INSTRUCTION *startp, INSTRUCTION *endp, bool in_for_header)\n{\n\tINSTRUCTION *pc;\n\tNODE *t1;\n\tchar *str;\n\tNODE *t2;\n\tINSTRUCTION *ip;\n\tNODE *m;\n\tchar *tmp;\n\tint rule;\n\tstatic int rule_count[MAXRULE];\n\n\tfor (pc = startp; pc != endp; pc = pc->nexti) {\n\t\tif (pc->source_line > 0)\n\t\t\tsourceline = pc->source_line;\n\n\t\tswitch (pc->opcode) {\n\t\tcase Op_rule:\n\t\t\tsource = pc->source_file;\n\t\t\trule = pc->in_rule;\n\n\t\t\tif (rule != Rule) {\n\t\t\t\tif (! rule_count[rule]++)\n\t\t\t\t\tfprintf(prof_fp, _(\"\\t# %s rule(s)\\n\\n\"), ruletab[rule]);\n\t\t\t\tfprintf(prof_fp, \"\\t%s {\\n\", ruletab[rule]);\n\t\t\t\tip = (pc + 1)->firsti;\n\t\t\t} else {\n\t\t\t\tif (! rule_count[rule]++)\n\t\t\t\t\tfprintf(prof_fp, _(\"\\t# Rule(s)\\n\\n\"));\n\t\t\t\tip = pc->nexti;\n\t\t\t\tindent(ip->exec_count);\n\t\t\t\tif (ip != (pc + 1)->firsti) {\t\t/* non-empty pattern */\n\t\t\t\t\tpprint(ip->nexti, (pc + 1)->firsti, false);\n\t\t\t\t\tt1 = pp_pop();\n\t\t\t\t\tfprintf(prof_fp, \"%s {\", t1->pp_str);\n\t\t\t\t\tpp_free(t1);\n\t\t\t\t\tip = (pc + 1)->firsti;\n\n\t\t\t\t\tif (do_profile && ip->exec_count > 0)\n\t\t\t\t\t\tfprintf(prof_fp, \" # %ld\", ip->exec_count);\n\n\t\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(prof_fp, \"{\\n\");\n\t\t\t\t\tip = (pc + 1)->firsti;\n\t\t\t\t}\n\t\t\t\tip = ip->nexti;\n\t\t\t}\n\t\t\tindent_in();\n\t\t\tpprint(ip, (pc + 1)->lasti, false);\n\t\t\tindent_out();\n\t\t\tfprintf(prof_fp, \"\\t}\\n\\n\");\n\t\t\tpc = (pc + 1)->lasti;\n\t\t\tbreak;\n\n\t\tcase Op_atexit:\n\t\t\tbreak;\n\n\t\tcase Op_stop:\n\t\t\tmemset(rule_count, 0, MAXRULE * sizeof(int));\n\t\t\tbreak;\n\n\t\tcase Op_push_i:\n\t\t\tm = pc->memory;\n\t\t\tif (m == Nnull_string)\t/* optional return or exit value; don't print 0 or \"\" */\n\t\t\t\tpp_push(pc->opcode, m->stptr, DONT_FREE);\n\t\t\telse if ((m->flags & NUMBER) != 0)\n\t\t\t\tpp_push(pc->opcode, pp_number(m), CAN_FREE);\n\t\t\telse {\n\t\t\t\tstr = pp_string(m->stptr, m->stlen, '\"');\n\t\t\t\tif ((m->flags & INTLSTR) != 0) {\n\t\t\t\t\tchar *tmp = str;\n\t\t\t\t\tstr = pp_group3(\"_\", tmp, \"\");\n\t\t\t\t\tefree(tmp);\n\t\t\t\t}\n\t\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_store_var:\n\t\t\tif (pc->initval != NULL)\n\t\t\t\tpp_push(Op_push_i, pp_node(pc->initval), CAN_FREE);\n\t\t\t/* fall through */\n\t\tcase Op_store_sub:\n\t\tcase Op_assign_concat:\n\t\tcase Op_push_lhs:\n\t\tcase Op_push_param:\n\t\tcase Op_push_array:\n\t\tcase Op_push:\n\t\tcase Op_push_arg:\n\t\t\tm = pc->memory;\n\t\t\tswitch (m->type) {\n\t\t\tcase Node_param_list:\n\t\t\t\tpp_push(pc->opcode, func_params[m->param_cnt].param, DONT_FREE);\n\t\t\t\tbreak;\n\n\t\t\tcase Node_var:\n\t\t\tcase Node_var_new:\n\t\t\tcase Node_var_array:\n\t\t\t\tif (m->vname != NULL)\n\t\t\t\t\tpp_push(pc->opcode, m->vname, DONT_FREE);\n \t\t\t\telse\n\t\t\t\t\tfatal(_(\"internal error: %s with null vname\"),\n\t\t\t\t\t\t\tnodetype2str(m->type));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcant_happen();\n\t\t\t}\n\n\t\t\tswitch (pc->opcode) {\n\t\t\tcase Op_store_var:\n\t\t\t\tt2 = pp_pop(); /* l.h.s. */\n\t\t\t\tt1 = pp_pop(); /* r.h.s. */\n\t\t\t\tfprintf(prof_fp, \"%s%s%s\", t2->pp_str, op2str(pc->opcode), t1->pp_str);\n\t\t\t\tgoto cleanup;\n\n\t\t\tcase Op_store_sub:\n\t\t\t\tt1 = pp_pop();\t/* array */\n\t\t\t\ttmp = pp_list(pc->expr_count, op2str(Op_subscript), \", \"); /*subscript*/\n\t\t\t\tt2 = pp_pop(); /* r.h.s. */\n\t\t\t\tfprintf(prof_fp, \"%s%s%s%s\", t1->pp_str, tmp,\n\t\t\t\t\t\t\t\t\top2str(pc->opcode), t2->pp_str);\n\t\t\t\tefree(tmp);\n\t\t\t\tgoto cleanup;\n\n\t\t\tcase Op_assign_concat:\n\t\t\t\tt2 = pp_pop(); /* l.h.s. */\n\t\t\t\tt1 = pp_pop();\n\t\t\t\ttmp = pp_group3(t2->pp_str, op2str(Op_concat), t1->pp_str);\n\t\t\t\tfprintf(prof_fp, \"%s%s%s\", t2->pp_str, op2str(Op_assign), tmp);\n\t\t\t\tefree(tmp);\ncleanup:\n\t\t\t\tpp_free(t2);\n\t\t\t\tpp_free(t1);\n\t\t\t\tif (! in_for_header)\n\t\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_sub_array:\n\t\tcase Op_subscript_lhs:\n\t\tcase Op_subscript:\n\t\t\ttmp = pp_list(pc->sub_count, op2str(pc->opcode), \", \");\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(t1->pp_str, tmp, \"\");\n\t\t\tefree(tmp);\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_and:\n\t\tcase Op_or:\n\t\t\tpprint(pc->nexti, pc->target_jmp, in_for_header);\n\t\t\tt2 = pp_pop();\n\t\t\tt1 = pp_pop();\n\t\t\tparenthesize(pc->opcode, t1, t2);\n\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpp_free(t2);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tpc = pc->target_jmp;\n\t\t\tbreak;\n\n\t\tcase Op_plus_i:\n\t\tcase Op_minus_i:\n\t\tcase Op_times_i:\n\t\tcase Op_exp_i:\n\t\tcase Op_quotient_i:\n\t\tcase Op_mod_i:\n\t\t\tm = pc->memory;\n\t\t\tt1 = pp_pop();\n\t\t\tif (prec_level(pc->opcode) > prec_level(t1->type)\n\t\t\t\t\t&& is_binary(t1->type))  /* (a - b) * 1 */\n\t\t\t\tpp_parenthesize(t1);\n\t\t\tif ((m->flags & NUMBER) != 0)\n\t\t\t\ttmp = pp_number(m);\n\t\t\telse\n\t\t\t\ttmp = pp_string(m->stptr, m->stlen, '\"');\n\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), tmp);\n\t\t\tefree(tmp);\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_plus:\n\t\tcase Op_minus:\n\t\tcase Op_times:\n\t\tcase Op_exp:\n\t\tcase Op_quotient:\n\t\tcase Op_mod:\n\t\tcase Op_equal:\n\t\tcase Op_notequal:\n\t\tcase Op_less:\n\t\tcase Op_greater:\n\t\tcase Op_leq:\n\t\tcase Op_geq:\n\t\t\tt2 = pp_pop();\n\t\t\tt1 = pp_pop();\n\t\t\tparenthesize(pc->opcode, t1, t2);\n\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), t2->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpp_free(t2);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_preincrement:\n\t\tcase Op_predecrement:\n\t\tcase Op_postincrement:\n\t\tcase Op_postdecrement:\n\t\t\tt1 = pp_pop();\n\t\t\tif (pc->opcode == Op_preincrement || pc->opcode == Op_predecrement)\n\t\t\t\tstr = pp_group3(op2str(pc->opcode), t1->pp_str, \"\");\n\t\t\telse\n\t\t\t\tstr = pp_group3(t1->pp_str, op2str(pc->opcode), \"\");\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_field_spec:\n\t\tcase Op_field_spec_lhs:\n\t\tcase Op_unary_minus:\n\t\tcase Op_not:\n\t\t\tt1 = pp_pop();\n\t\t\tif (is_binary(t1->type)\n\t\t\t    || (((OPCODE) t1->type) == pc->opcode && pc->opcode == Op_unary_minus))\n\t\t\t\tpp_parenthesize(t1);\n\n\t\t\t/* optypes table (eval.c) includes space after ! */\n\t\t\tstr = pp_group3(op2str(pc->opcode), t1->pp_str, \"\");\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_assign:\n\t\tcase Op_assign_plus:\n\t\tcase Op_assign_minus:\n\t\tcase Op_assign_times:\n\t\tcase Op_assign_quotient:\n\t\tcase Op_assign_mod:\n\t\tcase Op_assign_exp:\n\t\t\tt2 = pp_pop(); /* l.h.s. */\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(t2->pp_str, op2str(pc->opcode), t1->pp_str);\n\t\t\tpp_free(t2);\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_store_field:\n\t\t\tt1 = pp_pop(); /* field num */\n\t\t\tif (is_binary(t1->type))\n\t\t\t\tpp_parenthesize(t1);\n\t\t\tt2 = pp_pop(); /* r.h.s. */\n\t\t\tfprintf(prof_fp, \"$%s%s%s\", t1->pp_str, op2str(pc->opcode), t2->pp_str);\n\t\t\tpp_free(t2);\n\t\t\tpp_free(t1);\n\t\t\tif (! in_for_header)\n\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\tbreak;\n\n\t\tcase Op_concat:\n\t\t\tstr = pp_concat(pc->expr_count);\n\t\t\tpp_push(Op_concat, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_K_delete:\n\t\t{\n\t\t\tchar *array;\n\t\t\tt1 = pp_pop();\n\t\t\tarray = t1->pp_str;\n\t\t\tif (pc->expr_count > 0) {\n\t\t\t\tchar *sub;\n\t\t\t\tsub = pp_list(pc->expr_count, NULL, pc->expr_count > 1 ? \"][\" : \", \");\n\t\t\t\tfprintf(prof_fp, \"%s %s[%s]\", op2str(Op_K_delete), array, sub);\n\t\t\t\tefree(sub);\n\t\t\t} else\n\t\t\t\tfprintf(prof_fp, \"%s %s\", op2str(Op_K_delete), array);\n\t\t\tif (! in_for_header)\n\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\tpp_free(t1);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_delete_loop:\n\t\t\t/* Efficency hack not in effect because of exec_count instruction */\n\t\t\tcant_happen();\n\t\t\tbreak;\n\n\t\tcase Op_in_array:\n\t\t{\n\t\t\tchar *array, *sub;\n\t\t\tt1 = pp_pop();\n\t\t\tarray = t1->pp_str;\n\t\t\tif (pc->expr_count > 1) {\n\t\t\t\tsub = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\t\tstr = pp_group3(sub, op2str(Op_in_array), array);\n\t\t\t\tefree(sub);\n\t\t\t} else {\n\t\t\t\tt2 = pp_pop();\n\t\t\t\tif (prec_level(t2->type) < prec_level(Op_in_array)) {\n\t\t\t\t\t\tpp_parenthesize(t2);\n\t\t\t\t}\n\t\t\t\tsub = t2->pp_str;\n\t\t\t\tstr = pp_group3(sub, op2str(Op_in_array), array);\n\t\t\t\tpp_free(t2);\n\t\t\t}\n\t\t\tpp_free(t1);\n\t\t\tpp_push(Op_in_array, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_var_update:\n\t\tcase Op_var_assign:\n\t\tcase Op_field_assign:\n\t\tcase Op_subscript_assign:\n\t\tcase Op_arrayfor_init:\n\t\tcase Op_arrayfor_incr:\n\t\tcase Op_arrayfor_final:\n\t\tcase Op_newfile:\n\t\tcase Op_get_record:\n\t\tcase Op_lint:\n\t\tcase Op_jmp:\n\t\tcase Op_jmp_false:\n\t\tcase Op_jmp_true:\n\t\tcase Op_no_op:\n\t\tcase Op_and_final:\n\t\tcase Op_or_final:\n\t\tcase Op_cond_pair:\n\t\tcase Op_after_beginfile:\n\t\tcase Op_after_endfile:\n\t\t\tbreak;\n\n\t\tcase Op_sub_builtin:\n\t\t{\n\t\t\tconst char *fname = \"sub\";\n\t\t\tif ((pc->sub_flags & GSUB) != 0)\n\t\t\t\tfname = \"gsub\";\n\t\t\telse if ((pc->sub_flags & GENSUB) != 0)\n\t\t\t\tfname = \"gensub\";\n\t\t\ttmp = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\tstr = pp_group3(fname, tmp, \"\");\n\t\t\tefree(tmp);\n\t\t\tpp_push(Op_sub_builtin, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_builtin:\n\t\tcase Op_ext_builtin:\n\t\t{\n\t\t\tconst char *fname;\n\t\t\tif (pc->opcode == Op_builtin)\n\t\t\t\tfname = getfname(pc->builtin);\n\t\t\telse\n\t\t\t\tfname = (pc + 1)->func_name;\n\t\t\tif (fname != NULL) {\n\t\t\t\tif (pc->expr_count > 0) {\n\t\t\t\t\ttmp = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\t\t\tstr = pp_group3(fname, tmp, \"\");\n\t\t\t\t\tefree(tmp);\n\t\t\t\t} else\n\t\t\t\t\tstr = pp_group3(fname, \"()\", \"\");\n\t\t\t\tpp_push(Op_builtin, str, CAN_FREE);\n\t\t\t} else\n\t\t\t\tfatal(_(\"internal error: builtin with null fname\"));\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_print:\n\t\tcase Op_K_printf:\n\t\tcase Op_K_print_rec:\n\t\t\tif (pc->opcode == Op_K_print_rec)\n\t\t\t\ttmp = pp_group3(\" \", op2str(Op_field_spec), \"0\");\n\t\t\telse if (pc->redir_type != 0)\n\t\t\t\ttmp = pp_list(pc->expr_count, \"()\", \", \");\n\t\t\telse {\n\t\t\t\ttmp = pp_list(pc->expr_count, \"  \", \", \");\n\t\t\t\ttmp[strlen(tmp) - 1] = '\\0';\t/* remove trailing space */\n\t\t\t}\n\n\t\t\tif (pc->redir_type != 0) {\n\t\t\t\tt1 = pp_pop();\n\t\t\t\tif (is_binary(t1->type))\n\t\t\t\t\tpp_parenthesize(t1);\n\t\t\t\tfprintf(prof_fp, \"%s%s%s%s\", op2str(pc->opcode),\n\t\t\t\t\t\t\ttmp, redir2str(pc->redir_type), t1->pp_str);\n\t\t\t\tpp_free(t1);\n\t\t\t} else\n\t\t\t\tfprintf(prof_fp, \"%s%s\", op2str(pc->opcode), tmp);\n\t\t\tefree(tmp);\n\t\t\tif (! in_for_header)\n\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\tbreak;\n\n\t\tcase Op_push_re:\n\t\t\tif (pc->memory->type != Node_regex)\n\t\t\t\tbreak;\n\t\t\t/* else\n\t\t\t\tfall through */\n\t\tcase Op_match_rec:\n\t\t{\n\t\t\tNODE *re = pc->memory->re_exp;\n\t\t\tstr = pp_string(re->stptr, re->stlen, '/');\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_nomatch:\n\t\tcase Op_match:\n\t\t{\n\t\t\tchar *restr, *txt;\n\t\t\tt1 = pp_pop();\n\t\t\tif (is_binary(t1->type))\n\t\t\t\tpp_parenthesize(t1);\n\t\t\ttxt = t1->pp_str;\n\t\t\tm = pc->memory;\n\t\t\tif (m->type == Node_dynregex) {\n\t\t\t\trestr = txt;\n\t\t\t\tt2 = pp_pop();\n\t\t\t\tif (is_binary(t2->type))\n\t\t\t\t\tpp_parenthesize(t2);\n\t\t\t\ttxt = t2->pp_str;\n\t\t\t\tstr = pp_group3(txt, op2str(pc->opcode), restr);\n\t\t\t\tpp_free(t2);\n\t\t\t} else {\n\t\t\t\tNODE *re = m->re_exp;\n\t\t\t\trestr = pp_string(re->stptr, re->stlen, '/');\n\t\t\t\tstr = pp_group3(txt, op2str(pc->opcode), restr);\n\t\t\t\tefree(restr);\n\t\t\t}\n\t\t\tpp_free(t1);\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_getline:\n\t\tcase Op_K_getline_redir:\n\t\t\tif (pc->into_var) {\n\t\t\t\tt1 = pp_pop();\n\t\t\t\ttmp = pp_group3(op2str(Op_K_getline), \" \", t1->pp_str);\n\t\t\t\tpp_free(t1);\n\t\t\t} else\n\t\t\t\ttmp = pp_group3(op2str(Op_K_getline), \"\", \"\");\n\n\t\t\tif (pc->redir_type != 0) {\n\t\t\t\tint before = (pc->redir_type == redirect_pipein\n\t\t\t\t\t\t\t|| pc->redir_type == redirect_twoway);\n\n\t\t\t\tt2 = pp_pop();\n\t\t\t\tif (is_binary(t2->type))\n\t\t\t\t\tpp_parenthesize(t2);\n\t\t\t\tif (before)\n\t\t\t\t\tstr = pp_group3(t2->pp_str, redir2str(pc->redir_type), tmp);\n\t\t\t\telse\n\t\t\t\t\tstr = pp_group3(tmp, redir2str(pc->redir_type), t2->pp_str);\n\t\t\t\tefree(tmp);\n\t\t\t\tpp_free(t2);\n\t\t\t} else\n\t\t\t\tstr = tmp;\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t\tbreak;\n\n\t\tcase Op_indirect_func_call:\n\t\tcase Op_func_call:\n\t\t{\n\t\t\tchar *fname = pc->func_name;\n\t\t\tchar *pre;\n \t\t\tint pcount;\n\n\t\t\tif (pc->opcode == Op_indirect_func_call)\n\t\t\t\tpre = \"@\";\n\t\t\telse\n\t\t\t\tpre = \"\";\n\t\t\tpcount = (pc + 1)->expr_count;\n\t\t\tif (pcount > 0) {\n\t\t\t\ttmp = pp_list(pcount, \"()\", \", \");\n\t\t\t\tstr = pp_group3(pre, fname, tmp);\n\t\t\t\tefree(tmp);\n\t\t\t} else\n\t\t\t\tstr = pp_group3(pre, fname, \"()\");\n\t\t\tif (pc->opcode == Op_indirect_func_call) {\n\t\t\t\tt1 = pp_pop();\t/* indirect var */\n\t\t\t\tpp_free(t1);\n\t\t\t}\n\t\t\tpp_push(pc->opcode, str, CAN_FREE);\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_continue:\n\t\tcase Op_K_break:\n\t\tcase Op_K_nextfile:\n\t\tcase Op_K_next:\n\t\t\tfprintf(prof_fp, \"%s\\n\", op2str(pc->opcode));\n\t\t\tbreak;\n\n\t\tcase Op_K_return:\n\t\tcase Op_K_exit:\n\t\t\tt1 = pp_pop();\n\t\t\tif (is_binary(t1->type))\n\t\t\t\tpp_parenthesize(t1);\n\t\t\tif (pc->source_line > 0)\t/* don't print implicit 'return' at end of function */\n\t\t\t\tfprintf(prof_fp, \"%s %s\\n\", op2str(pc->opcode), t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tbreak;\n\n\t\tcase Op_pop:\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s\", t1->pp_str);\n\t\t\tif (! in_for_header)\n\t\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\tpp_free(t1);\n\t\t\tbreak;\n\n\t\tcase Op_line_range:\n\t\t\tip = pc + 1;\n\t\t\tpprint(pc->nexti, ip->condpair_left, false);\n\t\t\tpprint(ip->condpair_left->nexti, ip->condpair_right, false);\n\t\t\tt2 = pp_pop();\n\t\t\tt1 = pp_pop();\n\t\t\tstr = pp_group3(t1->pp_str, \", \", t2->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpp_free(t2);\n\t\t\tpp_push(Op_line_range, str, CAN_FREE);\n\t\t\tpc = ip->condpair_right;\n\t\t\tbreak;\n\n\t\tcase Op_K_while:\n\t\t\tip = pc + 1;\n\t\t\tindent(ip->while_body->exec_count);\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\t\t\tpprint(pc->nexti, ip->while_body, false);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s) {\\n\", t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tindent_in();\n\t\t\tpprint(ip->while_body->nexti, pc->target_break, false);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_do:\n\t\t\tip = pc + 1;\n\t\t\tindent(pc->nexti->exec_count);\n\t\t\tfprintf(prof_fp, \"%s {\\n\", op2str(pc->opcode));\n\t\t\tindent_in();\n\t\t\tpprint(pc->nexti->nexti, ip->doloop_cond, false);\n\t\t\tindent_out();\n\t\t\tpprint(ip->doloop_cond, pc->target_break, false);\n\t\t\tindent(SPACEOVER);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"} %s (%s)\\n\", op2str(Op_K_while), t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_for:\n\t\t\tip = pc + 1;\n\t\t\tindent(ip->forloop_body->exec_count);\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\n\t\t\t/* If empty for looop header, print it a little more nicely. */\n\t\t\tif (   pc->nexti->opcode == Op_no_op\n\t\t\t    && ip->forloop_cond == pc->nexti\n\t\t\t    && pc->target_continue->opcode == Op_jmp) {\n\t\t\t\tfprintf(prof_fp, \";;\");\n\t\t\t} else {\n\t\t\t\tpprint(pc->nexti, ip->forloop_cond, true);\n\t\t\t\tfprintf(prof_fp, \"; \");\n\n\t\t\t\tif (ip->forloop_cond->opcode == Op_no_op &&\n\t\t\t\t\t\tip->forloop_cond->nexti == ip->forloop_body)\n\t\t\t\t\tfprintf(prof_fp, \"; \");\n\t\t\t\telse {\n\t\t\t\t\tpprint(ip->forloop_cond, ip->forloop_body, true);\n\t\t\t\t\tt1 = pp_pop();\n\t\t\t\t\tfprintf(prof_fp, \"%s; \", t1->pp_str);\n\t\t\t\t\tpp_free(t1);\n\t\t\t\t}\n\n\t\t\t\tpprint(pc->target_continue, pc->target_break, true);\n\t\t\t}\n\t\t\tfprintf(prof_fp, \") {\\n\");\n\t\t\tindent_in();\n\t\t\tpprint(ip->forloop_body->nexti, pc->target_continue, false);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_arrayfor:\n\t\t{\n\t\t\tchar *array;\n\t\t\tconst char *item;\n\n\t\t\tip = pc + 1;\n\t\t\tt1 = pp_pop();\n\t\t\tarray = t1->pp_str;\n\t\t\tm = ip->forloop_cond->array_var;\n\t\t\tif (m->type == Node_param_list)\n\t\t\t\titem = func_params[m->param_cnt].param;\n\t\t\telse\n\t\t\t\titem = m->vname;\n\t\t\tindent(ip->forloop_body->exec_count);\n\t\t\tfprintf(prof_fp, \"%s (%s%s%s) {\\n\", op2str(Op_K_arrayfor),\n\t\t\t\t\t\titem, op2str(Op_in_array), array);\n\t\t\tindent_in();\n\t\t\tpp_free(t1);\n\t\t\tpprint(ip->forloop_body->nexti, pc->target_break, false);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\tpc = pc->target_break;\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_switch:\n\t\t\tip = pc + 1;\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\t\t\tpprint(pc->nexti, ip->switch_start, false);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s) {\\n\", t1->pp_str);\n\t\t\tpp_free(t1);\n\t\t\tpprint(ip->switch_start, ip->switch_end, false);\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\tpc = pc->target_break;\n\t\t\tbreak;\n\n\t\tcase Op_K_case:\n\t\tcase Op_K_default:\n\t\t\tindent(pc->stmt_start->exec_count);\n\t\t\tif (pc->opcode == Op_K_case) {\n\t\t\t\tt1 = pp_pop();\n\t\t\t\tfprintf(prof_fp, \"%s %s:\\n\", op2str(pc->opcode), t1->pp_str);\n\t\t\t\tpp_free(t1);\n\t\t\t} else\n\t\t\t\tfprintf(prof_fp, \"%s:\\n\", op2str(pc->opcode));\n\t\t\tindent_in();\n\t\t\tpprint(pc->stmt_start->nexti, pc->stmt_end->nexti, false);\n\t\t\tindent_out();\n\t\t\tbreak;\n\n\t\tcase Op_K_if:\n\t\t\tfprintf(prof_fp, \"%s (\", op2str(pc->opcode));\n\t\t\tpprint(pc->nexti, pc->branch_if, false);\n\t\t\tt1 = pp_pop();\n\t\t\tfprintf(prof_fp, \"%s) {\", t1->pp_str);\n\t\t\tpp_free(t1);\n\n\t\t\tip = pc->branch_if;\n\t\t\tif (ip->exec_count > 0)\n\t\t\t\tfprintf(prof_fp, \" # %ld\", ip->exec_count);\n\t\t\tfprintf(prof_fp, \"\\n\");\n\t\t\tindent_in();\n\t\t\tpprint(ip->nexti, pc->branch_else, false);\n\t\t\tindent_out();\n\t\t\tpc = pc->branch_else;\n\t\t\tif (pc->nexti->opcode == Op_no_op) {\n\t\t\t\tindent(SPACEOVER);\n\t\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_K_else:\n\t\t\tfprintf(prof_fp, \"} %s {\\n\", op2str(pc->opcode));\n\t\t\tindent_in();\n\t\t\tpprint(pc->nexti, pc->branch_end, false);\n\t\t\tindent_out();\n\t\t\tindent(SPACEOVER);\n\t\t\tfprintf(prof_fp, \"}\\n\");\n\t\t\tpc = pc->branch_end;\n\t\t\tbreak;\n\n\t\tcase Op_cond_exp:\n\t\t{\n\t\t\tNODE *f, *t, *cond;\n\t\t\tsize_t len;\n\n\t\t\tpprint(pc->nexti, pc->branch_if, false);\n\t\t\tip = pc->branch_if;\n\t\t\tpprint(ip->nexti, pc->branch_else, false);\n\t\t\tip = pc->branch_else->nexti;\n\n\t\t\tpc = ip->nexti;\n\t\t\tassert(pc->opcode == Op_cond_exp);\n\t\t\tpprint(pc->nexti, pc->branch_end, false);\n\n\t\t\tf = pp_pop();\n\t\t\tt = pp_pop();\n\t\t\tcond = pp_pop();\n\n\t\t\tlen =  f->pp_len + t->pp_len + cond->pp_len + 12;\n\t\t\temalloc(str, char *, len, \"pprint\");\n\t\t\tsprintf(str, \"(%s ? %s : %s)\", cond->pp_str, t->pp_str, f->pp_str);\n\n\t\t\tpp_free(cond);\n\t\t\tpp_free(t);\n\t\t\tpp_free(f);\n\t\t\tpp_push(Op_cond_exp, str, CAN_FREE);\n\t\t\tpc = pc->branch_end;\n\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_exec_count:\n\t\t\tif (! in_for_header)\n\t\t\t\tindent(pc->exec_count);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\n\t\tif (pc == endp)\n\t\t\tbreak;\n\t}\n}"
}