{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "node.c",
    "message": "pointer `*ptr` last assigned on line 697 could be null and is dereferenced by call to `memset()` at line 698, column 3.",
    "warning_function_name": "str2wstr",
    "warning_line": "memset(*ptr, 0, sizeof(size_t) * n->stlen);",
    "warning_context": "NODE *\nstr2wstr(NODE *n, size_t **ptr)\n{\n\tsize_t i, count, src_count;\n\tchar *sp;\n\tmbstate_t mbs;\n\twchar_t wc, *wsp;\n\tstatic bool warned = false;\n\n\tassert((n->flags & (STRING|STRCUR)) != 0);\n\n\t/*\n\t * Don't convert global null string or global null field\n\t * variables to a wide string. They are both zero-length anyway.\n\t * This also avoids future double-free errors while releasing\n\t * shallow copies, eg. *tmp = *Null_field; free_wstr(tmp);\n\t */\n\tif (n == Nnull_string || n == Null_field)\n\t\treturn n;\n\n\tif ((n->flags & WSTRCUR) != 0) {\n\t\tif (ptr == NULL)\n\t\t\treturn n;\n\t\t/* otherwise\n\t\t\tfall through and recompute to fill in the array */\n\t\tfree_wstr(n);\n\t}\n\n\t/*\n\t * After consideration and consultation, this\n\t * code trades space for time. We allocate\n\t * an array of wchar_t that is n->stlen long.\n\t * This is needed in the worst case anyway, where\n\t * each input byte maps to one wchar_t.  The\n\t * advantage is that we only have to convert the string\n\t * once, instead of twice, once to find out how many\n\t * wide characters, and then again to actually fill in\n\t * the info.  If there's a lot left over, we can\n\t * realloc the wide string down in size.\n\t */\n\n\temalloc(n->wstptr, wchar_t *, sizeof(wchar_t) * (n->stlen + 2), \"str2wstr\");\n\twsp = n->wstptr;\n\n\t/*\n\t * For use by do_match, create and fill in an array.\n\t * For each byte `i' in n->stptr (the original string),\n\t * a[i] is equal to `j', where `j' is the corresponding wchar_t\n\t * in the converted wide string.\n\t *\n\t * Create the array.\n\t */\n\tif (ptr != NULL) {\n\t\temalloc(*ptr, size_t *, sizeof(size_t) * n->stlen, \"str2wstr\");\n\t\tmemset(*ptr, 0, sizeof(size_t) * n->stlen);\n\t}\n\n\tsp = n->stptr;\n\tsrc_count = n->stlen;\n\tmemset(& mbs, 0, sizeof(mbs));\n\tfor (i = 0; src_count > 0; i++) {\n\t\t/*\n\t\t * 9/2010: Check the current byte; if it's a valid character,\n\t\t * then it doesn't start a multibyte sequence. This brings a\n\t\t * big speed up. Thanks to Ulrich Drepper for the tip.\n\t\t * 11/2010: Thanks to Paolo Bonzini for some even faster code.\n\t\t */\n\t\tif (is_valid_character(*sp)) {\n\t\t\tcount = 1;\n\t\t\twc = btowc_cache(*sp);\n\t\t} else\n\t\t\tcount = mbrtowc(& wc, sp, src_count, & mbs);\n\t\tswitch (count) {\n\t\tcase (size_t) -2:\n\t\tcase (size_t) -1:\n\t\t\t/*\n\t\t\t * Just skip the bad byte and keep going, so that\n\t\t\t * we get a more-or-less full string, instead of\n\t\t\t * stopping early. This is particularly important\n\t\t\t * for match() where we need to build the indices.\n\t\t\t */\n\t\t\tsp++;\n\t\t\tsrc_count--;\n\t\t\t/*\n\t\t\t * mbrtowc(3) says the state of mbs becomes undefined\n\t\t\t * after a bad character, so reset it.\n\t\t\t */\n\t\t\tmemset(& mbs, 0, sizeof(mbs));\n\t\t\t/* And warn the user something's wrong */\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"Invalid multibyte data detected. There may be a mismatch between your data and your locale.\"));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\tcount = 1;\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\t*wsp++ = wc;\n\t\t\tsrc_count -= count;\n"
}