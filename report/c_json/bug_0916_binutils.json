{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset: 0 Size: [0, 16] by call to `_bfd_relocate_contents`.",
    "warning_function_name": "elf_reloc_link_order",
    "warning_line": "rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);",
    "warning_context": "      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  addend = link_order->u.reloc.p->addend;\n\n  if (esdo->rel.hdr)\n    reldata = &esdo->rel;\n  else if (esdo->rela.hdr)\n    reldata = &esdo->rela;\n  else\n    {\n      reldata = NULL;\n      BFD_ASSERT (0);\n    }\n\n  /* Figure out the symbol index.  */\n  rel_hash_ptr = reldata->hashes + reldata->count;\n  if (link_order->type == bfd_section_reloc_link_order)\n    {\n      indx = link_order->u.reloc.p->u.section->target_index;\n      BFD_ASSERT (indx != 0);\n      *rel_hash_ptr = NULL;\n    }\n  else\n    {\n      struct elf_link_hash_entry *h;\n\n      /* Treat a reloc against a defined symbol as though it were\n\t actually against the section.  */\n      h = ((struct elf_link_hash_entry *)\n\t   bfd_wrapped_link_hash_lookup (output_bfd, info,\n\t\t\t\t\t link_order->u.reloc.p->u.name,\n\t\t\t\t\t FALSE, FALSE, TRUE));\n      if (h != NULL\n\t  && (h->root.type == bfd_link_hash_defined\n\t      || h->root.type == bfd_link_hash_defweak))\n\t{\n\t  asection *section;\n\n\t  section = h->root.u.def.section;\n\t  indx = section->output_section->target_index;\n\t  *rel_hash_ptr = NULL;\n\t  /* It seems that we ought to add the symbol value to the\n\t     addend here, but in practice it has already been added\n\t     because it was passed to constructor_callback.  */\n\t  addend += section->output_section->vma + section->output_offset;\n\t}\n      else if (h != NULL)\n\t{\n\t  /* Setting the index to -2 tells elf_link_output_extsym that\n\t     this symbol is used by a reloc.  */\n\t  h->indx = -2;\n\t  *rel_hash_ptr = h;\n\t  indx = 0;\n\t}\n      else\n\t{\n\t  if (! ((*info->callbacks->unattached_reloc)\n\t\t (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))\n\t    return FALSE;\n\t  indx = 0;\n\t}\n    }\n\n  /* If this is an inplace reloc, we must write the addend into the\n     object file.  */\n  if (howto->partial_inplace && addend != 0)\n    {\n      bfd_size_type size;\n      bfd_reloc_status_type rstat;\n      bfd_byte *buf;\n      bfd_boolean ok;\n      const char *sym_name;\n\n      size = (bfd_size_type) bfd_get_reloc_size (howto);\n      buf = (bfd_byte *) bfd_zmalloc (size);\n      if (buf == NULL && size != 0)\n\treturn FALSE;\n      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);\n      switch (rstat)\n\t{\n\tcase bfd_reloc_ok:\n\t  break;\n\n\tdefault:\n\tcase bfd_reloc_outofrange:\n\t  abort ();\n\n\tcase bfd_reloc_overflow:\n\t  if (link_order->type == bfd_section_reloc_link_order)\n\t    sym_name = bfd_section_name (output_bfd,\n\t\t\t\t\t link_order->u.reloc.p->u.section);\n\t  else\n\t    sym_name = link_order->u.reloc.p->u.name;\n\t  if (! ((*info->callbacks->reloc_overflow)\n\t\t (info, NULL, sym_name, howto->name, addend, NULL,\n\t\t  NULL, (bfd_vma) 0)))\n\t    {\n\t      free (buf);\n\t      return FALSE;\n"
}