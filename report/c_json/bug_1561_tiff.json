{
    "project": "tiff",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "tools/tiff2ps.c",
    "message": "Offset: [1, +oo] Size: [0, +oo] by call to `PS_FlipBytes`.",
    "warning_function_name": "PS_Lvl2page",
    "warning_line": "PS_FlipBytes(buf_data, byte_count);",
    "warning_context": "\t\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\t}\n\n\tif (use_rawdata) {\n\t\tchunk_size = (tsize_t) bc[0];\n\t\tfor (chunk_no = 1; chunk_no < num_chunks; chunk_no++)\n\t\t\tif ((tsize_t) bc[chunk_no] > chunk_size)\n\t\t\t\tchunk_size = (tsize_t) bc[chunk_no];\n\t} else {\n\t\tif (tiled_image)\n\t\t\tchunk_size = TIFFTileSize(tif);\n\t\telse\n\t\t\tchunk_size = TIFFStripSize(tif);\n\t}\n\tbuf_data = (unsigned char *)_TIFFmalloc(chunk_size);\n\tif (!buf_data) {\n\t\tTIFFError(filename, \"Can't alloc %lu bytes for %s.\",\n\t\t\t(unsigned long) chunk_size, tiled_image ? \"tiles\" : \"strips\");\n\t\treturn(FALSE);\n\t}\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*chunk_size/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*chunk_size/4 rather than\n\t     * 5*chunk_size/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (chunk_size+(chunk_size/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( buf_data );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn ( FALSE );\n\t    }\n\t}\n#endif\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &fillorder);\n\tfor (chunk_no = 0; chunk_no < num_chunks; chunk_no++) {\n\t\tif (ascii85)\n\t\t\tAscii85Init();\n\t\telse\n\t\t\tbreaklen = MAXLINE;\n\t\tif (use_rawdata) {\n\t\t\tif (tiled_image)\n\t\t\t\tbyte_count = TIFFReadRawTile(tif, chunk_no,\n\t\t\t\t\t\t  buf_data, chunk_size);\n\t\t\telse\n\t\t\t\tbyte_count = TIFFReadRawStrip(tif, chunk_no,\n\t\t\t\t\t\t  buf_data, chunk_size);\n\t\t\tif (fillorder == FILLORDER_LSB2MSB)\n\t\t\t    TIFFReverseBits(buf_data, byte_count);\n\t\t} else {\n\t\t\tif (tiled_image)\n\t\t\t\tbyte_count = TIFFReadEncodedTile(tif,\n\t\t\t\t\t\tchunk_no, buf_data,\n\t\t\t\t\t\tchunk_size);\n\t\t\telse\n\t\t\t\tbyte_count = TIFFReadEncodedStrip(tif,\n\t\t\t\t\t\tchunk_no, buf_data,\n\t\t\t\t\t\tchunk_size);\n\t\t}\n\t\tif (byte_count < 0) {\n\t\t\tTIFFError(filename, \"Can't read %s %d.\",\n\t\t\t\ttiled_image ? \"tile\" : \"strip\", chunk_no);\n\t\t\tif (ascii85)\n\t\t\t\tAscii85Put('\\0', fd);\n\t\t}\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !TIFFIsBigEndian(tif)) {\n\t\t\tPS_FlipBytes(buf_data, byte_count);\n\t\t}\n\t\t/*\n\t\t * For images with alpha, matte against a white background;\n\t\t * i.e. Cback * (1 - Aimage) where Cback = 1. We will fill the\n\t\t * lower part of the buffer with the modified values.\n\t\t *\n\t\t * XXX: needs better solution\n\t\t */\n\t\tif (alpha) {\n\t\t\tint adjust, i, j = 0;\n\t\t\tint ncomps = samplesperpixel - extrasamples;\n\t\t\tfor (i = 0; i < byte_count; i+=samplesperpixel) {\n\t\t\t\tadjust = 255 - buf_data[i + ncomps];\n\t\t\t\tswitch (ncomps) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i] + adjust;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i] + adjust;\n\t\t\t\t\t\tbuf_data[j++] = buf_data[i+1] + adjust;\n\t\t\t\t\t\tbreak;\n"
}