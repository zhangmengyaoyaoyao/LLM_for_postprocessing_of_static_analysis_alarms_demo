{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "debug.c",
    "message": "Access to field 'prev' results in a dereference of a null pointer (loaded from variable 'commands')",
    "warning_function_name": "do_commands",
    "warning_line": "c->prev = commands->prev;",
    "warning_context": "int\ndo_commands(CMDARG *arg, int cmd)\n{\n\tstatic BREAKPOINT *b;\n\tstatic struct list_item *w;\n\tstatic struct commands_item *commands;\n\tstruct commands_item *c;\n\t\n\tif (cmd == D_commands) {\n\t\tint num = -1, type;\n\t\tif (arg == NULL)\n\t\t\ttype = has_break_or_watch_point(&num, true);\n\t\telse {\n\t\t\tnum = arg->a_int;\n\t\t\ttype = has_break_or_watch_point(&num, false);\n\t\t}\n\t\tb = NULL;\n\t\tw = NULL;\n\t\tif (type == D_break)\n\t\t\tb = find_breakpoint(num);\n\t\telse if (type == D_watch)\n\t\t\tw = find_item(&watch_list, num);\n\t\tassert((b != NULL) || (w != NULL));\n\t\tcommands = (b != NULL) ? &b->commands : &w->commands;\n\n\t\t/* delete current commands */\n\t\tfor (c = commands->next; c != commands; c = c->next) {\n\t\t\tc = c->prev;\n\t\t\tdelete_commands_item(c->next);\n\t\t}\n\t\treturn false;\n\n\t} else if (cmd == D_end) {\n\t\tcommands = NULL;\n\t\tif (read_a_line == read_commands_string) /* unserializig commands */\n\t\t\treturn true;\t/* done unserializing, terminate zzparse() */\n\t\treturn false;\n\n\t} else if (cmd == D_silent) {\n\t\tif (b != NULL)\n\t\t\tb->silent = true;\n\t\telse if (w != NULL)\n\t\t\tw->silent = true;\n\t\t/* we also append silent command to the list for use\n\t\t * in `info break(watch)', and to simplify\n\t\t * serialization/unserialization of commands.\n\t\t */\n\t}\n\n\tassert(commands != NULL);\n\n\temalloc(c, struct commands_item *, sizeof(struct commands_item), \"do_commands\");\n\tc->next = NULL;\n\tc->cmd = cmd;\n\n\t/* N.B.: first arg is the command string, see command.y */ \n\tc->cmd_string = arg->a_string;\n\tc->arg = arg->next; /* actual arguments to the command */\n\tefree(arg);\n\n\t/* append to the list */\n\tc->prev = commands->prev;\n\tc->next = commands;\n\tcommands->prev = c;\n\tc->prev->next = c;\n\treturn false;\n}\n"
}