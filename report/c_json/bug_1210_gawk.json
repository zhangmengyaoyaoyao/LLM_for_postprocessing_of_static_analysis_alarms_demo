{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "eval.c",
    "message": "Offset added: 72 Size: [0, 7200].",
    "warning_function_name": "setup_frame",
    "warning_line": "memset(r, 0, sizeof(NODE));",
    "warning_context": "static INSTRUCTION *\nsetup_frame(INSTRUCTION *pc)\n{\n\tNODE *r = NULL;\n\tNODE *m, *f, *fp;\n\tNODE **sp = NULL;\n\tint pcount, arg_count, i, j;\n\tbool tail_optimize = false;\n\n\tf = pc->func_body;\n\tpcount = f->param_cnt;\n\tfp = f->fparms;\n\targ_count = (pc + 1)->expr_count;\n\n\t/* tail recursion optimization */\n\ttail_optimize =  ((pc + 1)->tail_call && do_optimize\n\t\t\t\t&& ! do_debug && ! do_profile);\n\n\tif (tail_optimize) {\n\t\t/* free local vars of calling frame */\n\n\t\tNODE *func;\n\t\tint n;\n\n\t\tfunc = frame_ptr->func_node;\n\t\tfor (n = func->param_cnt, sp = frame_ptr->stack; n > 0; n--) {\n\t\t\tr = *sp++;\n\t\t\tif (r->type == Node_var)     /* local variable */\n\t\t\t\tDEREF(r->var_value);\n\t\t\telse if (r->type == Node_var_array)     /* local array */\n\t\t\t\tassoc_clear(r);\n\t\t}\n\t\tsp = frame_ptr->stack;\n\n\t} else if (pcount > 0) {\n\t\temalloc(sp, NODE **, pcount * sizeof(NODE *), \"setup_frame\");\n\t\tmemset(sp, 0, pcount * sizeof(NODE *));\n\t}\n\n\n\t/* check for extra args */ \n\tif (arg_count > pcount) {\n\t\twarning(\n\t\t\t_(\"function `%s' called with more arguments than declared\"),\n       \t\t\tf->vname);\n\t\tdo {\n\t\t\tr = POP();\n\t\t\tif (r->type == Node_val)\n\t\t\t\tDEREF(r);\n\t\t} while (--arg_count > pcount);\n\t}\n\n\tfor (i = 0, j = arg_count - 1; i < pcount; i++, j--) {\n\t\tif (tail_optimize)\n\t\t\tr = sp[i];\n\t\telse {\n\t\t\tgetnode(r);\n\t\t\tmemset(r, 0, sizeof(NODE));\n\t\t\tsp[i] = r;\n\t\t}\n\n\t\tif (i >= arg_count) {\n\t\t\t/* local variable */\n\t\t\tr->type = Node_var_new;\n\t\t\tr->vname = fp[i].param;\n\t\t\tcontinue;\n\t\t}\n\n\t\tm = PEEK(j); /* arguments in reverse order on runtime stack */\n\n\t\tif (m->type == Node_param_list)\n\t\t\tm = GET_PARAM(m->param_cnt);\n\n\t\t/* $0 needs to be passed by value to a function */\n\t\tif (m == fields_arr[0]) {\n\t\t\tDEREF(m);\n\t\t\tm = dupnode(m);\n\t\t}\n\n\t\tswitch (m->type) {\n\t\tcase Node_var_new:\n\t\tcase Node_var_array:\n\t\t\tr->type = Node_array_ref;\n\t\t\tr->orig_array = r->prev_array = m;\n\t\t\tbreak;\n\n\t\tcase Node_array_ref:\n\t\t\tr->type = Node_array_ref;\n\t\t\tr->orig_array = m->orig_array;\n\t\t\tr->prev_array = m;\n\t\t\tbreak;\n\n\t\tcase Node_var:\n\t\t\t/* Untyped (Node_var_new) variable as param became a\n\t\t\t * scalar during evaluation of expression for a\n\t\t\t * subsequent param.\n\t\t\t */\n\t\t\tr->type = Node_var;\n\t\t\tr->var_value = dupnode(Nnull_string);\n\t\t\tbreak;\n\n"
}