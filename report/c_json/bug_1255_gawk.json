{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "awkgram.y",
    "message": "Offset: [`m->strlen`, +oo] (⇐ [0, +oo] + `m->strlen`) Size: [0, `m->strlen` + 16].",
    "warning_function_name": "yyerror",
    "warning_line": "strcpy(bp, mesg);",
    "warning_context": "static void\nyyerror(const char *m, ...)\n{\n\tva_list args;\n\tconst char *mesg = NULL;\n\tchar *bp, *cp;\n\tchar *scan;\n\tchar *buf;\n\tint count;\n\tstatic char end_of_file_line[] = \"(END OF FILE)\";\n\tchar save;\n\n\tprint_included_from();\n\n\terrcount++;\n\t/* Find the current line in the input file */\n\tif (lexptr && lexeme) {\n\t\tif (thisline == NULL) {\n\t\t\tcp = lexeme;\n\t\t\tif (*cp == '\\n') {\n\t\t\t\tcp--;\n\t\t\t\tmesg = _(\"unexpected newline or end of string\");\n\t\t\t}\n\t\t\tfor (; cp != lexptr_begin && *cp != '\\n'; --cp)\n\t\t\t\tcontinue;\n\t\t\tif (*cp == '\\n')\n\t\t\t\tcp++;\n\t\t\tthisline = cp;\n\t\t}\n\t\t/* NL isn't guaranteed */\n\t\tbp = lexeme;\n\t\twhile (bp < lexend && *bp && *bp != '\\n')\n\t\t\tbp++;\n\t} else {\n\t\tthisline = end_of_file_line;\n\t\tbp = thisline + strlen(thisline);\n\t}\n\n\t/*\n\t * Saving and restoring *bp keeps valgrind happy,\n\t * since the guts of glibc uses strlen, even though\n\t * we're passing an explict precision. Sigh.\n\t *\n\t * 8/2003: We may not need this anymore.\n\t */\n\tsave = *bp;\n\t*bp = '\\0';\n\n\tmsg(\"%.*s\", (int) (bp - thisline), thisline);\n\n\t*bp = save;\n\tva_start(args, m);\n\tif (mesg == NULL)\n\t\tmesg = m;\n\n\tcount = (bp - thisline) + strlen(mesg) + 2 + 1;\n\temalloc(buf, char *, count, \"yyerror\");\n\n\tbp = buf;\n\n\tif (lexptr != NULL) {\n\t\tscan = thisline;\n\t\twhile (scan < lexeme)\n\t\t\tif (*scan++ == '\\t')\n\t\t\t\t*bp++ = '\\t';\n\t\t\telse\n\t\t\t\t*bp++ = ' ';\n\t\t*bp++ = '^';\n\t\t*bp++ = ' ';\n\t}\n\tstrcpy(bp, mesg);\n\terr(false, \"\", buf, args);\n\tva_end(args);\n\tefree(buf);\n}\n"
}