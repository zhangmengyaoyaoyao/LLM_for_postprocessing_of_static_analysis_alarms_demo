{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "binutils/ieee.c",
    "message": "Offset added: [`info->types.alloc` + 32, +oo] (⇐ `info->types.alloc` + [32, +oo]) Size: [1, +oo] by call to `ieee_alloc_type`.",
    "warning_function_name": "parse_ieee_bb",
    "warning_line": "if (! ieee_alloc_type (info, typindx, TRUE))",
    "warning_context": "  ++*pp;\n\n  if (! ieee_read_number (info, pp, &size)\n      || ! ieee_read_id (info, pp, &name, &namlen))\n    return FALSE;\n\n  fnindx = (unsigned int) -1;\n  skip = FALSE;\n\n  switch (b)\n    {\n    case 1:\n      /* BB1: Type definitions local to a module.  */\n      namcopy = savestring (name, namlen);\n      if (namcopy == NULL)\n\treturn FALSE;\n      if (! debug_set_filename (info->dhandle, namcopy))\n\treturn FALSE;\n      info->saw_filename = TRUE;\n\n      /* Discard any variables or types we may have seen before.  */\n      if (info->vars.vars != NULL)\n\tfree (info->vars.vars);\n      info->vars.vars = NULL;\n      info->vars.alloc = 0;\n      if (info->types.types != NULL)\n\tfree (info->types.types);\n      info->types.types = NULL;\n      info->types.alloc = 0;\n\n      /* Initialize the types to the global types.  */\n      if (info->global_types != NULL)\n\t{\n\t  info->types.alloc = info->global_types->alloc;\n\t  info->types.types = ((struct ieee_type *)\n\t\t\t       xmalloc (info->types.alloc\n\t\t\t\t\t* sizeof (*info->types.types)));\n\t  memcpy (info->types.types, info->global_types->types,\n\t\t  info->types.alloc * sizeof (*info->types.types));\n\t}\n\n      break;\n\n    case 2:\n      /* BB2: Global type definitions.  The name is supposed to be\n\t empty, but we don't check.  */\n      if (! debug_set_filename (info->dhandle, \"*global*\"))\n\treturn FALSE;\n      info->saw_filename = TRUE;\n      break;\n\n    case 3:\n      /* BB3: High level module block begin.  We don't have to do\n\t anything here.  The name is supposed to be the same as for\n\t the BB1, but we don't check.  */\n      break;\n\n    case 4:\n      /* BB4: Global function.  */\n      {\n\tbfd_vma stackspace, typindx, offset;\n\tdebug_type return_type;\n\n\tif (! ieee_read_number (info, pp, &stackspace)\n\t    || ! ieee_read_number (info, pp, &typindx)\n\t    || ! ieee_read_expression (info, pp, &offset))\n\t  return FALSE;\n\n\t/* We have no way to record the stack space.  FIXME.  */\n\n\tif (typindx < 256)\n\t  {\n\t    return_type = ieee_builtin_type (info, block_start, typindx);\n\t    if (return_type == DEBUG_TYPE_NULL)\n\t      return FALSE;\n\t  }\n\telse\n\t  {\n\t    typindx -= 256;\n\t    if (! ieee_alloc_type (info, typindx, TRUE))\n\t      return FALSE;\n\t    fnindx = typindx;\n\t    return_type = info->types.types[typindx].type;\n\t    if (debug_get_type_kind (info->dhandle, return_type)\n\t\t== DEBUG_KIND_FUNCTION)\n\t      return_type = debug_get_return_type (info->dhandle,\n\t\t\t\t\t\t   return_type);\n\t  }\n\n\tnamcopy = savestring (name, namlen);\n\tif (namcopy == NULL)\n\t  return FALSE;\n\tif (! debug_record_function (info->dhandle, namcopy, return_type,\n\t\t\t\t     TRUE, offset))\n\t  return FALSE;\n      }\n      break;\n\n    case 5:\n      /* BB5: File name for source line numbers.  */\n      {\n"
}