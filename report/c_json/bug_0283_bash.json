{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "pcomplete.c",
    "message": "The value read from cw was never initialized.",
    "warning_function_name": "gen_compspec_completions",
    "warning_line": "tmatches = gen_shell_function_matches (cs, cmd, word, line, rl_point - start, lwords, nw, cw, &foundf);",
    "warning_context": "  /* Now we start generating completions based on the other members of CS. */\n  if (cs->globpat)\n    {\n      tmatches = gen_globpat_matches (cs, word);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_globpat_matches (%p, %s) -->\", cs, word);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t  rl_filename_completion_desired = 1;\n\t}\n    }\n\n  if (cs->words)\n    {\n      tmatches = gen_wordlist_matches (cs, word);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_wordlist_matches (%p, %s) -->\", cs, word);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  lwords = (WORD_LIST *)NULL;\n  line = (char *)NULL;\n  if (cs->command || cs->funcname)\n    {\n      /* If we have a command or function to execute, we need to first break\n\t the command line into individual words, find the number of words,\n\t and find the word in the list containing the word to be completed. */\n      line = substring (rl_line_buffer, start, end);\n      llen = end - start;\n\n#ifdef DEBUG\n      debug_printf (\"command_line_to_word_list (%s, %d, %d, %p, %p)\",\n\t\tline, llen, rl_point - start, &nw, &cw);\n#endif\n      lwords = command_line_to_word_list (line, llen, rl_point - start, &nw, &cw);\n      /* If we skipped a NULL word at the beginning of the line, add it back */\n      if (lwords && lwords->word && cmd[0] == 0 && lwords->word->word[0] != 0)\n\t{\n\t  lw = make_bare_word (cmd);\n\t  lwords = make_word_list (lw, lwords);\n\t  nw++;\n\t  cw++;\n\t}\n#ifdef DEBUG\n      if (lwords == 0 && llen > 0)\n\tdebug_printf (\"ERROR: command_line_to_word_list returns NULL\");\n      else if (progcomp_debug)\n\t{\n\t  debug_printf (\"command_line_to_word_list -->\");\n\t  printf (\"\\t\");\n\t  print_word_list (lwords, \"!\");\n\t  printf (\"\\n\");\n\t  fflush(stdout);\n\t  rl_on_new_line ();\n\t}\n#endif\n    }\n\n  if (cs->funcname)\n    {\n      foundf = 0;\n      tmatches = gen_shell_function_matches (cs, cmd, word, line, rl_point - start, lwords, nw, cw, &foundf);\n      if (foundf != 0)\n\tfound = foundf;\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_shell_function_matches (%p, %s, %s, %p, %d, %d) -->\", cs, cmd, word, lwords, nw, cw);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  if (cs->command)\n    {\n      tmatches = gen_command_matches (cs, cmd, word, line, rl_point - start, lwords, nw, cw);\n      if (tmatches)\n"
}