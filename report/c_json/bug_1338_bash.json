{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "      temp_results = glob_vector (filename,",
    "Code_function": "glob_filename (pathname, flags)\n     char *pathname;\n     int flags;\n{\n  char **result;\n  unsigned int result_size;\n  char *directory_name, *filename, *dname;\n  unsigned int directory_len;\n  int free_dirname;\t\t\t/* flag */\n  int dflags;\n\n  result = (char **) malloc (sizeof (char *));\n  result_size = 1;\n  if (result == NULL)\n    return (NULL);\n\n  result[0] = NULL;\n\n  directory_name = NULL;\n\n  /* Find the filename.  */\n  filename = strrchr (pathname, '/');\n  if (filename == NULL)\n    {\n      filename = pathname;\n      directory_name = \"\";\n      directory_len = 0;\n      free_dirname = 0;\n    }\n  else\n    {\n      directory_len = (filename - pathname) + 1;\n      directory_name = (char *) malloc (directory_len + 1);\n\n      if (directory_name == 0)\t\t/* allocation failed? */\n\treturn (NULL);\n\n      bcopy (pathname, directory_name, directory_len);\n      directory_name[directory_len] = '\\0';\n      ++filename;\n      free_dirname = 1;\n    }\n\n  /* If directory_name contains globbing characters, then we\n     have to expand the previous levels.  Just recurse. */\n  if (directory_len > 0 && glob_pattern_p (directory_name))\n    {\n      char **directories, *d, *p;\n      register unsigned int i;\n      int all_starstar, last_starstar;\n\n      all_starstar = last_starstar = 0;\n      d = directory_name;\n      dflags = flags & ~GX_MARKDIRS;\n      /* Collapse a sequence of ** patterns separated by one or more slashes\n\t to a single ** terminated by a slash or NUL */\n      if ((flags & GX_GLOBSTAR) && d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\\0'))\n\t{\n\t  p = d;\n\t  while (d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\\0'))\n\t    {\n\t      p = d;\n\t      if (d[2])\n\t\t{\n\t\t  d += 3;\n\t\t  while (*d == '/')\n\t\t    d++;\n\t\t  if (*d == 0)\n\t\t    break;\n\t\t}\n\t    }\n\t  if (*d == 0)\n\t    all_starstar = 1;\n\t  d = p;\n\t  dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n\t  directory_len = strlen (d);\n\t}\n\n      /* If there is a non [star][star]/ component in directory_name, we\n\t still need to collapse trailing sequences of [star][star]/ into\n\t a single one and note that the directory name ends with [star][star],\n\t so we can compensate if filename is [star][star] */\n      if ((flags & GX_GLOBSTAR) && all_starstar == 0)\n\t{\n\t  int dl, prev;\n\t  prev = dl = directory_len;\n\t  while (dl >= 4 && d[dl - 1] == '/' &&\n\t\t\t   d[dl - 2] == '*' &&\n\t\t\t   d[dl - 3] == '*' &&\n\t\t\t   d[dl - 4] == '/')\n\t    prev = dl, dl -= 3;\n\t  if (dl != directory_len)\n\t    last_starstar = 1;\n\t  directory_len = prev;\n\t}\n\n      /* If the directory name ends in [star][star]/ but the filename is\n\t [star][star], just remove the final [star][star] from the directory\n\t so we don't have to scan everything twice. */\n      if (last_starstar && directory_len > 4 &&\n\t    filename[0] == '*' && filename[1] == '*' && filename[2] == 0)\n\t{\n\t  directory_len -= 3;\n\t}\n\n      if (d[directory_len - 1] == '/')\n\td[directory_len - 1] = '\\0';\n\n      directories = glob_filename (d, dflags);\n\n      if (free_dirname)\n\t{\n\t  free (directory_name);\n\t  directory_name = NULL;\n\t}\n\n      if (directories == NULL)\n\tgoto memory_error;\n      else if (directories == (char **)&glob_error_return)\n\t{\n\t  free ((char *) result);\n\t  return ((char **) &glob_error_return);\n\t}\n      else if (*directories == NULL)\n\t{\n\t  free ((char *) directories);\n\t  free ((char *) result);\n\t  return ((char **) &glob_error_return);\n\t}\n\n      /* If we have something like [star][star]/[star][star], it's no use to\n         glob **, then do it again, and throw half the results away.  */\n      if (all_starstar && filename[0] == '*' && filename[1] == '*' && filename[2] == 0)\n\t{\n\t  free ((char *) directories);\n\t  free (directory_name);\n\t  directory_name = NULL;\n\t  directory_len = 0;\n\t  goto only_filename;\n\t}\n\n      /* We have successfully globbed the preceding directory name.\n\t For each name in DIRECTORIES, call glob_vector on it and\n\t FILENAME.  Concatenate the results together.  */\n      for (i = 0; directories[i] != NULL; ++i)\n\t{\n\t  char **temp_results;\n\t  int shouldbreak;\n\n\t  shouldbreak = 0;\n\t  /* XXX -- we've recursively scanned any directories resulting from\n\t     a `**', so turn off the flag.  We turn it on again below if\n\t     filename is `**' */\n\t  /* Scan directory even on a NULL filename.  That way, `*h/'\n\t     returns only directories ending in `h', instead of all\n\t     files ending in `h' with a `/' appended. */\n\t  dname = directories[i];\n\t  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);\n\t  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t    dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n\t  if (dname[0] == '\\0' && filename[0])\n\t    {\n\t      dflags |= GX_NULLDIR;\n\t      dname = \".\";\t/* treat null directory name and non-null filename as current directory */\n\t    }\n\t  temp_results = glob_vector (filename, dname, dflags);\n\n\t  /* Handle error cases. */\n\t  if (temp_results == NULL)\n\t    goto memory_error;\n\t  else if (temp_results == (char **)&glob_error_return)\n\t    /* This filename is probably not a directory.  Ignore it.  */\n\t    ;\n\t  else\n\t    {\n\t      char **array;\n\t      register unsigned int l;\n\n\t      /* If we're expanding **, we don't need to glue the directory\n\t\t name to the results; we've already done it in glob_vector */\n\t      if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && (filename[2] == '\\0' || filename[2] == '/'))\n\t\t{\n\t\t  /* When do we remove null elements from temp_results?  And\n\t\t     how to avoid duplicate elements in the final result? */\n\t\t  /* If (dflags & GX_NULLDIR) glob_filename potentially left a\n\t\t     NULL placeholder in the temp results just in case\n\t\t     glob_vector/glob_dir_to_array did something with it, but\n\t\t     if it didn't, and we're not supposed to be passing them\n\t\t     through for some reason ((flags & GX_NULLDIR) == 0) we\n\t\t     need to remove all the NULL elements from the beginning\n\t\t     of TEMP_RESULTS. */\n\t\t  /* If we have a null directory name and ** as the filename,\n\t\t     we have just searched for everything from the current\n\t\t     directory on down. Break now (shouldbreak = 1) to avoid\n\t\t     duplicate entries in the final result. */\n#define NULL_PLACEHOLDER(x)\t((x) && *(x) && **(x) == 0)\n\t\t  if ((dflags & GX_NULLDIR) && (flags & GX_NULLDIR) == 0 &&\n\t\t\tNULL_PLACEHOLDER (temp_results))\n#undef NULL_PLACEHOLDER\n\t\t    {\n\t\t      register int i, n;\n\t\t      for (n = 0; temp_results[n] && *temp_results[n] == 0; n++)\n\t\t\t;\n\t\t      i = n;\n\t\t      do\n\t\t\ttemp_results[i - n] = temp_results[i];\n\t\t      while (temp_results[i++] != 0);\n\t\t      array = temp_results;\n\t\t      shouldbreak = 1;\n\t\t    }\n\t          else\n\t\t    array = temp_results;\n\t\t}\n\t      else\n\t\tarray = glob_dir_to_array (directories[i], temp_results, flags);\n\t      l = 0;\n\t      while (array[l] != NULL)\n\t\t++l;\n\n\t      result =\n\t\t(char **)realloc (result, (result_size + l) * sizeof (char *));\n\n\t      if (result == NULL)\n\t\tgoto memory_error;\n\n\t      for (l = 0; array[l] != NULL; ++l)\n\t\tresult[result_size++ - 1] = array[l];\n\n\t      result[result_size - 1] = NULL;\n\n\t      /* Note that the elements of ARRAY are not freed.  */\n\t      if (array != temp_results)\n\t\tfree ((char *) array);\n\t      else if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t\tfree (temp_results);\t/* expanding ** case above */\n\n\t      if (shouldbreak)\n\t\tbreak;\n\t    }\n\t}\n      /* Free the directories.  */\n      for (i = 0; directories[i]; i++)\n\tfree (directories[i]);\n\n      free ((char *) directories);\n\n      return (result);\n    }\n\nonly_filename:\n  /* If there is only a directory name, return it. */\n  if (*filename == '\\0')\n    {\n      result = (char **) realloc ((char *) result, 2 * sizeof (char *));\n      if (result == NULL)\n\treturn (NULL);\n      /* Handle GX_MARKDIRS here. */\n      result[0] = (char *) malloc (directory_len + 1);\n      if (result[0] == NULL)\n\tgoto memory_error;\n      bcopy (directory_name, result[0], directory_len + 1);\n      if (free_dirname)\n\tfree (directory_name);\n      result[1] = NULL;\n      return (result);\n    }\n  else\n    {\n      char **temp_results;\n\n      /* There are no unquoted globbing characters in DIRECTORY_NAME.\n\t Dequote it before we try to open the directory since there may\n\t be quoted globbing characters which should be treated verbatim. */\n      if (directory_len > 0)\n\tdequote_pathname (directory_name);\n\n      /* We allocated a small array called RESULT, which we won't be using.\n\t Free that memory now. */\n      free (result);\n\n      /* Just return what glob_vector () returns appended to the\n\t directory name. */\n      /* If flags & GX_ALLDIRS, we're called recursively */\n      dflags = flags & ~GX_MARKDIRS;\n      if (directory_len == 0)\n\tdflags |= GX_NULLDIR;\n      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t{\n\t  dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n#if 0\n\t  /* If we want all directories (dflags & GX_ALLDIRS) and we're not\n\t     being called recursively as something like `echo [star][star]/[star].o'\n\t     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from\n\t     adding a null directory name to the front of the temp_results\n\t     array.  We turn off ADDCURDIR if not called recursively and\n\t     dlen == 0 */\n#endif\n\t  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)\n\t    dflags &= ~GX_ADDCURDIR;\n\t}\n      temp_results = glob_vector (filename,\n\t\t\t\t  (directory_len == 0 ? \".\" : directory_name),\n\t\t\t\t  dflags);\n\n      if (temp_results == NULL || temp_results == (char **)&glob_error_return)\n\t{\n\t  if (free_dirname)\n\t    free (directory_name);\n\t  QUIT;\t\t\t/* XXX - shell */\n\t  run_pending_traps ();\n\t  return (temp_results);\n\t}\n\n      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? \"\" : directory_name, temp_results, flags);\n\n      if (free_dirname)\n\tfree (directory_name);\n      return (result);\n    }\n\n  /* We get to memory_error if the program has run out of memory, or\n     if this is the shell, and we have been interrupted. */\n memory_error:\n  if (result != NULL)\n    {\n      register unsigned int i;\n      for (i = 0; result[i] != NULL; ++i)\n\tfree (result[i]);\n      free ((char *) result);\n    }\n\n  if (free_dirname && directory_name)\n    free (directory_name);\n\n  QUIT;\n  run_pending_traps ();\n\n  return (NULL);\n}"
}