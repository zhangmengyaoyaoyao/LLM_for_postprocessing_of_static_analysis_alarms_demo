{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "binutils/readelf.c",
    "message": "The value read from addr.section was never initialized.",
    "warning_function_name": "decode_arm_unwind",
    "warning_line": "&& addr.section == SHN_UNDEF && addr.offset == 0",
    "warning_context": "static void\ndecode_arm_unwind (struct arm_unw_aux_info *  aux,\n\t\t   unsigned int               word,\n\t\t   unsigned int               remaining,\n\t\t   bfd_vma                    data_offset,\n\t\t   Elf_Internal_Shdr *        data_sec,\n\t\t   struct arm_section *       data_arm_sec)\n{\n  int per_index;\n  unsigned int more_words = 0;\n  struct absaddr addr;\n  bfd_vma sym_name = (bfd_vma) -1;\n\n  if (remaining == 0)\n    {\n      /* Fetch the first word.\n\t Note - when decoding an object file the address extracted\n\t here will always be 0.  So we also pass in the sym_name\n\t parameter so that we can find the symbol associated with\n\t the personality routine.  */\n      if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset,\n\t\t\t\t     & word, & addr, & sym_name))\n\treturn;\n\n      remaining = 4;\n    }\n\n  if ((word & 0x80000000) == 0)\n    {\n      /* Expand prel31 for personality routine.  */\n      bfd_vma fn;\n      const char *procname;\n\n      fn = arm_expand_prel31 (word, data_sec->sh_addr + data_offset);\n      printf (_(\"  Personality routine: \"));\n      if (fn == 0\n\t  && addr.section == SHN_UNDEF && addr.offset == 0\n\t  && sym_name != (bfd_vma) -1 && sym_name < aux->strtab_size)\n\t{\n\t  procname = aux->strtab + sym_name;\n\t  print_vma (fn, PREFIX_HEX);\n\t  if (procname)\n\t    {\n\t      fputs (\" <\", stdout);\n\t      fputs (procname, stdout);\n\t      fputc ('>', stdout);\n\t    }\n\t}\n      else\n\tprocname = arm_print_vma_and_name (aux, fn, addr);\n      fputc ('\\n', stdout);\n\n      /* The GCC personality routines use the standard compact\n\t encoding, starting with one byte giving the number of\n\t words.  */\n      if (procname != NULL\n\t  && (const_strneq (procname, \"__gcc_personality_v0\")\n\t      || const_strneq (procname, \"__gxx_personality_v0\")\n\t      || const_strneq (procname, \"__gcj_personality_v0\")\n\t      || const_strneq (procname, \"__gnu_objc_personality_v0\")))\n\t{\n\t  remaining = 0;\n\t  more_words = 1;\n\t  ADVANCE;\n\t  if (!remaining)\n\t    {\n\t      printf (_(\"  [Truncated data]\\n\"));\n\t      return;\n\t    }\n\t  more_words = word >> 24;\n\t  word <<= 8;\n\t  remaining--;\n\t  per_index = -1;\n\t}\n      else\n\treturn;\n    }\n  else\n    {\n      /* ARM EHABI Section 6.3:\n\n\t An exception-handling table entry for the compact model looks like:\n\n           31 30-28 27-24 23-0\n\t   -- ----- ----- ----\n            1   0   index Data for personalityRoutine[index]    */\n\n      if (elf_header.e_machine == EM_ARM\n\t  && (word & 0x70000000))\n\twarn (_(\"Corrupt ARM compact model table entry: %x \\n\"), word);\n\n      per_index = (word >> 24) & 0x7f;\n      printf (_(\"  Compact model index: %d\\n\"), per_index);\n      if (per_index == 0)\n\t{\n\t  more_words = 0;\n\t  word <<= 8;\n\t  remaining--;\n\t}\n      else if (per_index < 3)\n\t{\n"
}