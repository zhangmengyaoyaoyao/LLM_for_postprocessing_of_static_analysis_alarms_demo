{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "re.c",
    "message": "Offset added: 112 Size: [0, 112].",
    "warning_function_name": "make_regexp",
    "warning_line": "memset((char *) rp, 0, sizeof(*rp));",
    "warning_context": "\t\t\t    || is_multibyte == (size_t) -2\n\t\t\t    || is_multibyte == 0) {\n\t\t\t\t/* We treat it as a single-byte character.  */\n\t\t\t\tis_multibyte = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* We skip multibyte character, since it must not be a special\n\t\t   character.  */\n\t\tif ((gawk_mb_cur_max == 1 || ! is_multibyte) &&\n\t\t    (*src == '\\\\')) {\n\t\t\tc = *++src;\n\t\t\tswitch (c) {\n\t\t\tcase 'a':\n\t\t\tcase 'b':\n\t\t\tcase 'f':\n\t\t\tcase 'n':\n\t\t\tcase 'r':\n\t\t\tcase 't':\n\t\t\tcase 'v':\n\t\t\tcase 'x':\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\t\tc2 = parse_escape(&src);\n\t\t\t\tif (c2 < 0)\n\t\t\t\t\tcant_happen();\n\t\t\t\t/*\n\t\t\t\t * Unix awk treats octal (and hex?) chars\n\t\t\t\t * literally in re's, so escape regexp\n\t\t\t\t * metacharacters.\n\t\t\t\t */\n\t\t\t\tif (do_traditional\n\t\t\t\t    && ! do_posix\n\t\t\t\t    && (isdigit(c) || c == 'x')\n\t\t\t\t    && strchr(\"()|*+?.^$\\\\[]\", c2) != NULL)\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c2;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\tcase '9':\t/* a\\9b not valid */\n\t\t\t\t*dest++ = c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\tcase 'y':\t/* normally \\b */\n\t\t\t\t/* gnu regex op */\n\t\t\t\tif (! do_traditional) {\n\t\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t\t*dest++ = 'b';\n\t\t\t\t\tsrc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else, fall through */\n\t\t\tdefault:\n\t\t\t\t*dest++ = '\\\\';\n\t\t\t\t*dest++ = (char) c;\n\t\t\t\tsrc++;\n\t\t\t\tbreak;\n\t\t\t} /* switch */\n\t\t} else {\n\t\t\tc = *src;\n\t\t\tif (c == '^' || c == '$')\n\t\t\t\thas_anchor = true;\n\n\t\t\t*dest++ = *src++;\t/* not '\\\\' */\n\t\t}\n\t\tif (gawk_mb_cur_max > 1 && is_multibyte)\n\t\t\tis_multibyte--;\n\t} /* while */\n\n\t*dest = '\\0';\n\tlen = dest - buf;\n\n\temalloc(rp, Regexp *, sizeof(*rp), \"make_regexp\");\n\tmemset((char *) rp, 0, sizeof(*rp));\n\trp->dfareg = NULL;\n\trp->pat.allocated = 0;\t/* regex will allocate the buffer */\n\temalloc(rp->pat.fastmap, char *, 256, \"make_regexp\");\n\n\t/*\n\t * Lo these many years ago, had I known what a P.I.T.A. IGNORECASE\n\t * was going to turn out to be, I wouldn't have bothered with it.\n\t *\n\t * In the case where we have a multibyte character set, we have no\n\t * choice but to use RE_ICASE, since the casetable is for single-byte\n\t * character sets only.\n\t *\n\t * On the other hand, if we do have a single-byte character set,\n\t * using the casetable should give  a performance improvement, since\n\t * it's computed only once, not each time a regex is compiled.  We\n\t * also think it's probably better for portability.  See the\n\t * discussion by the definition of casetable[] in eval.c.\n\t */\n\n\tignorecase = !! ignorecase;\t/* force to 1 or 0 */\n\tif (ignorecase) {\n"
}