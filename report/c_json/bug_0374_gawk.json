{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "unix.Malloc",
    "Code_line": "\t  d->__nextchar += strlen (d->__nextchar);",
    "Code_function": "_getopt_internal_r (int argc, char *const *argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n\td->optind = 1;\t/* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n\t\t\t\t      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n\t\t      || (d->optind < d->__nonoption_flags_len\t\t      \\\n\t\t\t  && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange ((char **) argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element `--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange ((char **) argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n\t\t  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n\t  || (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n\tconst struct option *p;\n\tstruct option_list *next;\n\tint needs_free;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n\t/* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n\t or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (namelen == (unsigned int) strlen (p->name))\n\t      {\n\t\t/* Exact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t\texact = 1;\n\t\tbreak;\n\t      }\n\t    else if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tstruct option_list *newp = malloc (sizeof (*newp));\n\t\tnewp->p = p;\n\t\tnewp->needs_free = 1;\n\t\tnewp->next = ambig_list;\n\t\tambig_list = newp;\n\t      }\n\t  }\n\n      if (ambig_list != NULL && !exact)\n\t{\n\t  if (print_errors)\n\t    {\n\t      struct option_list first;\n\t      first.p = pfound;\n\t      first.next = ambig_list;\n\t      first.needs_free = 0;\n\t      ambig_list = &first;\n\n#if defined _LIBC\n\t      char *buf = NULL;\n\t      size_t buflen = 0;\n\n\t      FILE *fp = open_memstream (&buf, &buflen);\n\t      if (fp != NULL)\n\t\t{\n\t\t  fprintf (fp,\n\t\t\t   _(\"%s: option '%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], argv[d->optind]);\n\n\t\t  do\n\t\t    {\n\t\t      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n\t\t      ambig_list = ambig_list->next;\n\t\t    }\n\t\t  while (ambig_list != NULL);\n\n\t\t  fputc_unlocked ('\\n', fp);\n\n\t\t  if (__glibc_likely (fclose (fp) != EOF))\n\t\t    {\n\t\t      _IO_flockfile (stderr);\n\n\t\t      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t      __fxprintf (NULL, \"%s\", buf);\n\n\t\t      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t      _IO_funlockfile (stderr);\n\n\t\t      free (buf);\n\t\t    }\n\t\t}\n#else\n\t      fprintf (stderr,\n\t\t       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n\t\t       argv[0], argv[d->optind]);\n\t      do\n\t\t{\n\t\t  struct option_list *tmp_next;\n\n\t\t  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n\t\t  tmp_next = ambig_list->next;\n\t\t  if (ambig_list->needs_free)\n\t\t    free(ambig_list);\n\t\t  ambig_list = tmp_next;\n\t\t}\n\t      while (ambig_list != NULL);\n\n\t      fputc ('\\n', stderr);\n#endif\n\t    }\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      if (pfound != NULL)\n\t{\n\t  option_index = indfound;\n\t  d->optind++;\n\t  if (*nameend)\n\t    {\n\t      /* Don't test has_arg with >, because some C compilers don't\n\t\t allow it to be used on enums.  */\n\t      if (pfound->has_arg)\n\t\td->optarg = nameend + 1;\n\t      else\n\t\t{\n\t\t  if (print_errors)\n\t\t    {\n#if defined _LIBC\n\t\t      char *buf;\n\t\t      int n;\n#endif\n\n\t\t      if (argv[d->optind - 1][1] == '-')\n\t\t\t{\n\t\t\t  /* --option */\n#if defined _LIBC\n\t\t\t  n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n\t\t\t\t\t  argv[0], pfound->name);\n#else\n\t\t\t  fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n\t\t\t\t   argv[0], pfound->name);\n#endif\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* +option or -option */\n#if defined _LIBC\n\t\t\t  n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n\t\t\t\t\t  argv[0], argv[d->optind - 1][0],\n\t\t\t\t\t  pfound->name);\n#else\n\t\t\t  fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n\t\t\t\t   argv[0], argv[d->optind - 1][0],\n\t\t\t\t   pfound->name);\n#endif\n\t\t\t}\n\n#if defined _LIBC\n\t\t      if (n >= 0)\n\t\t\t{\n\t\t\t  _IO_flockfile (stderr);\n\n\t\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t  ((_IO_FILE *) stderr)->_flags2\n\t\t\t    |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t  _IO_funlockfile (stderr);\n\n\t\t\t  free (buf);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t  d->__nextchar += strlen (d->__nextchar);\n\n\t\t  d->optopt = pfound->val;\n\t\t  return '?';\n\t\t}\n\t    }\n\t  else if (pfound->has_arg == 1)\n\t    {\n\t      if (d->optind < argc)\n\t\td->optarg = argv[d->optind++];\n\t      else\n\t\t{\n\t\t  if (print_errors)\n\t\t    {\n#if defined _LIBC\n\t\t      char *buf;\n\n\t\t      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n\t\t\t\t      argv[0], pfound->name) >= 0)\n\t\t\t{\n\t\t\t  _IO_flockfile (stderr);\n\n\t\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t  ((_IO_FILE *) stderr)->_flags2\n\t\t\t    |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t  _IO_funlockfile (stderr);\n\n\t\t\t  free (buf);\n\t\t\t}\n#else\n\t\t      fprintf (stderr,\n\t\t\t       _(\"%s: option '--%s' requires an argument\\n\"),\n\t\t\t       argv[0], pfound->name);\n#endif\n\t\t    }\n\t\t  d->__nextchar += strlen (d->__nextchar);\n\t\t  d->optopt = pfound->val;\n\t\t  return optstring[0] == ':' ? ':' : '?';\n\t\t}\n\t    }\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  if (longind != NULL)\n\t    *longind = option_index;\n\t  if (pfound->flag)\n\t    {\n\t      *(pfound->flag) = pfound->val;\n\t      return 0;\n\t    }\n\t  return pfound->val;\n\t}\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short\n\t option, then it's an error.\n\t Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    {\n#if defined _LIBC\n\t      char *buf;\n\t      int n;\n#endif\n\n\t      if (argv[d->optind][1] == '-')\n\t\t{\n\t\t  /* --option */\n#if defined _LIBC\n\t\t  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n\t\t\t\t  argv[0], d->__nextchar);\n#else\n\t\t  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n\t\t\t   argv[0], d->__nextchar);\n#endif\n\t\t}\n\t      else\n\t\t{\n\t\t  /* +option or -option */\n#if defined _LIBC\n\t\t  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n\t\t\t\t  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n\t\t  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n\t\t\t   argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n\t\t}\n\n#if defined _LIBC\n\t      if (n >= 0)\n\t\t{\n\t\t  _IO_flockfile (stderr);\n\n\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t  _IO_funlockfile (stderr);\n\n\t\t  free (buf);\n\t\t}\n#endif\n\t    }\n\t  d->__nextchar = (char *) \"\";\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    char *temp = strchr (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  {\n#if defined _LIBC\n\t    char *buf;\n\t    int n;\n#endif\n\n#if defined _LIBC\n\t    n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n\t\t\t    argv[0], c);\n#else\n\t    fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC\n\t    if (n >= 0)\n\t      {\n\t\t_IO_flockfile (stderr);\n\n\t\tint old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t__fxprintf (NULL, \"%s\", buf);\n\n\t\t((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t_IO_funlockfile (stderr);\n\n\t\tfree (buf);\n\t      }\n#endif\n\t  }\n\td->optopt = c;\n\treturn '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n\tchar *nameend;\n\tconst struct option *p;\n\tconst struct option *pfound = NULL;\n\tint exact = 0;\n\tint ambig = 0;\n\tint indfound = 0;\n\tint option_index;\n\n\tif (longopts == NULL)\n\t  goto no_longs;\n\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  {\n\t    d->optarg = d->__nextchar;\n\t    /* If we end this ARGV-element by taking the rest as an arg,\n\t       we must advance to the next element now.  */\n\t    d->optind++;\n\t  }\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      {\n#if defined _LIBC\n\t\tchar *buf;\n\n\t\tif (__asprintf (&buf,\n\t\t\t\t_(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t\targv[0], c) >= 0)\n\t\t  {\n\t\t    _IO_flockfile (stderr);\n\n\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t    _IO_funlockfile (stderr);\n\n\t\t    free (buf);\n\t\t  }\n#else\n\t\tfprintf (stderr,\n\t\t\t _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t argv[0], c);\n#endif\n\t      }\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  /* We already incremented `d->optind' once;\n\t     increment it again when taking next ARGV-elt as argument.  */\n\t  d->optarg = argv[d->optind++];\n\n\t/* optarg is now the argument, see if it's in the\n\t   table of longopts.  */\n\n\tfor (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n\t     nameend++)\n\t  /* Do nothing.  */ ;\n\n\t/* Test all long options for either exact match\n\t   or abbreviated matches.  */\n\tfor (p = longopts, option_index = 0; p->name; p++, option_index++)\n\t  if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n\t    {\n\t      if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n\t\t{\n\t\t  /* Exact match found.  */\n\t\t  pfound = p;\n\t\t  indfound = option_index;\n\t\t  exact = 1;\n\t\t  break;\n\t\t}\n\t      else if (pfound == NULL)\n\t\t{\n\t\t  /* First nonexact match found.  */\n\t\t  pfound = p;\n\t\t  indfound = option_index;\n\t\t}\n\t      else if (long_only\n\t\t       || pfound->has_arg != p->has_arg\n\t\t       || pfound->flag != p->flag\n\t\t       || pfound->val != p->val)\n\t\t/* Second or later nonexact match found.  */\n\t\tambig = 1;\n\t    }\n\tif (ambig && !exact)\n\t  {\n\t    if (print_errors)\n\t      {\n#if defined _LIBC\n\t\tchar *buf;\n\n\t\tif (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n\t\t\t\targv[0], d->optarg) >= 0)\n\t\t  {\n\t\t    _IO_flockfile (stderr);\n\n\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t    _IO_funlockfile (stderr);\n\n\t\t    free (buf);\n\t\t  }\n#else\n\t\tfprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n\t\t\t argv[0], d->optarg);\n#endif\n\t      }\n\t    d->__nextchar += strlen (d->__nextchar);\n\t    d->optind++;\n\t    return '?';\n\t  }\n\tif (pfound != NULL)\n\t  {\n\t    option_index = indfound;\n\t    if (*nameend)\n\t      {\n\t\t/* Don't test has_arg with >, because some C compilers don't\n\t\t   allow it to be used on enums.  */\n\t\tif (pfound->has_arg)\n\t\t  d->optarg = nameend + 1;\n\t\telse\n\t\t  {\n\t\t    if (print_errors)\n\t\t      {\n#if defined _LIBC\n\t\t\tchar *buf;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n\t\t\t\t\targv[0], pfound->name) >= 0)\n\t\t\t  {\n\t\t\t    _IO_flockfile (stderr);\n\n\t\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t    ((_IO_FILE *) stderr)->_flags2\n\t\t\t      |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t    _IO_funlockfile (stderr);\n\n\t\t\t    free (buf);\n\t\t\t  }\n#else\n\t\t\tfprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n\t\t\t\t argv[0], pfound->name);\n#endif\n\t\t      }\n\n\t\t    d->__nextchar += strlen (d->__nextchar);\n\t\t    return '?';\n\t\t  }\n\t      }\n\t    else if (pfound->has_arg == 1)\n\t      {\n\t\tif (d->optind < argc)\n\t\t  d->optarg = argv[d->optind++];\n\t\telse\n\t\t  {\n\t\t    if (print_errors)\n\t\t      {\n#if defined _LIBC\n\t\t\tchar *buf;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n\t\t\t\t\targv[0], pfound->name) >= 0)\n\t\t\t  {\n\t\t\t    _IO_flockfile (stderr);\n\n\t\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t    ((_IO_FILE *) stderr)->_flags2\n\t\t\t      |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t    _IO_funlockfile (stderr);\n\n\t\t\t    free (buf);\n\t\t\t  }\n#else\n\t\t\tfprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n\t\t\t\t argv[0], pfound->name);\n#endif\n\t\t      }\n\t\t    d->__nextchar += strlen (d->__nextchar);\n\t\t    return optstring[0] == ':' ? ':' : '?';\n\t\t  }\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar += strlen (d->__nextchar);\n\t    if (longind != NULL)\n\t      *longind = option_index;\n\t    if (pfound->flag)\n\t      {\n\t\t*(pfound->flag) = pfound->val;\n\t\treturn 0;\n\t      }\n\t    return pfound->val;\n\t  }\n\n      no_longs:\n\td->__nextchar = NULL;\n\treturn 'W';\t/* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  {\n#if defined _LIBC\n\t\t    char *buf;\n\n\t\t    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n\t\t\t\t    argv[0], c) >= 0)\n\t\t      {\n\t\t\t_IO_flockfile (stderr);\n\n\t\t\tint old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t__fxprintf (NULL, \"%s\", buf);\n\n\t\t\t((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t_IO_funlockfile (stderr);\n\n\t\t\tfree (buf);\n\t\t      }\n#else\n\t\t    fprintf (stderr,\n\t\t\t     _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t     argv[0], c);\n#endif\n\t\t  }\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented `optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}"
}