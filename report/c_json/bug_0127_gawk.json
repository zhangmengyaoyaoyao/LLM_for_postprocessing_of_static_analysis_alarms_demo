{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t\tfd = devopen(str, mode);",
    "Code_function": "redirect(NODE *redir_exp, int redirtype, int *errflg)\n{\n\tstruct redirect *rp;\n\tchar *str;\n\tint tflag = 0;\n\tint outflag = 0;\n\tconst char *direction = \"to\";\n\tconst char *mode;\n\tint fd;\n\tconst char *what = NULL;\n\tbool new_rp = false;\n#ifdef HAVE_SOCKETS\n\tstruct inet_socket_info isi;\n#endif\n\tstatic struct redirect *save_rp = NULL;\t/* hold onto rp that should\n\t                                         * be freed for reuse\n\t                                         */\n\n\tif (do_sandbox)\n\t\tfatal(_(\"redirection not allowed in sandbox mode\"));\n\n\tswitch (redirtype) {\n\tcase redirect_append:\n\t\ttflag = RED_APPEND;\n\t\t/* FALL THROUGH */\n\tcase redirect_output:\n\t\toutflag = (RED_FILE|RED_WRITE);\n\t\ttflag |= outflag;\n\t\tif (redirtype == redirect_output)\n\t\t\twhat = \">\";\n\t\telse\n\t\t\twhat = \">>\";\n\t\tbreak;\n\tcase redirect_pipe:\n\t\ttflag = (RED_PIPE|RED_WRITE);\n\t\twhat = \"|\";\n\t\tbreak;\n\tcase redirect_pipein:\n\t\ttflag = (RED_PIPE|RED_READ);\n\t\twhat = \"|\";\n\t\tbreak;\n\tcase redirect_input:\n\t\ttflag = (RED_FILE|RED_READ);\n\t\twhat = \"<\";\n\t\tbreak;\n\tcase redirect_twoway:\n\t\ttflag = (RED_READ|RED_WRITE|RED_TWOWAY);\n\t\twhat = \"|&\";\n\t\tbreak;\n\tdefault:\n\t\tcant_happen();\n\t}\n\tif (do_lint && (redir_exp->flags & STRCUR) == 0)\n\t\tlintwarn(_(\"expression in `%s' redirection only has numeric value\"),\n\t\t\twhat);\n\tredir_exp = force_string(redir_exp);\n\tstr = redir_exp->stptr;\n\n\tif (str == NULL || *str == '\\0')\n\t\tfatal(_(\"expression for `%s' redirection has null string value\"),\n\t\t\twhat);\n\n\tif (do_lint && (strncmp(str, \"0\", redir_exp->stlen) == 0\n\t\t\t|| strncmp(str, \"1\", redir_exp->stlen) == 0))\n\t\tlintwarn(_(\"filename `%s' for `%s' redirection may be result of logical expression\"),\n\t\t\t\tstr, what);\n\n#ifdef HAVE_SOCKETS\n\t/*\n\t * Use /inet4 to force IPv4, /inet6 to force IPv6, and plain\n\t * /inet will be whatever we get back from the system.\n\t */\n\tif (inetfile(str, & isi)) {\n\t\ttflag |= RED_SOCKET;\n\t\tif (isi.protocol == SOCK_STREAM)\n\t\t\ttflag |= RED_TCP;\t/* use shutdown when closing */\n\t}\n#endif /* HAVE_SOCKETS */\n\n\tfor (rp = red_head; rp != NULL; rp = rp->next) {\n#ifndef PIPES_SIMULATED\n\t\t/*\n\t\t * This is an efficiency hack.  We want to\n\t\t * recover the process slot for dead children,\n\t\t * if at all possible.  Messing with signal() for\n\t\t * SIGCLD leads to lots of headaches.  However, if\n\t\t * we've gotten EOF from a child input pipeline, it's\n\t\t * a good bet that the child has died. So recover it.\n\t\t */\n\t\tif ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {\n\t\t\tif (rp->pid != -1)\n#ifdef __MINGW32__\n\t\t\t\t/* MinGW cannot wait for any process.  */\n\t\t\t\twait_any(rp->pid);\n#else\n\t\t\t\twait_any(0);\n#endif\n\t\t}\n#endif /* PIPES_SIMULATED */\n\n\t\t/* now check for a match */\n\t\tif (strlen(rp->value) == redir_exp->stlen\n\t\t    && memcmp(rp->value, str, redir_exp->stlen) == 0\n\t\t    && ((rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY)) == tflag\n\t\t\t|| (outflag != 0\n\t\t\t    && (rp->flag & (RED_FILE|RED_WRITE)) == outflag))) {\n\n\t\t\tint rpflag = (rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\t\t\tint newflag = (tflag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\n\t\t\tif (do_lint && rpflag != newflag)\n\t\t\t\tlintwarn(\n\t\t_(\"unnecessary mixing of `>' and `>>' for file `%.*s'\"),\n\t\t\t\t\t(int) redir_exp->stlen, rp->value);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rp == NULL) {\n\t\tnew_rp = true;\n\t\tif (save_rp != NULL) {\n\t\t\trp = save_rp;\n\t\t\tefree(rp->value);\n\t\t} else\n\t\t\temalloc(rp, struct redirect *, sizeof(struct redirect), \"redirect\");\n\t\temalloc(str, char *, redir_exp->stlen + 1, \"redirect\");\n\t\tmemcpy(str, redir_exp->stptr, redir_exp->stlen);\n\t\tstr[redir_exp->stlen] = '\\0';\n\t\trp->value = str;\n\t\trp->flag = tflag;\n\t\tinit_output_wrapper(& rp->output);\n\t\trp->output.name = str;\n\t\trp->iop = NULL;\n\t\trp->pid = -1;\n\t\trp->status = 0;\n\t} else\n\t\tstr = rp->value;\t/* get \\0 terminated string */\n\tsave_rp = rp;\n\n\twhile (rp->output.fp == NULL && rp->iop == NULL) {\n\t\tif (! new_rp && (rp->flag & RED_EOF) != 0) {\n\t\t\t/*\n\t\t\t * Encountered EOF on file or pipe -- must be cleared\n\t\t\t * by explicit close() before reading more\n\t\t\t */\n\t\t\tsave_rp = NULL;\n\t\t\treturn rp;\n\t\t}\n\t\tmode = NULL;\n\t\terrno = 0;\n\t\tswitch (redirtype) {\n\t\tcase redirect_output:\n\t\t\tmode = binmode(\"w\");\n\t\t\tif ((rp->flag & RED_USED) != 0)\n\t\t\t\tmode = (rp->mode[1] == 'b') ? \"ab\" : \"a\";\n\t\t\tbreak;\n\t\tcase redirect_append:\n\t\t\tmode = binmode(\"a\");\n\t\t\tbreak;\n\t\tcase redirect_pipe:\n\t\t\t/* synchronize output before new pipe */\n\t\t\t(void) flush_io();\n\n\t\t\tos_restore_mode(fileno(stdin));\n\t\t\tif ((rp->output.fp = popen(str, binmode(\"w\"))) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for output (%s)\"),\n\t\t\t\t\t\tstr, strerror(errno));\n\n\t\t\t/* set close-on-exec */\n\t\t\tos_close_on_exec(fileno(rp->output.fp), str, \"pipe\", \"to\");\n\t\t\trp->flag |= RED_NOBUF;\n\t\t\tbreak;\n\t\tcase redirect_pipein:\n\t\t\tdirection = \"from\";\n\t\t\tif (gawk_popen(str, rp) == NULL)\n\t\t\t\tfatal(_(\"can't open pipe `%s' for input (%s)\"),\n\t\t\t\t\tstr, strerror(errno));\n\t\t\tbreak;\n\t\tcase redirect_input:\n\t\t\tdirection = \"from\";\n\t\t\tfd = devopen(str, binmode(\"r\"));\n\t\t\tif (fd == INVALID_HANDLE && errno == EISDIR) {\n\t\t\t\t*errflg = EISDIR;\n\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trp->iop = iop_alloc(fd, str, errno);\n\t\t\tfind_input_parser(rp->iop);\n\t\t\tiop_finish(rp->iop);\n\t\t\tif (! rp->iop->valid) {\n\t\t\t\tif (! do_traditional && rp->iop->errcode != 0)\n\t\t\t\t\tupdate_ERRNO_int(rp->iop->errcode);\n\t\t\t\tiop_close(rp->iop);\n\t\t\t\trp->iop = NULL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase redirect_twoway:\n\t\t\tdirection = \"to/from\";\n\t\t\tif (! two_way_open(str, rp)) {\n#ifdef HAVE_SOCKETS\n\t\t\t\tif (inetfile(str, NULL)) {\n\t\t\t\t\t*errflg = errno;\n\t\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\t\treturn NULL;\n\t\t\t\t} else\n#endif\n\t\t\t\t\tfatal(_(\"can't open two way pipe `%s' for input/output (%s)\"),\n\t\t\t\t\t\t\tstr, strerror(errno));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcant_happen();\n\t\t}\n\n\t\tif (mode != NULL) {\n\t\t\terrno = 0;\n\t\t\trp->output.mode = mode;\n\t\t\tfd = devopen(str, mode);\n\n\t\t\tif (fd > INVALID_HANDLE) {\n\t\t\t\tif (fd == fileno(stdin))\n\t\t\t\t\trp->output.fp = stdin;\n\t\t\t\telse if (fd == fileno(stdout))\n\t\t\t\t\trp->output.fp = stdout;\n\t\t\t\telse if (fd == fileno(stderr))\n\t\t\t\t\trp->output.fp = stderr;\n\t\t\t\telse {\n\t\t\t\t\tconst char *omode = mode;\n#if defined(F_GETFL) && defined(O_APPEND)\n\t\t\t\t\tint fd_flags;\n\n\t\t\t\t\tfd_flags = fcntl(fd, F_GETFL);\n\t\t\t\t\tif (fd_flags != -1 && (fd_flags & O_APPEND) == O_APPEND)\n\t\t\t\t\t\tomode = binmode(\"a\");\n#endif\n\t\t\t\t\tos_close_on_exec(fd, str, \"file\", \"\");\n\t\t\t\t\trp->output.fp = fdopen(fd, (const char *) omode);\n\t\t\t\t\trp->mode = (const char *) mode;\n\t\t\t\t\t/* don't leak file descriptors */\n\t\t\t\t\tif (rp->output.fp == NULL)\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t}\n\t\t\t\tif (rp->output.fp != NULL && os_isatty(fd))\n\t\t\t\t\trp->flag |= RED_NOBUF;\n\n\t\t\t\t/* Move rp to the head of the list. */\n\t\t\t\tif (! new_rp && red_head != rp) {\n\t\t\t\t\tif ((rp->prev->next = rp->next) != NULL)\n\t\t\t\t\t\trp->next->prev = rp->prev;\n\t\t\t\t\tred_head->prev = rp;\n\t\t\t\t\trp->prev = NULL;\n\t\t\t\t\trp->next = red_head;\n\t\t\t\t\tred_head = rp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfind_output_wrapper(& rp->output);\n\t\t}\n\n\t\tif (rp->output.fp == NULL && rp->iop == NULL) {\n\t\t\t/* too many files open -- close one and try again */\n\t\t\tif (errno == EMFILE || errno == ENFILE)\n\t\t\t\tclose_one();\n#ifdef VMS\n\t\t\t/* Alpha/VMS V7.1+ C RTL is returning these instead\n\t\t\t   of EMFILE (haven't tried other post-V6.2 systems) */\n\t\t\telse if ((errno == EIO || errno == EVMSERR) &&\n                                 (vaxc$errno == SS$_EXQUOTA ||\n                                  vaxc$errno == SS$_EXBYTLM ||\n                                  vaxc$errno == RMS$_ACC ||\n\t\t\t\t  vaxc$errno == RMS$_SYN))\n\t\t\t\tclose_one();\n#endif\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Some other reason for failure.\n\t\t\t\t *\n\t\t\t\t * On redirection of input from a file,\n\t\t\t\t * just return an error, so e.g. getline\n\t\t\t\t * can return -1.  For output to file,\n\t\t\t\t * complain. The shell will complain on\n\t\t\t\t * a bad command to a pipe.\n\t\t\t\t */\n\t\t\t\tif (errflg != NULL)\n\t\t\t\t\t*errflg = errno;\n\t\t\t\tif (   redirtype == redirect_output\n\t\t\t\t    || redirtype == redirect_append) {\n\t\t\t\t\t/* multiple messages make life easier for translators */\n\t\t\t\t\tif (*direction == 'f')\n\t\t\t\t\t\tfatal(_(\"can't redirect from `%s' (%s)\"),\n\t\t\t\t\t    \t\tstr, strerror(errno));\n\t\t\t\t\telse\n\t\t\t\t\t\tfatal(_(\"can't redirect to `%s' (%s)\"),\n\t\t\t\t\t\t\tstr, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\t/* do not free rp, saving it for reuse (save_rp = rp) */\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (new_rp) {\n\t\t/*\n\t\t * It opened successfully, hook it into the list.\n\t\t * Maintain the list in most-recently-used first order.\n\t\t */\n\t\tif (red_head != NULL)\n\t\t\tred_head->prev = rp;\n\t\trp->prev = NULL;\n\t\trp->next = red_head;\n\t\tred_head = rp;\n\t}\n\tsave_rp = NULL;\n\treturn rp;\n}"
}