{
    "project": "gawk",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "io.c",
    "message": "The value read from recm.start was never initialized.",
    "warning_function_name": "get_a_record",
    "warning_line": "*out = recm.start;",
    "warning_context": "#ifdef SSIZE_MAX\n\t\t/*\n\t\t * POSIX limits read to SSIZE_MAX. There are (bizarre)\n\t\t * systems where this amount is small.\n\t\t */\n\t\tamt_to_read = MIN(amt_to_read, SSIZE_MAX);\n#endif\n\n\t\tiop->count = iop->public.read_func(iop->public.fd, iop->dataend, amt_to_read);\n\t\tif (iop->count == -1) {\n\t\t\t*errcode = errno;\n\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\tbreak;\n\t\t} else if (iop->count == 0) {\n\t\t\t/*\n\t\t\t * Hit EOF before being certain that we've matched\n\t\t\t * the end of the record. If ret is TERMNEAREND,\n\t\t\t * we need to pull out what we've got in the buffer.\n\t\t\t * Eventually we'll come back here and see the EOF,\n\t\t\t * end the record and set RT to \"\".\n\t\t\t */\n\t\t\tif (ret != TERMNEAREND)\n\t\t\t\tiop->flag |= IOP_AT_EOF;\n\t\t\tbreak;\n\t\t} else\n\t\t\tiop->dataend += iop->count;\n\t}\n\n\t/* set record, RT, return right value */\n\n\t/*\n\t * rtval is not a static pointer to avoid dangling pointer problems\n\t * in case awk code assigns to RT.  A remote possibility, to be sure,\n\t * but Bitter Experience teaches us not to make ``that'll never\n\t * happen'' kinds of assumptions.\n\t */\n\trtval = RT_node->var_value;\n\n\tif (recm.rt_len == 0) {\n\t\tset_RT_to_null();\n\t\tlastmatchrec = NULL;\n\t} else {\n\t\tassert(recm.rt_start != NULL);\n\t\t/*\n\t\t * Optimization. For rs1 case, don't set RT if\n\t\t * character is same as last time.  This knocks a\n\t\t * chunk of time off something simple like\n\t\t *\n\t\t *      gawk '{ print }' /some/big/file\n\t\t *\n\t\t * Similarly, for rsnull case, if length of new RT is\n\t\t * shorter than current RT, just bump length down in RT.\n\t\t *\n\t\t * Make sure that matchrec didn't change since the last\n\t\t * check.  (Ugh, details, details, details.)\n\t\t */\n\t\tif (lastmatchrec == NULL || lastmatchrec != matchrec) {\n\t\t\tlastmatchrec = matchrec;\n\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t} else if (matchrec == rs1scan) {\n\t\t\tif (rtval->stlen != 1 || rtval->stptr[0] != recm.rt_start[0])\n\t\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t\t/* else\n\t\t\t\tleave it alone */\n\t\t} else if (matchrec == rsnullscan) {\n\t\t\tif (rtval->stlen >= recm.rt_len) {\n\t\t\t\trtval->stlen = recm.rt_len;\n\t\t\t\tfree_wstr(rtval);\n\t\t\t} else\n\t\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t\t} else\n\t\t\tset_RT(recm.rt_start, recm.rt_len);\n\t}\n\n\tif (recm.len == 0) {\n\t\t*out = NULL;\n\t\tretval = 0;\n\t} else {\n\t\tassert(recm.start != NULL);\n\t\t*out = recm.start;\n\t\tretval = recm.len;\n\t}\n\n\tiop->off += recm.len + recm.rt_len;\n\n\tif (recm.len == 0 && recm.rt_len == 0 && at_eof(iop))\n\t\treturn EOF;\n\telse\n\t\treturn retval;\n}\n\n/* set_RS --- update things as appropriate when RS is set */\n\nvoid\nset_RS()\n{\n\tstatic NODE *save_rs = NULL;\n\n\t/*\n\t * Don't use cmp_nodes(), which pays attention to IGNORECASE.\n\t */\n"
}