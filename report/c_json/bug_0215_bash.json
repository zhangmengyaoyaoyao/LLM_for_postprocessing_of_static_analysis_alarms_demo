{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/glob/glob.c",
    "message": "The value read from isdir was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "if (isdir == 0)",
    "warning_context": "#if defined (OPENDIR_NOT_ROBUST)\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n#endif\n\n      d = opendir (dir);\n      if (d == NULL)\n\treturn ((char **) &glob_error_return);\n\n      /* Compute the flags that will be passed to strmatch().  We don't\n\t need to do this every time through the loop. */\n      mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;\n\n#ifdef FNM_CASEFOLD\n      if (glob_ignore_case)\n\tmflags |= FNM_CASEFOLD;\n#endif\n\n      if (extended_glob)\n\tmflags |= FNM_EXTMATCH;\n\n      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));\n\n      /* Scan the directory, finding all names that match.\n\t For each name that matches, allocate a struct globval\n\t on the stack and store the name in it.\n\t Chain those structs together; lastlink is the front of the chain.  */\n      while (1)\n\t{\n\t  /* Make globbing interruptible in the shell. */\n\t  if (interrupt_state || terminating_signal)\n\t    {\n\t      lose = 1;\n\t      break;\n\t    }\n\t  else if (signal_is_pending (SIGINT))\t/* XXX - make SIGINT traps responsive */\n\t    {\n\t      lose = 1;\n\t      break;\n\t    }\n\n\t  dp = readdir (d);\n\t  if (dp == NULL)\n\t    break;\n\n\t  /* If this directory entry is not to be used, try again. */\n\t  if (REAL_DIR_ENTRY (dp) == 0)\n\t    continue;\n\n#if 0\n\t  if (dp->d_name == 0 || *dp->d_name == 0)\n\t    continue;\n#endif\n\n#if HANDLE_MULTIBYTE\n\t  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))\n\t    continue;\n\t  else\n#endif\n\t  if (skipname (pat, dp->d_name, flags))\n\t    continue;\n\n\t  /* If we're only interested in directories, don't bother with files */\n\t  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))\n\t    {\n\t      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;\n\t      if (flags & GX_NULLDIR)\n\t\tpflags |= MP_IGNDOT;\n\t      subdir = sh_makepath (dir, dp->d_name, pflags);\n\t      isdir = glob_testdir (subdir, flags);\n\t      if (isdir < 0 && (flags & GX_MATCHDIRS))\n\t\t{\n\t\t  free (subdir);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  if (flags & GX_ALLDIRS)\n\t    {\n\t      if (isdir == 0)\n\t\t{\n\t\t  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);\n\t\t  if (dirlist == &finddirs_error_return)\n\t\t    {\n\t\t      free (subdir);\n\t\t      lose = 1;\n\t\t      break;\n\t\t    }\n\t\t  if (ndirs)\t\t/* add recursive directories to list */\n\t\t    {\n\t\t      if (firstmalloc == 0)\n\t\t        firstmalloc = e;\n\t\t      e->next = lastlink;\n\t\t      lastlink = dirlist;\n\t\t      count += ndirs;\n\t\t    }\n\t\t}\n\n\t      nextlink = (struct globval *) malloc (sizeof (struct globval));\n\t      if (firstmalloc == 0)\n\t\tfirstmalloc = nextlink;\n"
}