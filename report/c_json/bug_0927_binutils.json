{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset added: [-20, 91] (⇐ [-44, 67] + 24) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "bfd_elf_gc_record_vtinherit",
    "warning_line": "bfd_zalloc (abfd, sizeof (*child->vtable));",
    "warning_context": "bfd_boolean\nbfd_elf_gc_record_vtinherit (bfd *abfd,\n\t\t\t     asection *sec,\n\t\t\t     struct elf_link_hash_entry *h,\n\t\t\t     bfd_vma offset)\n{\n  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;\n  struct elf_link_hash_entry **search, *child;\n  bfd_size_type extsymcount;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n\n  /* The sh_info field of the symtab header tells us where the\n     external symbols start.  We don't care about the local symbols at\n     this point.  */\n  extsymcount = elf_tdata (abfd)->symtab_hdr.sh_size / bed->s->sizeof_sym;\n  if (!elf_bad_symtab (abfd))\n    extsymcount -= elf_tdata (abfd)->symtab_hdr.sh_info;\n\n  sym_hashes = elf_sym_hashes (abfd);\n  sym_hashes_end = sym_hashes + extsymcount;\n\n  /* Hunt down the child symbol, which is in this section at the same\n     offset as the relocation.  */\n  for (search = sym_hashes; search != sym_hashes_end; ++search)\n    {\n      if ((child = *search) != NULL\n\t  && (child->root.type == bfd_link_hash_defined\n\t      || child->root.type == bfd_link_hash_defweak)\n\t  && child->root.u.def.section == sec\n\t  && child->root.u.def.value == offset)\n\tgoto win;\n    }\n\n  (*_bfd_error_handler) (\"%B: %A+%lu: No symbol found for INHERIT\",\n\t\t\t abfd, sec, (unsigned long) offset);\n  bfd_set_error (bfd_error_invalid_operation);\n  return FALSE;\n\n win:\n  if (!child->vtable)\n    {\n      child->vtable = (struct elf_link_virtual_table_entry *)\n          bfd_zalloc (abfd, sizeof (*child->vtable));\n      if (!child->vtable)\n\treturn FALSE;\n    }\n  if (!h)\n    {\n      /* This *should* only be the absolute section.  It could potentially\n\t be that someone has defined a non-global vtable though, which\n\t would be bad.  It isn't worth paging in the local symbols to be\n\t sure though; that case should simply be handled by the assembler.  */\n\n      child->vtable->parent = (struct elf_link_hash_entry *) -1;\n    }\n  else\n    child->vtable->parent = h;\n\n  return TRUE;\n}\n"
}