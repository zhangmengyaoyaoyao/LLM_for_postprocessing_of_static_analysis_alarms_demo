{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "dfa.c",
    "message": "Access to field 'ranges' results in a dereference of a null pointer (loaded from variable 'work_mbc')",
    "warning_function_name": "parse_bracket_exp",
    "warning_line": NaN,
    "warning_context": "              /* Fetch bracket.  */\n              FETCH_WC (c, wc, _(\"unbalanced [\"));\n              if (c1 == ':')\n                /* Build character class.  POSIX allows character\n                   classes to match multicharacter collating elements,\n                   but the regex code does not support that, so do not\n                   worry about that possibility.  */\n                {\n                  char const *class\n                    = (case_fold && (STREQ (str, \"upper\")\n                                     || STREQ (str, \"lower\")) ? \"alpha\" : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n                    dfaerror (_(\"invalid character class\"));\n\n                  if (dfa->multibyte && !pred->single_byte_only)\n                    {\n                      /* Store the character class as wctype_t.  */\n                      wctype_t wt = (wctype_t) wctype (class);\n\n                      work_mbc->ch_classes\n                        = maybe_realloc (work_mbc->ch_classes,\n                                         work_mbc->nch_classes, &ch_classes_al,\n                                         sizeof *work_mbc->ch_classes);\n                      work_mbc->ch_classes[work_mbc->nch_classes++] = wt;\n                    }\n\n                  for (c2 = 0; c2 < NOTCHAR; ++c2)\n                    if (pred->func (c2))\n                      setbit (c2, ccl);\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n\n              /* Fetch new lookahead character.  */\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* We treat '[' as a normal character here.  c/c1/wc/wc1\n             are already set up.  */\n        }\n\n      if (c == '\\\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n        FETCH_WC (c, wc, _(\"unbalanced [\"));\n\n      if (c1 == NOTCHAR)\n        FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n\n      if (c1 == '-')\n        /* build range characters.  */\n        {\n          FETCH_WC (c2, wc2, _(\"unbalanced [\"));\n\n          /* A bracket expression like [a-[.aa.]] matches an unknown set.\n             Treat it like [-a[.aa.]] while parsing it, and\n             remember that the set is unknown.  */\n          if (c2 == '[' && *lexptr == '.')\n            {\n              known_bracket_exp = false;\n              c2 = ']';\n            }\n\n          if (c2 != ']')\n            {\n              if (c2 == '\\\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))\n                FETCH_WC (c2, wc2, _(\"unbalanced [\"));\n\n              if (dfa->multibyte)\n                {\n                  /* When case folding map a range, say [m-z] (or even [M-z])\n                     to the pair of ranges, [m-z] [M-Z].  Although this code\n                     is wrong in multiple ways, it's never used in practice.\n                     FIXME: Remove this (and related) unused code.  */\n                  if (wc != WEOF && wc2 != WEOF)\n                    {\n                      work_mbc->ranges\n                        = maybe_realloc (work_mbc->ranges,\n                                         work_mbc->nranges + 2,\n                                         &ranges_al, sizeof *work_mbc->ranges);\n                      work_mbc->ranges[work_mbc->nranges].beg\n                        = case_fold ? towlower (wc) : wc;\n                      work_mbc->ranges[work_mbc->nranges++].end\n                        = case_fold ? towlower (wc2) : wc2;\n\n                      if (case_fold && (iswalpha (wc) || iswalpha (wc2)))\n                        {\n                          work_mbc->ranges[work_mbc->nranges].beg\n                            = towupper (wc);\n                          work_mbc->ranges[work_mbc->nranges++].end\n                            = towupper (wc2);\n                        }\n                    }\n                }\n              else if (using_simple_locale ())\n                {\n                  for (c1 = c; c1 <= c2; c1++)\n                    setbit (c1, ccl);\n                  if (case_fold)\n"
}