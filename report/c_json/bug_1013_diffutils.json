{
    "Project": "diffutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "              part->xmid = fxbest;",
    "Code_function": "diag (OFFSET xoff, OFFSET xlim, OFFSET yoff, OFFSET ylim, bool find_minimal,\n      struct partition *part, struct context *ctxt)\n{\n  OFFSET *const fd = ctxt->fdiag;       /* Give the compiler a chance. */\n  OFFSET *const bd = ctxt->bdiag;       /* Additional help for the compiler. */\n#ifdef ELEMENT\n  ELEMENT const *const xv = ctxt->xvec; /* Still more help for the compiler. */\n  ELEMENT const *const yv = ctxt->yvec; /* And more and more . . . */\n  #define XREF_YREF_EQUAL(x,y)  EQUAL (xv[x], yv[y])\n#else\n  #define XREF_YREF_EQUAL(x,y)  XVECREF_YVECREF_EQUAL (ctxt, x, y)\n#endif\n  const OFFSET dmin = xoff - ylim;      /* Minimum valid diagonal. */\n  const OFFSET dmax = xlim - yoff;      /* Maximum valid diagonal. */\n  const OFFSET fmid = xoff - yoff;      /* Center diagonal of top-down search. */\n  const OFFSET bmid = xlim - ylim;      /* Center diagonal of bottom-up search. */\n  OFFSET fmin = fmid;\n  OFFSET fmax = fmid;           /* Limits of top-down search. */\n  OFFSET bmin = bmid;\n  OFFSET bmax = bmid;           /* Limits of bottom-up search. */\n  OFFSET c;                     /* Cost. */\n  bool odd = (fmid - bmid) & 1; /* True if southeast corner is on an odd\n                                   diagonal with respect to the northwest. */\n\n  fd[fmid] = xoff;\n  bd[bmid] = xlim;\n\n  for (c = 1;; ++c)\n    {\n      OFFSET d;                 /* Active diagonal. */\n      bool big_snake = false;\n\n      /* Extend the top-down search by an edit step in each diagonal. */\n      if (fmin > dmin)\n        fd[--fmin - 1] = -1;\n      else\n        ++fmin;\n      if (fmax < dmax)\n        fd[++fmax + 1] = -1;\n      else\n        --fmax;\n      for (d = fmax; d >= fmin; d -= 2)\n        {\n          OFFSET x;\n          OFFSET y;\n          OFFSET tlo = fd[d - 1];\n          OFFSET thi = fd[d + 1];\n          OFFSET x0 = tlo < thi ? thi : tlo + 1;\n\n          for (x = x0, y = x0 - d;\n               x < xlim && y < ylim && XREF_YREF_EQUAL (x, y);\n               x++, y++)\n            continue;\n          if (x - x0 > SNAKE_LIMIT)\n            big_snake = true;\n          fd[d] = x;\n          if (odd && bmin <= d && d <= bmax && bd[d] <= x)\n            {\n              part->xmid = x;\n              part->ymid = y;\n              part->lo_minimal = part->hi_minimal = true;\n              return;\n            }\n        }\n\n      /* Similarly extend the bottom-up search.  */\n      if (bmin > dmin)\n        bd[--bmin - 1] = OFFSET_MAX;\n      else\n        ++bmin;\n      if (bmax < dmax)\n        bd[++bmax + 1] = OFFSET_MAX;\n      else\n        --bmax;\n      for (d = bmax; d >= bmin; d -= 2)\n        {\n          OFFSET x;\n          OFFSET y;\n          OFFSET tlo = bd[d - 1];\n          OFFSET thi = bd[d + 1];\n          OFFSET x0 = tlo < thi ? tlo : thi - 1;\n\n          for (x = x0, y = x0 - d;\n               xoff < x && yoff < y && XREF_YREF_EQUAL (x - 1, y - 1);\n               x--, y--)\n            continue;\n          if (x0 - x > SNAKE_LIMIT)\n            big_snake = true;\n          bd[d] = x;\n          if (!odd && fmin <= d && d <= fmax && x <= fd[d])\n            {\n              part->xmid = x;\n              part->ymid = y;\n              part->lo_minimal = part->hi_minimal = true;\n              return;\n            }\n        }\n\n      if (find_minimal)\n        continue;\n\n#ifdef USE_HEURISTIC\n      /* Heuristic: check occasionally for a diagonal that has made lots\n         of progress compared with the edit distance.  If we have any\n         such, find the one that has made the most progress and return it\n         as if it had succeeded.\n\n         With this heuristic, for vectors with a constant small density\n         of changes, the algorithm is linear in the vector size.  */\n\n      if (200 < c && big_snake && ctxt->heuristic)\n        {\n          {\n            OFFSET best = 0;\n\n            for (d = fmax; d >= fmin; d -= 2)\n              {\n                OFFSET dd = d - fmid;\n                OFFSET x = fd[d];\n                OFFSET y = x - d;\n                OFFSET v = (x - xoff) * 2 - dd;\n\n                if (v > 12 * (c + (dd < 0 ? -dd : dd)))\n                  {\n                    if (v > best\n                        && xoff + SNAKE_LIMIT <= x && x < xlim\n                        && yoff + SNAKE_LIMIT <= y && y < ylim)\n                      {\n                        /* We have a good enough best diagonal; now insist\n                           that it end with a significant snake.  */\n                        int k;\n\n                        for (k = 1; XREF_YREF_EQUAL (x - k, y - k); k++)\n                          if (k == SNAKE_LIMIT)\n                            {\n                              best = v;\n                              part->xmid = x;\n                              part->ymid = y;\n                              break;\n                            }\n                      }\n                  }\n              }\n            if (best > 0)\n              {\n                part->lo_minimal = true;\n                part->hi_minimal = false;\n                return;\n              }\n          }\n\n          {\n            OFFSET best = 0;\n\n            for (d = bmax; d >= bmin; d -= 2)\n              {\n                OFFSET dd = d - bmid;\n                OFFSET x = bd[d];\n                OFFSET y = x - d;\n                OFFSET v = (xlim - x) * 2 + dd;\n\n                if (v > 12 * (c + (dd < 0 ? -dd : dd)))\n                  {\n                    if (v > best\n                        && xoff < x && x <= xlim - SNAKE_LIMIT\n                        && yoff < y && y <= ylim - SNAKE_LIMIT)\n                      {\n                        /* We have a good enough best diagonal; now insist\n                           that it end with a significant snake.  */\n                        int k;\n\n                        for (k = 0; XREF_YREF_EQUAL (x + k, y + k); k++)\n                          if (k == SNAKE_LIMIT - 1)\n                            {\n                              best = v;\n                              part->xmid = x;\n                              part->ymid = y;\n                              break;\n                            }\n                      }\n                  }\n              }\n            if (best > 0)\n              {\n                part->lo_minimal = false;\n                part->hi_minimal = true;\n                return;\n              }\n          }\n        }\n#endif /* USE_HEURISTIC */\n\n      /* Heuristic: if we've gone well beyond the call of duty, give up\n         and report halfway between our best results so far.  */\n      if (c >= ctxt->too_expensive)\n        {\n          OFFSET fxybest;\n          OFFSET fxbest IF_LINT (= 0);\n          OFFSET bxybest;\n          OFFSET bxbest IF_LINT (= 0);\n\n          /* Find forward diagonal that maximizes X + Y.  */\n          fxybest = -1;\n          for (d = fmax; d >= fmin; d -= 2)\n            {\n              OFFSET x = MIN (fd[d], xlim);\n              OFFSET y = x - d;\n              if (ylim < y)\n                {\n                  x = ylim + d;\n                  y = ylim;\n                }\n              if (fxybest < x + y)\n                {\n                  fxybest = x + y;\n                  fxbest = x;\n                }\n            }\n\n          /* Find backward diagonal that minimizes X + Y.  */\n          bxybest = OFFSET_MAX;\n          for (d = bmax; d >= bmin; d -= 2)\n            {\n              OFFSET x = MAX (xoff, bd[d]);\n              OFFSET y = x - d;\n              if (y < yoff)\n                {\n                  x = yoff + d;\n                  y = yoff;\n                }\n              if (x + y < bxybest)\n                {\n                  bxybest = x + y;\n                  bxbest = x;\n                }\n            }\n\n          /* Use the better of the two diagonals.  */\n          if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff))\n            {\n              part->xmid = fxbest;\n              part->ymid = fxybest - fxbest;\n              part->lo_minimal = true;\n              part->hi_minimal = false;\n            }\n          else\n            {\n              part->xmid = bxbest;\n              part->ymid = bxybest - bxbest;\n              part->lo_minimal = false;\n              part->hi_minimal = true;\n            }\n          return;\n        }\n    }\n  #undef XREF_YREF_EQUAL\n}"
}