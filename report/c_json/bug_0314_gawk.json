{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "core.UndefinedBinaryOperatorResult",
    "Message": "The result of the left shift is undefined because the left operand is negative",
    "Code_line": "\tstatic const time_t time_t_min = TYPE_MINIMUM(time_t);",
    "Code_function": "do_strftime(int nargs)\n{\n\tNODE *t1, *t2, *t3, *ret;\n\tstruct tm *tm;\n\ttime_t fclock;\n\tdouble clock_val;\n\tchar *bufp;\n\tsize_t buflen, bufsize;\n\tchar buf[BUFSIZ];\n\tconst char *format;\n\tint formatlen;\n\tint do_gmt;\n\tNODE *val = NULL;\n\tNODE *sub = NULL;\n\tstatic const time_t time_t_min = TYPE_MINIMUM(time_t);\n\tstatic const time_t time_t_max = TYPE_MAXIMUM(time_t);\n\n\t/* set defaults first */\n\tformat = def_strftime_format;\t/* traditional date format */\n\tformatlen = strlen(format);\n\t(void) time(& fclock);\t/* current time of day */\n\tdo_gmt = false;\n\n\tif (PROCINFO_node != NULL) {\n\t\tsub = make_string(\"strftime\", 8);\n\t\tval = in_array(PROCINFO_node, sub);\n\t\tunref(sub);\n\n\t\tif (val != NULL) {\n\t\t\tif (do_lint && (val->flags & STRING) == 0)\n\t\t\t\tlintwarn(_(\"strftime: format value in PROCINFO[\\\"strftime\\\"] has numeric type\"));\n\t\t\tval = force_string(val);\n\t\t\tformat = val->stptr;\n\t\t\tformatlen = val->stlen;\n\t\t}\n\t}\n\n\tt1 = t2 = t3 = NULL;\n\tif (nargs > 0) {\t/* have args */\n\t\tNODE *tmp;\n\n\t\tif (nargs == 3) {\n\t\t\tt3 = POP_SCALAR();\n\t\t\tif ((t3->flags & (NUMCUR|NUMBER)) != 0)\n\t\t\t\tdo_gmt = (t3->numbr != 0);\n\t\t\telse\n\t\t\t\tdo_gmt = (t3->stlen > 0);\n\t\t\tDEREF(t3);\n\t\t}\n\n\t\tif (nargs >= 2) {\n\t\t\tt2 = POP_SCALAR();\n\t\t\tif (do_lint && (t2->flags & (NUMCUR|NUMBER)) == 0)\n\t\t\t\tlintwarn(_(\"strftime: received non-numeric second argument\"));\n\t\t\t(void) force_number(t2);\n\t\t\tclock_val = get_number_d(t2);\n\t\t\tfclock = (time_t) clock_val;\n\t\t\t/*\n\t\t\t * Protect against negative value being assigned\n\t\t\t * to unsigned time_t.\n\t\t\t */\n\t\t\tif (clock_val < 0 && fclock > 0) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"strftime: second argument less than 0 or too big for time_t\"));\n\t\t\t\treturn make_string(\"\", 0);\n\t\t\t}\n\n\t\t\t/* And check that the value is in range */\n\t\t\tif (clock_val < time_t_min || clock_val > time_t_max) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"strftime: second argument out of range for time_t\"));\n\t\t\t\treturn make_string(\"\", 0);\n\t\t\t}\n\n\t\t\tDEREF(t2);\n\t\t}\n\n\t\ttmp = POP_SCALAR();\n\t\tif (do_lint && (tmp->flags & (STRING|STRCUR)) == 0)\n\t\t\tlintwarn(_(\"strftime: received non-string first argument\"));\n\n\t\tt1 = force_string(tmp);\n\t\tformat = t1->stptr;\n\t\tformatlen = t1->stlen;\n\t\tif (formatlen == 0) {\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"strftime: received empty format string\"));\n\t\t\tDEREF(t1);\n\t\t\treturn make_string(\"\", 0);\n\t\t}\n\t}\n\n\tif (do_gmt)\n\t\ttm = gmtime(& fclock);\n\telse\n\t\ttm = localtime(& fclock);\n\n\tif (tm == NULL)\n\t\treturn make_string(\"\", 0);\n\n\tbufp = buf;\n\tbufsize = sizeof(buf);\n\tfor (;;) {\n\t\t*bufp = '\\0';\n\t\tbuflen = strftime(bufp, bufsize, format, tm);\n\t\t/*\n\t\t * buflen can be zero EITHER because there's not enough\n\t\t * room in the string, or because the control command\n\t\t * goes to the empty string. Make a reasonable guess that\n\t\t * if the buffer is 1024 times bigger than the length of the\n\t\t * format string, it's not failing for lack of room.\n\t\t * Thanks to Paul Eggert for pointing out this issue.\n\t\t */\n\t\tif (buflen > 0 || bufsize >= 1024 * formatlen)\n\t\t\tbreak;\n\t\tbufsize *= 2;\n\t\tif (bufp == buf)\n\t\t\temalloc(bufp, char *, bufsize, \"do_strftime\");\n\t\telse\n\t\t\terealloc(bufp, char *, bufsize, \"do_strftime\");\n\t}\n\tret = make_string(bufp, buflen);\n\tif (bufp != buf)\n\t\tefree(bufp);\n\tif (t1)\n\t\tDEREF(t1);\n\treturn ret;\n}"
}