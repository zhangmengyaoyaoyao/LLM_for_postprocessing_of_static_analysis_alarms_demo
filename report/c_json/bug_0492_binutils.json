{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `link_order` last assigned on line 58 could be null and is dereferenced at line 62, column 2.",
    "Code_line": "\tlink_order->type = bfd_data_link_order;",
    "Code_function": "build_link_order (lang_statement_union_type *statement)\n{\n  switch (statement->header.type)\n    {\n    case lang_data_statement_enum:\n      {\n\tasection *output_section;\n\tstruct bfd_link_order *link_order;\n\tbfd_vma value;\n\tbfd_boolean big_endian = FALSE;\n\n\toutput_section = statement->data_statement.output_section;\n\tASSERT (output_section->owner == link_info.output_bfd);\n\n\tif (!((output_section->flags & SEC_HAS_CONTENTS) != 0\n\t      || ((output_section->flags & SEC_LOAD) != 0\n\t\t  && (output_section->flags & SEC_THREAD_LOCAL))))\n\t  break;\n\n\tlink_order = bfd_new_link_order (link_info.output_bfd, output_section);\n\tif (link_order == NULL)\n\t  einfo (_(\"%P%F: bfd_new_link_order failed\\n\"));\n\n\tlink_order->type = bfd_data_link_order;\n\tlink_order->offset = statement->data_statement.output_offset;\n\tlink_order->u.data.contents = (bfd_byte *) xmalloc (QUAD_SIZE);\n\n\tvalue = statement->data_statement.value;\n\n\t/* If the endianness of the output BFD is not known, then we\n\t   base the endianness of the data on the first input file.\n\t   By convention, the bfd_put routines for an unknown\n\t   endianness are big endian, so we must swap here if the\n\t   input file is little endian.  */\n\tif (bfd_big_endian (link_info.output_bfd))\n\t  big_endian = TRUE;\n\telse if (bfd_little_endian (link_info.output_bfd))\n\t  big_endian = FALSE;\n\telse\n\t  {\n\t    bfd_boolean swap;\n\n\t    swap = FALSE;\n\t    if (command_line.endian == ENDIAN_BIG)\n\t      big_endian = TRUE;\n\t    else if (command_line.endian == ENDIAN_LITTLE)\n\t      {\n\t\tbig_endian = FALSE;\n\t\tswap = TRUE;\n\t      }\n\t    else if (command_line.endian == ENDIAN_UNSET)\n\t      {\n\t\tbig_endian = TRUE;\n\t\t{\n\t\t  LANG_FOR_EACH_INPUT_STATEMENT (s)\n\t\t    {\n\t\t      if (s->the_bfd != NULL)\n\t\t\t{\n\t\t\t  if (bfd_little_endian (s->the_bfd))\n\t\t\t    {\n\t\t\t      big_endian = FALSE;\n\t\t\t      swap = TRUE;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      }\n\n\t    if (swap)\n\t      {\n\t\tbfd_byte buffer[8];\n\n\t\tswitch (statement->data_statement.type)\n\t\t  {\n\t\t  case QUAD:\n\t\t  case SQUAD:\n\t\t    if (sizeof (bfd_vma) >= QUAD_SIZE)\n\t\t      {\n\t\t\tbfd_putl64 (value, buffer);\n\t\t\tvalue = bfd_getb64 (buffer);\n\t\t\tbreak;\n\t\t      }\n\t\t    /* Fall through.  */\n\t\t  case LONG:\n\t\t    bfd_putl32 (value, buffer);\n\t\t    value = bfd_getb32 (buffer);\n\t\t    break;\n\t\t  case SHORT:\n\t\t    bfd_putl16 (value, buffer);\n\t\t    value = bfd_getb16 (buffer);\n\t\t    break;\n\t\t  case BYTE:\n\t\t    break;\n\t\t  default:\n\t\t    abort ();\n\t\t  }\n\t      }\n\t  }\n\n\tASSERT (output_section->owner == link_info.output_bfd);\n\tswitch (statement->data_statement.type)\n\t  {\n\t  case QUAD:\n\t  case SQUAD:\n\t    if (sizeof (bfd_vma) >= QUAD_SIZE)\n\t      bfd_put_64 (link_info.output_bfd, value,\n\t\t\t  link_order->u.data.contents);\n\t    else\n\t      {\n\t\tbfd_vma high;\n\n\t\tif (statement->data_statement.type == QUAD)\n\t\t  high = 0;\n\t\telse if ((value & 0x80000000) == 0)\n\t\t  high = 0;\n\t\telse\n\t\t  high = (bfd_vma) -1;\n\t\tbfd_put_32 (link_info.output_bfd, high,\n\t\t\t    (link_order->u.data.contents\n\t\t\t     + (big_endian ? 0 : 4)));\n\t\tbfd_put_32 (link_info.output_bfd, value,\n\t\t\t    (link_order->u.data.contents\n\t\t\t     + (big_endian ? 4 : 0)));\n\t      }\n\t    link_order->size = QUAD_SIZE;\n\t    break;\n\t  case LONG:\n\t    bfd_put_32 (link_info.output_bfd, value,\n\t\t\tlink_order->u.data.contents);\n\t    link_order->size = LONG_SIZE;\n\t    break;\n\t  case SHORT:\n\t    bfd_put_16 (link_info.output_bfd, value,\n\t\t\tlink_order->u.data.contents);\n\t    link_order->size = SHORT_SIZE;\n\t    break;\n\t  case BYTE:\n\t    bfd_put_8 (link_info.output_bfd, value,\n\t\t       link_order->u.data.contents);\n\t    link_order->size = BYTE_SIZE;\n\t    break;\n\t  default:\n\t    abort ();\n\t  }\n\tlink_order->u.data.size = link_order->size;\n      }\n      break;\n\n    case lang_reloc_statement_enum:\n      {\n\tlang_reloc_statement_type *rs;\n\tasection *output_section;\n\tstruct bfd_link_order *link_order;\n\n\trs = &statement->reloc_statement;\n\n\toutput_section = rs->output_section;\n\tASSERT (output_section->owner == link_info.output_bfd);\n\n\tif (!((output_section->flags & SEC_HAS_CONTENTS) != 0\n\t      || ((output_section->flags & SEC_LOAD) != 0\n\t\t  && (output_section->flags & SEC_THREAD_LOCAL))))\n\t  break;\n\n\tlink_order = bfd_new_link_order (link_info.output_bfd, output_section);\n\tif (link_order == NULL)\n\t  einfo (_(\"%P%F: bfd_new_link_order failed\\n\"));\n\n\tlink_order->offset = rs->output_offset;\n\tlink_order->size = bfd_get_reloc_size (rs->howto);\n\n\tlink_order->u.reloc.p = (struct bfd_link_order_reloc *)\n            xmalloc (sizeof (struct bfd_link_order_reloc));\n\n\tlink_order->u.reloc.p->reloc = rs->reloc;\n\tlink_order->u.reloc.p->addend = rs->addend_value;\n\n\tif (rs->name == NULL)\n\t  {\n\t    link_order->type = bfd_section_reloc_link_order;\n\t    if (rs->section->owner == link_info.output_bfd)\n\t      link_order->u.reloc.p->u.section = rs->section;\n\t    else\n\t      {\n\t\tlink_order->u.reloc.p->u.section = rs->section->output_section;\n\t\tlink_order->u.reloc.p->addend += rs->section->output_offset;\n\t      }\n\t  }\n\telse\n\t  {\n\t    link_order->type = bfd_symbol_reloc_link_order;\n\t    link_order->u.reloc.p->u.name = rs->name;\n\t  }\n      }\n      break;\n\n    case lang_input_section_enum:\n      {\n\t/* Create a new link_order in the output section with this\n\t   attached */\n\tasection *i = statement->input_section.section;\n\n\tif (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS\n\t    && (i->flags & SEC_EXCLUDE) == 0)\n\t  {\n\t    asection *output_section = i->output_section;\n\t    struct bfd_link_order *link_order;\n\n\t    ASSERT (output_section->owner == link_info.output_bfd);\n\n\t    if (!((output_section->flags & SEC_HAS_CONTENTS) != 0\n\t\t  || ((output_section->flags & SEC_LOAD) != 0\n\t\t      && (output_section->flags & SEC_THREAD_LOCAL))))\n\t      break;\n\n\t    link_order = bfd_new_link_order (link_info.output_bfd,\n\t\t\t\t\t     output_section);\n\n\t    if ((i->flags & SEC_NEVER_LOAD) != 0\n\t\t&& (i->flags & SEC_DEBUGGING) == 0)\n\t      {\n\t\t/* We've got a never load section inside one which is\n\t\t   going to be output, we'll change it into a fill.  */\n\t\tlink_order->type = bfd_data_link_order;\n\t\tlink_order->u.data.contents = (unsigned char *) \"\";\n\t\tlink_order->u.data.size = 1;\n\t      }\n\t    else\n\t      {\n\t\tlink_order->type = bfd_indirect_link_order;\n\t\tlink_order->u.indirect.section = i;\n\t\tASSERT (i->output_section == output_section);\n\t      }\n\t    link_order->size = i->size;\n\t    link_order->offset = i->output_offset;\n\t  }\n      }\n      break;\n\n    case lang_padding_statement_enum:\n      /* Make a new link_order with the right filler */\n      {\n\tasection *output_section;\n\tstruct bfd_link_order *link_order;\n\n\toutput_section = statement->padding_statement.output_section;\n\tASSERT (statement->padding_statement.output_section->owner\n\t\t== link_info.output_bfd);\n\n\tif (!((output_section->flags & SEC_HAS_CONTENTS) != 0\n\t      || ((output_section->flags & SEC_LOAD) != 0\n\t\t  && (output_section->flags & SEC_THREAD_LOCAL))))\n\t  break;\n\n\tlink_order = bfd_new_link_order (link_info.output_bfd,\n\t\t\t\t\t output_section);\n\tlink_order->type = bfd_data_link_order;\n\tlink_order->size = statement->padding_statement.size;\n\tlink_order->offset = statement->padding_statement.output_offset;\n\tlink_order->u.data.contents = statement->padding_statement.fill->data;\n\tlink_order->u.data.size = statement->padding_statement.fill->size;\n      }\n      break;\n\n    default:\n      /* All the other ones fall through */\n      break;\n    }\n}"
}