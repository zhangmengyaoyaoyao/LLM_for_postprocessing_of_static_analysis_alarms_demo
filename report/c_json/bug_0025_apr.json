{
    "project": "apr",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "threadproc/unix/proc.c",
    "message": "Offset: [-1, +oo] Size: [8192, +oo].",
    "warning_function_name": "apr_proc_create",
    "warning_line": "*ch = '\\0';",
    "warning_context": "\n        apr_signal(SIGCHLD, SIG_DFL); /* not sure if this is needed or not */\n\n        if (attr->currdir != NULL) {\n            if (chdir(attr->currdir) == -1) {\n                if (attr->errfn) {\n                    attr->errfn(pool, errno, \"change of working directory failed\");\n                }\n                _exit(-1);   /* We have big problems, the child should exit. */\n            }\n        }\n\n        /* Only try to switch if we are running as root */\n        if (attr->gid != -1 && !geteuid()) {\n            if (setgid(attr->gid)) {\n                if (attr->errfn) {\n                    attr->errfn(pool, errno, \"setting of group failed\");\n                }\n                _exit(-1);   /* We have big problems, the child should exit. */\n            }\n        }\n\n        if (attr->uid != -1 && !geteuid()) {\n            if (setuid(attr->uid)) {\n                if (attr->errfn) {\n                    attr->errfn(pool, errno, \"setting of user failed\");\n                }\n                _exit(-1);   /* We have big problems, the child should exit. */\n            }\n        }\n\n        if (limit_proc(attr) != APR_SUCCESS) {\n            if (attr->errfn) {\n                attr->errfn(pool, errno, \"setting of resource limits failed\");\n            }\n            _exit(-1);   /* We have big problems, the child should exit. */\n        }\n\n        if (attr->cmdtype == APR_SHELLCMD ||\n            attr->cmdtype == APR_SHELLCMD_ENV) {\n            int onearg_len = 0;\n            const char *newargs[4];\n\n            newargs[0] = SHELL_PATH;\n            newargs[1] = \"-c\";\n\n            i = 0;\n            while (args[i]) {\n                onearg_len += strlen(args[i]);\n                onearg_len++; /* for space delimiter */\n                i++;\n            }\n\n            switch(i) {\n            case 0:\n                /* bad parameters; we're doomed */\n                break;\n            case 1:\n                /* no args, or caller already built a single string from\n                 * progname and args\n                 */\n                newargs[2] = args[0];\n                break;\n            default:\n            {\n                char *ch, *onearg;\n                \n                ch = onearg = apr_palloc(pool, onearg_len);\n                i = 0;\n                while (args[i]) {\n                    size_t len = strlen(args[i]);\n\n                    memcpy(ch, args[i], len);\n                    ch += len;\n                    *ch = ' ';\n                    ++ch;\n                    ++i;\n                }\n                --ch; /* back up to trailing blank */\n                *ch = '\\0';\n                newargs[2] = onearg;\n            }\n            }\n\n            newargs[3] = NULL;\n\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n\n            if (attr->cmdtype == APR_SHELLCMD) {\n                execve(SHELL_PATH, (char * const *) newargs, (char * const *)env);\n            }\n            else {\n                execv(SHELL_PATH, (char * const *)newargs);\n            }\n        }\n        else if (attr->cmdtype == APR_PROGRAM) {\n            if (attr->detached) {\n                apr_proc_detach(APR_PROC_DETACH_DAEMONIZE);\n            }\n"
}