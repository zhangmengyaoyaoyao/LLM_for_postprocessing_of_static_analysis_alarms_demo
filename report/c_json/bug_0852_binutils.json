{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf.c",
    "message": "Offset added: [-20, 203] (â‡ [-100, 123] + 80) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "_bfd_elf_map_sections_to_segments",
    "warning_line": "m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);",
    "warning_context": "bfd_boolean\n_bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n{\n  unsigned int count;\n  struct elf_segment_map *m;\n  asection **sections = NULL;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  bfd_boolean no_user_phdrs;\n\n  no_user_phdrs = elf_seg_map (abfd) == NULL;\n\n  if (info != NULL)\n    info->user_phdrs = !no_user_phdrs;\n\n  if (no_user_phdrs && bfd_count_sections (abfd) != 0)\n    {\n      asection *s;\n      unsigned int i;\n      struct elf_segment_map *mfirst;\n      struct elf_segment_map **pm;\n      asection *last_hdr;\n      bfd_vma last_size;\n      unsigned int phdr_index;\n      bfd_vma maxpagesize;\n      asection **hdrpp;\n      bfd_boolean phdr_in_segment = TRUE;\n      bfd_boolean writable;\n      int tls_count = 0;\n      asection *first_tls = NULL;\n      asection *dynsec, *eh_frame_hdr;\n      bfd_size_type amt;\n      bfd_vma addr_mask, wrap_to = 0;\n\n      /* Select the allocated sections, and sort them.  */\n\n      sections = (asection **) bfd_malloc2 (bfd_count_sections (abfd),\n                                            sizeof (asection *));\n      if (sections == NULL)\n\tgoto error_return;\n\n      /* Calculate top address, avoiding undefined behaviour of shift\n\t left operator when shift count is equal to size of type\n\t being shifted.  */\n      addr_mask = ((bfd_vma) 1 << (bfd_arch_bits_per_address (abfd) - 1)) - 1;\n      addr_mask = (addr_mask << 1) + 1;\n\n      i = 0;\n      for (s = abfd->sections; s != NULL; s = s->next)\n\t{\n\t  if ((s->flags & SEC_ALLOC) != 0)\n\t    {\n\t      sections[i] = s;\n\t      ++i;\n\t      /* A wrapping section potentially clashes with header.  */\n\t      if (((s->lma + s->size) & addr_mask) < (s->lma & addr_mask))\n\t\twrap_to = (s->lma + s->size) & addr_mask;\n\t    }\n\t}\n      BFD_ASSERT (i <= bfd_count_sections (abfd));\n      count = i;\n\n      qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);\n\n      /* Build the mapping.  */\n\n      mfirst = NULL;\n      pm = &mfirst;\n\n      /* If we have a .interp section, then create a PT_PHDR segment for\n\t the program headers and a PT_INTERP segment for the .interp\n\t section.  */\n      s = bfd_get_section_by_name (abfd, \".interp\");\n      if (s != NULL && (s->flags & SEC_LOAD) != 0)\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_PHDR;\n\t  /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */\n\t  m->p_flags = PF_R | PF_X;\n\t  m->p_flags_valid = 1;\n\t  m->includes_phdrs = 1;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_INTERP;\n\t  m->count = 1;\n\t  m->sections[0] = s;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n"
}