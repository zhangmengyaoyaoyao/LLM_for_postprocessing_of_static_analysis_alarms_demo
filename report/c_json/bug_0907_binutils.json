{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from mnem_p was never initialized.",
    "Code_line": "      else if (mnem_p - 4 == dot_p",
    "Code_function": "parse_insn (char *line, char *mnemonic)\n{\n  char *l = line;\n  char *token_start = l;\n  char *mnem_p;\n  int supported;\n  const insn_template *t;\n  char *dot_p = NULL;\n\n  while (1)\n    {\n      mnem_p = mnemonic;\n      while ((*mnem_p = mnemonic_chars[(unsigned char) *l]) != 0)\n\t{\n\t  if (*mnem_p == '.')\n\t    dot_p = mnem_p;\n\t  mnem_p++;\n\t  if (mnem_p >= mnemonic + MAX_MNEM_SIZE)\n\t    {\n\t      as_bad (_(\"no such instruction: `%s'\"), token_start);\n\t      return NULL;\n\t    }\n\t  l++;\n\t}\n      if (!is_space_char (*l)\n\t  && *l != END_OF_INSN\n\t  && (intel_syntax\n\t      || (*l != PREFIX_SEPARATOR\n\t\t  && *l != ',')))\n\t{\n\t  as_bad (_(\"invalid character %s in mnemonic\"),\n\t\t  output_invalid (*l));\n\t  return NULL;\n\t}\n      if (token_start == l)\n\t{\n\t  if (!intel_syntax && *l == PREFIX_SEPARATOR)\n\t    as_bad (_(\"expecting prefix; got nothing\"));\n\t  else\n\t    as_bad (_(\"expecting mnemonic; got nothing\"));\n\t  return NULL;\n\t}\n\n      /* Look up instruction (or prefix) via hash table.  */\n      current_templates = (const templates *) hash_find (op_hash, mnemonic);\n\n      if (*l != END_OF_INSN\n\t  && (!is_space_char (*l) || l[1] != END_OF_INSN)\n\t  && current_templates\n\t  && current_templates->start->opcode_modifier.isprefix)\n\t{\n\t  if (!cpu_flags_check_cpu64 (current_templates->start->cpu_flags))\n\t    {\n\t      as_bad ((flag_code != CODE_64BIT\n\t\t       ? _(\"`%s' is only supported in 64-bit mode\")\n\t\t       : _(\"`%s' is not supported in 64-bit mode\")),\n\t\t      current_templates->start->name);\n\t      return NULL;\n\t    }\n\t  /* If we are in 16-bit mode, do not allow addr16 or data16.\n\t     Similarly, in 32-bit mode, do not allow addr32 or data32.  */\n\t  if ((current_templates->start->opcode_modifier.size16\n\t       || current_templates->start->opcode_modifier.size32)\n\t      && flag_code != CODE_64BIT\n\t      && (current_templates->start->opcode_modifier.size32\n\t\t  ^ (flag_code == CODE_16BIT)))\n\t    {\n\t      as_bad (_(\"redundant %s prefix\"),\n\t\t      current_templates->start->name);\n\t      return NULL;\n\t    }\n\t  /* Add prefix, checking for repeated prefixes.  */\n\t  switch (add_prefix (current_templates->start->base_opcode))\n\t    {\n\t    case PREFIX_EXIST:\n\t      return NULL;\n\t    case PREFIX_REP:\n\t      if (current_templates->start->cpu_flags.bitfield.cpuhle)\n\t\ti.hle_prefix = current_templates->start->name;\n\t      else if (current_templates->start->cpu_flags.bitfield.cpumpx)\n\t\ti.bnd_prefix = current_templates->start->name;\n\t      else\n\t\ti.rep_prefix = current_templates->start->name;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t  /* Skip past PREFIX_SEPARATOR and reset token_start.  */\n\t  token_start = ++l;\n\t}\n      else\n\tbreak;\n    }\n\n  if (!current_templates)\n    {\n      /* Check if we should swap operand or force 32bit displacement in\n\t encoding.  */\n      if (mnem_p - 2 == dot_p && dot_p[1] == 's')\n\ti.swap_operand = 1;\n      else if (mnem_p - 3 == dot_p\n\t       && dot_p[1] == 'd'\n\t       && dot_p[2] == '8')\n\ti.disp_encoding = disp_encoding_8bit;\n      else if (mnem_p - 4 == dot_p\n\t       && dot_p[1] == 'd'\n\t       && dot_p[2] == '3'\n\t       && dot_p[3] == '2')\n\ti.disp_encoding = disp_encoding_32bit;\n      else\n\tgoto check_suffix;\n      mnem_p = dot_p;\n      *dot_p = '\\0';\n      current_templates = (const templates *) hash_find (op_hash, mnemonic);\n    }\n\n  if (!current_templates)\n    {\ncheck_suffix:\n      /* See if we can get a match by trimming off a suffix.  */\n      switch (mnem_p[-1])\n\t{\n\tcase WORD_MNEM_SUFFIX:\n\t  if (intel_syntax && (intel_float_operand (mnemonic) & 2))\n\t    i.suffix = SHORT_MNEM_SUFFIX;\n\t  else\n\tcase BYTE_MNEM_SUFFIX:\n\tcase QWORD_MNEM_SUFFIX:\n\t  i.suffix = mnem_p[-1];\n\t  mnem_p[-1] = '\\0';\n\t  current_templates = (const templates *) hash_find (op_hash,\n                                                             mnemonic);\n\t  break;\n\tcase SHORT_MNEM_SUFFIX:\n\tcase LONG_MNEM_SUFFIX:\n\t  if (!intel_syntax)\n\t    {\n\t      i.suffix = mnem_p[-1];\n\t      mnem_p[-1] = '\\0';\n\t      current_templates = (const templates *) hash_find (op_hash,\n                                                                 mnemonic);\n\t    }\n\t  break;\n\n\t  /* Intel Syntax.  */\n\tcase 'd':\n\t  if (intel_syntax)\n\t    {\n\t      if (intel_float_operand (mnemonic) == 1)\n\t\ti.suffix = SHORT_MNEM_SUFFIX;\n\t      else\n\t\ti.suffix = LONG_MNEM_SUFFIX;\n\t      mnem_p[-1] = '\\0';\n\t      current_templates = (const templates *) hash_find (op_hash,\n                                                                 mnemonic);\n\t    }\n\t  break;\n\t}\n      if (!current_templates)\n\t{\n\t  as_bad (_(\"no such instruction: `%s'\"), token_start);\n\t  return NULL;\n\t}\n    }\n\n  if (current_templates->start->opcode_modifier.jump\n      || current_templates->start->opcode_modifier.jumpbyte)\n    {\n      /* Check for a branch hint.  We allow \",pt\" and \",pn\" for\n\t predict taken and predict not taken respectively.\n\t I'm not sure that branch hints actually do anything on loop\n\t and jcxz insns (JumpByte) for current Pentium4 chips.  They\n\t may work in the future and it doesn't hurt to accept them\n\t now.  */\n      if (l[0] == ',' && l[1] == 'p')\n\t{\n\t  if (l[2] == 't')\n\t    {\n\t      if (!add_prefix (DS_PREFIX_OPCODE))\n\t\treturn NULL;\n\t      l += 3;\n\t    }\n\t  else if (l[2] == 'n')\n\t    {\n\t      if (!add_prefix (CS_PREFIX_OPCODE))\n\t\treturn NULL;\n\t      l += 3;\n\t    }\n\t}\n    }\n  /* Any other comma loses.  */\n  if (*l == ',')\n    {\n      as_bad (_(\"invalid character %s in mnemonic\"),\n\t      output_invalid (*l));\n      return NULL;\n    }\n\n  /* Check if instruction is supported on specified architecture.  */\n  supported = 0;\n  for (t = current_templates->start; t < current_templates->end; ++t)\n    {\n      supported |= cpu_flags_match (t);\n      if (supported == CPU_FLAGS_PERFECT_MATCH)\n\tgoto skip;\n    }\n\n  if (!(supported & CPU_FLAGS_64BIT_MATCH))\n    {\n      as_bad (flag_code == CODE_64BIT\n\t      ? _(\"`%s' is not supported in 64-bit mode\")\n\t      : _(\"`%s' is only supported in 64-bit mode\"),\n\t      current_templates->start->name);\n      return NULL;\n    }\n  if (supported != CPU_FLAGS_PERFECT_MATCH)\n    {\n      as_bad (_(\"`%s' is not supported on `%s%s'\"),\n\t      current_templates->start->name,\n\t      cpu_arch_name ? cpu_arch_name : default_arch,\n\t      cpu_sub_arch_name ? cpu_sub_arch_name : \"\");\n      return NULL;\n    }\n\nskip:\n  if (!cpu_arch_flags.bitfield.cpui386\n\t   && (flag_code != CODE_16BIT))\n    {\n      as_warn (_(\"use .code16 to ensure correct addressing mode\"));\n    }\n\n  return l;\n}"
}