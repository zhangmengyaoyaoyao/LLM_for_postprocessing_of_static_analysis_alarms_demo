{
    "Project": "bash",
    "Tool": "Cppcheck",
    "category": "memleakOnRealloc",
    "file": "lib/intl/localcharset.c",
    "message": "Common realloc mistake: 'res_ptr' nulled but not freed upon failure",
    "warning_function_name": "get_charset_aliases",
    "warning_line": "res_ptr = (char *) realloc (res_ptr, res_size + 1);",
    "warning_context": "static const char *\nget_charset_aliases ()\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined VMS || defined WIN32)\n      FILE *fp;\n      const char *dir = relocate (LIBDIR);\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n\tsize_t dir_len = strlen (dir);\n\tsize_t base_len = strlen (base);\n\tint add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n\tfile_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n\tif (file_name != NULL)\n\t  {\n\t    memcpy (file_name, dir, dir_len);\n\t    if (add_slash)\n\t      file_name[dir_len] = DIRECTORY_SEPARATOR;\n\t    memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n\t  }\n      }\n\n      if (file_name == NULL || (fp = fopen (file_name, \"r\")) == NULL)\n\t/* Out of memory or file not found, treat it as empty.  */\n\tcp = \"\";\n      else\n\t{\n\t  /* Parse the file's contents.  */\n\t  int c;\n\t  char buf1[50+1];\n\t  char buf2[50+1];\n\t  char *res_ptr = NULL;\n\t  size_t res_size = 0;\n\t  size_t l1, l2;\n\n\t  for (;;)\n\t    {\n\t      c = getc (fp);\n\t      if (c == EOF)\n\t\tbreak;\n\t      if (c == '\\n' || c == ' ' || c == '\\t')\n\t\tcontinue;\n\t      if (c == '#')\n\t\t{\n\t\t  /* Skip comment, to end of line.  */\n\t\t  do\n\t\t    c = getc (fp);\n\t\t  while (!(c == EOF || c == '\\n'));\n\t\t  if (c == EOF)\n\t\t    break;\n\t\t  continue;\n\t\t}\n\t      ungetc (c, fp);\n\t      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n\t\tbreak;\n\t      l1 = strlen (buf1);\n\t      l2 = strlen (buf2);\n\t      if (res_size == 0)\n\t\t{\n\t\t  res_size = l1 + 1 + l2 + 1;\n\t\t  res_ptr = (char *) malloc (res_size + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  res_size += l1 + 1 + l2 + 1;\n\t\t  res_ptr = (char *) realloc (res_ptr, res_size + 1);\n\t\t}\n\t      if (res_ptr == NULL)\n\t\t{\n\t\t  /* Out of memory. */\n\t\t  res_size = 0;\n\t\t  break;\n\t\t}\n\t      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n\t      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n\t    }\n\t  fclose (fp);\n\t  if (res_size == 0)\n\t    cp = \"\";\n\t  else\n\t    {\n\t      *(res_ptr + res_size) = '\\0';\n\t      cp = res_ptr;\n\t    }\n\t}\n\n      if (file_name != NULL)\n\tfree (file_name);\n\n#else\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n\t sources of many GNU packages, simply inline the aliases here.  */\n"
}