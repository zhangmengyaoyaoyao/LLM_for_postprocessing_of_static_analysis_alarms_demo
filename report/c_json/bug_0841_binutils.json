{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "gas/config/tc-i386.c",
    "message": "Offset: [-1, 18] (‚áê [0, 19] + -1) Size: 20 by call to `parse_insn`.",
    "warning_function_name": "md_assemble",
    "warning_line": "line = parse_insn (line, mnemonic);",
    "warning_context": "void\nmd_assemble (char *line)\n{\n  unsigned int j;\n  char mnemonic[MAX_MNEM_SIZE];\n  const insn_template *t;\n\n  /* Initialize globals.  */\n  memset (&i, '\\0', sizeof (i));\n  for (j = 0; j < MAX_OPERANDS; j++)\n    i.reloc[j] = NO_RELOC;\n  memset (disp_expressions, '\\0', sizeof (disp_expressions));\n  memset (im_expressions, '\\0', sizeof (im_expressions));\n  save_stack_p = save_stack;\n\n  /* First parse an instruction mnemonic & call i386_operand for the operands.\n     We assume that the scrubber has arranged it so that line[0] is the valid\n     start of a (possibly prefixed) mnemonic.  */\n\n  line = parse_insn (line, mnemonic);\n  if (line == NULL)\n    return;\n\n  line = parse_operands (line, mnemonic);\n  this_operand = -1;\n  if (line == NULL)\n    return;\n\n  /* Now we've parsed the mnemonic into a set of templates, and have the\n     operands at hand.  */\n\n  /* All intel opcodes have reversed operands except for \"bound\" and\n     \"enter\".  We also don't reverse intersegment \"jmp\" and \"call\"\n     instructions with 2 immediate operands so that the immediate segment\n     precedes the offset, as it does when in AT&T mode. */\n  if (intel_syntax\n      && i.operands > 1\n      && (strcmp (mnemonic, \"bound\") != 0)\n      && (strcmp (mnemonic, \"invlpga\") != 0)\n      && !(operand_type_check (i.types[0], imm)\n\t   && operand_type_check (i.types[1], imm)))\n    swap_operands ();\n\n  /* The order of the immediates should be reversed\n     for 2 immediates extrq and insertq instructions */\n  if (i.imm_operands == 2\n      && (strcmp (mnemonic, \"extrq\") == 0\n\t  || strcmp (mnemonic, \"insertq\") == 0))\n      swap_2_operands (0, 1);\n\n  if (i.imm_operands)\n    optimize_imm ();\n\n  /* Don't optimize displacement for movabs since it only takes 64bit\n     displacement.  */\n  if (i.disp_operands\n      && i.disp_encoding != disp_encoding_32bit\n      && (flag_code != CODE_64BIT\n\t  || strcmp (mnemonic, \"movabs\") != 0))\n    optimize_disp ();\n\n  /* Next, we find a template that matches the given insn,\n     making sure the overlap of the given operands types is consistent\n     with the template operand types.  */\n\n  if (!(t = match_template ()))\n    return;\n\n  if (sse_check != check_none\n      && !i.tm.opcode_modifier.noavx\n      && (i.tm.cpu_flags.bitfield.cpusse\n\t  || i.tm.cpu_flags.bitfield.cpusse2\n\t  || i.tm.cpu_flags.bitfield.cpusse3\n\t  || i.tm.cpu_flags.bitfield.cpussse3\n\t  || i.tm.cpu_flags.bitfield.cpusse4_1\n\t  || i.tm.cpu_flags.bitfield.cpusse4_2))\n    {\n      (sse_check == check_warning\n       ? as_warn\n       : as_bad) (_(\"SSE instruction `%s' is used\"), i.tm.name);\n    }\n\n  /* Zap movzx and movsx suffix.  The suffix has been set from\n     \"word ptr\" or \"byte ptr\" on the source operand in Intel syntax\n     or extracted from mnemonic in AT&T syntax.  But we'll use\n     the destination register to choose the suffix for encoding.  */\n  if ((i.tm.base_opcode & ~9) == 0x0fb6)\n    {\n      /* In Intel syntax, there must be a suffix.  In AT&T syntax, if\n\t there is no suffix, the default will be byte extension.  */\n      if (i.reg_operands != 2\n\t  && !i.suffix\n\t  && intel_syntax)\n\tas_bad (_(\"ambiguous operand size for `%s'\"), i.tm.name);\n\n      i.suffix = 0;\n    }\n\n  if (i.tm.opcode_modifier.fwait)\n    if (!add_prefix (FWAIT_OPCODE))\n      return;\n"
}