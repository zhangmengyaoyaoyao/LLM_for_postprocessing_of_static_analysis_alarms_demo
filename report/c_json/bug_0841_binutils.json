{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from seg_left was never initialized.",
    "Code_line": "      else if (seg_left == reg_section && final_val == 0)",
    "Code_function": "resolve_expression (expressionS *expressionP)\n{\n  /* Help out with CSE.  */\n  valueT final_val = expressionP->X_add_number;\n  symbolS *add_symbol = expressionP->X_add_symbol;\n  symbolS *orig_add_symbol = add_symbol;\n  symbolS *op_symbol = expressionP->X_op_symbol;\n  operatorT op = expressionP->X_op;\n  valueT left, right;\n  segT seg_left, seg_right;\n  fragS *frag_left, *frag_right;\n  offsetT frag_off;\n\n  switch (op)\n    {\n    default:\n      return 0;\n\n    case O_constant:\n    case O_register:\n      left = 0;\n      break;\n\n    case O_symbol:\n    case O_symbol_rva:\n      if (!snapshot_symbol (&add_symbol, &left, &seg_left, &frag_left))\n\treturn 0;\n\n      break;\n\n    case O_uminus:\n    case O_bit_not:\n    case O_logical_not:\n      if (!snapshot_symbol (&add_symbol, &left, &seg_left, &frag_left))\n\treturn 0;\n\n      if (seg_left != absolute_section)\n\treturn 0;\n\n      if (op == O_logical_not)\n\tleft = !left;\n      else if (op == O_uminus)\n\tleft = -left;\n      else\n\tleft = ~left;\n      op = O_constant;\n      break;\n\n    case O_multiply:\n    case O_divide:\n    case O_modulus:\n    case O_left_shift:\n    case O_right_shift:\n    case O_bit_inclusive_or:\n    case O_bit_or_not:\n    case O_bit_exclusive_or:\n    case O_bit_and:\n    case O_add:\n    case O_subtract:\n    case O_eq:\n    case O_ne:\n    case O_lt:\n    case O_le:\n    case O_ge:\n    case O_gt:\n    case O_logical_and:\n    case O_logical_or:\n      if (!snapshot_symbol (&add_symbol, &left, &seg_left, &frag_left)\n\t  || !snapshot_symbol (&op_symbol, &right, &seg_right, &frag_right))\n\treturn 0;\n\n      /* Simplify addition or subtraction of a constant by folding the\n\t constant into X_add_number.  */\n      if (op == O_add)\n\t{\n\t  if (seg_right == absolute_section)\n\t    {\n\t      final_val += right;\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t  else if (seg_left == absolute_section)\n\t    {\n\t      final_val += left;\n\t      left = right;\n\t      seg_left = seg_right;\n\t      add_symbol = op_symbol;\n\t      orig_add_symbol = expressionP->X_op_symbol;\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t}\n      else if (op == O_subtract)\n\t{\n\t  if (seg_right == absolute_section)\n\t    {\n\t      final_val -= right;\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t}\n\n      /* Equality and non-equality tests are permitted on anything.\n\t Subtraction, and other comparison operators are permitted if\n\t both operands are in the same section.\n\t Shifts by constant zero are permitted on anything.\n\t Multiplies, bit-ors, and bit-ands with constant zero are\n\t permitted on anything.\n\t Multiplies and divides by constant one are permitted on\n\t anything.\n\t Binary operations with both operands being the same register\n\t or undefined symbol are permitted if the result doesn't depend\n\t on the input value.\n\t Otherwise, both operands must be absolute.  We already handled\n\t the case of addition or subtraction of a constant above.  */\n      frag_off = 0;\n      if (!(seg_left == absolute_section\n\t       && seg_right == absolute_section)\n\t  && !(op == O_eq || op == O_ne)\n\t  && !((op == O_subtract\n\t\t|| op == O_lt || op == O_le || op == O_ge || op == O_gt)\n\t       && seg_left == seg_right\n\t       && (finalize_syms\n\t\t   || frag_offset_fixed_p (frag_left, frag_right, &frag_off))\n\t       && (seg_left != reg_section || left == right)\n\t       && (seg_left != undefined_section || add_symbol == op_symbol)))\n\t{\n\t  if ((seg_left == absolute_section && left == 0)\n\t      || (seg_right == absolute_section && right == 0))\n\t    {\n\t      if (op == O_bit_exclusive_or || op == O_bit_inclusive_or)\n\t\t{\n\t\t  if (!(seg_right == absolute_section && right == 0))\n\t\t    {\n\t\t      seg_left = seg_right;\n\t\t      left = right;\n\t\t      add_symbol = op_symbol;\n\t\t      orig_add_symbol = expressionP->X_op_symbol;\n\t\t    }\n\t\t  op = O_symbol;\n\t\t  break;\n\t\t}\n\t      else if (op == O_left_shift || op == O_right_shift)\n\t\t{\n\t\t  if (!(seg_left == absolute_section && left == 0))\n\t\t    {\n\t\t      op = O_symbol;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else if (op != O_multiply\n\t\t       && op != O_bit_or_not && op != O_bit_and)\n\t        return 0;\n\t    }\n\t  else if (op == O_multiply\n\t\t   && seg_left == absolute_section && left == 1)\n\t    {\n\t      seg_left = seg_right;\n\t      left = right;\n\t      add_symbol = op_symbol;\n\t      orig_add_symbol = expressionP->X_op_symbol;\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t  else if ((op == O_multiply || op == O_divide)\n\t\t   && seg_right == absolute_section && right == 1)\n\t    {\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t  else if (!(left == right\n\t\t     && ((seg_left == reg_section && seg_right == reg_section)\n\t\t\t || (seg_left == undefined_section\n\t\t\t     && seg_right == undefined_section\n\t\t\t     && add_symbol == op_symbol))))\n\t    return 0;\n\t  else if (op == O_bit_and || op == O_bit_inclusive_or)\n\t    {\n\t      op = O_symbol;\n\t      break;\n\t    }\n\t  else if (op != O_bit_exclusive_or && op != O_bit_or_not)\n\t    return 0;\n\t}\n\n      right += frag_off / OCTETS_PER_BYTE;\n      switch (op)\n\t{\n\tcase O_add:\t\t\tleft += right; break;\n\tcase O_subtract:\t\tleft -= right; break;\n\tcase O_multiply:\t\tleft *= right; break;\n\tcase O_divide:\n\t  if (right == 0)\n\t    return 0;\n\t  left = (offsetT) left / (offsetT) right;\n\t  break;\n\tcase O_modulus:\n\t  if (right == 0)\n\t    return 0;\n\t  left = (offsetT) left % (offsetT) right;\n\t  break;\n\tcase O_left_shift:\t\tleft <<= right; break;\n\tcase O_right_shift:\t\tleft >>= right; break;\n\tcase O_bit_inclusive_or:\tleft |= right; break;\n\tcase O_bit_or_not:\t\tleft |= ~right; break;\n\tcase O_bit_exclusive_or:\tleft ^= right; break;\n\tcase O_bit_and:\t\t\tleft &= right; break;\n\tcase O_eq:\n\tcase O_ne:\n\t  left = (left == right\n\t\t  && seg_left == seg_right\n\t\t  && (finalize_syms || frag_left == frag_right)\n\t\t  && (seg_left != undefined_section\n\t\t      || add_symbol == op_symbol)\n\t\t  ? ~ (valueT) 0 : 0);\n\t  if (op == O_ne)\n\t    left = ~left;\n\t  break;\n\tcase O_lt:\n\t  left = (offsetT) left <  (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_le:\n\t  left = (offsetT) left <= (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_ge:\n\t  left = (offsetT) left >= (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_gt:\n\t  left = (offsetT) left >  (offsetT) right ? ~ (valueT) 0 : 0;\n\t  break;\n\tcase O_logical_and:\tleft = left && right; break;\n\tcase O_logical_or:\tleft = left || right; break;\n\tdefault:\t\tabort ();\n\t}\n\n      op = O_constant;\n      break;\n    }\n\n  if (op == O_symbol)\n    {\n      if (seg_left == absolute_section)\n\top = O_constant;\n      else if (seg_left == reg_section && final_val == 0)\n\top = O_register;\n      else if (!symbol_same_p (add_symbol, orig_add_symbol))\n\tfinal_val += left;\n      expressionP->X_add_symbol = add_symbol;\n    }\n  expressionP->X_op = op;\n\n  if (op == O_constant || op == O_register)\n    final_val += left;\n  expressionP->X_add_number = final_val;\n\n  return 1;\n}"
}