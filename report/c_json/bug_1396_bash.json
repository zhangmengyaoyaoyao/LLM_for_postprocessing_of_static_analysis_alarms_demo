{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: [-oo, -1] Size: 1 by call to `make_word`.",
    "Code_line": "\t  tl = make_word_list (make_word (\"\"), ret->next);",
    "Code_function": "split_at_delims (string, slen, delims, sentinel, flags, nwp, cwp)\n     char *string;\n     int slen;\n     char *delims;\n     int sentinel, flags;\n     int *nwp, *cwp;\n{\n  int ts, te, i, nw, cw, ifs_split, dflags;\n  char *token, *d, *d2;\n  WORD_LIST *ret, *tl;\n\n  if (string == 0 || *string == '\\0')\n    {\n      if (nwp)\n\t*nwp = 0;\n      if (cwp)\n\t*cwp = 0;\n      return ((WORD_LIST *)NULL);\n    }\n\n  d = (delims == 0) ? ifs_value : delims;\n  ifs_split = delims == 0;\n\n  /* Make d2 the non-whitespace characters in delims */\n  d2 = 0;\n  if (delims)\n    {\n      size_t slength;\n#if defined (HANDLE_MULTIBYTE)\n      size_t mblength = 1;\n#endif\n      DECLARE_MBSTATE;\n\n      slength = strlen (delims);\n      d2 = (char *)xmalloc (slength + 1);\n      i = ts = 0;\n      while (delims[i])\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  mbstate_t state_bak;\n\t  state_bak = state;\n\t  mblength = MBRLEN (delims + i, slength, &state);\n\t  if (MB_INVALIDCH (mblength))\n\t    state = state_bak;\n\t  else if (mblength > 1)\n\t    {\n\t      memcpy (d2 + ts, delims + i, mblength);\n\t      ts += mblength;\n\t      i += mblength;\n\t      slength -= mblength;\n\t      continue;\n\t    }\n#endif\n\t  if (whitespace (delims[i]) == 0)\n\t    d2[ts++] = delims[i];\n\n\t  i++;\n\t  slength--;\n\t}\n      d2[ts] = '\\0';\n    }\n\n  ret = (WORD_LIST *)NULL;\n\n  /* Remove sequences of whitespace characters at the start of the string, as\n     long as those characters are delimiters. */\n  for (i = 0; member (string[i], d) && spctabnl (string[i]); i++)\n    ;\n  if (string[i] == '\\0')\n    return (ret);\n\n  ts = i;\n  nw = 0;\n  cw = -1;\n  dflags = flags|SD_NOJMP;\n  while (1)\n    {\n      te = skip_to_delim (string, ts, d, dflags);\n\n      /* If we have a non-whitespace delimiter character, use it to make a\n\t separate field.  This is just about what $IFS splitting does and\n\t is closer to the behavior of the shell parser. */\n      if (ts == te && d2 && member (string[ts], d2))\n\t{\n\t  te = ts + 1;\n\t  /* If we're using IFS splitting, the non-whitespace delimiter char\n\t     and any additional IFS whitespace delimits a field. */\n\t  if (ifs_split)\n\t    while (member (string[te], d) && spctabnl (string[te]))\n\t      te++;\n\t  else\n\t    while (member (string[te], d2))\n\t      te++;\n\t}\n\n      token = substring (string, ts, te);\n\n      ret = add_string_to_list (token, ret);\n      free (token);\n      nw++;\n\n      if (sentinel >= ts && sentinel <= te)\n\tcw = nw;\n\n      /* If the cursor is at whitespace just before word start, set the\n\t sentinel word to the current word. */\n      if (cwp && cw == -1 && sentinel == ts-1)\n\tcw = nw;\n\n      /* If the cursor is at whitespace between two words, make a new, empty\n\t word, add it before (well, after, since the list is in reverse order)\n\t the word we just added, and set the current word to that one. */\n      if (cwp && cw == -1 && sentinel < ts)\n\t{\n\t  tl = make_word_list (make_word (\"\"), ret->next);\n\t  ret->next = tl;\n\t  cw = nw;\n\t  nw++;\n\t}\n\n      if (string[te] == 0)\n\tbreak;\n\n      i = te;\n      while (member (string[i], d) && (ifs_split || spctabnl(string[i])))\n\ti++;\n\n      if (string[i])\n\tts = i;\n      else\n\tbreak;\n    }\n\n  /* Special case for SENTINEL at the end of STRING.  If we haven't found\n     the word containing SENTINEL yet, and the index we're looking for is at\n     the end of STRING (or past the end of the previously-found token,\n     possible if the end of the line is composed solely of IFS whitespace)\n     add an additional null argument and set the current word pointer to that. */\n  if (cwp && cw == -1 && (sentinel >= slen || sentinel >= te))\n    {\n      if (whitespace (string[sentinel - 1]))\n\t{\n\t  token = \"\";\n\t  ret = add_string_to_list (token, ret);\n\t  nw++;\n\t}\n      cw = nw;\n    }\n\n  if (nwp)\n    *nwp = nw;\n  if (cwp)\n    *cwp = cw;\n\n  FREE (d2);\n\n  return (REVERSE_LIST (ret, WORD_LIST *));\n}"
}