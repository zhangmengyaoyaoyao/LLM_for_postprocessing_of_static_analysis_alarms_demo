{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Code_line": "\t      debug_info_p->range_lists [num] = uvalue;",
    "Code_function": "read_and_display_attr_value (unsigned long attribute,\n\t\t\t     unsigned long form,\n\t\t\t     unsigned char * data,\n\t\t\t     unsigned char * end,\n\t\t\t     dwarf_vma cu_offset,\n\t\t\t     dwarf_vma pointer_size,\n\t\t\t     dwarf_vma offset_size,\n\t\t\t     int dwarf_version,\n\t\t\t     debug_info * debug_info_p,\n\t\t\t     int do_loc,\n\t\t\t     struct dwarf_section * section,\n\t\t\t     struct cu_tu_set * this_set)\n{\n  dwarf_vma uvalue = 0;\n  unsigned char *block_start = NULL;\n  unsigned char * orig_data = data;\n  unsigned int bytes_read;\n\n  if (data > end || (data == end && form != DW_FORM_flag_present))\n    {\n      warn (_(\"Corrupt attribute\\n\"));\n      return data;\n    }\n\n  switch (form)\n    {\n    default:\n      break;\n\n    case DW_FORM_ref_addr:\n      if (dwarf_version == 2)\n\tSAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);\n      else if (dwarf_version == 3 || dwarf_version == 4)\n\tSAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);\n      else\n\terror (_(\"Internal error: DWARF version is not 2, 3 or 4.\\n\"));\n\n      break;\n\n    case DW_FORM_addr:\n      SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);\n      break;\n\n    case DW_FORM_strp:\n    case DW_FORM_sec_offset:\n    case DW_FORM_GNU_ref_alt:\n    case DW_FORM_GNU_strp_alt:\n      SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);\n      break;\n\n    case DW_FORM_flag_present:\n      uvalue = 1;\n      break;\n\n    case DW_FORM_ref1:\n    case DW_FORM_flag:\n    case DW_FORM_data1:\n      SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);\n      break;\n\n    case DW_FORM_ref2:\n    case DW_FORM_data2:\n      SAFE_BYTE_GET_AND_INC (uvalue, data, 2, end);\n      break;\n\n    case DW_FORM_ref4:\n    case DW_FORM_data4:\n      SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);\n      break;\n\n    case DW_FORM_sdata:\n      uvalue = read_sleb128 (data, & bytes_read, end);\n      data += bytes_read;\n      break;\n\n    case DW_FORM_GNU_str_index:\n      uvalue = read_uleb128 (data, & bytes_read, end);\n      data += bytes_read;\n      break;\n\n    case DW_FORM_ref_udata:\n    case DW_FORM_udata:\n      uvalue = read_uleb128 (data, & bytes_read, end);\n      data += bytes_read;\n      break;\n\n    case DW_FORM_indirect:\n      form = read_uleb128 (data, & bytes_read, end);\n      data += bytes_read;\n      if (!do_loc)\n\tprintf (\" %s\", get_FORM_name (form));\n      return read_and_display_attr_value (attribute, form, data, end,\n\t\t\t\t\t  cu_offset, pointer_size,\n\t\t\t\t\t  offset_size, dwarf_version,\n\t\t\t\t\t  debug_info_p, do_loc,\n\t\t\t\t\t  section, this_set);\n    case DW_FORM_GNU_addr_index:\n      uvalue = read_uleb128 (data, & bytes_read, end);\n      data += bytes_read;\n      break;\n    }\n\n  switch (form)\n    {\n    case DW_FORM_ref_addr:\n      if (!do_loc)\n\tprintf (\" <0x%s>\", dwarf_vmatoa (\"x\",uvalue));\n      break;\n\n    case DW_FORM_GNU_ref_alt:\n      if (!do_loc)\n\tprintf (\" <alt 0x%s>\", dwarf_vmatoa (\"x\",uvalue));\n      break;\n\n    case DW_FORM_ref1:\n    case DW_FORM_ref2:\n    case DW_FORM_ref4:\n    case DW_FORM_ref_udata:\n      if (!do_loc)\n\tprintf (\" <0x%s>\", dwarf_vmatoa (\"x\", uvalue + cu_offset));\n      break;\n\n    case DW_FORM_data4:\n    case DW_FORM_addr:\n    case DW_FORM_sec_offset:\n      if (!do_loc)\n\tprintf (\" 0x%s\", dwarf_vmatoa (\"x\", uvalue));\n      break;\n\n    case DW_FORM_flag_present:\n    case DW_FORM_flag:\n    case DW_FORM_data1:\n    case DW_FORM_data2:\n    case DW_FORM_sdata:\n    case DW_FORM_udata:\n      if (!do_loc)\n\tprintf (\" %s\", dwarf_vmatoa (\"d\", uvalue));\n      break;\n\n    case DW_FORM_ref8:\n    case DW_FORM_data8:\n      if (!do_loc)\n\t{\n\t  dwarf_vma high_bits;\n\t  dwarf_vma utmp;\n\t  char buf[64];\n\n\t  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);\n\t  utmp = uvalue;\n\t  if (form == DW_FORM_ref8)\n\t    add64 (& high_bits, & utmp, cu_offset);\n\t  printf (\" 0x%s\",\n\t\t  dwarf_vmatoa64 (high_bits, utmp, buf, sizeof (buf)));\n\t}\n\n      if ((do_loc || do_debug_loc || do_debug_ranges)\n\t  && num_debug_info_entries == 0)\n\t{\n\t  if (sizeof (uvalue) == 8)\n\t    SAFE_BYTE_GET (uvalue, data, 8, end);\n\t  else\n\t    error (_(\"DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\\n\"));\n\t}\n\n      data += 8;\n      break;\n\n    case DW_FORM_string:\n      if (!do_loc)\n\tprintf (\" %.*s\", (int) (end - data), data);\n      data += strnlen ((char *) data, end - data) + 1;\n      break;\n\n    case DW_FORM_block:\n    case DW_FORM_exprloc:\n      uvalue = read_uleb128 (data, & bytes_read, end);\n      block_start = data + bytes_read;\n      if (block_start >= end)\n\t{\n\t  warn (_(\"Block ends prematurely\\n\"));\n\t  uvalue = 0;\n\t  block_start = end;\n\t}\n      /* FIXME: Testing \"(block_start + uvalue) < block_start\" miscompiles with\n\t gcc 4.8.3 running on an x86_64 host in 32-bit mode.  So we pre-compute\n\t block_start + uvalue here.  */\n      data = block_start + uvalue;\n      /* PR 17512: file: 008-103549-0.001:0.1.  */\n      if (block_start + uvalue > end || data < block_start)\n\t{\n\t  warn (_(\"Corrupt attribute block length: %lx\\n\"), (long) uvalue);\n\t  uvalue = end - block_start;\n\t}\n      if (do_loc)\n\tdata = block_start + uvalue;\n      else\n\tdata = display_block (block_start, uvalue, end);\n      break;\n\n    case DW_FORM_block1:\n      SAFE_BYTE_GET (uvalue, data, 1, end);\n      block_start = data + 1;\n      if (block_start >= end)\n\t{\n\t  warn (_(\"Block ends prematurely\\n\"));\n\t  uvalue = 0;\n\t  block_start = end;\n\t}\n      data = block_start + uvalue;\n      if (block_start + uvalue > end || data < block_start)\n\t{\n\t  warn (_(\"Corrupt attribute block length: %lx\\n\"), (long) uvalue);\n\t  uvalue = end - block_start;\n\t}\n      if (do_loc)\n\tdata = block_start + uvalue;\n      else\n\tdata = display_block (block_start, uvalue, end);\n      break;\n\n    case DW_FORM_block2:\n      SAFE_BYTE_GET (uvalue, data, 2, end);\n      block_start = data + 2;\n      if (block_start >= end)\n\t{\n\t  warn (_(\"Block ends prematurely\\n\"));\n\t  uvalue = 0;\n\t  block_start = end;\n\t}\n      data = block_start + uvalue;\n      if (block_start + uvalue > end || data < block_start)\n\t{\n\t  warn (_(\"Corrupt attribute block length: %lx\\n\"), (long) uvalue);\n\t  uvalue = end - block_start;\n\t}\n      if (do_loc)\n\tdata = block_start + uvalue;\n      else\n\tdata = display_block (block_start, uvalue, end);\n      break;\n\n    case DW_FORM_block4:\n      SAFE_BYTE_GET (uvalue, data, 4, end);\n      block_start = data + 4;\n      /* PR 17512: file: 3371-3907-0.004.  */\n      if (block_start >= end)\n\t{\n\t  warn (_(\"Block ends prematurely\\n\"));\n\t  uvalue = 0;\n\t  block_start = end;\n\t}\n      data = block_start + uvalue;\n      if (block_start + uvalue > end\n\t  /* PR 17531: file: 5b5f0592.  */\n\t  || data < block_start)\n\t{\n\t  warn (_(\"Corrupt attribute block length: %lx\\n\"), (long) uvalue);\n\t  uvalue = end - block_start;\n\t}\n      if (do_loc)\n\tdata = block_start + uvalue;\n      else\n\tdata = display_block (block_start, uvalue, end);\n      break;\n\n    case DW_FORM_strp:\n      if (!do_loc)\n\tprintf (_(\" (indirect string, offset: 0x%s): %s\"),\n\t\tdwarf_vmatoa (\"x\", uvalue),\n\t\tfetch_indirect_string (uvalue));\n      break;\n\n    case DW_FORM_GNU_str_index:\n      if (!do_loc)\n\t{\n\t  const char *suffix = strrchr (section->name, '.');\n\t  int dwo = (suffix && strcmp (suffix, \".dwo\") == 0) ? 1 : 0;\n\n\t  printf (_(\" (indexed string: 0x%s): %s\"),\n\t\t  dwarf_vmatoa (\"x\", uvalue),\n\t\t  fetch_indexed_string (uvalue, this_set, offset_size, dwo));\n\t}\n      break;\n\n    case DW_FORM_GNU_strp_alt:\n      if (!do_loc)\n\tprintf (_(\" (alt indirect string, offset: 0x%s)\"),\n\t\tdwarf_vmatoa (\"x\", uvalue));\n      break;\n\n    case DW_FORM_indirect:\n      /* Handled above.  */\n      break;\n\n    case DW_FORM_ref_sig8:\n      if (!do_loc)\n\t{\n\t  dwarf_vma high_bits;\n\t  char buf[64];\n\n\t  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);\n\t  printf (\" signature: 0x%s\",\n\t\t  dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));\n\t}\n      data += 8;\n      break;\n\n    case DW_FORM_GNU_addr_index:\n      if (!do_loc)\n\tprintf (_(\" (addr_index: 0x%s): %s\"),\n\t\tdwarf_vmatoa (\"x\", uvalue),\n\t\tfetch_indexed_value (uvalue * pointer_size, pointer_size));\n      break;\n\n    default:\n      warn (_(\"Unrecognized form: %lu\\n\"), form);\n      break;\n    }\n\n  if ((do_loc || do_debug_loc || do_debug_ranges)\n      && num_debug_info_entries == 0\n      && debug_info_p != NULL)\n    {\n      switch (attribute)\n\t{\n\tcase DW_AT_frame_base:\n\t  have_frame_base = 1;\n\tcase DW_AT_location:\n\tcase DW_AT_string_length:\n\tcase DW_AT_return_addr:\n\tcase DW_AT_data_member_location:\n\tcase DW_AT_vtable_elem_location:\n\tcase DW_AT_segment:\n\tcase DW_AT_static_link:\n\tcase DW_AT_use_location:\n\tcase DW_AT_GNU_call_site_value:\n\tcase DW_AT_GNU_call_site_data_value:\n\tcase DW_AT_GNU_call_site_target:\n\tcase DW_AT_GNU_call_site_target_clobbered:\n\t  if ((dwarf_version < 4\n\t       && (form == DW_FORM_data4 || form == DW_FORM_data8))\n\t      || form == DW_FORM_sec_offset)\n\t    {\n\t      /* Process location list.  */\n\t      unsigned int lmax = debug_info_p->max_loc_offsets;\n\t      unsigned int num = debug_info_p->num_loc_offsets;\n\n\t      if (lmax == 0 || num >= lmax)\n\t\t{\n\t\t  lmax += 1024;\n\t\t  debug_info_p->loc_offsets = (dwarf_vma *)\n\t\t    xcrealloc (debug_info_p->loc_offsets,\n\t\t\t       lmax, sizeof (*debug_info_p->loc_offsets));\n\t\t  debug_info_p->have_frame_base = (int *)\n\t\t    xcrealloc (debug_info_p->have_frame_base,\n\t\t\t       lmax, sizeof (*debug_info_p->have_frame_base));\n\t\t  debug_info_p->max_loc_offsets = lmax;\n\t\t}\n\t      if (this_set != NULL)\n\t\tuvalue += this_set->section_offsets [DW_SECT_LOC];\n\t      debug_info_p->loc_offsets [num] = uvalue;\n\t      debug_info_p->have_frame_base [num] = have_frame_base;\n\t      debug_info_p->num_loc_offsets++;\n\t    }\n\t  break;\n\n\tcase DW_AT_low_pc:\n\t  if (need_base_address)\n\t    debug_info_p->base_address = uvalue;\n\t  break;\n\n\tcase DW_AT_GNU_addr_base:\n\t  debug_info_p->addr_base = uvalue;\n\t  break;\n\n\tcase DW_AT_GNU_ranges_base:\n\t  debug_info_p->ranges_base = uvalue;\n\t  break;\n\n\tcase DW_AT_ranges:\n\t  if ((dwarf_version < 4\n\t       && (form == DW_FORM_data4 || form == DW_FORM_data8))\n\t      || form == DW_FORM_sec_offset)\n\t    {\n\t      /* Process range list.  */\n\t      unsigned int lmax = debug_info_p->max_range_lists;\n\t      unsigned int num = debug_info_p->num_range_lists;\n\n\t      if (lmax == 0 || num >= lmax)\n\t\t{\n\t\t  lmax += 1024;\n\t\t  debug_info_p->range_lists = (dwarf_vma *)\n\t\t    xcrealloc (debug_info_p->range_lists,\n\t\t\t       lmax, sizeof (*debug_info_p->range_lists));\n\t\t  debug_info_p->max_range_lists = lmax;\n\t\t}\n\t      debug_info_p->range_lists [num] = uvalue;\n\t      debug_info_p->num_range_lists++;\n\t    }\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n\n  if (do_loc || attribute == 0)\n    return data;\n\n  /* For some attributes we can display further information.  */\n  switch (attribute)\n    {\n    case DW_AT_inline:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_INL_not_inlined:\n\t  printf (_(\"(not inlined)\"));\n\t  break;\n\tcase DW_INL_inlined:\n\t  printf (_(\"(inlined)\"));\n\t  break;\n\tcase DW_INL_declared_not_inlined:\n\t  printf (_(\"(declared as inline but ignored)\"));\n\t  break;\n\tcase DW_INL_declared_inlined:\n\t  printf (_(\"(declared as inline and inlined)\"));\n\t  break;\n\tdefault:\n\t  printf (_(\"  (Unknown inline attribute value: %s)\"),\n\t\t  dwarf_vmatoa (\"x\", uvalue));\n\t  break;\n\t}\n      break;\n\n    case DW_AT_language:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\t  /* Ordered by the numeric value of these constants.  */\n\tcase DW_LANG_C89:\t\tprintf (\"(ANSI C)\"); break;\n\tcase DW_LANG_C:\t\t\tprintf (\"(non-ANSI C)\"); break;\n\tcase DW_LANG_Ada83:\t\tprintf (\"(Ada)\"); break;\n\tcase DW_LANG_C_plus_plus:\tprintf (\"(C++)\"); break;\n\tcase DW_LANG_Cobol74:\t\tprintf (\"(Cobol 74)\"); break;\n\tcase DW_LANG_Cobol85:\t\tprintf (\"(Cobol 85)\"); break;\n\tcase DW_LANG_Fortran77:\t\tprintf (\"(FORTRAN 77)\"); break;\n\tcase DW_LANG_Fortran90:\t\tprintf (\"(Fortran 90)\"); break;\n\tcase DW_LANG_Pascal83:\t\tprintf (\"(ANSI Pascal)\"); break;\n\tcase DW_LANG_Modula2:\t\tprintf (\"(Modula 2)\"); break;\n\t  /* DWARF 2.1 values.\t*/\n\tcase DW_LANG_Java:\t\tprintf (\"(Java)\"); break;\n\tcase DW_LANG_C99:\t\tprintf (\"(ANSI C99)\"); break;\n\tcase DW_LANG_Ada95:\t\tprintf (\"(ADA 95)\"); break;\n\tcase DW_LANG_Fortran95:\t\tprintf (\"(Fortran 95)\"); break;\n\t  /* DWARF 3 values.  */\n\tcase DW_LANG_PLI:\t\tprintf (\"(PLI)\"); break;\n\tcase DW_LANG_ObjC:\t\tprintf (\"(Objective C)\"); break;\n\tcase DW_LANG_ObjC_plus_plus:\tprintf (\"(Objective C++)\"); break;\n\tcase DW_LANG_UPC:\t\tprintf (\"(Unified Parallel C)\"); break;\n\tcase DW_LANG_D:\t\t\tprintf (\"(D)\"); break;\n\t  /* DWARF 4 values.  */\n\tcase DW_LANG_Python:\t\tprintf (\"(Python)\"); break;\n\t  /* DWARF 5 values.  */\n\tcase DW_LANG_Go:\t\tprintf (\"(Go)\"); break;\n\tcase DW_LANG_C_plus_plus_11:\tprintf (\"(C++11)\"); break;\n\tcase DW_LANG_C11:\t\tprintf (\"(C11)\"); break;\n\tcase DW_LANG_C_plus_plus_14:\tprintf (\"(C++14)\"); break;\n\t  /* MIPS extension.  */\n\tcase DW_LANG_Mips_Assembler:\tprintf (\"(MIPS assembler)\"); break;\n\t  /* UPC extension.  */\n\tcase DW_LANG_Upc:\t\tprintf (\"(Unified Parallel C)\"); break;\n\tdefault:\n\t  if (uvalue >= DW_LANG_lo_user && uvalue <= DW_LANG_hi_user)\n\t    printf (_(\"(implementation defined: %s)\"),\n\t\t    dwarf_vmatoa (\"x\", uvalue));\n\t  else\n\t    printf (_(\"(Unknown: %s)\"), dwarf_vmatoa (\"x\", uvalue));\n\t  break;\n\t}\n      break;\n\n    case DW_AT_encoding:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_ATE_void:\t\tprintf (\"(void)\"); break;\n\tcase DW_ATE_address:\t\tprintf (\"(machine address)\"); break;\n\tcase DW_ATE_boolean:\t\tprintf (\"(boolean)\"); break;\n\tcase DW_ATE_complex_float:\tprintf (\"(complex float)\"); break;\n\tcase DW_ATE_float:\t\tprintf (\"(float)\"); break;\n\tcase DW_ATE_signed:\t\tprintf (\"(signed)\"); break;\n\tcase DW_ATE_signed_char:\tprintf (\"(signed char)\"); break;\n\tcase DW_ATE_unsigned:\t\tprintf (\"(unsigned)\"); break;\n\tcase DW_ATE_unsigned_char:\tprintf (\"(unsigned char)\"); break;\n\t  /* DWARF 2.1 values:  */\n\tcase DW_ATE_imaginary_float:\tprintf (\"(imaginary float)\"); break;\n\tcase DW_ATE_decimal_float:\tprintf (\"(decimal float)\"); break;\n\t  /* DWARF 3 values:  */\n\tcase DW_ATE_packed_decimal:\tprintf (\"(packed_decimal)\"); break;\n\tcase DW_ATE_numeric_string:\tprintf (\"(numeric_string)\"); break;\n\tcase DW_ATE_edited:\t\tprintf (\"(edited)\"); break;\n\tcase DW_ATE_signed_fixed:\tprintf (\"(signed_fixed)\"); break;\n\tcase DW_ATE_unsigned_fixed:\tprintf (\"(unsigned_fixed)\"); break;\n\t  /* HP extensions:  */\n\tcase DW_ATE_HP_float80:\t\tprintf (\"(HP_float80)\"); break;\n\tcase DW_ATE_HP_complex_float80:\tprintf (\"(HP_complex_float80)\"); break;\n\tcase DW_ATE_HP_float128:\tprintf (\"(HP_float128)\"); break;\n\tcase DW_ATE_HP_complex_float128:printf (\"(HP_complex_float128)\"); break;\n\tcase DW_ATE_HP_floathpintel:\tprintf (\"(HP_floathpintel)\"); break;\n\tcase DW_ATE_HP_imaginary_float80:\tprintf (\"(HP_imaginary_float80)\"); break;\n\tcase DW_ATE_HP_imaginary_float128:\tprintf (\"(HP_imaginary_float128)\"); break;\n\n\tdefault:\n\t  if (uvalue >= DW_ATE_lo_user\n\t      && uvalue <= DW_ATE_hi_user)\n\t    printf (_(\"(user defined type)\"));\n\t  else\n\t    printf (_(\"(unknown type)\"));\n\t  break;\n\t}\n      break;\n\n    case DW_AT_accessibility:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_ACCESS_public:\t\tprintf (\"(public)\"); break;\n\tcase DW_ACCESS_protected:\tprintf (\"(protected)\"); break;\n\tcase DW_ACCESS_private:\t\tprintf (\"(private)\"); break;\n\tdefault:\n\t  printf (_(\"(unknown accessibility)\"));\n\t  break;\n\t}\n      break;\n\n    case DW_AT_visibility:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_VIS_local:\t\tprintf (\"(local)\"); break;\n\tcase DW_VIS_exported:\t\tprintf (\"(exported)\"); break;\n\tcase DW_VIS_qualified:\t\tprintf (\"(qualified)\"); break;\n\tdefault:\t\t\tprintf (_(\"(unknown visibility)\")); break;\n\t}\n      break;\n\n    case DW_AT_virtuality:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_VIRTUALITY_none:\tprintf (\"(none)\"); break;\n\tcase DW_VIRTUALITY_virtual:\tprintf (\"(virtual)\"); break;\n\tcase DW_VIRTUALITY_pure_virtual:printf (\"(pure_virtual)\"); break;\n\tdefault:\t\t\tprintf (_(\"(unknown virtuality)\")); break;\n\t}\n      break;\n\n    case DW_AT_identifier_case:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_ID_case_sensitive:\tprintf (\"(case_sensitive)\"); break;\n\tcase DW_ID_up_case:\t\tprintf (\"(up_case)\"); break;\n\tcase DW_ID_down_case:\t\tprintf (\"(down_case)\"); break;\n\tcase DW_ID_case_insensitive:\tprintf (\"(case_insensitive)\"); break;\n\tdefault:\t\t\tprintf (_(\"(unknown case)\")); break;\n\t}\n      break;\n\n    case DW_AT_calling_convention:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase DW_CC_normal:\tprintf (\"(normal)\"); break;\n\tcase DW_CC_program:\tprintf (\"(program)\"); break;\n\tcase DW_CC_nocall:\tprintf (\"(nocall)\"); break;\n\tdefault:\n\t  if (uvalue >= DW_CC_lo_user\n\t      && uvalue <= DW_CC_hi_user)\n\t    printf (_(\"(user defined)\"));\n\t  else\n\t    printf (_(\"(unknown convention)\"));\n\t}\n      break;\n\n    case DW_AT_ordering:\n      printf (\"\\t\");\n      switch (uvalue)\n\t{\n\tcase -1: printf (_(\"(undefined)\")); break;\n\tcase 0:  printf (\"(row major)\"); break;\n\tcase 1:  printf (\"(column major)\"); break;\n\t}\n      break;\n\n    case DW_AT_frame_base:\n      have_frame_base = 1;\n    case DW_AT_location:\n    case DW_AT_string_length:\n    case DW_AT_return_addr:\n    case DW_AT_data_member_location:\n    case DW_AT_vtable_elem_location:\n    case DW_AT_segment:\n    case DW_AT_static_link:\n    case DW_AT_use_location:\n    case DW_AT_GNU_call_site_value:\n    case DW_AT_GNU_call_site_data_value:\n    case DW_AT_GNU_call_site_target:\n    case DW_AT_GNU_call_site_target_clobbered:\n      if ((dwarf_version < 4\n\t   && (form == DW_FORM_data4 || form == DW_FORM_data8))\n\t  || form == DW_FORM_sec_offset)\n\tprintf (_(\" (location list)\"));\n      /* Fall through.  */\n    case DW_AT_allocated:\n    case DW_AT_associated:\n    case DW_AT_data_location:\n    case DW_AT_stride:\n    case DW_AT_upper_bound:\n    case DW_AT_lower_bound:\n      if (block_start)\n\t{\n\t  int need_frame_base;\n\n\t  printf (\"\\t(\");\n\t  need_frame_base = decode_location_expression (block_start,\n\t\t\t\t\t\t\tpointer_size,\n\t\t\t\t\t\t\toffset_size,\n\t\t\t\t\t\t\tdwarf_version,\n\t\t\t\t\t\t\tuvalue,\n\t\t\t\t\t\t\tcu_offset, section);\n\t  printf (\")\");\n\t  if (need_frame_base && !have_frame_base)\n\t    printf (_(\" [without DW_AT_frame_base]\"));\n\t}\n      break;\n\n    case DW_AT_import:\n      {\n\tif (form == DW_FORM_ref_sig8\n\t    || form == DW_FORM_GNU_ref_alt)\n\t  break;\n\n\tif (form == DW_FORM_ref1\n\t    || form == DW_FORM_ref2\n\t    || form == DW_FORM_ref4\n\t    || form == DW_FORM_ref_udata)\n\t  uvalue += cu_offset;\n\n\tif (uvalue >= section->size)\n\t  warn (_(\"Offset %s used as value for DW_AT_import attribute of DIE at offset 0x%lx is too big.\\n\"),\n\t\tdwarf_vmatoa (\"x\", uvalue),\n\t\t(unsigned long) (orig_data - section->start));\n\telse\n\t  {\n\t    unsigned long abbrev_number;\n\t    abbrev_entry * entry;\n\n\t    abbrev_number = read_uleb128 (section->start + uvalue, NULL, end);\n\n\t    printf (_(\"\\t[Abbrev Number: %ld\"), abbrev_number);\n\t    /* Don't look up abbrev for DW_FORM_ref_addr, as it very often will\n\t       use different abbrev table, and we don't track .debug_info chunks\n\t       yet.  */\n\t    if (form != DW_FORM_ref_addr)\n\t      {\n\t\tfor (entry = first_abbrev; entry != NULL; entry = entry->next)\n\t\t  if (entry->entry == abbrev_number)\n\t\t    break;\n\t\tif (entry != NULL)\n\t\t  printf (\" (%s)\", get_TAG_name (entry->tag));\n\t      }\n\t    printf (\"]\");\n\t  }\n      }\n      break;\n\n    default:\n      break;\n    }\n\n  return data;\n}"
}