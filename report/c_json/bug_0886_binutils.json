{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [-203, 33] Size: 34 by call to `elf_i386_tls_transition`.",
    "Code_line": "\t  if (! elf_i386_tls_transition (info, input_bfd,",
    "Code_function": "elf_i386_relocate_section (bfd *output_bfd,\n\t\t\t   struct bfd_link_info *info,\n\t\t\t   bfd *input_bfd,\n\t\t\t   asection *input_section,\n\t\t\t   bfd_byte *contents,\n\t\t\t   Elf_Internal_Rela *relocs,\n\t\t\t   Elf_Internal_Sym *local_syms,\n\t\t\t   asection **local_sections)\n{\n  struct elf_i386_link_hash_table *htab;\n  Elf_Internal_Shdr *symtab_hdr;\n  struct elf_link_hash_entry **sym_hashes;\n  bfd_vma *local_got_offsets;\n  bfd_vma *local_tlsdesc_gotents;\n  Elf_Internal_Rela *rel;\n  Elf_Internal_Rela *relend;\n  bfd_boolean is_vxworks_tls;\n  unsigned plt_entry_size;\n\n  BFD_ASSERT (is_i386_elf (input_bfd));\n\n  htab = elf_i386_hash_table (info);\n  if (htab == NULL)\n    return FALSE;\n  symtab_hdr = &elf_symtab_hdr (input_bfd);\n  sym_hashes = elf_sym_hashes (input_bfd);\n  local_got_offsets = elf_local_got_offsets (input_bfd);\n  local_tlsdesc_gotents = elf_i386_local_tlsdesc_gotent (input_bfd);\n  /* We have to handle relocations in vxworks .tls_vars sections\n     specially, because the dynamic loader is 'weird'.  */\n  is_vxworks_tls = (get_elf_i386_backend_data (output_bfd)->is_vxworks\n                    && info->shared\n\t\t    && !strcmp (input_section->output_section->name,\n\t\t\t\t\".tls_vars\"));\n\n  elf_i386_set_tls_module_base (info);\n\n  plt_entry_size = GET_PLT_ENTRY_SIZE (output_bfd);\n\n  rel = relocs;\n  relend = relocs + input_section->reloc_count;\n  for (; rel < relend; rel++)\n    {\n      unsigned int r_type;\n      reloc_howto_type *howto;\n      unsigned long r_symndx;\n      struct elf_link_hash_entry *h;\n      Elf_Internal_Sym *sym;\n      asection *sec;\n      bfd_vma off, offplt;\n      bfd_vma relocation;\n      bfd_boolean unresolved_reloc;\n      bfd_reloc_status_type r;\n      unsigned int indx;\n      int tls_type;\n      bfd_vma st_size;\n\n      r_type = ELF32_R_TYPE (rel->r_info);\n      if (r_type == R_386_GNU_VTINHERIT\n\t  || r_type == R_386_GNU_VTENTRY)\n\tcontinue;\n\n      if ((indx = r_type) >= R_386_standard\n\t  && ((indx = r_type - R_386_ext_offset) - R_386_standard\n\t      >= R_386_ext - R_386_standard)\n\t  && ((indx = r_type - R_386_tls_offset) - R_386_ext\n\t      >= R_386_irelative - R_386_ext))\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"%B: unrecognized relocation (0x%x) in section `%A'\"),\n\t     input_bfd, input_section, r_type);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n      howto = elf_howto_table + indx;\n\n      r_symndx = ELF32_R_SYM (rel->r_info);\n      h = NULL;\n      sym = NULL;\n      sec = NULL;\n      unresolved_reloc = FALSE;\n      if (r_symndx < symtab_hdr->sh_info)\n\t{\n\t  sym = local_syms + r_symndx;\n\t  sec = local_sections[r_symndx];\n\t  relocation = (sec->output_section->vma\n\t\t\t+ sec->output_offset\n\t\t\t+ sym->st_value);\n\t  st_size = sym->st_size;\n\n\t  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION\n\t      && ((sec->flags & SEC_MERGE) != 0\n\t\t  || (info->relocatable\n\t\t      && sec->output_offset != 0)))\n\t    {\n\t      bfd_vma addend;\n\t      bfd_byte *where = contents + rel->r_offset;\n\n\t      switch (howto->size)\n\t\t{\n\t\tcase 0:\n\t\t  addend = bfd_get_8 (input_bfd, where);\n\t\t  if (howto->pc_relative)\n\t\t    {\n\t\t      addend = (addend ^ 0x80) - 0x80;\n\t\t      addend += 1;\n\t\t    }\n\t\t  break;\n\t\tcase 1:\n\t\t  addend = bfd_get_16 (input_bfd, where);\n\t\t  if (howto->pc_relative)\n\t\t    {\n\t\t      addend = (addend ^ 0x8000) - 0x8000;\n\t\t      addend += 2;\n\t\t    }\n\t\t  break;\n\t\tcase 2:\n\t\t  addend = bfd_get_32 (input_bfd, where);\n\t\t  if (howto->pc_relative)\n\t\t    {\n\t\t      addend = (addend ^ 0x80000000) - 0x80000000;\n\t\t      addend += 4;\n\t\t    }\n\t\t  break;\n\t\tdefault:\n\t\t  abort ();\n\t\t}\n\n\t      if (info->relocatable)\n\t\taddend += sec->output_offset;\n\t      else\n\t\t{\n\t\t  asection *msec = sec;\n\t\t  addend = _bfd_elf_rel_local_sym (output_bfd, sym, &msec,\n\t\t\t\t\t\t   addend);\n\t\t  addend -= relocation;\n\t\t  addend += msec->output_section->vma + msec->output_offset;\n\t\t}\n\n\t      switch (howto->size)\n\t\t{\n\t\tcase 0:\n\t\t  /* FIXME: overflow checks.  */\n\t\t  if (howto->pc_relative)\n\t\t    addend -= 1;\n\t\t  bfd_put_8 (input_bfd, addend, where);\n\t\t  break;\n\t\tcase 1:\n\t\t  if (howto->pc_relative)\n\t\t    addend -= 2;\n\t\t  bfd_put_16 (input_bfd, addend, where);\n\t\t  break;\n\t\tcase 2:\n\t\t  if (howto->pc_relative)\n\t\t    addend -= 4;\n\t\t  bfd_put_32 (input_bfd, addend, where);\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (!info->relocatable\n\t\t   && ELF32_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)\n\t    {\n\t      /* Relocate against local STT_GNU_IFUNC symbol.  */\n\t      h = elf_i386_get_local_sym_hash (htab, input_bfd, rel,\n\t\t\t\t\t       FALSE);\n\t      if (h == NULL)\n\t\tabort ();\n\n\t      /* Set STT_GNU_IFUNC symbol value.  */\n\t      h->root.u.def.value = sym->st_value;\n\t      h->root.u.def.section = sec;\n\t    }\n\t}\n      else\n\t{\n\t  bfd_boolean warned ATTRIBUTE_UNUSED;\n\t  bfd_boolean ignored ATTRIBUTE_UNUSED;\n\n\t  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,\n\t\t\t\t   r_symndx, symtab_hdr, sym_hashes,\n\t\t\t\t   h, sec, relocation,\n\t\t\t\t   unresolved_reloc, warned, ignored);\n\t  st_size = h->size;\n\t}\n\n      if (sec != NULL && discarded_section (sec))\n\tRELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,\n\t\t\t\t\t rel, 1, relend, howto, 0, contents);\n\n      if (info->relocatable)\n\tcontinue;\n\n      /* Since STT_GNU_IFUNC symbol must go through PLT, we handle\n\t it here if it is defined in a non-shared object.  */\n      if (h != NULL\n\t  && h->type == STT_GNU_IFUNC\n\t  && h->def_regular)\n\t{\n\t  asection *plt, *gotplt, *base_got;\n\t  bfd_vma plt_index;\n\t  const char *name;\n\n\t  if ((input_section->flags & SEC_ALLOC) == 0\n\t      || h->plt.offset == (bfd_vma) -1)\n\t    abort ();\n\n\t  /* STT_GNU_IFUNC symbol must go through PLT.  */\n\t  if (htab->elf.splt != NULL)\n\t    {\n\t      plt = htab->elf.splt;\n\t      gotplt = htab->elf.sgotplt;\n\t    }\n\t  else\n\t    {\n\t      plt = htab->elf.iplt;\n\t      gotplt = htab->elf.igotplt;\n\t    }\n\n\t  relocation = (plt->output_section->vma\n\t\t\t+ plt->output_offset + h->plt.offset);\n\n\t  switch (r_type)\n\t    {\n\t    default:\n\t      if (h->root.root.string)\n\t\tname = h->root.root.string;\n\t      else\n\t\tname = bfd_elf_sym_name (input_bfd, symtab_hdr, sym,\n\t\t\t\t\t NULL);\n\t      (*_bfd_error_handler)\n\t\t(_(\"%B: relocation %s against STT_GNU_IFUNC \"\n\t\t   \"symbol `%s' isn't handled by %s\"), input_bfd,\n\t\t elf_howto_table[r_type].name,\n\t\t name, __FUNCTION__);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\n\t    case R_386_32:\n\t      /* Generate dynamic relcoation only when there is a\n\t\t non-GOT reference in a shared object.  */\n\t      if (info->shared && h->non_got_ref)\n\t\t{\n\t\t  Elf_Internal_Rela outrel;\n\t\t  asection *sreloc;\n\t\t  bfd_vma offset;\n\n\t\t  /* Need a dynamic relocation to get the real function\n\t\t     adddress.  */\n\t\t  offset = _bfd_elf_section_offset (output_bfd,\n\t\t\t\t\t\t    info,\n\t\t\t\t\t\t    input_section,\n\t\t\t\t\t\t    rel->r_offset);\n\t\t  if (offset == (bfd_vma) -1\n\t\t      || offset == (bfd_vma) -2)\n\t\t    abort ();\n\n\t\t  outrel.r_offset = (input_section->output_section->vma\n\t\t\t\t     + input_section->output_offset\n\t\t\t\t     + offset);\n\n\t\t  if (h->dynindx == -1\n\t\t      || h->forced_local\n\t\t      || info->executable)\n\t\t    {\n\t\t      /* This symbol is resolved locally.  */\n\t\t      outrel.r_info = ELF32_R_INFO (0, R_386_IRELATIVE);\n\t\t      bfd_put_32 (output_bfd,\n\t\t\t\t  (h->root.u.def.value\n\t\t\t\t   + h->root.u.def.section->output_section->vma\n\t\t\t\t   + h->root.u.def.section->output_offset),\n\t\t\t\t  contents + offset);\n\t\t    }\n\t\t  else\n\t\t    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);\n\n\t\t  sreloc = htab->elf.irelifunc;\n\t\t  elf_append_rel (output_bfd, sreloc, &outrel);\n\n\t\t  /* If this reloc is against an external symbol, we\n\t\t     do not want to fiddle with the addend.  Otherwise,\n\t\t     we need to include the symbol value so that it\n\t\t     becomes an addend for the dynamic reloc.  For an\n\t\t     internal symbol, we have updated addend.  */\n\t\t  continue;\n\t\t}\n\t      /* FALLTHROUGH */\n\t    case R_386_PC32:\n\t    case R_386_PLT32:\n\t      goto do_relocation;\n\n\t    case R_386_GOT32:\n\t      base_got = htab->elf.sgot;\n\t      off = h->got.offset;\n\n\t      if (base_got == NULL)\n\t\tabort ();\n\n\t      if (off == (bfd_vma) -1)\n\t\t{\n\t\t  /* We can't use h->got.offset here to save state, or\n\t\t     even just remember the offset, as finish_dynamic_symbol\n\t\t     would use that as offset into .got.  */\n\n\t\t  if (htab->elf.splt != NULL)\n\t\t    {\n\t\t      plt_index = h->plt.offset / plt_entry_size - 1;\n\t\t      off = (plt_index + 3) * 4;\n\t\t      base_got = htab->elf.sgotplt;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      plt_index = h->plt.offset / plt_entry_size;\n\t\t      off = plt_index * 4;\n\t\t      base_got = htab->elf.igotplt;\n\t\t    }\n\n\t\t  if (h->dynindx == -1\n\t\t      || h->forced_local\n\t\t      || info->symbolic)\n\t\t    {\n\t\t      /* This references the local defitionion.  We must\n\t\t\t initialize this entry in the global offset table.\n\t\t\t Since the offset must always be a multiple of 8,\n\t\t\t we use the least significant bit to record\n\t\t\t whether we have initialized it already.\n\n\t\t\t When doing a dynamic link, we create a .rela.got\n\t\t\t relocation entry to initialize the value.  This\n\t\t\t is done in the finish_dynamic_symbol routine.\t */\n\t\t      if ((off & 1) != 0)\n\t\t\toff &= ~1;\n\t\t      else\n\t\t\t{\n\t\t\t  bfd_put_32 (output_bfd, relocation,\n\t\t\t\t      base_got->contents + off);\n\t\t\t  h->got.offset |= 1;\n\t\t\t}\n\t\t    }\n\n\t\t  relocation = off;\n\n\t\t  /* Adjust for static executables.  */\n\t\t  if (htab->elf.splt == NULL)\n\t\t    relocation += gotplt->output_offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  relocation = (base_got->output_section->vma\n\t\t\t\t+ base_got->output_offset + off\n\t\t\t\t- gotplt->output_section->vma\n\t\t\t\t- gotplt->output_offset);\n\t\t  /* Adjust for static executables.  */\n\t\t  if (htab->elf.splt == NULL)\n\t\t    relocation += gotplt->output_offset;\n\t\t}\n\n\t      goto do_relocation;\n\n\t    case R_386_GOTOFF:\n\t      relocation -= (gotplt->output_section->vma\n\t\t\t     + gotplt->output_offset);\n\t      goto do_relocation;\n\t    }\n\t}\n\n      switch (r_type)\n\t{\n\tcase R_386_GOT32:\n\t  /* Relocation is to the entry for this symbol in the global\n\t     offset table.  */\n\t  if (htab->elf.sgot == NULL)\n\t    abort ();\n\n\t  if (h != NULL)\n\t    {\n\t      bfd_boolean dyn;\n\n\t      off = h->got.offset;\n\t      dyn = htab->elf.dynamic_sections_created;\n\t      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)\n\t\t  || (info->shared\n\t\t      && SYMBOL_REFERENCES_LOCAL (info, h))\n\t\t  || (ELF_ST_VISIBILITY (h->other)\n\t\t      && h->root.type == bfd_link_hash_undefweak))\n\t\t{\n\t\t  /* This is actually a static link, or it is a\n\t\t     -Bsymbolic link and the symbol is defined\n\t\t     locally, or the symbol was forced to be local\n\t\t     because of a version file.  We must initialize\n\t\t     this entry in the global offset table.  Since the\n\t\t     offset must always be a multiple of 4, we use the\n\t\t     least significant bit to record whether we have\n\t\t     initialized it already.\n\n\t\t     When doing a dynamic link, we create a .rel.got\n\t\t     relocation entry to initialize the value.  This\n\t\t     is done in the finish_dynamic_symbol routine.  */\n\t\t  if ((off & 1) != 0)\n\t\t    off &= ~1;\n\t\t  else\n\t\t    {\n\t\t      bfd_put_32 (output_bfd, relocation,\n\t\t\t\t  htab->elf.sgot->contents + off);\n\t\t      h->got.offset |= 1;\n\t\t    }\n\t\t}\n\t      else\n\t\tunresolved_reloc = FALSE;\n\t    }\n\t  else\n\t    {\n\t      if (local_got_offsets == NULL)\n\t\tabort ();\n\n\t      off = local_got_offsets[r_symndx];\n\n\t      /* The offset must always be a multiple of 4.  We use\n\t\t the least significant bit to record whether we have\n\t\t already generated the necessary reloc.  */\n\t      if ((off & 1) != 0)\n\t\toff &= ~1;\n\t      else\n\t\t{\n\t\t  bfd_put_32 (output_bfd, relocation,\n\t\t\t      htab->elf.sgot->contents + off);\n\n\t\t  if (info->shared)\n\t\t    {\n\t\t      asection *s;\n\t\t      Elf_Internal_Rela outrel;\n\n\t\t      s = htab->elf.srelgot;\n\t\t      if (s == NULL)\n\t\t\tabort ();\n\n\t\t      outrel.r_offset = (htab->elf.sgot->output_section->vma\n\t\t\t\t\t + htab->elf.sgot->output_offset\n\t\t\t\t\t + off);\n\t\t      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n\t\t      elf_append_rel (output_bfd, s, &outrel);\n\t\t    }\n\n\t\t  local_got_offsets[r_symndx] |= 1;\n\t\t}\n\t    }\n\n\t  if (off >= (bfd_vma) -2)\n\t    abort ();\n\n\t  relocation = htab->elf.sgot->output_section->vma\n\t\t       + htab->elf.sgot->output_offset + off\n\t\t       - htab->elf.sgotplt->output_section->vma\n\t\t       - htab->elf.sgotplt->output_offset;\n\t  break;\n\n\tcase R_386_GOTOFF:\n\t  /* Relocation is relative to the start of the global offset\n\t     table.  */\n\n\t  /* Check to make sure it isn't a protected function symbol\n\t     for shared library since it may not be local when used\n\t     as function address.  We also need to make sure that a\n\t     symbol is defined locally.  */\n\t  if (info->shared && h)\n\t    {\n\t      if (!h->def_regular)\n\t\t{\n\t\t  const char *v;\n\n\t\t  switch (ELF_ST_VISIBILITY (h->other))\n\t\t    {\n\t\t    case STV_HIDDEN:\n\t\t      v = _(\"hidden symbol\");\n\t\t      break;\n\t\t    case STV_INTERNAL:\n\t\t      v = _(\"internal symbol\");\n\t\t      break;\n\t\t    case STV_PROTECTED:\n\t\t      v = _(\"protected symbol\");\n\t\t      break;\n\t\t    default:\n\t\t      v = _(\"symbol\");\n\t\t      break;\n\t\t    }\n\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"%B: relocation R_386_GOTOFF against undefined %s `%s' can not be used when making a shared object\"),\n\t\t     input_bfd, v, h->root.root.string);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t  return FALSE;\n\t\t}\n\t      else if (!info->executable\n\t\t       && !SYMBOLIC_BIND (info, h)\n\t\t       && h->type == STT_FUNC\n\t\t       && ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)\n\t\t{\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"%B: relocation R_386_GOTOFF against protected function `%s' can not be used when making a shared object\"),\n\t\t     input_bfd, h->root.root.string);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t  return FALSE;\n\t\t}\n\t    }\n\n\t  /* Note that sgot is not involved in this\n\t     calculation.  We always want the start of .got.plt.  If we\n\t     defined _GLOBAL_OFFSET_TABLE_ in a different way, as is\n\t     permitted by the ABI, we might have to change this\n\t     calculation.  */\n\t  relocation -= htab->elf.sgotplt->output_section->vma\n\t\t\t+ htab->elf.sgotplt->output_offset;\n\t  break;\n\n\tcase R_386_GOTPC:\n\t  /* Use global offset table as symbol value.  */\n\t  relocation = htab->elf.sgotplt->output_section->vma\n\t\t       + htab->elf.sgotplt->output_offset;\n\t  unresolved_reloc = FALSE;\n\t  break;\n\n\tcase R_386_PLT32:\n\t  /* Relocation is to the entry for this symbol in the\n\t     procedure linkage table.  */\n\n\t  /* Resolve a PLT32 reloc against a local symbol directly,\n\t     without using the procedure linkage table.  */\n\t  if (h == NULL)\n\t    break;\n\n\t  if (h->plt.offset == (bfd_vma) -1\n\t      || htab->elf.splt == NULL)\n\t    {\n\t      /* We didn't make a PLT entry for this symbol.  This\n\t\t happens when statically linking PIC code, or when\n\t\t using -Bsymbolic.  */\n\t      break;\n\t    }\n\n\t  relocation = (htab->elf.splt->output_section->vma\n\t\t\t+ htab->elf.splt->output_offset\n\t\t\t+ h->plt.offset);\n\t  unresolved_reloc = FALSE;\n\t  break;\n\n\tcase R_386_SIZE32:\n\t  /* Set to symbol size.  */\n\t  relocation = st_size;\n\t  /* Fall through.  */\n\n\tcase R_386_32:\n\tcase R_386_PC32:\n\t  if ((input_section->flags & SEC_ALLOC) == 0\n\t      || is_vxworks_tls)\n\t    break;\n\n\t  if ((info->shared\n\t       && (h == NULL\n\t\t   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT\n\t\t   || h->root.type != bfd_link_hash_undefweak)\n\t       && ((r_type != R_386_PC32 && r_type != R_386_SIZE32)\n\t\t   || !SYMBOL_CALLS_LOCAL (info, h)))\n\t      || (ELIMINATE_COPY_RELOCS\n\t\t  && !info->shared\n\t\t  && h != NULL\n\t\t  && h->dynindx != -1\n\t\t  && !h->non_got_ref\n\t\t  && ((h->def_dynamic\n\t\t       && !h->def_regular)\n\t\t      || h->root.type == bfd_link_hash_undefweak\n\t\t      || h->root.type == bfd_link_hash_undefined)))\n\t    {\n\t      Elf_Internal_Rela outrel;\n\t      bfd_boolean skip, relocate;\n\t      asection *sreloc;\n\n\t      /* When generating a shared object, these relocations\n\t\t are copied into the output file to be resolved at run\n\t\t time.  */\n\n\t      skip = FALSE;\n\t      relocate = FALSE;\n\n\t      outrel.r_offset =\n\t\t_bfd_elf_section_offset (output_bfd, info, input_section,\n\t\t\t\t\t rel->r_offset);\n\t      if (outrel.r_offset == (bfd_vma) -1)\n\t\tskip = TRUE;\n\t      else if (outrel.r_offset == (bfd_vma) -2)\n\t\tskip = TRUE, relocate = TRUE;\n\t      outrel.r_offset += (input_section->output_section->vma\n\t\t\t\t  + input_section->output_offset);\n\n\t      if (skip)\n\t\tmemset (&outrel, 0, sizeof outrel);\n\t      else if (h != NULL\n\t\t       && h->dynindx != -1\n\t\t       && (r_type == R_386_PC32\n\t\t\t   || !info->shared\n\t\t\t   || !SYMBOLIC_BIND (info, h)\n\t\t\t   || !h->def_regular))\n\t\toutrel.r_info = ELF32_R_INFO (h->dynindx, r_type);\n\t      else\n\t\t{\n\t\t  /* This symbol is local, or marked to become local.  */\n\t\t  relocate = TRUE;\n\t\t  outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n\t\t}\n\n\t      sreloc = elf_section_data (input_section)->sreloc;\n\n\t      if (sreloc == NULL || sreloc->contents == NULL)\n\t\t{\n\t\t  r = bfd_reloc_notsupported;\n\t\t  goto check_relocation_error;\n\t\t}\n\n\t      elf_append_rel (output_bfd, sreloc, &outrel);\n\n\t      /* If this reloc is against an external symbol, we do\n\t\t not want to fiddle with the addend.  Otherwise, we\n\t\t need to include the symbol value so that it becomes\n\t\t an addend for the dynamic reloc.  */\n\t      if (! relocate)\n\t\tcontinue;\n\t    }\n\t  break;\n\n\tcase R_386_TLS_IE:\n\t  if (!info->executable)\n\t    {\n\t      Elf_Internal_Rela outrel;\n\t      asection *sreloc;\n\n\t      outrel.r_offset = rel->r_offset\n\t\t\t\t+ input_section->output_section->vma\n\t\t\t\t+ input_section->output_offset;\n\t      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);\n\t      sreloc = elf_section_data (input_section)->sreloc;\n\t      if (sreloc == NULL)\n\t\tabort ();\n\t      elf_append_rel (output_bfd, sreloc, &outrel);\n\t    }\n\t  /* Fall through */\n\n\tcase R_386_TLS_GD:\n\tcase R_386_TLS_GOTDESC:\n\tcase R_386_TLS_DESC_CALL:\n\tcase R_386_TLS_IE_32:\n\tcase R_386_TLS_GOTIE:\n\t  tls_type = GOT_UNKNOWN;\n\t  if (h == NULL && local_got_offsets)\n\t    tls_type = elf_i386_local_got_tls_type (input_bfd) [r_symndx];\n\t  else if (h != NULL)\n\t    tls_type = elf_i386_hash_entry(h)->tls_type;\n\t  if (tls_type == GOT_TLS_IE)\n\t    tls_type = GOT_TLS_IE_NEG;\n\n\t  if (! elf_i386_tls_transition (info, input_bfd,\n\t\t\t\t\t input_section, contents,\n\t\t\t\t\t symtab_hdr, sym_hashes,\n\t\t\t\t\t &r_type, tls_type, rel,\n\t\t\t\t\t relend, h, r_symndx))\n\t    return FALSE;\n\n\t  if (r_type == R_386_TLS_LE_32)\n\t    {\n\t      BFD_ASSERT (! unresolved_reloc);\n\t      if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)\n\t\t{\n\t\t  unsigned int type;\n\t\t  bfd_vma roff;\n\n\t\t  /* GD->LE transition.  */\n\t\t  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);\n\t\t  if (type == 0x04)\n\t\t    {\n\t\t      /* leal foo(,%reg,1), %eax; call ___tls_get_addr\n\t\t\t Change it into:\n\t\t\t movl %gs:0, %eax; subl $foo@tpoff, %eax\n\t\t\t (6 byte form of subl).  */\n\t\t      memcpy (contents + rel->r_offset - 3,\n\t\t\t      \"\\x65\\xa1\\0\\0\\0\\0\\x81\\xe8\\0\\0\\0\", 12);\n\t\t      roff = rel->r_offset + 5;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* leal foo(%reg), %eax; call ___tls_get_addr; nop\n\t\t\t Change it into:\n\t\t\t movl %gs:0, %eax; subl $foo@tpoff, %eax\n\t\t\t (6 byte form of subl).  */\n\t\t      memcpy (contents + rel->r_offset - 2,\n\t\t\t      \"\\x65\\xa1\\0\\0\\0\\0\\x81\\xe8\\0\\0\\0\", 12);\n\t\t      roff = rel->r_offset + 6;\n\t\t    }\n\t\t  bfd_put_32 (output_bfd, elf_i386_tpoff (info, relocation),\n\t\t\t      contents + roff);\n\t\t  /* Skip R_386_PC32/R_386_PLT32.  */\n\t\t  rel++;\n\t\t  continue;\n\t\t}\n\t      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)\n\t\t{\n\t\t  /* GDesc -> LE transition.\n\t\t     It's originally something like:\n\t\t     leal x@tlsdesc(%ebx), %eax\n\n\t\t     leal x@ntpoff, %eax\n\n\t\t     Registers other than %eax may be set up here.  */\n\n\t\t  unsigned int val;\n\t\t  bfd_vma roff;\n\n\t\t  roff = rel->r_offset;\n\t\t  val = bfd_get_8 (input_bfd, contents + roff - 1);\n\n\t\t  /* Now modify the instruction as appropriate.  */\n\t\t  /* aoliva FIXME: remove the above and xor the byte\n\t\t     below with 0x86.  */\n\t\t  bfd_put_8 (output_bfd, val ^ 0x86,\n\t\t\t     contents + roff - 1);\n\t\t  bfd_put_32 (output_bfd, -elf_i386_tpoff (info, relocation),\n\t\t\t      contents + roff);\n\t\t  continue;\n\t\t}\n\t      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)\n\t\t{\n\t\t  /* GDesc -> LE transition.\n\t\t     It's originally:\n\t\t     call *(%eax)\n\t\t     Turn it into:\n\t\t     xchg %ax,%ax  */\n\n\t\t  bfd_vma roff;\n\n\t\t  roff = rel->r_offset;\n\t\t  bfd_put_8 (output_bfd, 0x66, contents + roff);\n\t\t  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);\n\t\t  continue;\n\t\t}\n\t      else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_IE)\n\t\t{\n\t\t  unsigned int val;\n\n\t\t  /* IE->LE transition:\n\t\t     Originally it can be one of:\n\t\t     movl foo, %eax\n\t\t     movl foo, %reg\n\t\t     addl foo, %reg\n\t\t     We change it into:\n\t\t     movl $foo, %eax\n\t\t     movl $foo, %reg\n\t\t     addl $foo, %reg.  */\n\t\t  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);\n\t\t  if (val == 0xa1)\n\t\t    {\n\t\t      /* movl foo, %eax.  */\n\t\t      bfd_put_8 (output_bfd, 0xb8,\n\t\t\t\t contents + rel->r_offset - 1);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      unsigned int type;\n\n\t\t      type = bfd_get_8 (input_bfd,\n\t\t\t\t\tcontents + rel->r_offset - 2);\n\t\t      switch (type)\n\t\t\t{\n\t\t\tcase 0x8b:\n\t\t\t  /* movl */\n\t\t\t  bfd_put_8 (output_bfd, 0xc7,\n\t\t\t\t     contents + rel->r_offset - 2);\n\t\t\t  bfd_put_8 (output_bfd,\n\t\t\t\t     0xc0 | ((val >> 3) & 7),\n\t\t\t\t     contents + rel->r_offset - 1);\n\t\t\t  break;\n\t\t\tcase 0x03:\n\t\t\t  /* addl */\n\t\t\t  bfd_put_8 (output_bfd, 0x81,\n\t\t\t\t     contents + rel->r_offset - 2);\n\t\t\t  bfd_put_8 (output_bfd,\n\t\t\t\t     0xc0 | ((val >> 3) & 7),\n\t\t\t\t     contents + rel->r_offset - 1);\n\t\t\t  break;\n\t\t\tdefault:\n\t\t\t  BFD_FAIL ();\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  bfd_put_32 (output_bfd, -elf_i386_tpoff (info, relocation),\n\t\t\t      contents + rel->r_offset);\n\t\t  continue;\n\t\t}\n\t      else\n\t\t{\n\t\t  unsigned int val, type;\n\n\t\t  /* {IE_32,GOTIE}->LE transition:\n\t\t     Originally it can be one of:\n\t\t     subl foo(%reg1), %reg2\n\t\t     movl foo(%reg1), %reg2\n\t\t     addl foo(%reg1), %reg2\n\t\t     We change it into:\n\t\t     subl $foo, %reg2\n\t\t     movl $foo, %reg2 (6 byte form)\n\t\t     addl $foo, %reg2.  */\n\t\t  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);\n\t\t  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);\n\t\t  if (type == 0x8b)\n\t\t    {\n\t\t      /* movl */\n\t\t      bfd_put_8 (output_bfd, 0xc7,\n\t\t\t\t contents + rel->r_offset - 2);\n\t\t      bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),\n\t\t\t\t contents + rel->r_offset - 1);\n\t\t    }\n\t\t  else if (type == 0x2b)\n\t\t    {\n\t\t      /* subl */\n\t\t      bfd_put_8 (output_bfd, 0x81,\n\t\t\t\t contents + rel->r_offset - 2);\n\t\t      bfd_put_8 (output_bfd, 0xe8 | ((val >> 3) & 7),\n\t\t\t\t contents + rel->r_offset - 1);\n\t\t    }\n\t\t  else if (type == 0x03)\n\t\t    {\n\t\t      /* addl */\n\t\t      bfd_put_8 (output_bfd, 0x81,\n\t\t\t\t contents + rel->r_offset - 2);\n\t\t      bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),\n\t\t\t\t contents + rel->r_offset - 1);\n\t\t    }\n\t\t  else\n\t\t    BFD_FAIL ();\n\t\t  if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTIE)\n\t\t    bfd_put_32 (output_bfd, -elf_i386_tpoff (info, relocation),\n\t\t\t\tcontents + rel->r_offset);\n\t\t  else\n\t\t    bfd_put_32 (output_bfd, elf_i386_tpoff (info, relocation),\n\t\t\t\tcontents + rel->r_offset);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  if (htab->elf.sgot == NULL)\n\t    abort ();\n\n\t  if (h != NULL)\n\t    {\n\t      off = h->got.offset;\n\t      offplt = elf_i386_hash_entry (h)->tlsdesc_got;\n\t    }\n\t  else\n\t    {\n\t      if (local_got_offsets == NULL)\n\t\tabort ();\n\n\t      off = local_got_offsets[r_symndx];\n\t      offplt = local_tlsdesc_gotents[r_symndx];\n\t    }\n\n\t  if ((off & 1) != 0)\n\t    off &= ~1;\n\t  else\n\t    {\n\t      Elf_Internal_Rela outrel;\n\t      int dr_type;\n\t      asection *sreloc;\n\n\t      if (htab->elf.srelgot == NULL)\n\t\tabort ();\n\n\t      indx = h && h->dynindx != -1 ? h->dynindx : 0;\n\n\t      if (GOT_TLS_GDESC_P (tls_type))\n\t\t{\n\t\t  bfd_byte *loc;\n\t\t  outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_DESC);\n\t\t  BFD_ASSERT (htab->sgotplt_jump_table_size + offplt + 8\n\t\t\t      <= htab->elf.sgotplt->size);\n\t\t  outrel.r_offset = (htab->elf.sgotplt->output_section->vma\n\t\t\t\t     + htab->elf.sgotplt->output_offset\n\t\t\t\t     + offplt\n\t\t\t\t     + htab->sgotplt_jump_table_size);\n\t\t  sreloc = htab->elf.srelplt;\n\t\t  loc = sreloc->contents;\n\t\t  loc += (htab->next_tls_desc_index++\n\t\t\t  * sizeof (Elf32_External_Rel));\n\t\t  BFD_ASSERT (loc + sizeof (Elf32_External_Rel)\n\t\t\t      <= sreloc->contents + sreloc->size);\n\t\t  bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);\n\t\t  if (indx == 0)\n\t\t    {\n\t\t      BFD_ASSERT (! unresolved_reloc);\n\t\t      bfd_put_32 (output_bfd,\n\t\t\t\t  relocation - elf_i386_dtpoff_base (info),\n\t\t\t\t  htab->elf.sgotplt->contents + offplt\n\t\t\t\t  + htab->sgotplt_jump_table_size + 4);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      bfd_put_32 (output_bfd, 0,\n\t\t\t\t  htab->elf.sgotplt->contents + offplt\n\t\t\t\t  + htab->sgotplt_jump_table_size + 4);\n\t\t    }\n\t\t}\n\n\t      sreloc = htab->elf.srelgot;\n\n\t      outrel.r_offset = (htab->elf.sgot->output_section->vma\n\t\t\t\t + htab->elf.sgot->output_offset + off);\n\n\t      if (GOT_TLS_GD_P (tls_type))\n\t\tdr_type = R_386_TLS_DTPMOD32;\n\t      else if (GOT_TLS_GDESC_P (tls_type))\n\t\tgoto dr_done;\n\t      else if (tls_type == GOT_TLS_IE_POS)\n\t\tdr_type = R_386_TLS_TPOFF;\n\t      else\n\t\tdr_type = R_386_TLS_TPOFF32;\n\n\t      if (dr_type == R_386_TLS_TPOFF && indx == 0)\n\t\tbfd_put_32 (output_bfd,\n\t\t\t    relocation - elf_i386_dtpoff_base (info),\n\t\t\t    htab->elf.sgot->contents + off);\n\t      else if (dr_type == R_386_TLS_TPOFF32 && indx == 0)\n\t\tbfd_put_32 (output_bfd,\n\t\t\t    elf_i386_dtpoff_base (info) - relocation,\n\t\t\t    htab->elf.sgot->contents + off);\n\t      else if (dr_type != R_386_TLS_DESC)\n\t\tbfd_put_32 (output_bfd, 0,\n\t\t\t    htab->elf.sgot->contents + off);\n\t      outrel.r_info = ELF32_R_INFO (indx, dr_type);\n\n\t      elf_append_rel (output_bfd, sreloc, &outrel);\n\n\t      if (GOT_TLS_GD_P (tls_type))\n\t\t{\n\t\t  if (indx == 0)\n\t\t    {\n\t    \t      BFD_ASSERT (! unresolved_reloc);\n\t\t      bfd_put_32 (output_bfd,\n\t\t\t\t  relocation - elf_i386_dtpoff_base (info),\n\t\t\t\t  htab->elf.sgot->contents + off + 4);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      bfd_put_32 (output_bfd, 0,\n\t\t\t\t  htab->elf.sgot->contents + off + 4);\n\t\t      outrel.r_info = ELF32_R_INFO (indx,\n\t\t\t\t\t\t    R_386_TLS_DTPOFF32);\n\t\t      outrel.r_offset += 4;\n\t\t      elf_append_rel (output_bfd, sreloc, &outrel);\n\t\t    }\n\t\t}\n\t      else if (tls_type == GOT_TLS_IE_BOTH)\n\t\t{\n\t\t  bfd_put_32 (output_bfd,\n\t\t\t      (indx == 0\n\t\t\t       ? relocation - elf_i386_dtpoff_base (info)\n\t\t\t       : 0),\n\t\t\t      htab->elf.sgot->contents + off + 4);\n\t\t  outrel.r_info = ELF32_R_INFO (indx, R_386_TLS_TPOFF);\n\t\t  outrel.r_offset += 4;\n\t\t  elf_append_rel (output_bfd, sreloc, &outrel);\n\t\t}\n\n\t    dr_done:\n\t      if (h != NULL)\n\t\th->got.offset |= 1;\n\t      else\n\t\tlocal_got_offsets[r_symndx] |= 1;\n\t    }\n\n\t  if (off >= (bfd_vma) -2\n\t      && ! GOT_TLS_GDESC_P (tls_type))\n\t    abort ();\n\t  if (r_type == R_386_TLS_GOTDESC\n\t      || r_type == R_386_TLS_DESC_CALL)\n\t    {\n\t      relocation = htab->sgotplt_jump_table_size + offplt;\n\t      unresolved_reloc = FALSE;\n\t    }\n\t  else if (r_type == ELF32_R_TYPE (rel->r_info))\n\t    {\n\t      bfd_vma g_o_t = htab->elf.sgotplt->output_section->vma\n\t\t\t      + htab->elf.sgotplt->output_offset;\n\t      relocation = htab->elf.sgot->output_section->vma\n\t\t+ htab->elf.sgot->output_offset + off - g_o_t;\n\t      if ((r_type == R_386_TLS_IE || r_type == R_386_TLS_GOTIE)\n\t\t  && tls_type == GOT_TLS_IE_BOTH)\n\t\trelocation += 4;\n\t      if (r_type == R_386_TLS_IE)\n\t\trelocation += g_o_t;\n\t      unresolved_reloc = FALSE;\n\t    }\n\t  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GD)\n\t    {\n\t      unsigned int val, type;\n\t      bfd_vma roff;\n\n\t      /* GD->IE transition.  */\n\t      type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);\n\t      val = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);\n\t      if (type == 0x04)\n\t\t{\n\t\t  /* leal foo(,%reg,1), %eax; call ___tls_get_addr\n\t\t     Change it into:\n\t\t     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */\n\t\t  val >>= 3;\n\t\t  roff = rel->r_offset - 3;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* leal foo(%reg), %eax; call ___tls_get_addr; nop\n\t\t     Change it into:\n\t\t     movl %gs:0, %eax; subl $foo@gottpoff(%reg), %eax.  */\n\t\t  roff = rel->r_offset - 2;\n\t\t}\n\t      memcpy (contents + roff,\n\t\t      \"\\x65\\xa1\\0\\0\\0\\0\\x2b\\x80\\0\\0\\0\", 12);\n\t      contents[roff + 7] = 0x80 | (val & 7);\n\t      /* If foo is used only with foo@gotntpoff(%reg) and\n\t\t foo@indntpoff, but not with foo@gottpoff(%reg), change\n\t\t subl $foo@gottpoff(%reg), %eax\n\t\t into:\n\t\t addl $foo@gotntpoff(%reg), %eax.  */\n\t      if (tls_type == GOT_TLS_IE_POS)\n\t\tcontents[roff + 6] = 0x03;\n\t      bfd_put_32 (output_bfd,\n\t\t\t  htab->elf.sgot->output_section->vma\n\t\t\t  + htab->elf.sgot->output_offset + off\n\t\t\t  - htab->elf.sgotplt->output_section->vma\n\t\t\t  - htab->elf.sgotplt->output_offset,\n\t\t\t  contents + roff + 8);\n\t      /* Skip R_386_PLT32.  */\n\t      rel++;\n\t      continue;\n\t    }\n\t  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)\n\t    {\n\t      /* GDesc -> IE transition.\n\t\t It's originally something like:\n\t\t leal x@tlsdesc(%ebx), %eax\n\n\t\t Change it to:\n\t\t movl x@gotntpoff(%ebx), %eax # before xchg %ax,%ax\n\t\t or:\n\t\t movl x@gottpoff(%ebx), %eax # before negl %eax\n\n\t\t Registers other than %eax may be set up here.  */\n\n\t      bfd_vma roff;\n\n\t      /* First, make sure it's a leal adding ebx to a 32-bit\n\t\t offset into any register, although it's probably\n\t\t almost always going to be eax.  */\n\t      roff = rel->r_offset;\n\n\t      /* Now modify the instruction as appropriate.  */\n\t      /* To turn a leal into a movl in the form we use it, it\n\t\t suffices to change the first byte from 0x8d to 0x8b.\n\t\t aoliva FIXME: should we decide to keep the leal, all\n\t\t we have to do is remove the statement below, and\n\t\t adjust the relaxation of R_386_TLS_DESC_CALL.  */\n\t      bfd_put_8 (output_bfd, 0x8b, contents + roff - 2);\n\n\t      if (tls_type == GOT_TLS_IE_BOTH)\n\t\toff += 4;\n\n\t      bfd_put_32 (output_bfd,\n\t\t\t  htab->elf.sgot->output_section->vma\n\t\t\t  + htab->elf.sgot->output_offset + off\n\t\t\t  - htab->elf.sgotplt->output_section->vma\n\t\t\t  - htab->elf.sgotplt->output_offset,\n\t\t\t  contents + roff);\n\t      continue;\n\t    }\n\t  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)\n\t    {\n\t      /* GDesc -> IE transition.\n\t\t It's originally:\n\t\t call *(%eax)\n\n\t\t Change it to:\n\t\t xchg %ax,%ax\n\t\t or\n\t\t negl %eax\n\t\t depending on how we transformed the TLS_GOTDESC above.\n\t      */\n\n\t      bfd_vma roff;\n\n\t      roff = rel->r_offset;\n\n\t      /* Now modify the instruction as appropriate.  */\n\t      if (tls_type != GOT_TLS_IE_NEG)\n\t\t{\n\t\t  /* xchg %ax,%ax */\n\t\t  bfd_put_8 (output_bfd, 0x66, contents + roff);\n\t\t  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* negl %eax */\n\t\t  bfd_put_8 (output_bfd, 0xf7, contents + roff);\n\t\t  bfd_put_8 (output_bfd, 0xd8, contents + roff + 1);\n\t\t}\n\n\t      continue;\n\t    }\n\t  else\n\t    BFD_ASSERT (FALSE);\n\t  break;\n\n\tcase R_386_TLS_LDM:\n\t  if (! elf_i386_tls_transition (info, input_bfd,\n\t\t\t\t\t input_section, contents,\n\t\t\t\t\t symtab_hdr, sym_hashes,\n\t\t\t\t\t &r_type, GOT_UNKNOWN, rel,\n\t\t\t\t\t relend, h, r_symndx))\n\t    return FALSE;\n\n\t  if (r_type != R_386_TLS_LDM)\n\t    {\n\t      /* LD->LE transition:\n\t\t leal foo(%reg), %eax; call ___tls_get_addr.\n\t\t We change it into:\n\t\t movl %gs:0, %eax; nop; leal 0(%esi,1), %esi.  */\n\t      BFD_ASSERT (r_type == R_386_TLS_LE_32);\n\t      memcpy (contents + rel->r_offset - 2,\n\t\t      \"\\x65\\xa1\\0\\0\\0\\0\\x90\\x8d\\x74\\x26\", 11);\n\t      /* Skip R_386_PC32/R_386_PLT32.  */\n\t      rel++;\n\t      continue;\n\t    }\n\n\t  if (htab->elf.sgot == NULL)\n\t    abort ();\n\n\t  off = htab->tls_ldm_got.offset;\n\t  if (off & 1)\n\t    off &= ~1;\n\t  else\n\t    {\n\t      Elf_Internal_Rela outrel;\n\n\t      if (htab->elf.srelgot == NULL)\n\t\tabort ();\n\n\t      outrel.r_offset = (htab->elf.sgot->output_section->vma\n\t\t\t\t + htab->elf.sgot->output_offset + off);\n\n\t      bfd_put_32 (output_bfd, 0,\n\t\t\t  htab->elf.sgot->contents + off);\n\t      bfd_put_32 (output_bfd, 0,\n\t\t\t  htab->elf.sgot->contents + off + 4);\n\t      outrel.r_info = ELF32_R_INFO (0, R_386_TLS_DTPMOD32);\n\t      elf_append_rel (output_bfd, htab->elf.srelgot, &outrel);\n\t      htab->tls_ldm_got.offset |= 1;\n\t    }\n\t  relocation = htab->elf.sgot->output_section->vma\n\t\t       + htab->elf.sgot->output_offset + off\n\t\t       - htab->elf.sgotplt->output_section->vma\n\t\t       - htab->elf.sgotplt->output_offset;\n\t  unresolved_reloc = FALSE;\n\t  break;\n\n\tcase R_386_TLS_LDO_32:\n\t  if (!info->executable || (input_section->flags & SEC_CODE) == 0)\n\t    relocation -= elf_i386_dtpoff_base (info);\n\t  else\n\t    /* When converting LDO to LE, we must negate.  */\n\t    relocation = -elf_i386_tpoff (info, relocation);\n\t  break;\n\n\tcase R_386_TLS_LE_32:\n\tcase R_386_TLS_LE:\n\t  if (!info->executable)\n\t    {\n\t      Elf_Internal_Rela outrel;\n\t      asection *sreloc;\n\n\t      outrel.r_offset = rel->r_offset\n\t\t\t\t+ input_section->output_section->vma\n\t\t\t\t+ input_section->output_offset;\n\t      if (h != NULL && h->dynindx !"
}