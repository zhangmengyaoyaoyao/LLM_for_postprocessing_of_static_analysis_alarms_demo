{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "bfd/elflink.c",
    "message": "Offset: [-34359738348, 34359738370+max(4294967291, `info->hash->root.table.size`)] (⇐ [-34359738348, 34359738371] + [0, -1+max(4294967291, `info->hash->root.table.size`)]) Size: 4064.",
    "warning_function_name": "elf_link_add_object_symbols",
    "warning_line": "for (p = htab->root.table.table[i]; p != NULL; p = p->next)",
    "warning_context": "\n  if (! dynamic || elf_dynsymtab (abfd) == 0)\n    hdr = &elf_tdata (abfd)->symtab_hdr;\n  else\n    hdr = &elf_tdata (abfd)->dynsymtab_hdr;\n\n  symcount = hdr->sh_size / bed->s->sizeof_sym;\n\n  /* The sh_info field of the symtab header tells us where the\n     external symbols start.  We don't care about the local symbols at\n     this point.  */\n  if (elf_bad_symtab (abfd))\n    {\n      extsymcount = symcount;\n      extsymoff = 0;\n    }\n  else\n    {\n      extsymcount = symcount - hdr->sh_info;\n      extsymoff = hdr->sh_info;\n    }\n\n  sym_hash = elf_sym_hashes (abfd);\n  if (extsymcount != 0)\n    {\n      isymbuf = bfd_elf_get_elf_syms (abfd, hdr, extsymcount, extsymoff,\n\t\t\t\t      NULL, NULL, NULL);\n      if (isymbuf == NULL)\n\tgoto error_return;\n\n      if (sym_hash == NULL)\n\t{\n\t  /* We store a pointer to the hash table entry for each\n\t     external symbol.  */\n\t  amt = extsymcount * sizeof (struct elf_link_hash_entry *);\n\t  sym_hash = (struct elf_link_hash_entry **) bfd_zalloc (abfd, amt);\n\t  if (sym_hash == NULL)\n\t    goto error_free_sym;\n\t  elf_sym_hashes (abfd) = sym_hash;\n\t}\n    }\n\n  if (dynamic)\n    {\n      /* Read in any version definitions.  */\n      if (!_bfd_elf_slurp_version_tables (abfd,\n\t\t\t\t\t  info->default_imported_symver))\n\tgoto error_free_sym;\n\n      /* Read in the symbol versions, but don't bother to convert them\n\t to internal format.  */\n      if (elf_dynversym (abfd) != 0)\n\t{\n\t  Elf_Internal_Shdr *versymhdr;\n\n\t  versymhdr = &elf_tdata (abfd)->dynversym_hdr;\n\t  extversym = (Elf_External_Versym *) bfd_malloc (versymhdr->sh_size);\n\t  if (extversym == NULL)\n\t    goto error_free_sym;\n\t  amt = versymhdr->sh_size;\n\t  if (bfd_seek (abfd, versymhdr->sh_offset, SEEK_SET) != 0\n\t      || bfd_bread (extversym, amt, abfd) != amt)\n\t    goto error_free_vers;\n\t}\n    }\n\n  /* If we are loading an as-needed shared lib, save the symbol table\n     state before we start adding symbols.  If the lib turns out\n     to be unneeded, restore the state.  */\n  if ((elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0)\n    {\n      unsigned int i;\n      size_t entsize;\n\n      for (entsize = 0, i = 0; i < htab->root.table.size; i++)\n\t{\n\t  struct bfd_hash_entry *p;\n\t  struct elf_link_hash_entry *h;\n\n\t  for (p = htab->root.table.table[i]; p != NULL; p = p->next)\n\t    {\n\t      h = (struct elf_link_hash_entry *) p;\n\t      entsize += htab->root.table.entsize;\n\t      if (h->root.type == bfd_link_hash_warning)\n\t\tentsize += htab->root.table.entsize;\n\t    }\n\t}\n\n      tabsize = htab->root.table.size * sizeof (struct bfd_hash_entry *);\n      old_tab = bfd_malloc (tabsize + entsize);\n      if (old_tab == NULL)\n\tgoto error_free_vers;\n\n      /* Remember the current objalloc pointer, so that all mem for\n\t symbols added can later be reclaimed.  */\n      alloc_mark = bfd_hash_allocate (&htab->root.table, 1);\n      if (alloc_mark == NULL)\n\tgoto error_free_vers;\n\n      /* Make a special call to the linker \"notice\" function to\n\t tell it that we are about to handle an as-needed lib.  */\n"
}