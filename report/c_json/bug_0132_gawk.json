{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [1, +oo] Size: [0, +oo] by call to `assoc_list`.",
    "Code_line": "\tlist = assoc_list(array, sort_str, ctxt);",
    "Code_function": "asort_actual(int nargs, sort_context_t ctxt)\n{\n\tNODE *array, *dest = NULL, *result;\n\tNODE *r, *subs, *s;\n\tNODE **list = NULL, **ptr, **lhs;\n\tunsigned long num_elems, i;\n\tconst char *sort_str;\n\n\tif (nargs == 3)  /* 3rd optional arg */\n\t\ts = POP_STRING();\n\telse\n\t\ts = dupnode(Nnull_string);\t/* \"\" => default sorting */\n\n\ts = force_string(s);\n\tsort_str = s->stptr;\n\tif (s->stlen == 0) {\t\t/* default sorting */\n\t\tif (ctxt == ASORT)\n\t\t\tsort_str = \"@val_type_asc\";\n\t\telse\n\t\t\tsort_str = \"@ind_str_asc\";\n\t}\n\n\tif (nargs >= 2) {  /* 2nd optional arg */\n\t\tdest = POP_PARAM();\n\t\tif (dest->type != Node_var_array) {\n\t\t\tfatal(ctxt == ASORT ?\n\t\t\t\t_(\"asort: second argument not an array\") :\n\t\t\t\t_(\"asorti: second argument not an array\"));\n\t\t}\n\t}\n\n\tarray = POP_PARAM();\n\tif (array->type != Node_var_array) {\n\t\tfatal(ctxt == ASORT ?\n\t\t\t_(\"asort: first argument not an array\") :\n\t\t\t_(\"asorti: first argument not an array\"));\n\t}\n\n\tif (dest != NULL) {\n\t\tfor (r = dest->parent_array; r != NULL; r = r->parent_array) {\n\t\t\tif (r == array)\n\t\t\t\tfatal(ctxt == ASORT ?\n\t\t\t\t\t_(\"asort: cannot use a subarray of first arg for second arg\") :\n\t\t\t\t\t_(\"asorti: cannot use a subarray of first arg for second arg\"));\n\t\t}\n\t\tfor (r = array->parent_array; r != NULL; r = r->parent_array) {\n\t\t\tif (r == dest)\n\t\t\t\tfatal(ctxt == ASORT ?\n\t\t\t\t\t_(\"asort: cannot use a subarray of second arg for first arg\") :\n\t\t\t\t\t_(\"asorti: cannot use a subarray of second arg for first arg\"));\n\t\t}\n\t}\n\n\t/* sorting happens inside assoc_list */\n\tlist = assoc_list(array, sort_str, ctxt);\n\tDEREF(s);\n\n\tnum_elems = assoc_length(array);\n\tif (num_elems == 0 || list == NULL) {\n \t\t/* source array is empty */\n \t\tif (dest != NULL && dest != array)\n \t\t\tassoc_clear(dest);\n\t\tif (list != NULL)\n\t\t\tefree(list);\n \t\treturn make_number((AWKNUM) 0);\n \t}\n\n\t/*\n\t * Must not assoc_clear() the source array before constructing\n\t * the output array. assoc_list() does not duplicate array values\n\t * which are needed for asort().\n\t */\n\n\tif (dest != NULL && dest != array) {\n\t\tassoc_clear(dest);\n\t\tresult = dest;\n\t} else {\n\t\t/* use 'result' as a temporary destination array */\n\t\tresult = make_array();\n\t\tresult->vname = array->vname;\n\t\tresult->parent_array = array->parent_array;\n\t}\n\n\tif (ctxt == ASORTI) {\n\t\t/* We want the indices of the source array. */\n\n\t\tfor (i = 1, ptr = list; i <= num_elems; i++, ptr += 2) {\n\t\t\tsubs = make_number(i);\n\t\t\tlhs = assoc_lookup(result, subs);\n\t\t\tunref(*lhs);\n\t\t\t*lhs = *ptr;\n\t\t\tif (result->astore != NULL)\n\t\t\t\t(*result->astore)(result, subs);\n\t\t\tunref(subs);\n\t\t}\n\t} else {\n\t\t/* We want the values of the source array. */\n\n\t\tfor (i = 1, ptr = list; i <= num_elems; i++) {\n\t\t\tsubs = make_number(i);\n\n\t\t\t/* free index node */\n\t\t\tr = *ptr++;\n\t\t\tunref(r);\n\n\t\t\t/* value node */\n\t\t\tr = *ptr++;\n\n\t\t\tif (r->type == Node_val) {\n\t\t\t\tlhs = assoc_lookup(result, subs);\n\t\t\t\tunref(*lhs);\n\t\t\t\t*lhs = dupnode(r);\n\t\t\t} else {\n\t\t\t\tNODE *arr;\n\t\t\t\tarr = make_array();\n\t\t\t\tsubs = force_string(subs);\n\t\t\t\tarr->vname = subs->stptr;\n\t\t\t\tsubs->stptr = NULL;\n\t\t\t\tsubs->flags &= ~STRCUR;\n\t\t\t\tarr->parent_array = array; /* actual parent, not the temporary one. */\n\t\t\t\tlhs = assoc_lookup(result, subs);\n\t\t\t\tunref(*lhs);\n\t\t\t\t*lhs = assoc_copy(r, arr);\n\t\t\t}\n\t\t\tif (result->astore != NULL)\n\t\t\t\t(*result->astore)(result, subs);\n\t\t\tunref(subs);\n\t\t}\n\t}\n\n\tefree(list);\n\n\tif (result != dest) {\n\t\t/* dest == NULL or dest == array */\n\t\tassoc_clear(array);\n\t\t*array = *result;\t/* copy result into array */\n\t\tfreenode(result);\n\t} /* else\n\t\tresult == dest\n\t\tdest != NULL and dest != array */\n\n\treturn make_number((AWKNUM) num_elems);\n}"
}