{
    "project": "bash",
    "tool": "CSA",
    "category": "core.uninitialized.Assign",
    "file": "subst.c",
    "message": "Assigned value is garbage or undefined",
    "warning_function_name": "command_substitute",
    "warning_line": "last_made_pid = old_pid;",
    "warning_context": "     int quoted;\n{\n  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;\n  char *istring;\n  int result, fildes[2], function_value, pflags, rc, tflag;\n  WORD_DESC *ret;\n\n  istring = (char *)NULL;\n\n  /* Don't fork () if there is no need to.  In the case of no command to\n     run, just return NULL. */\n  if (!string || !*string || (string[0] == '\\n' && !string[1]))\n    return ((WORD_DESC *)NULL);\n\n  if (wordexp_only && read_but_dont_execute)\n    {\n      last_command_exit_value = EX_WEXPCOMSUB;\n      jump_to_top_level (EXITPROG);\n    }\n\n  /* We're making the assumption here that the command substitution will\n     eventually run a command from the file system.  Since we'll run\n     maybe_make_export_env in this subshell before executing that command,\n     the parent shell and any other shells it starts will have to remake\n     the environment.  If we make it before we fork, other shells won't\n     have to.  Don't bother if we have any temporary variable assignments,\n     though, because the export environment will be remade after this\n     command completes anyway, but do it if all the words to be expanded\n     are variable assignments. */\n  if (subst_assign_varlist == 0 || garglist == 0)\n    maybe_make_export_env ();\t/* XXX */\n\n  /* Flags to pass to parse_and_execute() */\n  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;\n\n  /* Pipe the output of executing STRING into the current shell. */\n  if (pipe (fildes) < 0)\n    {\n      sys_error (_(\"cannot make pipe for command substitution\"));\n      goto error_exit;\n    }\n\n  old_pid = last_made_pid;\n#if defined (JOB_CONTROL)\n  old_pipeline_pgrp = pipeline_pgrp;\n  /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */\n  if ((subshell_environment & SUBSHELL_PIPE) == 0)\n    pipeline_pgrp = shell_pgrp;\n  cleanup_the_pipeline ();\n#endif /* JOB_CONTROL */\n\n  old_async_pid = last_asynchronous_pid;\n  pid = make_child ((char *)NULL, subshell_environment&SUBSHELL_ASYNC);\n  last_asynchronous_pid = old_async_pid;\n\n  if (pid == 0)\n    {\n      /* Reset the signal handlers in the child, but don't free the\n\t trap strings.  Set a flag noting that we have to free the\n\t trap strings if we run trap to change a signal disposition. */\n      reset_signal_handlers ();\n      subshell_environment |= SUBSHELL_RESETTRAP;\n    }\n\n#if defined (JOB_CONTROL)\n  /* XXX DO THIS ONLY IN PARENT ? XXX */\n  set_sigchld_handler ();\n  stop_making_children ();\n  if (pid != 0)\n    pipeline_pgrp = old_pipeline_pgrp;\n#else\n  stop_making_children ();\n#endif /* JOB_CONTROL */\n\n  if (pid < 0)\n    {\n      sys_error (_(\"cannot make child for command substitution\"));\n    error_exit:\n\n      last_made_pid = old_pid;\n\n      FREE (istring);\n      close (fildes[0]);\n      close (fildes[1]);\n      return ((WORD_DESC *)NULL);\n    }\n\n  if (pid == 0)\n    {\n      set_sigint_handler ();\t/* XXX */\n\n      free_pushed_string_input ();\n\n      if (dup2 (fildes[1], 1) < 0)\n\t{\n\t  sys_error (_(\"command_substitute: cannot duplicate pipe as fd 1\"));\n\t  exit (EXECUTION_FAILURE);\n\t}\n\n      /* If standard output is closed in the parent shell\n\t (such as after `exec >&-'), file descriptor 1 will be\n"
}