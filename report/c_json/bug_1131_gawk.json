{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "re.c",
    "message": "The value read from len was never initialized.",
    "warning_function_name": "check_bracket_exp",
    "warning_line": "warning(_(\"regexp component `%.*s' should probably be `[%.*s]'\"),",
    "warning_context": "static void\ncheck_bracket_exp(char *s, size_t length)\n{\n\tstatic struct reclass {\n\t\tconst char *name;\n\t\tsize_t len;\n\t\tbool warned;\n\t} classes[] = {\n\t\t/*\n\t\t * Ordered by what we hope is frequency,\n\t\t * since it's linear searched.\n\t\t */\n\t\t{ \"[:alpha:]\", 9, false },\n\t\t{ \"[:digit:]\", 9, false },\n\t\t{ \"[:alnum:]\", 9, false },\n\t\t{ \"[:upper:]\", 9, false },\n\t\t{ \"[:lower:]\", 9, false },\n\t\t{ \"[:space:]\", 9, false },\n\t\t{ \"[:xdigit:]\", 10, false },\n\t\t{ \"[:punct:]\", 9, false },\n\t\t{ \"[:print:]\", 9, false },\n\t\t{ \"[:graph:]\", 9, false },\n\t\t{ \"[:cntrl:]\", 9, false },\n\t\t{ \"[:blank:]\", 9, false },\n\t\t{ NULL, 0 }\n\t};\n\tint i;\n\tbool found = false;\n\tchar save;\n\tchar *sp, *sp2, *end;\n\tint len;\n\tint count = 0;\n\n\tif (length == 0)\n\t\treturn;\n\n\tend = s + length;\n\tsave = s[length];\n\ts[length] = '\\0';\n\tsp = s;\n\nagain:\n\tsp = sp2 = memchr(sp, '[', (end - sp));\n\tif (sp == NULL)\n\t\tgoto done;\n\n\tfor (count++, sp++; *sp != '\\0'; sp++) {\n\t\tif (*sp == '[')\n\t\t\tcount++;\n\t\t/*\n\t\t * ] as first char after open [ is skipped\n\t\t * \\] is skipped\n\t\t * [^]] is skipped\n\t\t */\n\t\tif (*sp == ']' && sp > sp2) {\n\t\t\t if (sp[-1] != '['\n\t\t\t     && sp[-1] != '\\\\')\n\t\t\t\t ;\n\t\t\t else if ((sp - sp2) >= 2\n\t\t\t\t  && sp[-1] == '^' && sp[-2] == '[')\n\t\t\t\t ;\n\t\t\t else\n\t\t\t\tcount--;\n\t\t}\n\n\t\tif (count == 0) {\n\t\t\tsp++;\t/* skip past ']' */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (count > 0) {\t/* bad regex, give up */\n\t\tgoto done;\n\t}\n\n\t/* sp2 has start */\n\n\tfor (i = 0; classes[i].name != NULL; i++) {\n\t\tif (classes[i].warned)\n\t\t\tcontinue;\n\t\tlen = classes[i].len;\n\t\tif (   len == (sp - sp2)\n\t\t    && memcmp(sp2, classes[i].name, len) == 0) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found && ! classes[i].warned) {\n\t\twarning(_(\"regexp component `%.*s' should probably be `[%.*s]'\"),\n\t\t\t\tlen, sp2, len, sp2);\n\t\tclasses[i].warned = true;\n\t}\n\n\tif (sp < end) {\n\t\tfound = false;\n\t\tgoto again;\n\t}\ndone:\n\ts[length] = save;\n}\n"
}