{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "  return temp;",
    "Code_function": "parameter_brace_patsub (varname, value, ind, patsub, quoted, flags)\n     char *varname, *value;\n     int ind;\n     char *patsub;\n     int quoted, flags;\n{\n  int vtype, mflags, starsub, delim;\n  char *val, *temp, *pat, *rep, *p, *lpatsub, *tt;\n  SHELL_VAR *v;\n\n  if (value == 0)\n    return ((char *)NULL);\n\n  this_command_name = varname;\n\n  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);\n  if (vtype == -1)\n    return ((char *)NULL);\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n  mflags = 0;\n  /* PATSUB is never NULL when this is called. */\n  if (*patsub == '/')\n    {\n      mflags |= MATCH_GLOBREP;\n      patsub++;\n    }\n\n  /* Malloc this because expand_string_if_necessary or one of the expansion\n     functions in its call chain may free it on a substitution error. */\n  lpatsub = savestring (patsub);\n\n  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n    mflags |= MATCH_QUOTED;\n\n  if (starsub)\n    mflags |= MATCH_STARSUB;\n\n  /* If the pattern starts with a `/', make sure we skip over it when looking\n     for the replacement delimiter. */\n  delim = skip_to_delim (lpatsub, ((*patsub == '/') ? 1 : 0), \"/\", 0);\n  if (lpatsub[delim] == '/')\n    {\n      lpatsub[delim] = 0;\n      rep = lpatsub + delim + 1;\n    }\n  else\n    rep = (char *)NULL;\n\n  if (rep && *rep == '\\0')\n    rep = (char *)NULL;\n\n  /* Perform the same expansions on the pattern as performed by the\n     pattern removal expansions. */\n  pat = getpattern (lpatsub, quoted, 1);\n\n  if (rep)\n    {\n      /* We want to perform quote removal on the expanded replacement even if\n\t the entire expansion is double-quoted because the parser and string\n\t extraction functions treated quotes in the replacement string as\n\t special.  THIS IS NOT BACKWARDS COMPATIBLE WITH BASH-4.2. */\n      if (shell_compatibility_level > 42)\n\trep = expand_string_if_necessary (rep, quoted & ~(Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT), expand_string_unsplit);\n      /* This is the bash-4.2 code. */\n      else if ((mflags & MATCH_QUOTED) == 0)\n\trep = expand_string_if_necessary (rep, quoted, expand_string_unsplit);\n      else\n\trep = expand_string_to_string_internal (rep, quoted, expand_string_unsplit);\n    }\n\n  /* ksh93 doesn't allow the match specifier to be a part of the expanded\n     pattern.  This is an extension.  Make sure we don't anchor the pattern\n     at the beginning or end of the string if we're doing global replacement,\n     though. */\n  p = pat;\n  if (mflags & MATCH_GLOBREP)\n    mflags |= MATCH_ANY;\n  else if (pat && pat[0] == '#')\n    {\n      mflags |= MATCH_BEG;\n      p++;\n    }\n  else if (pat && pat[0] == '%')\n    {\n      mflags |= MATCH_END;\n      p++;\n    }\n  else\n    mflags |= MATCH_ANY;\n\n  /* OK, we now want to substitute REP for PAT in VAL.  If\n     flags & MATCH_GLOBREP is non-zero, the substitution is done\n     everywhere, otherwise only the first occurrence of PAT is\n     replaced.  The pattern matching code doesn't understand\n     CTLESC quoting CTLESC and CTLNUL so we use the dequoted variable\n     values passed in (VT_VARIABLE) so the pattern substitution\n     code works right.  We need to requote special chars after\n     we're done for VT_VARIABLE and VT_ARRAYMEMBER, and for the\n     other cases if QUOTED == 0, since the posparams and arrays\n     indexed by * or @ do special things when QUOTED != 0. */\n\n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp = pat_subst (val, p, rep, mflags);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp)\n\t{\n\t  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n    case VT_POSPARMS:\n      temp = pos_params_pat_subst (val, p, rep, mflags);\n      if (temp && (mflags & MATCH_QUOTED) == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n      temp = assoc_p (v) ? assoc_patsub (assoc_cell (v), p, rep, mflags)\n\t\t\t : array_patsub (array_cell (v), p, rep, mflags);\n      /* Don't call quote_escapes anymore; array_patsub calls\n\t array_quote_escapes as appropriate before adding the\n\t space separators; ditto for assoc_patsub. */\n      break;\n#endif\n    }\n\n  FREE (pat);\n  FREE (rep);\n  free (lpatsub);\n\n  return temp;\n}"
}