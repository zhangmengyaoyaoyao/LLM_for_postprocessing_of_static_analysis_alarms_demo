{
    "Project": "gawk",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "dfa.c",
    "message": "Access to field 'invert' results in a dereference of a null pointer (loaded from variable 'work_mbc')",
    "warning_function_name": "parse_bracket_exp",
    "warning_line": "work_mbc->invert = invert;",
    "warning_context": "                        {\n                          work_mbc->ranges[work_mbc->nranges].beg\n                            = towupper (wc);\n                          work_mbc->ranges[work_mbc->nranges++].end\n                            = towupper (wc2);\n                        }\n                    }\n                }\n              else if (using_simple_locale ())\n                {\n                  for (c1 = c; c1 <= c2; c1++)\n                    setbit (c1, ccl);\n                  if (case_fold)\n                    {\n                      int uc = toupper (c);\n                      int uc2 = toupper (c2);\n                      for (c1 = 0; c1 < NOTCHAR; c1++)\n                        {\n                          int uc1 = toupper (c1);\n                          if (uc <= uc1 && uc1 <= uc2)\n                            setbit (c1, ccl);\n                        }\n                    }\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* In the case [x-], the - is an ordinary hyphen,\n             which is left in c1, the lookahead character.  */\n          lexptr -= cur_mb_len;\n          lexleft += cur_mb_len;\n        }\n\n      colon_warning_state |= (c == ':') ? 2 : 4;\n\n      if (!dfa->multibyte)\n        {\n          if (case_fold)\n            setbit_case_fold_c (c, ccl);\n          else\n            setbit (c, ccl);\n          continue;\n        }\n\n      if (wc == WEOF)\n        known_bracket_exp = false;\n      else\n        {\n          wchar_t folded[CASE_FOLDED_BUFSIZE + 1];\n          int i;\n          int n = (case_fold ? case_folded_counterparts (wc, folded + 1) + 1\n                   : 1);\n          folded[0] = wc;\n          for (i = 0; i < n; i++)\n            if (!setbit_wc (folded[i], ccl))\n              {\n                work_mbc->chars\n                  = maybe_realloc (work_mbc->chars, work_mbc->nchars,\n                                   &chars_al, sizeof *work_mbc->chars);\n                work_mbc->chars[work_mbc->nchars++] = folded[i];\n              }\n        }\n    }\n  while ((wc = wc1, (c = c1) != ']'));\n\n  if (colon_warning_state == 7)\n    dfawarn (_(\"character class syntax is [[:space:]], not [:space:]\"));\n\n  if (! known_bracket_exp)\n    return BACKREF;\n\n  if (dfa->multibyte)\n    {\n      static charclass zeroclass;\n      work_mbc->invert = invert;\n      work_mbc->cset = equal (ccl, zeroclass) ? -1 : charclass_index (ccl);\n      return MBCSET;\n    }\n\n  if (invert)\n    {\n      assert (!dfa->multibyte);\n      notset (ccl);\n      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)\n        clrbit (eolbyte, ccl);\n    }\n\n  return CSET + charclass_index (ccl);\n}\n\n#define PUSH_LEX_STATE(s)\t\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      char const *lexptr_saved = lexptr;\t\\\n      size_t lexleft_saved = lexleft;\t\t\\\n      lexptr = (s);\t\t\t\t\\\n"
}