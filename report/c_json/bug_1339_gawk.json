{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "awkgram.y",
    "message": "Offset added: 33 (⇐ 1 + 32) Size: [0, +oo] by call to `bcalloc`.",
    "warning_function_name": "optimize_assignment",
    "warning_line": "return list_append(exp, instruction(Op_pop));",
    "warning_context": "\t\t\t\ti3 = i2->nexti;\n\t\t\t\tassert(i3->opcode == Op_push_lhs);\n\t\t\t\ti3->opcode = Op_assign_concat;\t/* change Op_push_lhs to Op_assign_concat */\n\t\t\t\ti3->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_field_spec_lhs:\n\t\t\tif (i2->nexti->opcode == Op_assign\n\t\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_field_assign\n\t\t\t) {\n\t\t\t\t/* $n = .. */\n\t\t\t\ti2->opcode = Op_store_field;\n\t\t\t\tbcfree(i2->nexti);  /* Op_assign */\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_field_assign */\n\t\t\t\texp->lasti = i2;    /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_array:\n\t\t\tif (i2->nexti->nexti->opcode == Op_subscript_lhs) {\n\t\t\t\ti3 = i2->nexti->nexti;\n\t\t\t\tif (i3->sub_count == 1\n\t\t\t\t\t\t&& i3->nexti == i1\n\t\t\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t\t) {\n\t\t\t\t\t/* array[sub] = .. */\n\t\t\t\t\ti3->opcode = Op_store_sub;\n\t\t\t\t\ti3->memory = i2->memory;\n\t\t\t\t\ti3->expr_count = 1;  /* sub_count shadows memory,\n                                          * so use expr_count instead.\n\t\t\t\t                          */\n\t\t\t\t\ti3->nexti = NULL;\n\t\t\t\t\ti2->opcode = Op_no_op;\t\t\t\t\t\n\t\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\t\treturn exp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_lhs:\n\t\t\tif (i2->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t) {\n\t\t\t\t/* var = .. */\n\t\t\t\ti2->opcode = Op_store_var;\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i2;     /* update Op_list */\n\n\t\t\t\ti3 = exp->nexti;\n\t\t\t\tif (i3->opcode == Op_push_i\n\t\t\t\t\t&& (i3->memory->flags & INTLSTR) == 0\n\t\t\t\t\t&& i3->nexti == i2\n\t\t\t\t) {\n\t\t\t\t\t/* constant initializer */ \n\t\t\t\t\ti2->initval = i3->memory;\n\t\t\t\t\tbcfree(i3);\n\t\t\t\t\texp->nexti = i2;\n\t\t\t\t} else\n\t\t\t\t\ti2->initval = NULL;\n\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no optimization  */\n\treturn list_append(exp, instruction(Op_pop));\n}\n\n\n/* mk_getline --- make instructions for getline */\n\nstatic INSTRUCTION *\nmk_getline(INSTRUCTION *op, INSTRUCTION *var, INSTRUCTION *redir, int redirtype)\n{\n\tINSTRUCTION *ip;\n\tINSTRUCTION *tp;\n\tINSTRUCTION *asgn = NULL;\n\n\t/*\n\t *  getline [var] < [file]\n\t *\n\t *  [ file (simp_exp)]\n\t *  [ [ var ] ]\n\t *  [ Op_K_getline_redir|NULL|redir_type|into_var]\n\t *  [ [var_assign] ] \n\t *\n\t */\n"
}