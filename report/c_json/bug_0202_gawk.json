{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t\t\treturn make_string(\"\", 0);",
    "Code_function": "do_substr(int nargs)\n{\n\tNODE *t1;\n\tNODE *r;\n\tsize_t indx;\n\tsize_t length = 0;\n\tdouble d_index = 0, d_length = 0;\n\tsize_t src_len;\n\n\tif (nargs == 3) {\n\t\tt1 = POP_NUMBER();\n\t\td_length = get_number_d(t1);\n\t\tDEREF(t1);\n\t}\n\n\tt1 = POP_NUMBER();\n\td_index = get_number_d(t1);\n\tDEREF(t1);\n\n\tt1 = POP_STRING();\n\n\tif (nargs == 3) {\n\t\tif (! (d_length >= 1)) {\n\t\t\tif (do_lint == DO_LINT_ALL)\n\t\t\t\tlintwarn(_(\"substr: length %g is not >= 1\"), d_length);\n\t\t\telse if (do_lint == DO_LINT_INVALID && ! (d_length >= 0))\n\t\t\t\tlintwarn(_(\"substr: length %g is not >= 0\"), d_length);\n\t\t\tDEREF(t1);\n\t\t\t/*\n\t\t\t * Return explicit null string instead of doing\n\t\t\t * dupnode(Nnull_string) so that if the result\n\t\t\t * is checked with the combination of length()\n\t\t\t * and lint, no error is reported about using\n\t\t\t * an uninitialized value. Same thing later, too.\n\t\t\t */\n\t\t\treturn make_string(\"\", 0);\n\t\t}\n\t\tif (do_lint) {\n\t\t\tif (double_to_int(d_length) != d_length)\n\t\t\t\tlintwarn(\n\t\t\t_(\"substr: non-integer length %g will be truncated\"),\n\t\t\t\t\td_length);\n\n\t\t\tif (d_length > SIZE_MAX)\n\t\t\t\tlintwarn(\n\t\t\t_(\"substr: length %g too big for string indexing, truncating to %g\"),\n\t\t\t\t\td_length, (double) SIZE_MAX);\n\t\t}\n\t\tif (d_length < SIZE_MAX)\n\t\t\tlength = d_length;\n\t\telse\n\t\t\tlength = SIZE_MAX;\n\t}\n\n\t/* the weird `! (foo)' tests help catch NaN values. */\n\tif (! (d_index >= 1)) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is invalid, using 1\"),\n\t\t\t\t d_index);\n\t\td_index = 1;\n\t}\n\tif (do_lint && double_to_int(d_index) != d_index)\n\t\tlintwarn(_(\"substr: non-integer start index %g will be truncated\"),\n\t\t\t d_index);\n\n\t/* awk indices are from 1, C's are from 0 */\n\tif (d_index <= SIZE_MAX)\n\t\tindx = d_index - 1;\n\telse\n\t\tindx = SIZE_MAX;\n\n\tif (nargs == 2) {\t/* third arg. missing */\n\t\t/* use remainder of string */\n\t\tlength = t1->stlen - indx;\t/* default to bytes */\n\t\tif (gawk_mb_cur_max > 1) {\n\t\t\tt1 = force_wstring(t1);\n\t\t\tif (t1->wstlen > 0)\t/* use length of wide char string if we have one */\n\t\t\t\tlength = t1->wstlen - indx;\n\t\t}\n\t\td_length = length;\t/* set here in case used in diagnostics, below */\n\t}\n\n\tif (t1->stlen == 0) {\n\t\t/* substr(\"\", 1, 0) produces a warning only if LINT_ALL */\n\t\tif (do_lint && (do_lint == DO_LINT_ALL || ((indx | length) != 0)))\n\t\t\tlintwarn(_(\"substr: source string is zero length\"));\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\n\t/* get total len of input string, for following checks */\n\tif (gawk_mb_cur_max > 1) {\n\t\tt1 = force_wstring(t1);\n\t\tsrc_len = t1->wstlen;\n\t} else\n\t\tsrc_len = t1->stlen;\n\n\tif (indx >= src_len) {\n\t\tif (do_lint)\n\t\t\tlintwarn(_(\"substr: start index %g is past end of string\"),\n\t\t\t\td_index);\n\t\tDEREF(t1);\n\t\treturn make_string(\"\", 0);\n\t}\n\tif (length > src_len - indx) {\n\t\tif (do_lint)\n\t\t\tlintwarn(\n\t_(\"substr: length %g at start index %g exceeds length of first argument (%lu)\"),\n\t\t\td_length, d_index, (unsigned long int) src_len);\n\t\tlength = src_len - indx;\n\t}\n\n\t/* force_wstring() already called */\n\tif (gawk_mb_cur_max == 1 || t1->wstlen == t1->stlen)\n\t\t/* single byte case */\n\t\tr = make_string(t1->stptr + indx, length);\n\telse {\n\t\t/* multibyte case, more work */\n\t\tsize_t result;\n\t\twchar_t *wp;\n\t\tmbstate_t mbs;\n\t\tchar *substr, *cp;\n\n\t\t/*\n\t\t * Convert the wide chars in t1->wstptr back into m.b. chars.\n\t\t * This is pretty grotty, but it's the most straightforward\n\t\t * way to do things.\n\t\t */\n\t\tmemset(& mbs, 0, sizeof(mbs));\n\t\temalloc(substr, char *, (length * gawk_mb_cur_max) + 2, \"do_substr\");\n\t\twp = t1->wstptr + indx;\n\t\tfor (cp = substr; length > 0; length--) {\n\t\t\tresult = wcrtomb(cp, *wp, & mbs);\n\t\t\tif (result == (size_t) -1)\t/* what to do? break seems best */\n\t\t\t\tbreak;\n\t\t\tcp += result;\n\t\t\twp++;\n\t\t}\n\t\t*cp = '\\0';\n\t\tr = make_str_node(substr, cp - substr, ALREADY_MALLOCED);\n\t}\n\n\tDEREF(t1);\n\treturn r;\n}"
}