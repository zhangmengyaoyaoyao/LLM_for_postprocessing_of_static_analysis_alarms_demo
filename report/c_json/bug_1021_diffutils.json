{
    "Project": "diffutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from changes was never initialized.",
    "Code_line": "      changes = briefly_report (changes, cmp->file);",
    "Code_function": "diff_2_files (struct comparison *cmp)\n{\n  int f;\n  struct change *e, *p;\n  struct change *script;\n  int changes;\n\n\n  /* If we have detected that either file is binary,\n     compare the two files as binary.  This can happen\n     only when the first chunk is read.\n     Also, --brief without any --ignore-* options means\n     we can speed things up by treating the files as binary.  */\n\n  if (read_files (cmp->file, files_can_be_treated_as_binary))\n    {\n      /* Files with different lengths must be different.  */\n      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size\n\t  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))\n\t  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))\n\tchanges = 1;\n\n      /* Standard input equals itself.  */\n      else if (cmp->file[0].desc == cmp->file[1].desc)\n\tchanges = 0;\n\n      else\n\t/* Scan both files, a buffer at a time, looking for a difference.  */\n\t{\n\t  /* Allocate same-sized buffers for both files.  */\n\t  size_t lcm_max = PTRDIFF_MAX - 1;\n\t  size_t buffer_size =\n\t    buffer_lcm (sizeof (word),\n\t\t\tbuffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),\n\t\t\t\t    STAT_BLOCKSIZE (cmp->file[1].stat),\n\t\t\t\t    lcm_max),\n\t\t\tlcm_max);\n\t  for (f = 0; f < 2; f++)\n\t    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);\n\n\t  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)\n\t    {\n\t      /* Read a buffer's worth from both files.  */\n\t      for (f = 0; f < 2; f++)\n\t\tif (0 <= cmp->file[f].desc)\n\t\t  file_block_read (&cmp->file[f],\n\t\t\t\t   buffer_size - cmp->file[f].buffered);\n\n\t      /* If the buffers differ, the files differ.  */\n\t      if (cmp->file[0].buffered != cmp->file[1].buffered\n\t\t  || memcmp (cmp->file[0].buffer,\n\t\t\t     cmp->file[1].buffer,\n\t\t\t     cmp->file[0].buffered))\n\t\t{\n\t\t  changes = 1;\n\t\t  break;\n\t\t}\n\n\t      /* If we reach end of file, the files are the same.  */\n\t      if (cmp->file[0].buffered != buffer_size)\n\t\t{\n\t\t  changes = 0;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      changes = briefly_report (changes, cmp->file);\n    }\n  else\n    {\n      struct context ctxt;\n      lin diags;\n      lin too_expensive;\n\n      /* Allocate vectors for the results of comparison:\n\t a flag for each line of each file, saying whether that line\n\t is an insertion or deletion.\n\t Allocate an extra element, always 0, at each end of each vector.  */\n\n      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;\n      char *flag_space = zalloc (s);\n      cmp->file[0].changed = flag_space + 1;\n      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;\n\n      /* Some lines are obviously insertions or deletions\n\t because they don't match anything.  Detect them now, and\n\t avoid even thinking about them in the main comparison algorithm.  */\n\n      discard_confusing_lines (cmp->file);\n\n      /* Now do the main comparison algorithm, considering just the\n\t undiscarded lines.  */\n\n      ctxt.xvec = cmp->file[0].undiscarded;\n      ctxt.yvec = cmp->file[1].undiscarded;\n      diags = (cmp->file[0].nondiscarded_lines\n\t       + cmp->file[1].nondiscarded_lines + 3);\n      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));\n      ctxt.bdiag = ctxt.fdiag + diags;\n      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;\n      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;\n\n      ctxt.heuristic = speed_large_files;\n\n      /* Set TOO_EXPENSIVE to be approximate square root of input size,\n\t bounded below by 256.  */\n      too_expensive = 1;\n      for (;  diags != 0;  diags >>= 2)\n\ttoo_expensive <<= 1;\n      ctxt.too_expensive = MAX (256, too_expensive);\n\n      files[0] = cmp->file[0];\n      files[1] = cmp->file[1];\n\n      compareseq (0, cmp->file[0].nondiscarded_lines,\n\t\t  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);\n\n      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));\n\n      /* Modify the results slightly to make them prettier\n\t in cases where that can validly be done.  */\n\n      shift_boundaries (cmp->file);\n\n      /* Get the results of comparison in the form of a chain\n\t of 'struct change's -- an edit script.  */\n\n      if (output_style == OUTPUT_ED)\n\tscript = build_reverse_script (cmp->file);\n      else\n\tscript = build_script (cmp->file);\n\n      /* Set CHANGES if we had any diffs.\n\t If some changes are ignored, we must scan the script to decide.  */\n      if (ignore_blank_lines || ignore_regexp.fastmap)\n\t{\n\t  struct change *next = script;\n\t  changes = 0;\n\n\t  while (next && changes == 0)\n\t    {\n\t      struct change *this, *end;\n\t      lin first0, last0, first1, last1;\n\n\t      /* Find a set of changes that belong together.  */\n\t      this = next;\n\t      end = find_change (next);\n\n\t      /* Disconnect them from the rest of the changes, making them\n\t\t a hunk, and remember the rest for next iteration.  */\n\t      next = end->link;\n\t      end->link = 0;\n\n\t      /* Determine whether this hunk is really a difference.  */\n\t      if (analyze_hunk (this, &first0, &last0, &first1, &last1))\n\t\tchanges = 1;\n\n\t      /* Reconnect the script so it will all be freed properly.  */\n\t      end->link = next;\n\t    }\n\t}\n      else\n\tchanges = (script != 0);\n\n      if (brief)\n\tchanges = briefly_report (changes, cmp->file);\n      else\n\t{\n\t  if (changes || !no_diff_means_no_output)\n\t    {\n\t      /* Record info for starting up output,\n\t\t to be used if and when we have some output to print.  */\n\t      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,\n\t\t\t    file_label[1] ? file_label[1] : cmp->file[1].name,\n\t\t\t    cmp->parent != 0);\n\n\t      switch (output_style)\n\t\t{\n\t\tcase OUTPUT_CONTEXT:\n\t\t  print_context_script (script, false);\n\t\t  break;\n\n\t\tcase OUTPUT_UNIFIED:\n\t\t  print_context_script (script, true);\n\t\t  break;\n\n\t\tcase OUTPUT_ED:\n\t\t  print_ed_script (script);\n\t\t  break;\n\n\t\tcase OUTPUT_FORWARD_ED:\n\t\t  pr_forward_ed_script (script);\n\t\t  break;\n\n\t\tcase OUTPUT_RCS:\n\t\t  print_rcs_script (script);\n\t\t  break;\n\n\t\tcase OUTPUT_NORMAL:\n\t\t  print_normal_script (script);\n\t\t  break;\n\n\t\tcase OUTPUT_IFDEF:\n\t\t  print_ifdef_script (script);\n\t\t  break;\n\n\t\tcase OUTPUT_SDIFF:\n\t\t  print_sdiff_script (script);\n\t\t  break;\n\n\t\tdefault:\n\t\t  abort ();\n\t\t}\n\n\t      finish_output ();\n\t    }\n\t}\n\n      free (cmp->file[0].undiscarded);\n\n      free (flag_space);\n\n      for (f = 0; f < 2; f++)\n\t{\n\t  free (cmp->file[f].equivs);\n\t  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);\n\t}\n\n      for (e = script; e; e = p)\n\t{\n\t  p = e->link;\n\t  free (e);\n\t}\n\n      if (! ROBUST_OUTPUT_STYLE (output_style))\n\tfor (f = 0; f < 2; ++f)\n\t  if (cmp->file[f].missing_newline)\n\t    {\n\t      error (0, 0, \"%s: %s\\n\",\n\t\t     file_label[f] ? file_label[f] : cmp->file[f].name,\n\t\t     _(\"No newline at end of file\"));\n\t      changes = 2;\n\t    }\n    }\n\n  if (cmp->file[0].buffer != cmp->file[1].buffer)\n    free (cmp->file[0].buffer);\n  free (cmp->file[1].buffer);\n\n  return changes;\n}"
}