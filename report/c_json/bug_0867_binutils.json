{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "libiberty/cp-demangle.c",
    "message": "Offset: [-1, 2] Size: 4.",
    "warning_function_name": "d_print_comp_inner",
    "warning_line": "adpm[i] = adpm[i - 1];",
    "warning_context": "    case DEMANGLE_COMPONENT_TYPED_NAME:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct demangle_component *typed_name;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_template dpt;\n\n\t/* Pass the name down to the type so that it can be printed in\n\t   the right place for the type.  We also have to pass down\n\t   any CV-qualifiers, which apply to the this parameter.  */\n\thold_modifiers = dpi->modifiers;\n\tdpi->modifiers = 0;\n\ti = 0;\n\ttyped_name = d_left (dc);\n\twhile (typed_name != NULL)\n\t  {\n\t    if (i >= sizeof adpm / sizeof adpm[0])\n\t      {\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    adpm[i].next = dpi->modifiers;\n\t    dpi->modifiers = &adpm[i];\n\t    adpm[i].mod = typed_name;\n\t    adpm[i].printed = 0;\n\t    adpm[i].templates = dpi->templates;\n\t    ++i;\n\n\t    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t      break;\n\n\t    typed_name = d_left (typed_name);\n\t  }\n\n\tif (typed_name == NULL)\n\t  {\n\t    d_print_error (dpi);\n\t    return;\n\t  }\n\n\t/* If typed_name is a template, then it applies to the\n\t   function type as well.  */\n\tif (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)\n\t  {\n\t    dpt.next = dpi->templates;\n\t    dpi->templates = &dpt;\n\t    dpt.template_decl = typed_name;\n\t  }\n\n\t/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n\t   there may be CV-qualifiers on its right argument which\n\t   really apply here; this happens when parsing a class which\n\t   is local to a function.  */\n\tif (typed_name->type == DEMANGLE_COMPONENT_LOCAL_NAME)\n\t  {\n\t    struct demangle_component *local_name;\n\n\t    local_name = d_right (typed_name);\n\t    if (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t      local_name = local_name->u.s_unary_num.sub;\n\t    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS\n\t\t   || local_name->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t\t   || (local_name->type\n\t\t       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))\n\t      {\n\t\tif (i >= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = adpm[i - 1];\n\t\tadpm[i].next = &adpm[i - 1];\n\t\tdpi->modifiers = &adpm[i];\n\n\t\tadpm[i - 1].mod = local_name;\n\t\tadpm[i - 1].printed = 0;\n\t\tadpm[i - 1].templates = dpi->templates;\n\t\t++i;\n\n\t\tlocal_name = d_left (local_name);\n\t      }\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tif (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)\n\t  dpi->templates = dpt.next;\n\n\t/* If the modifiers didn't get printed by the type, print them\n\t   now.  */\n\twhile (i > 0)\n\t  {\n"
}