{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Message": "Dereference of null pointer",
    "Code_line": "\t\t\t\t\t*bp++ = *scan;",
    "Code_function": "do_sub(int nargs, unsigned int flags)\n{\n\tchar *scan;\n\tchar *bp, *cp;\n\tchar *buf = NULL;\n\tsize_t buflen;\n\tchar *matchend;\n\tsize_t len;\n\tchar *matchstart;\n\tchar *text;\n\tsize_t textlen = 0;\n\tchar *repl;\n\tchar *replend;\n\tsize_t repllen;\n\tint sofar;\n\tint ampersands;\n\tint matches = 0;\n\tRegexp *rp;\n\tNODE *s;\t\t/* subst. pattern */\n\tNODE *t;\t\t/* string to make sub. in; $0 if none given */\n\tNODE *tmp;\n\tNODE **lhs = NULL;\n\tlong how_many = 1;\t/* one substitution for sub, also gensub default */\n\tint global;\n\tlong current;\n\tbool lastmatchnonzero;\n\tchar *mb_indices = NULL;\n\n\tif ((flags & GENSUB) != 0) {\n\t\tdouble d;\n\t\tNODE *t1;\n\n\t\ttmp = PEEK(3);\n\t\trp = re_update(tmp);\n\n\t\tt = POP_STRING();\t/* original string */\n\n\t\tt1 = POP_SCALAR();\t/* value of global flag */\n\t\tif ((t1->flags & (STRCUR|STRING)) != 0) {\n\t\t\tif (t1->stlen > 0 && (t1->stptr[0] == 'g' || t1->stptr[0] == 'G'))\n\t\t\t\thow_many = -1;\n\t\t\telse {\n\t\t\t\t(void) force_number(t1);\n\t\t\t\td = get_number_d(t1);\n\t\t\t\tif ((t1->flags & NUMCUR) != 0)\n\t\t\t\t\tgoto set_how_many;\n\n\t\t\t\twarning(_(\"gensub: third argument `%.*s' treated as 1\"),\n\t\t\t\t\t\t(int) t1->stlen, t1->stptr);\n\t\t\t\thow_many = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t(void) force_number(t1);\n\t\t\td = get_number_d(t1);\nset_how_many:\n\t\t\tif (d < 1)\n\t\t\t\thow_many = 1;\n\t\t\telse if (d < LONG_MAX)\n\t\t\t\thow_many = d;\n\t\t\telse\n\t\t\t\thow_many = LONG_MAX;\n\t\t\tif (d <= 0)\n\t\t\t\twarning(_(\"gensub: third argument %g treated as 1\"), d);\n\t\t}\n\t\tDEREF(t1);\n\n\t} else {\n\n\t\t/* take care of regexp early, in case re_update is fatal */\n\n\t\ttmp = PEEK(2);\n\t\trp = re_update(tmp);\n\n\t\tif ((flags & GSUB) != 0)\n\t\t\thow_many = -1;\n\n\t\t/* original string */\n\n\t\tif ((flags & LITERAL) != 0)\n\t\t\tt = POP_STRING();\n\t\telse {\n\t\t\tlhs = POP_ADDRESS();\n\t\t\tt = force_string(*lhs);\n\t\t}\n\t}\n\n\tglobal = (how_many == -1);\n\n\ts = POP_STRING();\t/* replacement text */\n\tdecr_sp();\t\t/* regexp, already updated above */\n\n\t/* do the search early to avoid work on non-match */\n\tif (research(rp, t->stptr, 0, t->stlen, RE_NEED_START) == -1 ||\n\t\t\tRESTART(rp, t->stptr) > t->stlen)\n\t\tgoto done;\n\n\tt->flags |= STRING;\n\n\ttext = t->stptr;\n\ttextlen = t->stlen;\n\n\trepl = s->stptr;\n\treplend = repl + s->stlen;\n\trepllen = replend - repl;\n\n\tampersands = 0;\n\n\t/*\n\t * Some systems' malloc() can't handle being called with an\n\t * argument of zero.  Thus we have to have some special case\n\t * code to check for `repllen == 0'.  This can occur for\n\t * something like:\n\t * \tsub(/foo/, \"\", mystring)\n\t * for example.\n\t */\n\tif (gawk_mb_cur_max > 1 && repllen > 0) {\n\t\temalloc(mb_indices, char *, repllen * sizeof(char), \"do_sub\");\n\t\tindex_multibyte_buffer(repl, mb_indices, repllen);\n\t}\n\n\tfor (scan = repl; scan < replend; scan++) {\n\t\tif ((gawk_mb_cur_max == 1 || (repllen > 0 && mb_indices[scan - repl] == 1))\n\t\t    && (*scan == '&')) {\n\t\t\trepllen--;\n\t\t\tampersands++;\n\t\t} else if (*scan == '\\\\') {\n\t\t\tif ((flags & GENSUB) != 0) {\t/* gensub, behave sanely */\n\t\t\t\tif (isdigit((unsigned char) scan[1])) {\n\t\t\t\t\tampersands++;\n\t\t\t\t\tscan++;\n\t\t\t\t} else {\t/* \\q for any q --> q */\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t}\n\t\t\t} else if (do_posix) {\n\t\t\t\t/* \\& --> &, \\\\ --> \\ */\n\t\t\t\tif (scan[1] == '&' || scan[1] == '\\\\') {\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t} /* else\n\t\t\t\t\tleave alone, it goes into the output */\n\t\t\t} else {\n\t\t\t\t/* gawk default behavior since 1996 */\n\t\t\t\tif (strncmp(scan, \"\\\\\\\\\\\\&\", 4) == 0) {\n\t\t\t\t\t/* \\\\\\& --> \\& */\n\t\t\t\t\trepllen -= 2;\n\t\t\t\t\tscan += 3;\n\t\t\t\t} else if (strncmp(scan, \"\\\\\\\\&\", 3) == 0) {\n\t\t\t\t\t/* \\\\& --> \\<string> */\n\t\t\t\t\tampersands++;\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan += 2;\n\t\t\t\t} else if (scan[1] == '&') {\n\t\t\t\t\t/* \\& --> & */\n\t\t\t\t\trepllen--;\n\t\t\t\t\tscan++;\n\t\t\t\t} /* else\n\t\t\t\t\tleave alone, it goes into the output */\n\t\t\t}\n\t\t}\n\t}\n\n\tlastmatchnonzero = false;\n\n\t/* guesstimate how much room to allocate; +2 forces > 0 */\n\tbuflen = textlen + (ampersands + 1) * repllen + 2;\n\temalloc(buf, char *, buflen + 2, \"do_sub\");\n\tbuf[buflen] = '\\0';\n\tbuf[buflen + 1] = '\\0';\n\n\tbp = buf;\n\tfor (current = 1;; current++) {\n\t\tmatches++;\n\t\tmatchstart = t->stptr + RESTART(rp, t->stptr);\n\t\tmatchend = t->stptr + REEND(rp, t->stptr);\n\n\t\t/*\n\t\t * create the result, copying in parts of the original\n\t\t * string\n\t\t */\n\t\tlen = matchstart - text + repllen\n\t\t      + ampersands * (matchend - matchstart);\n\t\tsofar = bp - buf;\n\t\twhile (buflen < (sofar + len + 1)) {\n\t\t\tbuflen *= 2;\n\t\t\terealloc(buf, char *, buflen, \"sub_common\");\n\t\t\tbp = buf + sofar;\n\t\t}\n\t\tfor (scan = text; scan < matchstart; scan++)\n\t\t\t*bp++ = *scan;\n\t\tif (global || current == how_many) {\n\t\t\t/*\n\t\t\t * If the current match matched the null string,\n\t\t\t * and the last match didn't and did a replacement,\n\t\t\t * and the match of the null string is at the front of\n\t\t\t * the text (meaning right after end of the previous\n\t\t\t * replacement), then skip this one.\n\t\t\t */\n\t\t\tif (matchstart == matchend\n\t\t\t    && lastmatchnonzero\n\t\t\t    && matchstart == text) {\n\t\t\t\tlastmatchnonzero = false;\n\t\t\t\tmatches--;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If replacing all occurrences, or this is the\n\t\t\t * match we want, copy in the replacement text,\n\t\t\t * making substitutions as we go.\n\t\t\t */\n\t\t\tfor (scan = repl; scan < replend; scan++)\n\t\t\t\tif (*scan == '&'\n\t\t\t\t\t/*\n\t\t\t\t\t * Don't test repllen here. A simple \"&\" could\n\t\t\t\t\t * end up with repllen == 0.\n\t\t\t\t\t */\n\t\t\t\t\t&& (gawk_mb_cur_max == 1\n\t\t\t\t\t\t|| mb_indices[scan - repl] == 1)\n\t\t\t\t) {\n\t\t\t\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t} else if (*scan == '\\\\'\n\t\t\t\t\t&& (gawk_mb_cur_max == 1\n\t\t\t\t\t\t|| (repllen > 0 && mb_indices[scan - repl] == 1))\n\t\t\t\t) {\n\t\t\t\t\tif (flags & GENSUB) {\t/* gensub, behave sanely */\n\t\t\t\t\t\tif (isdigit((unsigned char) scan[1])) {\n\t\t\t\t\t\t\tint dig = scan[1] - '0';\n\t\t\t\t\t\t\tif (dig < NUMSUBPATS(rp, t->stptr) && SUBPATSTART(rp, tp->stptr, dig) != -1) {\n\t\t\t\t\t\t\t\tchar *start, *end;\n\n\t\t\t\t\t\t\t\tstart = t->stptr\n\t\t\t\t\t\t\t\t      + SUBPATSTART(rp, t->stptr, dig);\n\t\t\t\t\t\t\t\tend = t->stptr\n\t\t\t\t\t\t\t\t      + SUBPATEND(rp, t->stptr, dig);\n\n\t\t\t\t\t\t\t\tfor (cp = start; cp < end; cp++)\n\t\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t} else\t/* \\q for any q --> q */\n\t\t\t\t\t\t\t*bp++ = *++scan;\n\t\t\t\t\t} else if (do_posix) {\n\t\t\t\t\t\t/* \\& --> &, \\\\ --> \\ */\n\t\t\t\t\t\tif (scan[1] == '&' || scan[1] == '\\\\')\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t*bp++ = *scan;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* gawk default behavior since 1996 */\n\t\t\t\t\t\tif (strncmp(scan, \"\\\\\\\\\\\\&\", 4) == 0) {\n\t\t\t\t\t\t\t/* \\\\\\& --> \\& */\n\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\t*bp++ = '&';\n\t\t\t\t\t\t\tscan += 3;\n\t\t\t\t\t\t} else if (strncmp(scan, \"\\\\\\\\&\", 3) == 0) {\n\t\t\t\t\t\t\t/* \\\\& --> \\<string> */\n\t\t\t\t\t\t\t*bp++ = '\\\\';\n\t\t\t\t\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t\t\t\t\t*bp++ = *cp;\n\t\t\t\t\t\t\tscan += 2;\n\t\t\t\t\t\t} else if (scan[1] == '&') {\n\t\t\t\t\t\t\t/* \\& --> & */\n\t\t\t\t\t\t\t*bp++ = '&';\n\t\t\t\t\t\t\tscan++;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t*bp++ = *scan;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\t*bp++ = *scan;\n\t\t\tif (matchstart != matchend)\n\t\t\t\tlastmatchnonzero = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * don't want this match, skip over it by copying\n\t\t\t * in current text.\n\t\t\t */\n\t\t\tfor (cp = matchstart; cp < matchend; cp++)\n\t\t\t\t*bp++ = *cp;\n\t\t}\n\tempty:\n\t\t/* catch the case of gsub(//, \"blah\", whatever), i.e. empty regexp */\n\t\tif (matchstart == matchend && matchend < text + textlen) {\n\t\t\t*bp++ = *matchend;\n\t\t\tmatchend++;\n\t\t}\n\t\ttextlen = text + textlen - matchend;\n\t\ttext = matchend;\n\n\t\tif ((current >= how_many && ! global)\n\t\t    || ((long) textlen <= 0 && matchstart == matchend)\n\t\t    || research(rp, t->stptr, text - t->stptr, textlen, RE_NEED_START) == -1)\n\t\t\tbreak;\n\n\t}\n\tsofar = bp - buf;\n\tif (buflen - sofar - textlen - 1) {\n\t\tbuflen = sofar + textlen + 2;\n\t\terealloc(buf, char *, buflen, \"do_sub\");\n\t\tbp = buf + sofar;\n\t}\n\tfor (scan = matchend; scan < text + textlen; scan++)\n\t\t*bp++ = *scan;\n\t*bp = '\\0';\n\ttextlen = bp - buf;\n\n\tif (mb_indices != NULL)\n\t\tefree(mb_indices);\n\ndone:\n\tDEREF(s);\n\n\tif ((matches == 0 || (flags & LITERAL) != 0) && buf != NULL) {\n\t\tefree(buf);\n\t\tbuf = NULL;\n\t}\n\n\tif (flags & GENSUB) {\n\t\tif (matches > 0) {\n\t\t\t/* return the result string */\n\t\t\tDEREF(t);\n\t\t\tassert(buf != NULL);\n\t\t\treturn make_str_node(buf, textlen, ALREADY_MALLOCED);\n\t\t}\n\n\t\t/* return the original string */\n\t\treturn t;\n\t}\n\n\t/* For a string literal, must not change the original string. */\n\tif ((flags & LITERAL) != 0)\n\t\tDEREF(t);\n\telse if (matches > 0) {\n\t\tunref(*lhs);\n\t\t*lhs = make_str_node(buf, textlen, ALREADY_MALLOCED);\n\t}\n\n\treturn make_number((AWKNUM) matches);\n}"
}