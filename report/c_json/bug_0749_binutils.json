{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `cache` last assigned on line 1041 could be null and is dereferenced at line 1087, column 4.",
    "Code_line": "\t\t cache->line, cache->file->filename, cache->buffer);",
    "Code_function": "print_source (file_info_type *  current_file,\n\t      list_info_type *  list,\n\t      unsigned int      width)\n{\n#define NUM_CACHE_LINES  3\n  static cached_line cached_lines[NUM_CACHE_LINES];\n  static int next_free_line = 0;\n  cached_line * cache = NULL;\n\n  if (current_file->linenum > list->hll_line\n      && list->hll_line > 0)\n    {\n      /* This can happen with modern optimizing compilers.  The source\n\t lines from the high level language input program are split up\n\t and interleaved, meaning the line number we want to display\n\t (list->hll_line) can have already been displayed.  We have\n\t three choices:\n\n\t   a. Do nothing, since we have already displayed the source\n\t      line.  This was the old behaviour.\n\n\t   b. Display the particular line requested again, but only\n\t      that line.  This is the new behaviour.\n\n\t   c. Display the particular line requested again and reset\n\t      the current_file->line_num value so that we redisplay\n\t      all the following lines as well the next time we\n\t      encounter a larger line number.  */\n      int i;\n\n      /* Check the cache, maybe we already have the line saved.  */\n      for (i = 0; i < NUM_CACHE_LINES; i++)\n\tif (cached_lines[i].file == current_file\n\t    && cached_lines[i].line == list->hll_line)\n\t  {\n\t    cache = cached_lines + i;\n\t    break;\n\t  }\n\n      if (i == NUM_CACHE_LINES)\n\t{\n\t  cache = cached_lines + next_free_line;\n\t  next_free_line ++;\n\t  if (next_free_line == NUM_CACHE_LINES)\n\t    next_free_line = 0;\n\n\t  cache->file = current_file;\n\t  cache->line = list->hll_line;\n\t  cache->buffer[0] = 0;\n\t  rebuffer_line (current_file, cache->line, cache->buffer, width);\n\t}\n\n      emit_line (list, \"%4u:%-13s **** %s\\n\",\n\t\t cache->line, cache->file->filename, cache->buffer);\n      return;\n    }\n\n  if (!current_file->at_end)\n    {\n      int num_lines_shown = 0;\n\n      while (current_file->linenum < list->hll_line\n\t     && !current_file->at_end)\n\t{\n\t  char *p;\n\n\t  cache = cached_lines + next_free_line;\n\t  cache->file = current_file;\n\t  cache->line = current_file->linenum + 1;\n\t  cache->buffer[0] = 0;\n\t  p = buffer_line (current_file, cache->buffer, width);\n\n\t  /* Cache optimization:  If printing a group of lines\n\t     cache the first and last lines in the group.  */\n\t  if (num_lines_shown == 0)\n\t    {\n\t      next_free_line ++;\n\t      if (next_free_line == NUM_CACHE_LINES)\n\t\tnext_free_line = 0;\n\t    }\n\n\t  emit_line (list, \"%4u:%-13s **** %s\\n\",\n\t\t     cache->line, cache->file->filename, p);\n\t  num_lines_shown ++;\n\t}\n    }\n}"
}