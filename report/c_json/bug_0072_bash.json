{
    "project": "bash",
    "tool": "Cppcheck",
    "category": "memleak",
    "file": "lib/glob/glob.c",
    "message": "Memory leak: result",
    "warning_function_name": NaN,
    "warning_line": "return (NULL);",
    "warning_context": "    {\n      /* 3 == 1 for NUL, 1 for slash at end of DIR, 1 for GX_MARKDIRS */\n      result[i] = (char *) malloc (l + strlen (array[i]) + 3);\n\n      if (result[i] == NULL)\n\t{\n\t  int ind;\n\t  for (ind = 0; ind < i; ind++)\n\t    free (result[ind]);\n\t  free (result);\n\t  return (NULL);\n\t}\n\n      strcpy (result[i], dir);\n      if (add_slash)\n\tresult[i][l] = '/';\n      strcpy (result[i] + l + add_slash, array[i]);\n      if (flags & GX_MARKDIRS)\n\t{\n\t  if ((stat (result[i], &sb) == 0) && S_ISDIR (sb.st_mode))\n\t    {\n\t      size_t rlen;\n\t      rlen = strlen (result[i]);\n\t      result[i][rlen] = '/';\n\t      result[i][rlen+1] = '\\0';\n\t    }\n\t}\n    }\n  result[i] = NULL;\n\n  /* Free the input array.  */\n  for (i = 0; array[i] != NULL; i++)\n    free (array[i]);\n  free ((char *) array);\n\n  return (result);\n}\n\n/* Do globbing on PATHNAME.  Return an array of pathnames that match,\n   marking the end of the array with a null-pointer as an element.\n   If no pathnames match, then the array is empty (first element is null).\n   If there isn't enough memory, then return NULL.\n   If a file system error occurs, return -1; `errno' has the error code.  */\nchar **\nglob_filename (pathname, flags)\n     char *pathname;\n     int flags;\n{\n  char **result;\n  unsigned int result_size;\n  char *directory_name, *filename, *dname;\n  unsigned int directory_len;\n  int free_dirname;\t\t\t/* flag */\n  int dflags;\n\n  result = (char **) malloc (sizeof (char *));\n  result_size = 1;\n  if (result == NULL)\n    return (NULL);\n\n  result[0] = NULL;\n\n  directory_name = NULL;\n\n  /* Find the filename.  */\n  filename = strrchr (pathname, '/');\n  if (filename == NULL)\n    {\n      filename = pathname;\n      directory_name = \"\";\n      directory_len = 0;\n      free_dirname = 0;\n    }\n  else\n    {\n      directory_len = (filename - pathname) + 1;\n      directory_name = (char *) malloc (directory_len + 1);\n\n      if (directory_name == 0)\t\t/* allocation failed? */\n\treturn (NULL);\n\n      bcopy (pathname, directory_name, directory_len);\n      directory_name[directory_len] = '\\0';\n      ++filename;\n      free_dirname = 1;\n    }\n\n  /* If directory_name contains globbing characters, then we\n     have to expand the previous levels.  Just recurse. */\n  if (directory_len > 0 && glob_pattern_p (directory_name))\n    {\n      char **directories, *d, *p;\n      register unsigned int i;\n      int all_starstar, last_starstar;\n\n      all_starstar = last_starstar = 0;\n      d = directory_name;\n      dflags = flags & ~GX_MARKDIRS;\n      /* Collapse a sequence of ** patterns separated by one or more slashes\n\t to a single ** terminated by a slash or NUL */\n      if ((flags & GX_GLOBSTAR) && d[0] == '*' && d[1] == '*' && (d[2] == '/' || d[2] == '\\0'))\n"
}