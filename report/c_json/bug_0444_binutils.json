{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "gas/macro.c",
    "message": "Offset: [`ptr->len` + 1, +oo] Size: [1, +oo].",
    "warning_function_name": "buffer_and_nest",
    "warning_line": "while (i < ptr->len && ISWHITE (ptr->ptr[i]))",
    "warning_context": "int\nbuffer_and_nest (const char *from, const char *to, sb *ptr,\n\t\t size_t (*get_line) (sb *))\n{\n  size_t from_len;\n  size_t to_len = strlen (to);\n  int depth = 1;\n  size_t line_start = ptr->len;\n  size_t more = get_line (ptr);\n\n  if (to_len == 4 && strcasecmp (to, \"ENDR\") == 0)\n    {\n      from = NULL;\n      from_len = 0;\n    }\n  else\n    from_len = strlen (from);\n\n  while (more)\n    {\n      /* Try to find the first pseudo op on the line.  */\n      size_t i = line_start;\n      bfd_boolean had_colon = FALSE;\n\n      /* With normal syntax we can suck what we want till we get\n\t to the dot.  With the alternate, labels have to start in\n\t the first column, since we can't tell what's a label and\n\t what's a pseudoop.  */\n\n      if (! LABELS_WITHOUT_COLONS)\n\t{\n\t  /* Skip leading whitespace.  */\n\t  while (i < ptr->len && ISWHITE (ptr->ptr[i]))\n\t    i++;\n\t}\n\n      for (;;)\n\t{\n\t  /* Skip over a label, if any.  */\n\t  if (i >= ptr->len || ! is_name_beginner (ptr->ptr[i]))\n\t    break;\n\t  i++;\n\t  while (i < ptr->len && is_part_of_name (ptr->ptr[i]))\n\t    i++;\n\t  if (i < ptr->len && is_name_ender (ptr->ptr[i]))\n\t    i++;\n\t  /* Skip whitespace.  */\n\t  while (i < ptr->len && ISWHITE (ptr->ptr[i]))\n\t    i++;\n\t  /* Check for the colon.  */\n\t  if (i >= ptr->len || ptr->ptr[i] != ':')\n\t    {\n\t      /* LABELS_WITHOUT_COLONS doesn't mean we cannot have a\n\t\t colon after a label.  If we do have a colon on the\n\t\t first label then handle more than one label on the\n\t\t line, assuming that each label has a colon.  */\n\t      if (LABELS_WITHOUT_COLONS && !had_colon)\n\t\tbreak;\n\t      i = line_start;\n\t      break;\n\t    }\n\t  i++;\n\t  line_start = i;\n\t  had_colon = TRUE;\n\t}\n\n      /* Skip trailing whitespace.  */\n      while (i < ptr->len && ISWHITE (ptr->ptr[i]))\n\ti++;\n\n      if (i < ptr->len && (ptr->ptr[i] == '.'\n\t\t\t   || NO_PSEUDO_DOT\n\t\t\t   || macro_mri))\n\t{\n\t  if (! flag_m68k_mri && ptr->ptr[i] == '.')\n\t    i++;\n\t  if (from == NULL\n\t     && strncasecmp (ptr->ptr + i, \"IRPC\", from_len = 4) != 0\n\t     && strncasecmp (ptr->ptr + i, \"IRP\", from_len = 3) != 0\n\t     && strncasecmp (ptr->ptr + i, \"IREPC\", from_len = 5) != 0\n\t     && strncasecmp (ptr->ptr + i, \"IREP\", from_len = 4) != 0\n\t     && strncasecmp (ptr->ptr + i, \"REPT\", from_len = 4) != 0\n\t     && strncasecmp (ptr->ptr + i, \"REP\", from_len = 3) != 0)\n\t    from_len = 0;\n\t  if ((from != NULL\n\t       ? strncasecmp (ptr->ptr + i, from, from_len) == 0\n\t       : from_len > 0)\n\t      && (ptr->len == (i + from_len)\n\t\t  || ! (is_part_of_name (ptr->ptr[i + from_len])\n\t\t\t|| is_name_ender (ptr->ptr[i + from_len]))))\n\t    depth++;\n\t  if (strncasecmp (ptr->ptr + i, to, to_len) == 0\n\t      && (ptr->len == (i + to_len)\n\t\t  || ! (is_part_of_name (ptr->ptr[i + to_len])\n\t\t\t|| is_name_ender (ptr->ptr[i + to_len]))))\n\t    {\n\t      depth--;\n\t      if (depth == 0)\n\t\t{\n\t\t  /* Reset the string to not include the ending rune.  */\n\t\t  ptr->len = line_start;\n"
}