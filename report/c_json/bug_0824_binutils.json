{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf32-i386.c",
    "message": "Offset: [-202, 33] Size: 34 by call to `elf_i386_tls_transition`.",
    "warning_function_name": "elf_i386_relocate_section",
    "warning_line": "if (! elf_i386_tls_transition (info, input_bfd,",
    "warning_context": "\t      continue;\n\t    }\n\t  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_GOTDESC)\n\t    {\n\t      /* GDesc -> IE transition.\n\t\t It's originally something like:\n\t\t leal x@tlsdesc(%ebx), %eax\n\n\t\t Change it to:\n\t\t movl x@gotntpoff(%ebx), %eax # before xchg %ax,%ax\n\t\t or:\n\t\t movl x@gottpoff(%ebx), %eax # before negl %eax\n\n\t\t Registers other than %eax may be set up here.  */\n\n\t      bfd_vma roff;\n\n\t      /* First, make sure it's a leal adding ebx to a 32-bit\n\t\t offset into any register, although it's probably\n\t\t almost always going to be eax.  */\n\t      roff = rel->r_offset;\n\n\t      /* Now modify the instruction as appropriate.  */\n\t      /* To turn a leal into a movl in the form we use it, it\n\t\t suffices to change the first byte from 0x8d to 0x8b.\n\t\t aoliva FIXME: should we decide to keep the leal, all\n\t\t we have to do is remove the statement below, and\n\t\t adjust the relaxation of R_386_TLS_DESC_CALL.  */\n\t      bfd_put_8 (output_bfd, 0x8b, contents + roff - 2);\n\n\t      if (tls_type == GOT_TLS_IE_BOTH)\n\t\toff += 4;\n\n\t      bfd_put_32 (output_bfd,\n\t\t\t  htab->elf.sgot->output_section->vma\n\t\t\t  + htab->elf.sgot->output_offset + off\n\t\t\t  - htab->elf.sgotplt->output_section->vma\n\t\t\t  - htab->elf.sgotplt->output_offset,\n\t\t\t  contents + roff);\n\t      continue;\n\t    }\n\t  else if (ELF32_R_TYPE (rel->r_info) == R_386_TLS_DESC_CALL)\n\t    {\n\t      /* GDesc -> IE transition.\n\t\t It's originally:\n\t\t call *(%eax)\n\n\t\t Change it to:\n\t\t xchg %ax,%ax\n\t\t or\n\t\t negl %eax\n\t\t depending on how we transformed the TLS_GOTDESC above.\n\t      */\n\n\t      bfd_vma roff;\n\n\t      roff = rel->r_offset;\n\n\t      /* Now modify the instruction as appropriate.  */\n\t      if (tls_type != GOT_TLS_IE_NEG)\n\t\t{\n\t\t  /* xchg %ax,%ax */\n\t\t  bfd_put_8 (output_bfd, 0x66, contents + roff);\n\t\t  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* negl %eax */\n\t\t  bfd_put_8 (output_bfd, 0xf7, contents + roff);\n\t\t  bfd_put_8 (output_bfd, 0xd8, contents + roff + 1);\n\t\t}\n\n\t      continue;\n\t    }\n\t  else\n\t    BFD_ASSERT (FALSE);\n\t  break;\n\n\tcase R_386_TLS_LDM:\n\t  if (! elf_i386_tls_transition (info, input_bfd,\n\t\t\t\t\t input_section, contents,\n\t\t\t\t\t symtab_hdr, sym_hashes,\n\t\t\t\t\t &r_type, GOT_UNKNOWN, rel,\n\t\t\t\t\t relend, h, r_symndx))\n\t    return FALSE;\n\n\t  if (r_type != R_386_TLS_LDM)\n\t    {\n\t      /* LD->LE transition:\n\t\t leal foo(%reg), %eax; call ___tls_get_addr.\n\t\t We change it into:\n\t\t movl %gs:0, %eax; nop; leal 0(%esi,1), %esi.  */\n\t      BFD_ASSERT (r_type == R_386_TLS_LE_32);\n\t      memcpy (contents + rel->r_offset - 2,\n\t\t      \"\\x65\\xa1\\0\\0\\0\\0\\x90\\x8d\\x74\\x26\", 11);\n\t      /* Skip R_386_PC32/R_386_PLT32.  */\n\t      rel++;\n\t      continue;\n\t    }\n\n\t  if (htab->elf.sgot == NULL)\n"
}