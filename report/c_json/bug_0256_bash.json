{
    "Project": "bash",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "lib/glob/glob.c",
    "message": "Offset: 2 Size: 2 by call to `glob_vector`.",
    "warning_function_name": NaN,
    "warning_line": "temp_results = glob_vector (filename,",
    "warning_context": "\n\t      if (result == NULL)\n\t\tgoto memory_error;\n\n\t      for (l = 0; array[l] != NULL; ++l)\n\t\tresult[result_size++ - 1] = array[l];\n\n\t      result[result_size - 1] = NULL;\n\n\t      /* Note that the elements of ARRAY are not freed.  */\n\t      if (array != temp_results)\n\t\tfree ((char *) array);\n\t      else if ((dflags & GX_ALLDIRS) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t\tfree (temp_results);\t/* expanding ** case above */\n\n\t      if (shouldbreak)\n\t\tbreak;\n\t    }\n\t}\n      /* Free the directories.  */\n      for (i = 0; directories[i]; i++)\n\tfree (directories[i]);\n\n      free ((char *) directories);\n\n      return (result);\n    }\n\nonly_filename:\n  /* If there is only a directory name, return it. */\n  if (*filename == '\\0')\n    {\n      result = (char **) realloc ((char *) result, 2 * sizeof (char *));\n      if (result == NULL)\n\treturn (NULL);\n      /* Handle GX_MARKDIRS here. */\n      result[0] = (char *) malloc (directory_len + 1);\n      if (result[0] == NULL)\n\tgoto memory_error;\n      bcopy (directory_name, result[0], directory_len + 1);\n      if (free_dirname)\n\tfree (directory_name);\n      result[1] = NULL;\n      return (result);\n    }\n  else\n    {\n      char **temp_results;\n\n      /* There are no unquoted globbing characters in DIRECTORY_NAME.\n\t Dequote it before we try to open the directory since there may\n\t be quoted globbing characters which should be treated verbatim. */\n      if (directory_len > 0)\n\tdequote_pathname (directory_name);\n\n      /* We allocated a small array called RESULT, which we won't be using.\n\t Free that memory now. */\n      free (result);\n\n      /* Just return what glob_vector () returns appended to the\n\t directory name. */\n      /* If flags & GX_ALLDIRS, we're called recursively */\n      dflags = flags & ~GX_MARKDIRS;\n      if (directory_len == 0)\n\tdflags |= GX_NULLDIR;\n      if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\\0')\n\t{\n\t  dflags |= GX_ALLDIRS|GX_ADDCURDIR;\n#if 0\n\t  /* If we want all directories (dflags & GX_ALLDIRS) and we're not\n\t     being called recursively as something like `echo [star][star]/[star].o'\n\t     ((flags & GX_ALLDIRS) == 0), we want to prevent glob_vector from\n\t     adding a null directory name to the front of the temp_results\n\t     array.  We turn off ADDCURDIR if not called recursively and\n\t     dlen == 0 */\n#endif\n\t  if (directory_len == 0 && (flags & GX_ALLDIRS) == 0)\n\t    dflags &= ~GX_ADDCURDIR;\n\t}\n      temp_results = glob_vector (filename,\n\t\t\t\t  (directory_len == 0 ? \".\" : directory_name),\n\t\t\t\t  dflags);\n\n      if (temp_results == NULL || temp_results == (char **)&glob_error_return)\n\t{\n\t  if (free_dirname)\n\t    free (directory_name);\n\t  QUIT;\t\t\t/* XXX - shell */\n\t  run_pending_traps ();\n\t  return (temp_results);\n\t}\n\n      result = glob_dir_to_array ((dflags & GX_ALLDIRS) ? \"\" : directory_name, temp_results, flags);\n\n      if (free_dirname)\n\tfree (directory_name);\n      return (result);\n    }\n\n  /* We get to memory_error if the program has run out of memory, or\n     if this is the shell, and we have been interrupted. */\n"
}