{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "builtins/evalfile.c",
    "message": "The value read from old_interactive was never initialized.",
    "warning_function_name": "_evalfile",
    "warning_line": "interactive = old_interactive;",
    "warning_context": "\t    memmove (string+i, string+i+1, nr - i);\n\t    nr--;\n\t    /* Even if the `check binary' flag is not set, we want to avoid\n\t       sourcing files with more than 256 null characters -- that\n\t       probably indicates a binary file. */\n\t    if ((flags & FEVAL_BUILTIN) && ++nnull > 256)\n\t      {\n\t\tfree (string);\n\t\t(*errfunc) (_(\"%s: cannot execute binary file\"), filename);\n\t\treturn ((flags & FEVAL_BUILTIN) ? EX_BINARY_FILE : -1);\n\t      }\n          }\n    }\n\n  if (flags & FEVAL_UNWINDPROT)\n    {\n      begin_unwind_frame (\"_evalfile\");\n\n      unwind_protect_int (return_catch_flag);\n      unwind_protect_jmp_buf (return_catch);\n      if (flags & FEVAL_NONINT)\n\tunwind_protect_int (interactive);\n      unwind_protect_int (sourcelevel);\n    }\n  else\n    {\n      COPY_PROCENV (return_catch, old_return_catch);\n      if (flags & FEVAL_NONINT)\n\told_interactive = interactive;\n    }\n\n  if (flags & FEVAL_NONINT)\n    interactive = 0;\n\n  return_catch_flag++;\n  sourcelevel++;\n\n#if defined (ARRAY_VARS)\n  array_push (bash_source_a, (char *)filename);\n  t = itos (executing_line_number ());\n  array_push (bash_lineno_a, t);\n  free (t);\n  array_push (funcname_a, \"source\");\t/* not exactly right */\n#  if defined (DEBUGGER)\n  /* Have to figure out a better way to do this when `source' is supplied\n     arguments */\n  if ((flags & FEVAL_NOPUSHARGS) == 0)\n    {\n      array_push (bash_argv_a, (char *)filename);\n      tt[0] = '1'; tt[1] = '\\0';\n      array_push (bash_argc_a, tt);\n    }\n#  endif\n#endif\n\n  /* set the flags to be passed to parse_and_execute */\n  pflags = SEVAL_RESETLINE;\n  pflags |= (flags & FEVAL_HISTORY) ? 0 : SEVAL_NOHIST;\n\n  if (flags & FEVAL_BUILTIN)\n    result = EXECUTION_SUCCESS;\n\n  return_val = setjmp_nosigs (return_catch);\n\n  /* If `return' was seen outside of a function, but in the script, then\n     force parse_and_execute () to clean up. */\n  if (return_val)\n    {\n      parse_and_execute_cleanup ();\n      result = return_catch_value;\n    }\n  else\n    result = parse_and_execute (string, filename, pflags);\n\n  if (flags & FEVAL_UNWINDPROT)\n    run_unwind_frame (\"_evalfile\");\n  else\n    {\n      if (flags & FEVAL_NONINT)\n\tinteractive = old_interactive;\n      return_catch_flag--;\n      sourcelevel--;\n      COPY_PROCENV (old_return_catch, return_catch);\n    }\n\n#if defined (ARRAY_VARS)\n  /* These two variables cannot be unset, and cannot be affected by the\n     sourced file. */\n  array_pop (bash_source_a);\n  array_pop (bash_lineno_a);\n\n  /* FUNCNAME can be unset, and so can potentially be changed by the\n     sourced file. */\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", nfv, funcname_a);\n  if (nfv == funcname_v)\n    array_pop (funcname_a);\n#  if defined (DEBUGGER)\n  if ((flags & FEVAL_NOPUSHARGS) == 0)\n    {\n      array_pop (bash_argc_a);\n      array_pop (bash_argv_a);\n"
}