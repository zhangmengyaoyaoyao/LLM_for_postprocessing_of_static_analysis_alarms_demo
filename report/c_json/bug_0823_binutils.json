{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "libiberty/cp-demangle.c",
    "message": "pointer `code` last assigned on line 3173 could be null and is dereferenced by call to `strcmp()` at line 3267, column 11.",
    "warning_function_name": "d_expression_1",
    "warning_line": "if (!strcmp (code, \"qu\"))",
    "warning_context": "\n      switch (op->type)\n\t{\n\tdefault:\n\t  return NULL;\n\tcase DEMANGLE_COMPONENT_OPERATOR:\n\t  args = op->u.s_operator.op->args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n\t  args = op->u.s_extended_operator.args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_CAST:\n\t  args = 1;\n\t  break;\n\t}\n\n      switch (args)\n\t{\n\tcase 0:\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_NULLARY, op, NULL);\n\n\tcase 1:\n\t  {\n\t    struct demangle_component *operand;\n\t    int suffix = 0;\n\n\t    if (code && (code[0] == 'p' || code[0] == 'm')\n\t\t&& code[1] == code[0])\n\t      /* pp_ and mm_ are the prefix variants.  */\n\t      suffix = !d_check_char (di, '_');\n\n\t    if (op->type == DEMANGLE_COMPONENT_CAST\n\t\t&& d_check_char (di, '_'))\n\t      operand = d_exprlist (di, 'E');\n\t    else\n\t      operand = d_expression_1 (di);\n\n\t    if (suffix)\n\t      /* Indicate the suffix variant for d_print_comp.  */\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  d_make_comp (di,\n\t\t\t\t\t       DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t       operand, operand));\n\t    else\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  operand);\n\t  }\n\tcase 2:\n\t  {\n\t    struct demangle_component *left;\n\t    struct demangle_component *right;\n\n\t    if (op_is_new_cast (op))\n\t      left = cplus_demangle_type (di);\n\t    else\n\t      left = d_expression_1 (di);\n\t    if (!strcmp (code, \"cl\"))\n\t      right = d_exprlist (di, 'E');\n\t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n\t      {\n\t\tright = d_unqualified_name (di);\n\t\tif (d_peek_char (di) == 'I')\n\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n\t\t\t\t       right, d_template_args (di));\n\t      }\n\t    else\n\t      right = d_expression_1 (di);\n\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t     left, right));\n\t  }\n\tcase 3:\n\t  {\n\t    struct demangle_component *first;\n\t    struct demangle_component *second;\n\t    struct demangle_component *third;\n\n\t    if (!strcmp (code, \"qu\"))\n\t      {\n\t\t/* ?: expression.  */\n\t\tfirst = d_expression_1 (di);\n\t\tsecond = d_expression_1 (di);\n\t\tthird = d_expression_1 (di);\n\t      }\n\t    else if (code[0] == 'n')\n\t      {\n\t\t/* new-expression.  */\n\t\tif (code[1] != 'w' && code[1] != 'a')\n\t\t  return NULL;\n\t\tfirst = d_exprlist (di, '_');\n\t\tsecond = cplus_demangle_type (di);\n\t\tif (d_peek_char (di) == 'E')\n\t\t  {\n\t\t    d_advance (di, 1);\n\t\t    third = NULL;\n\t\t  }\n\t\telse if (d_peek_char (di) == 'p'\n\t\t\t && d_peek_next_char (di) == 'i')\n\t\t  {\n"
}