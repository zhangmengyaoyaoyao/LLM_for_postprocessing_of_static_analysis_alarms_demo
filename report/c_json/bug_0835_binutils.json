{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elflink.c",
    "message": "Offset added: [1, +oo] Size: [0, +oo] by call to `bfd_link_hash_lookup`.",
    "warning_function_name": "elf_link_add_object_symbols",
    "warning_line": "bfd_link_hash_lookup (&htab->root, shortname,",
    "warning_context": "\t      /* Preserve the maximum alignment and size for common\n\t\t symbols even if this dynamic lib isn't on DT_NEEDED\n\t\t since it can still be loaded at run time by another\n\t\t dynamic lib.  */\n\t      if (h->root.type == bfd_link_hash_common)\n\t\t{\n\t\t  size = h->root.u.c.size;\n\t\t  alignment_power = h->root.u.c.p->alignment_power;\n\t\t}\n\t      else\n\t\t{\n\t\t  size = 0;\n\t\t  alignment_power = 0;\n\t\t}\n\t      memcpy (p, old_ent, htab->root.table.entsize);\n\t      old_ent = (char *) old_ent + htab->root.table.entsize;\n\t      h = (struct elf_link_hash_entry *) p;\n\t      if (h->root.type == bfd_link_hash_warning)\n\t\t{\n\t\t  memcpy (h->root.u.i.link, old_ent, htab->root.table.entsize);\n\t\t  old_ent = (char *) old_ent + htab->root.table.entsize;\n\t\t  h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\t\t}\n\t      if (h->root.type == bfd_link_hash_common)\n\t\t{\n\t\t  if (size > h->root.u.c.size)\n\t\t    h->root.u.c.size = size;\n\t\t  if (alignment_power > h->root.u.c.p->alignment_power)\n\t\t    h->root.u.c.p->alignment_power = alignment_power;\n\t\t}\n\t    }\n\t}\n\n      /* Make a special call to the linker \"notice\" function to\n\t tell it that symbols added for crefs may need to be removed.  */\n      if (!(*bed->notice_as_needed) (abfd, info, notice_not_needed))\n\tgoto error_free_vers;\n\n      free (old_tab);\n      objalloc_free_block ((struct objalloc *) htab->root.table.memory,\n\t\t\t   alloc_mark);\n      if (nondeflt_vers != NULL)\n\tfree (nondeflt_vers);\n      return TRUE;\n    }\n\n  if (old_tab != NULL)\n    {\n      if (!(*bed->notice_as_needed) (abfd, info, notice_needed))\n\tgoto error_free_vers;\n      free (old_tab);\n      old_tab = NULL;\n    }\n\n  /* Now that all the symbols from this input file are created, handle\n     .symver foo, foo@BAR such that any relocs against foo become foo@BAR.  */\n  if (nondeflt_vers != NULL)\n    {\n      bfd_size_type cnt, symidx;\n\n      for (cnt = 0; cnt < nondeflt_vers_cnt; ++cnt)\n\t{\n\t  struct elf_link_hash_entry *h = nondeflt_vers[cnt], *hi;\n\t  char *shortname, *p;\n\n\t  p = strchr (h->root.root.string, ELF_VER_CHR);\n\t  if (p == NULL\n\t      || (h->root.type != bfd_link_hash_defined\n\t\t  && h->root.type != bfd_link_hash_defweak))\n\t    continue;\n\n\t  amt = p - h->root.root.string;\n\t  shortname = (char *) bfd_malloc (amt + 1);\n\t  if (!shortname)\n\t    goto error_free_vers;\n\t  memcpy (shortname, h->root.root.string, amt);\n\t  shortname[amt] = '\\0';\n\n\t  hi = (struct elf_link_hash_entry *)\n\t       bfd_link_hash_lookup (&htab->root, shortname,\n\t\t\t\t     FALSE, FALSE, FALSE);\n\t  if (hi != NULL\n\t      && hi->root.type == h->root.type\n\t      && hi->root.u.def.value == h->root.u.def.value\n\t      && hi->root.u.def.section == h->root.u.def.section)\n\t    {\n\t      (*bed->elf_backend_hide_symbol) (info, hi, TRUE);\n\t      hi->root.type = bfd_link_hash_indirect;\n\t      hi->root.u.i.link = (struct bfd_link_hash_entry *) h;\n\t      (*bed->elf_backend_copy_indirect_symbol) (info, h, hi);\n\t      sym_hash = elf_sym_hashes (abfd);\n\t      if (sym_hash)\n\t\tfor (symidx = 0; symidx < extsymcount; ++symidx)\n\t\t  if (sym_hash[symidx] == hi)\n\t\t    {\n\t\t      sym_hash[symidx] = h;\n\t\t      break;\n\t\t    }\n\t    }\n\t  free (shortname);\n\t}\n"
}