{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from fromlen was never initialized.",
    "Code_line": "\t\t  ch = GET ();",
    "Code_function": "do_scrub_chars (size_t (*get) (char *, size_t), char *tostart, size_t tolen)\n{\n  char *to = tostart;\n  char *toend = tostart + tolen;\n  char *from;\n  char *fromend;\n  size_t fromlen;\n  register int ch, ch2 = 0;\n  /* Character that started the string we're working on.  */\n  static char quotechar;\n\n  /*State 0: beginning of normal line\n\t  1: After first whitespace on line (flush more white)\n\t  2: After first non-white (opcode) on line (keep 1white)\n\t  3: after second white on line (into operands) (flush white)\n\t  4: after putting out a .linefile, put out digits\n\t  5: parsing a string, then go to old-state\n\t  6: putting out \\ escape in a \"d string.\n\t  7: no longer used\n\t  8: no longer used\n\t  9: After seeing symbol char in state 3 (keep 1white after symchar)\n\t 10: After seeing whitespace in state 9 (keep white before symchar)\n\t 11: After seeing a symbol character in state 0 (eg a label definition)\n\t -1: output string in out_string and go to the state in old_state\n\t -2: flush text until a '*' '/' is seen, then go to state old_state\n#ifdef TC_V850\n\t 12: After seeing a dash, looking for a second dash as a start\n\t     of comment.\n#endif\n#ifdef DOUBLEBAR_PARALLEL\n\t 13: After seeing a vertical bar, looking for a second\n\t     vertical bar as a parallel expression separator.\n#endif\n#ifdef TC_PREDICATE_START_CHAR\n\t 14: After seeing a predicate start character at state 0, looking\n\t     for a predicate end character as predicate.\n\t 15: After seeing a predicate start character at state 1, looking\n\t     for a predicate end character as predicate.\n#endif\n#ifdef TC_Z80\n\t 16: After seeing an 'a' or an 'A' at the start of a symbol\n\t 17: After seeing an 'f' or an 'F' in state 16\n#endif\n\t  */\n\n  /* I added states 9 and 10 because the MIPS ECOFF assembler uses\n     constructs like ``.loc 1 20''.  This was turning into ``.loc\n     120''.  States 9 and 10 ensure that a space is never dropped in\n     between characters which could appear in an identifier.  Ian\n     Taylor, ian@cygnus.com.\n\n     I added state 11 so that something like \"Lfoo add %r25,%r26,%r27\" works\n     correctly on the PA (and any other target where colons are optional).\n     Jeff Law, law@cs.utah.edu.\n\n     I added state 13 so that something like \"cmp r1, r2 || trap #1\" does not\n     get squashed into \"cmp r1,r2||trap#1\", with the all important space\n     between the 'trap' and the '#1' being eliminated.  nickc@cygnus.com  */\n\n  /* This macro gets the next input character.  */\n\n#define GET()\t\t\t\t\t\t\t\\\n  (from < fromend\t\t\t\t\t\t\\\n   ? * (unsigned char *) (from++)\t\t\t\t\\\n   : (saved_input = NULL,\t\t\t\t\t\\\n      fromlen = (*get) (input_buffer, sizeof input_buffer),\t\\\n      from = input_buffer,\t\t\t\t\t\\\n      fromend = from + fromlen,\t\t\t\t\t\\\n      (fromlen == 0\t\t\t\t\t\t\\\n       ? EOF\t\t\t\t\t\t\t\\\n       : * (unsigned char *) (from++))))\n\n  /* This macro pushes a character back on the input stream.  */\n\n#define UNGET(uch) (*--from = (uch))\n\n  /* This macro puts a character into the output buffer.  If this\n     character fills the output buffer, this macro jumps to the label\n     TOFULL.  We use this rather ugly approach because we need to\n     handle two different termination conditions: EOF on the input\n     stream, and a full output buffer.  It would be simpler if we\n     always read in the entire input stream before processing it, but\n     I don't want to make such a significant change to the assembler's\n     memory usage.  */\n\n#define PUT(pch)\t\t\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      *to++ = (pch);\t\t\t\t\\\n      if (to >= toend)\t\t\t\t\\\n\tgoto tofull;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n  while (0)\n\n  if (saved_input != NULL)\n    {\n      from = saved_input;\n      fromend = from + saved_input_len;\n    }\n  else\n    {\n      fromlen = (*get) (input_buffer, sizeof input_buffer);\n      if (fromlen == 0)\n\treturn 0;\n      from = input_buffer;\n      fromend = from + fromlen;\n    }\n\n  while (1)\n    {\n      /* The cases in this switch end with continue, in order to\n\t branch back to the top of this while loop and generate the\n\t next output character in the appropriate state.  */\n      switch (state)\n\t{\n\tcase -1:\n\t  ch = *out_string++;\n\t  if (*out_string == '\\0')\n\t    {\n\t      state = old_state;\n\t      old_state = 3;\n\t    }\n\t  PUT (ch);\n\t  continue;\n\n\tcase -2:\n\t  for (;;)\n\t    {\n\t      do\n\t\t{\n\t\t  ch = GET ();\n\n\t\t  if (ch == EOF)\n\t\t    {\n\t\t      as_warn (_(\"end of file in comment\"));\n\t\t      goto fromeof;\n\t\t    }\n\n\t\t  if (ch == '\\n')\n\t\t    PUT ('\\n');\n\t\t}\n\t      while (ch != '*');\n\n\t      while ((ch = GET ()) == '*')\n\t\t;\n\n\t      if (ch == EOF)\n\t\t{\n\t\t  as_warn (_(\"end of file in comment\"));\n\t\t  goto fromeof;\n\t\t}\n\n\t      if (ch == '/')\n\t\tbreak;\n\n\t      UNGET (ch);\n\t    }\n\n\t  state = old_state;\n\t  UNGET (' ');\n\t  continue;\n\n\tcase 4:\n\t  ch = GET ();\n\t  if (ch == EOF)\n\t    goto fromeof;\n\t  else if (ch >= '0' && ch <= '9')\n\t    PUT (ch);\n\t  else\n\t    {\n\t      while (ch != EOF && IS_WHITESPACE (ch))\n\t\tch = GET ();\n\t      if (ch == '\"')\n\t\t{\n\t\t  quotechar = ch;\n\t\t  state = 5;\n\t\t  old_state = 3;\n\t\t  PUT (ch);\n\t\t}\n\t      else\n\t\t{\n\t\t  while (ch != EOF && ch != '\\n')\n\t\t    ch = GET ();\n\t\t  state = 0;\n\t\t  PUT (ch);\n\t\t}\n\t    }\n\t  continue;\n\n\tcase 5:\n\t  /* We are going to copy everything up to a quote character,\n\t     with special handling for a backslash.  We try to\n\t     optimize the copying in the simple case without using the\n\t     GET and PUT macros.  */\n\t  {\n\t    char *s;\n\t    ptrdiff_t len;\n\n\t    for (s = from; s < fromend; s++)\n\t      {\n\t\tch = *s;\n\t\tif (ch == '\\\\'\n\t\t    || ch == quotechar\n\t\t    || ch == '\\n')\n\t\t  break;\n\t      }\n\t    len = s - from;\n\t    if (len > toend - to)\n\t      len = toend - to;\n\t    if (len > 0)\n\t      {\n\t\tmemcpy (to, from, len);\n\t\tto += len;\n\t\tfrom += len;\n\t\tif (to >= toend)\n\t\t  goto tofull;\n\t      }\n\t  }\n\n\t  ch = GET ();\n\t  if (ch == EOF)\n\t    {\n\t      /* This buffer is here specifically so\n\t\t that the UNGET below will work.  */\n\t      static char one_char_buf[1];\n\n\t      as_warn (_(\"end of file in string; '%c' inserted\"), quotechar);\n\t      state = old_state;\n\t      from = fromend = one_char_buf + 1;\n\t      fromlen = 1;\n\t      UNGET ('\\n');\n\t      PUT (quotechar);\n\t    }\n\t  else if (ch == quotechar)\n\t    {\n\t      state = old_state;\n\t      PUT (ch);\n\t    }\n#ifndef NO_STRING_ESCAPES\n\t  else if (ch == '\\\\')\n\t    {\n\t      state = 6;\n\t      PUT (ch);\n\t    }\n#endif\n\t  else if (scrub_m68k_mri && ch == '\\n')\n\t    {\n\t      /* Just quietly terminate the string.  This permits lines like\n\t\t   bne\tlabel\tloop if we haven't reach end yet.  */\n\t      state = old_state;\n\t      UNGET (ch);\n\t      PUT ('\\'');\n\t    }\n\t  else\n\t    {\n\t      PUT (ch);\n\t    }\n\t  continue;\n\n\tcase 6:\n\t  state = 5;\n\t  ch = GET ();\n\t  switch (ch)\n\t    {\n\t      /* Handle strings broken across lines, by turning '\\n' into\n\t\t '\\\\' and 'n'.  */\n\t    case '\\n':\n\t      UNGET ('n');\n\t      add_newlines++;\n\t      PUT ('\\\\');\n\t      continue;\n\n\t    case EOF:\n\t      as_warn (_(\"end of file in string; '%c' inserted\"), quotechar);\n\t      PUT (quotechar);\n\t      continue;\n\n\t    case '\"':\n\t    case '\\\\':\n\t    case 'b':\n\t    case 'f':\n\t    case 'n':\n\t    case 'r':\n\t    case 't':\n\t    case 'v':\n\t    case 'x':\n\t    case 'X':\n\t    case '0':\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t      break;\n\n\t    default:\n#ifdef ONLY_STANDARD_ESCAPES\n\t      as_warn (_(\"unknown escape '\\\\%c' in string; ignored\"), ch);\n#endif\n\t      break;\n\t    }\n\t  PUT (ch);\n\t  continue;\n\n#ifdef DOUBLEBAR_PARALLEL\n\tcase 13:\n\t  ch = GET ();\n\t  if (ch != '|')\n\t    abort ();\n\n\t  /* Reset back to state 1 and pretend that we are parsing a\n\t     line from just after the first white space.  */\n\t  state = 1;\n\t  PUT ('|');\n#ifdef TC_TIC6X\n\t  /* \"||^\" is used for SPMASKed instructions.  */\n\t  ch = GET ();\n\t  if (ch == EOF)\n\t    goto fromeof;\n\t  else if (ch == '^')\n\t    PUT ('^');\n\t  else\n\t    UNGET (ch);\n#endif\n\t  continue;\n#endif\n#ifdef TC_Z80\n\tcase 16:\n\t  /* We have seen an 'a' at the start of a symbol, look for an 'f'.  */\n\t  ch = GET ();\n\t  if (ch == 'f' || ch == 'F')\n\t    {\n\t      state = 17;\n\t      PUT (ch);\n\t    }\n\t  else\n\t    {\n\t      state = 9;\n\t      break;\n\t    }\n\tcase 17:\n\t  /* We have seen \"af\" at the start of a symbol,\n\t     a ' here is a part of that symbol.  */\n\t  ch = GET ();\n\t  state = 9;\n\t  if (ch == '\\'')\n\t    /* Change to avoid warning about unclosed string.  */\n\t    PUT ('`');\n\t  else if (ch != EOF)\n\t    UNGET (ch);\n\t  break;\n#endif\n\t}\n\n      /* OK, we are somewhere in states 0 through 4 or 9 through 11.  */\n\n      /* flushchar: */\n      ch = GET ();\n\n#ifdef TC_PREDICATE_START_CHAR\n      if (ch == TC_PREDICATE_START_CHAR && (state == 0 || state == 1))\n\t{\n\t  state += 14;\n\t  PUT (ch);\n\t  continue;\n\t}\n      else if (state == 14 || state == 15)\n\t{\n\t  if (ch == TC_PREDICATE_END_CHAR)\n\t    {\n\t      state -= 14;\n\t      PUT (ch);\n\t      ch = GET ();\n\t    }\n\t  else\n\t    {\n\t      PUT (ch);\n\t      continue;\n\t    }\n\t}\n#endif\n\n    recycle:\n\n#if defined TC_ARM && defined OBJ_ELF\n      /* We need to watch out for .symver directives.  See the comment later\n\t in this function.  */\n      if (symver_state == NULL)\n\t{\n\t  if ((state == 0 || state == 1) && ch == symver_pseudo[0])\n\t    symver_state = symver_pseudo + 1;\n\t}\n      else\n\t{\n\t  /* We advance to the next state if we find the right\n\t     character.  */\n\t  if (ch != '\\0' && (*symver_state == ch))\n\t    ++symver_state;\n\t  else if (*symver_state != '\\0')\n\t    /* We did not get the expected character, or we didn't\n\t       get a valid terminating character after seeing the\n\t       entire pseudo-op, so we must go back to the beginning.  */\n\t    symver_state = NULL;\n\t  else\n\t    {\n\t      /* We've read the entire pseudo-op.  If this is the end\n\t\t of the line, go back to the beginning.  */\n\t      if (IS_NEWLINE (ch))\n\t\tsymver_state = NULL;\n\t    }\n\t}\n#endif /* TC_ARM && OBJ_ELF */\n\n#ifdef TC_M68K\n      /* We want to have pseudo-ops which control whether we are in\n\t MRI mode or not.  Unfortunately, since m68k MRI mode affects\n\t the scrubber, that means that we need a special purpose\n\t recognizer here.  */\n      if (mri_state == NULL)\n\t{\n\t  if ((state == 0 || state == 1)\n\t      && ch == mri_pseudo[0])\n\t    mri_state = mri_pseudo + 1;\n\t}\n      else\n\t{\n\t  /* We advance to the next state if we find the right\n\t     character, or if we need a space character and we get any\n\t     whitespace character, or if we need a '0' and we get a\n\t     '1' (this is so that we only need one state to handle\n\t     ``.mri 0'' and ``.mri 1'').  */\n\t  if (ch != '\\0'\n\t      && (*mri_state == ch\n\t\t  || (*mri_state == ' '\n\t\t      && lex[ch] == LEX_IS_WHITESPACE)\n\t\t  || (*mri_state == '0'\n\t\t      && ch == '1')))\n\t    {\n\t      mri_last_ch = ch;\n\t      ++mri_state;\n\t    }\n\t  else if (*mri_state != '\\0'\n\t\t   || (lex[ch] != LEX_IS_WHITESPACE\n\t\t       && lex[ch] != LEX_IS_NEWLINE))\n\t    {\n\t      /* We did not get the expected character, or we didn't\n\t\t get a valid terminating character after seeing the\n\t\t entire pseudo-op, so we must go back to the\n\t\t beginning.  */\n\t      mri_state = NULL;\n\t    }\n\t  else\n\t    {\n\t      /* We've read the entire pseudo-op.  mips_last_ch is\n\t\t either '0' or '1' indicating whether to enter or\n\t\t leave MRI mode.  */\n\t      do_scrub_begin (mri_last_ch == '1');\n\t      mri_state = NULL;\n\n\t      /* We continue handling the character as usual.  The\n\t\t main gas reader must also handle the .mri pseudo-op\n\t\t to control expression parsing and the like.  */\n\t    }\n\t}\n#endif\n\n      if (ch == EOF)\n\t{\n\t  if (state != 0)\n\t    {\n\t      as_warn (_(\"end of file not at end of a line; newline inserted\"));\n\t      state = 0;\n\t      PUT ('\\n');\n\t    }\n\t  goto fromeof;\n\t}\n\n      switch (lex[ch])\n\t{\n\tcase LEX_IS_WHITESPACE:\n\t  do\n\t    {\n\t      ch = GET ();\n\t    }\n\t  while (ch != EOF && IS_WHITESPACE (ch));\n\t  if (ch == EOF)\n\t    goto fromeof;\n\n\t  if (state == 0)\n\t    {\n\t      /* Preserve a single whitespace character at the\n\t\t beginning of a line.  */\n\t      state = 1;\n\t      UNGET (ch);\n\t      PUT (' ');\n\t      break;\n\t    }\n\n#ifdef KEEP_WHITE_AROUND_COLON\n\t  if (lex[ch] == LEX_IS_COLON)\n\t    {\n\t      /* Only keep this white if there's no white *after* the\n\t\t colon.  */\n\t      ch2 = GET ();\n\t      if (ch2 != EOF)\n\t\tUNGET (ch2);\n\t      if (!IS_WHITESPACE (ch2))\n\t\t{\n\t\t  state = 9;\n\t\t  UNGET (ch);\n\t\t  PUT (' ');\n\t\t  break;\n\t\t}\n\t    }\n#endif\n\t  if (IS_COMMENT (ch)\n\t      || ch == '/'\n\t      || IS_LINE_SEPARATOR (ch)\n\t      || IS_PARALLEL_SEPARATOR (ch))\n\t    {\n\t      if (scrub_m68k_mri)\n\t\t{\n\t\t  /* In MRI mode, we keep these spaces.  */\n\t\t  UNGET (ch);\n\t\t  PUT (' ');\n\t\t  break;\n\t\t}\n\t      goto recycle;\n\t    }\n\n\t  /* If we're in state 2 or 11, we've seen a non-white\n\t     character followed by whitespace.  If the next character\n\t     is ':', this is whitespace after a label name which we\n\t     normally must ignore.  In MRI mode, though, spaces are\n\t     not permitted between the label and the colon.  */\n\t  if ((state == 2 || state == 11)\n\t      && lex[ch] == LEX_IS_COLON\n\t      && ! scrub_m68k_mri)\n\t    {\n\t      state = 1;\n\t      PUT (ch);\n\t      break;\n\t    }\n\n\t  switch (state)\n\t    {\n\t    case 1:\n\t      /* We can arrive here if we leave a leading whitespace\n\t\t character at the beginning of a line.  */\n\t      goto recycle;\n\t    case 2:\n\t      state = 3;\n\t      if (to + 1 < toend)\n\t\t{\n\t\t  /* Optimize common case by skipping UNGET/GET.  */\n\t\t  PUT (' ');\t/* Sp after opco */\n\t\t  goto recycle;\n\t\t}\n\t      UNGET (ch);\n\t      PUT (' ');\n\t      break;\n\t    case 3:\n#ifndef TC_KEEP_OPERAND_SPACES\n\t      /* For TI C6X, we keep these spaces as they may separate\n\t\t functional unit specifiers from operands.  */\n\t      if (scrub_m68k_mri)\n#endif\n\t\t{\n\t\t  /* In MRI mode, we keep these spaces.  */\n\t\t  UNGET (ch);\n\t\t  PUT (' ');\n\t\t  break;\n\t\t}\n\t      goto recycle;\t/* Sp in operands */\n\t    case 9:\n\t    case 10:\n#ifndef TC_KEEP_OPERAND_SPACES\n\t      if (scrub_m68k_mri)\n#endif\n\t\t{\n\t\t  /* In MRI mode, we keep these spaces.  */\n\t\t  state = 3;\n\t\t  UNGET (ch);\n\t\t  PUT (' ');\n\t\t  break;\n\t\t}\n\t      state = 10;\t/* Sp after symbol char */\n\t      goto recycle;\n\t    case 11:\n\t      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)\n\t\tstate = 1;\n\t      else\n\t\t{\n\t\t  /* We know that ch is not ':', since we tested that\n\t\t     case above.  Therefore this is not a label, so it\n\t\t     must be the opcode, and we've just seen the\n\t\t     whitespace after it.  */\n\t\t  state = 3;\n\t\t}\n\t      UNGET (ch);\n\t      PUT (' ');\t/* Sp after label definition.  */\n\t      break;\n\t    default:\n\t      BAD_CASE (state);\n\t    }\n\t  break;\n\n\tcase LEX_IS_TWOCHAR_COMMENT_1ST:\n\t  ch2 = GET ();\n\t  if (ch2 == '*')\n\t    {\n\t      for (;;)\n\t\t{\n\t\t  do\n\t\t    {\n\t\t      ch2 = GET ();\n\t\t      if (ch2 != EOF && IS_NEWLINE (ch2))\n\t\t\tadd_newlines++;\n\t\t    }\n\t\t  while (ch2 != EOF && ch2 != '*');\n\n\t\t  while (ch2 == '*')\n\t\t    ch2 = GET ();\n\n\t\t  if (ch2 == EOF || ch2 == '/')\n\t\t    break;\n\n\t\t  /* This UNGET will ensure that we count newlines\n\t\t     correctly.  */\n\t\t  UNGET (ch2);\n\t\t}\n\n\t      if (ch2 == EOF)\n\t\tas_warn (_(\"end of file in multiline comment\"));\n\n\t      ch = ' ';\n\t      goto recycle;\n\t    }\n#ifdef DOUBLESLASH_LINE_COMMENTS\n\t  else if (ch2 == '/')\n\t    {\n\t      do\n\t\t{\n\t\t  ch = GET ();\n\t\t}\n\t      while (ch != EOF && !IS_NEWLINE (ch));\n\t      if (ch == EOF)\n\t\tas_warn (\"end of file in comment; newline inserted\");\n\t      state = 0;\n\t      PUT ('\\n');\n\t      break;\n\t    }\n#endif\n\t  else\n\t    {\n\t      if (ch2 != EOF)\n\t\tUNGET (ch2);\n\t      if (state == 9 || state == 10)\n\t\tstate = 3;\n\t      PUT (ch);\n\t    }\n\t  break;\n\n\tcase LEX_IS_STRINGQUOTE:\n\t  quotechar = ch;\n\t  if (state == 10)\n\t    {\n\t      /* Preserve the whitespace in foo \"bar\".  */\n\t      UNGET (ch);\n\t      state = 3;\n\t      PUT (' ');\n\n\t      /* PUT didn't jump out.  We could just break, but we\n\t\t know what will happen, so optimize a bit.  */\n\t      ch = GET ();\n\t      old_state = 3;\n\t    }\n\t  else if (state == 9)\n\t    old_state = 3;\n\t  else\n\t    old_state = state;\n\t  state = 5;\n\t  PUT (ch);\n\t  break;\n\n#ifndef IEEE_STYLE\n\tcase LEX_IS_ONECHAR_QUOTE:\n#ifdef H_TICK_HEX\n\t  if (state == 9 && enable_h_tick_hex)\n\t    {\n\t      char c;\n\n\t      c = GET ();\n\t      as_warn (\"'%c found after symbol\", c);\n\t      UNGET (c);\n\t    }\n#endif\n\t  if (state == 10)\n\t    {\n\t      /* Preserve the whitespace in foo 'b'.  */\n\t      UNGET (ch);\n\t      state = 3;\n\t      PUT (' ');\n\t      break;\n\t    }\n\t  ch = GET ();\n\t  if (ch == EOF)\n\t    {\n\t      as_warn (_(\"end of file after a one-character quote; \\\\0 inserted\"));\n\t      ch = 0;\n\t    }\n\t  if (ch == '\\\\')\n\t    {\n\t      ch = GET ();\n\t      if (ch == EOF)\n\t\t{\n\t\t  as_warn (_(\"end of file in escape character\"));\n\t\t  ch = '\\\\';\n\t\t}\n\t      else\n\t\tch = process_escape (ch);\n\t    }\n\t  sprintf (out_buf, \"%d\", (int) (unsigned char) ch);\n\n\t  /* None of these 'x constants for us.  We want 'x'.  */\n\t  if ((ch = GET ()) != '\\'')\n\t    {\n#ifdef REQUIRE_CHAR_CLOSE_QUOTE\n\t      as_warn (_(\"missing close quote; (assumed)\"));\n#else\n\t      if (ch != EOF)\n\t\tUNGET (ch);\n#endif\n\t    }\n\t  if (strlen (out_buf) == 1)\n\t    {\n\t      PUT (out_buf[0]);\n\t      break;\n\t    }\n\t  if (state == 9)\n\t    old_state = 3;\n\t  else\n\t    old_state = state;\n\t  state = -1;\n\t  out_string = out_buf;\n\t  PUT (*out_string++);\n\t  break;\n#endif\n\n\tcase LEX_IS_COLON:\n#ifdef KEEP_WHITE_AROUND_COLON\n\t  state = 9;\n#else\n\t  if (state == 9 || state == 10)\n\t    state = 3;\n\t  else if (state != 3)\n\t    state = 1;\n#endif\n\t  PUT (ch);\n\t  break;\n\n\tcase LEX_IS_NEWLINE:\n\t  /* Roll out a bunch of newlines from inside comments, etc.  */\n\t  if (add_newlines)\n\t    {\n\t      --add_newlines;\n\t      UNGET (ch);\n\t    }\n\t  /* Fall through.  */\n\n\tcase LEX_IS_LINE_SEPARATOR:\n\t  state = 0;\n\t  PUT (ch);\n\t  break;\n\n\tcase LEX_IS_PARALLEL_SEPARATOR:\n\t  state = 1;\n\t  PUT (ch);\n\t  break;\n\n#ifdef TC_V850\n\tcase LEX_IS_DOUBLEDASH_1ST:\n\t  ch2 = GET ();\n\t  if (ch2 != '-')\n\t    {\n\t      if (ch2 != EOF)\n\t\tUNGET (ch2);\n\t      goto de_fault;\n\t    }\n\t  /* Read and skip to end of line.  */\n\t  do\n\t    {\n\t      ch = GET ();\n\t    }\n\t  while (ch != EOF && ch != '\\n');\n\n\t  if (ch == EOF)\n\t    as_warn (_(\"end of file in comment; newline inserted\"));\n\n\t  state = 0;\n\t  PUT ('\\n');\n\t  break;\n#endif\n#ifdef DOUBLEBAR_PARALLEL\n\tcase LEX_IS_DOUBLEBAR_1ST:\n\t  ch2 = GET ();\n\t  if (ch2 != EOF)\n\t    UNGET (ch2);\n\t  if (ch2 != '|')\n\t    goto de_fault;\n\n\t  /* Handle '||' in two states as invoking PUT twice might\n\t     result in the first one jumping out of this loop.  We'd\n\t     then lose track of the state and one '|' char.  */\n\t  state = 13;\n\t  PUT ('|');\n\t  break;\n#endif\n\tcase LEX_IS_LINE_COMMENT_START:\n\t  /* FIXME-someday: The two character comment stuff was badly\n\t     thought out.  On i386, we want '/' as line comment start\n\t     AND we want C style comments.  hence this hack.  The\n\t     whole lexical process should be reworked.  xoxorich.  */\n\t  if (ch == '/')\n\t    {\n\t      ch2 = GET ();\n\t      if (ch2 == '*')\n\t\t{\n\t\t  old_state = 3;\n\t\t  state = -2;\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  UNGET (ch2);\n\t\t}\n\t    }\n\n\t  if (state == 0 || state == 1)\t/* Only comment at start of line.  */\n\t    {\n\t      int startch;\n\n\t      startch = ch;\n\n\t      do\n\t\t{\n\t\t  ch = GET ();\n\t\t}\n\t      while (ch != EOF && IS_WHITESPACE (ch));\n\n\t      if (ch == EOF)\n\t\t{\n\t\t  as_warn (_(\"end of file in comment; newline inserted\"));\n\t\t  PUT ('\\n');\n\t\t  break;\n\t\t}\n\n\t      if (ch < '0' || ch > '9' || state != 0 || startch != '#')\n\t\t{\n\t\t  /* Not a cpp line.  */\n\t\t  while (ch != EOF && !IS_NEWLINE (ch))\n\t\t    ch = GET ();\n\t\t  if (ch == EOF)\n\t\t    {\n\t\t      as_warn (_(\"end of file in comment; newline inserted\"));\n\t\t      PUT ('\\n');\n\t\t    }\n\t\t  else /* IS_NEWLINE (ch) */\n\t\t    {\n\t\t      /* To process non-zero add_newlines.  */\n\t\t      UNGET (ch);\n\t\t    }\n\t\t  state = 0;\n\t\t  break;\n\t\t}\n\t      /* Looks like `# 123 \"filename\"' from cpp.  */\n\t      UNGET (ch);\n\t      old_state = 4;\n\t      state = -1;\n\t      if (scrub_m68k_mri)\n\t\tout_string = \"\\tlinefile \";\n\t      else\n\t\tout_string = \"\\t.linefile \";\n\t      PUT (*out_string++);\n\t      break;\n\t    }\n\n#ifdef TC_D10V\n\t  /* All insns end in a char for which LEX_IS_SYMBOL_COMPONENT is true.\n\t     Trap is the only short insn that has a first operand that is\n\t     neither register nor label.\n\t     We must prevent exef0f ||trap #1 to degenerate to exef0f ||trap#1 .\n\t     We can't make '#' LEX_IS_SYMBOL_COMPONENT because it is\n\t     already LEX_IS_LINE_COMMENT_START.  However, it is the\n\t     only character in line_comment_chars for d10v, hence we\n\t     can recognize it as such.  */\n\t  /* An alternative approach would be to reset the state to 1 when\n\t     we see '||', '<'- or '->', but that seems to be overkill.  */\n\t  if (state == 10)\n\t    PUT (' ');\n#endif\n\t  /* We have a line comment character which is not at the\n\t     start of a line.  If this is also a normal comment\n\t     character, fall through.  Otherwise treat it as a default\n\t     character.  */\n\t  if (strchr (tc_comment_chars, ch) == NULL\n\t      && (! scrub_m68k_mri\n\t\t  || (ch != '!' && ch != '*')))\n\t    goto de_fault;\n\t  if (scrub_m68k_mri\n\t      && (ch == '!' || ch == '*' || ch == '#')\n\t      && state != 1\n\t      && state != 10)\n\t    goto de_fault;\n\t  /* Fall through.  */\n\tcase LEX_IS_COMMENT_START:\n#if defined TC_ARM && defined OBJ_ELF\n\t  /* On the ARM, `@' is the comment character.\n\t     Unfortunately this is also a special character in ELF .symver\n\t     directives (and .type, though we deal with those another way).\n\t     So we check if this line is such a directive, and treat\n\t     the character as default if so.  This is a hack.  */\n\t  if ((symver_state != NULL) && (*symver_state == 0))\n\t    goto de_fault;\n#endif\n\n#ifdef TC_ARM\n\t  /* For the ARM, care is needed not to damage occurrences of \\@\n\t     by stripping the @ onwards.  Yuck.  */\n\t  if (to > tostart && *(to - 1) == '\\\\')\n\t    /* Do not treat the @ as a start-of-comment.  */\n\t    goto de_fault;\n#endif\n\n#ifdef WARN_COMMENTS\n\t  if (!found_comment)\n\t    as_where (&found_comment_file, &found_comment);\n#endif\n\t  do\n\t    {\n\t      ch = GET ();\n\t    }\n\t  while (ch != EOF && !IS_NEWLINE (ch));\n\t  if (ch == EOF)\n\t    as_warn (_(\"end of file in comment; newline inserted\"));\n\t  state = 0;\n\t  PUT ('\\n');\n\t  break;\n\n#ifdef H_TICK_HEX\n\tcase LEX_IS_H:\n\t  /* Look for strings like H'[0-9A-Fa-f] and if found, replace\n\t     the H' with 0x to make them gas-style hex characters.  */\n\t  if (enable_h_tick_hex)\n\t    {\n\t      char quot;\n\n\t      quot = GET ();\n\t      if (quot == '\\'')\n\t\t{\n\t\t  UNGET ('x');\n\t\t  ch = '0';\n\t\t}\n\t      else\n\t\tUNGET (quot);\n\t    }\n\t  /* FALL THROUGH */\n#endif\n\n\tcase LEX_IS_SYMBOL_COMPONENT:\n\t  if (state == 10)\n\t    {\n\t      /* This is a symbol character following another symbol\n\t\t character, with whitespace in between.  We skipped\n\t\t the whitespace earlier, so output it now.  */\n\t      UNGET (ch);\n\t      state = 3;\n\t      PUT (' ');\n\t      break;\n\t    }\n\n#ifdef TC_Z80\n\t  /* \"af'\" is a symbol containing '\\''.  */\n\t  if (state == 3 && (ch == 'a' || ch == 'A'))\n\t    {\n\t      state = 16;\n\t      PUT (ch);\n\t      ch = GET ();\n\t      if (ch == 'f' || ch == 'F')\n\t\t{\n\t\t  state = 17;\n\t\t  PUT (ch);\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  state = 9;\n\t\t  if (ch == EOF || !IS_SYMBOL_COMPONENT (ch))\n\t\t    {\n\t\t      if (ch != EOF)\n\t\t\tUNGET (ch);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n#endif\n\t  if (state == 3)\n\t    state = 9;\n\n\t  /* This is a common case.  Quickly copy CH and all the\n\t     following symbol component or normal characters.  */\n\t  if (to + 1 < toend\n\t      && mri_state == NULL\n#if defined TC_ARM && defined OBJ_ELF\n\t      && symver_state == NULL\n#endif\n\t      )\n\t    {\n\t      char *s;\n\t      ptrdiff_t len;\n\n\t      for (s = from; s < fromend; s++)\n\t\t{\n\t\t  int type;\n\n\t\t  ch2 = *(unsigned char *) s;\n\t\t  type = lex[ch2];\n\t\t  if (type != 0\n\t\t      && type != LEX_IS_SYMBOL_COMPONENT)\n\t\t    break;\n\t\t}\n\n\t      if (s > from)\n\t\t/* Handle the last character normally, for\n\t\t   simplicity.  */\n\t\t--s;\n\n\t      len = s - from;\n\n\t      if (len > (toend - to) - 1)\n\t\tlen = (toend - to) - 1;\n\n\t      if (len > 0)\n\t\t{\n\t\t  PUT (ch);\n\t\t  memcpy (to, from, len);\n\t\t  to += len;\n\t\t  from += len;\n\t\t  if (to >= toend)\n\t\t    goto tofull;\n\t\t  ch = GET ();\n\t\t}\n\t    }\n\n\t  /* Fall through.  */\n\tdefault:\n\tde_fault:\n\t  /* Some relatively `normal' character.  */\n\t  if (state == 0)\n\t    {\n\t      state = 11;\t/* Now seeing label definition.  */\n\t    }\n\t  else if (state == 1)\n\t    {\n\t      state = 2;\t/* Ditto.  */\n\t    }\n\t  else if (state == 9)\n\t    {\n\t      if (!IS_SYMBOL_COMPONENT (ch))\n\t\tstate = 3;\n\t    }\n\t  else if (state == 10)\n\t    {\n\t      if (ch == '\\\\')\n\t\t{\n\t\t  /* Special handling for backslash: a backslash may\n\t\t     be the beginning of a formal parameter (of a\n\t\t     macro) following another symbol character, with\n\t\t     whitespace in between.  If that is the case, we\n\t\t     output a space before the parameter.  Strictly\n\t\t     speaking, correct handling depends upon what the\n\t\t     macro parameter expands into; if the parameter\n\t\t     expands into something which does not start with\n\t\t     an operand character, then we don't want to keep\n\t\t     the space.  We don't have enough information to\n\t\t     make the right choice, so here we are making the\n\t\t     choice which is more likely to be correct.  */\n\t\t  if (to + 1 >= toend)\n\t\t    {\n\t\t      /* If we're near the end of the buffer, save the\n\t\t         character for the next time round.  Otherwise\n\t\t         we'll lose our state.  */\n\t\t      UNGET (ch);\n\t\t      goto tofull;\n\t\t    }\n\t\t  *to++ = ' ';\n\t\t}\n\n\t      state = 3;\n\t    }\n\t  PUT (ch);\n\t  break;\n\t}\n    }\n\n  /*NOTREACHED*/\n\n fromeof:\n  /* We have reached the end of the input.  */\n  return to - tostart;\n\n tofull:\n  /* The output buffer is full.  Save any input we have not yet\n     processed.  */\n  if (fromend > from)\n    {\n      saved_input = from;\n      saved_input_len = fromend - from;\n    }\n  else\n    saved_input = NULL;\n\n  return to - tostart;\n}"
}