{
    "project": "Zephyr",
    "tool": "Cppcheck",
    "category": "Null Pointer Dereference",
    "file": "subsys/net/ip/tcp.c",
    "message": "Either the condition 'context' is redundant or there is possible null pointer dereference: context.",
    "warning_function_name": "NET_CONN_CB",
    "warning_line": "tcp = context->tcp;",
    "warning_context": "NET_CONN_CB(tcp_syn_rcvd)\n{\n\tstruct net_context *context = (struct net_context *)user_data;\n\tstruct net_tcp_hdr *tcp_hdr = proto_hdr->tcp;\n\tstruct net_tcp *tcp;\n\tstruct sockaddr_ptr pkt_src_addr;\n\tstruct sockaddr local_addr;\n\tstruct sockaddr remote_addr;\n\n\tNET_ASSERT(context && context->tcp);\n\n\ttcp = context->tcp;\n\n\tswitch (net_tcp_get_state(tcp)) {\n\tcase NET_TCP_LISTEN:\n\t\tnet_context_set_iface(context, net_pkt_iface(pkt));\n\t\tbreak;\n\tcase NET_TCP_SYN_RCVD:\n\t\tif (net_pkt_iface(pkt) != net_context_get_iface(context)) {\n\t\t\treturn NET_DROP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tNET_DBG(\"Context %p in wrong state %d\",\n\t\t\tcontext, tcp->state);\n\t\treturn NET_DROP;\n\t}\n\n\tnet_pkt_set_context(pkt, context);\n\n\tNET_ASSERT(net_pkt_iface(pkt));\n\n\ttcp_copy_ip_addr_from_hdr(net_pkt_family(pkt), ip_hdr, tcp_hdr,\n\t\t\t\t  &remote_addr, true);\n\ttcp_copy_ip_addr_from_hdr(net_pkt_family(pkt), ip_hdr, tcp_hdr,\n\t\t\t\t  &local_addr, false);\n\n\t/*\n\t * If we receive SYN, we send SYN-ACK and go to SYN_RCVD state.\n\t */\n\tif (NET_TCP_FLAGS(tcp_hdr) == NET_TCP_SYN) {\n\t\tstruct net_tcp_options tcp_opts = {\n\t\t\t.mss = NET_TCP_DEFAULT_MSS,\n\t\t};\n\t\tint opt_totlen;\n\t\tint r;\n\n\t\tnet_tcp_print_recv_info(\"SYN\", pkt, tcp_hdr->src_port);\n\n\t\topt_totlen = NET_TCP_HDR_LEN(tcp_hdr)\n\t\t\t     - sizeof(struct net_tcp_hdr);\n\t\t/* We expect MSS option to be present (opt_totlen > 0),\n\t\t * so call unconditionally.\n\t\t */\n\t\tif (net_tcp_parse_opts(pkt, opt_totlen, &tcp_opts) < 0) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tnet_tcp_change_state(tcp, NET_TCP_SYN_RCVD);\n\n\t\t/* Set TCP seq and ack which are then stored in the backlog */\n\t\tcontext->tcp->send_seq = tcp_init_isn();\n\t\tcontext->tcp->send_ack =\n\t\t\tsys_get_be32(tcp_hdr->seq) + 1;\n\n\t\t/* Get MSS from TCP options here*/\n\n\t\tr = tcp_backlog_syn(pkt, ip_hdr, tcp_hdr,\n\t\t\t\t    context, tcp_opts.mss);\n\t\tif (r < 0) {\n\t\t\tif (r == -EADDRINUSE) {\n\t\t\t\tNET_DBG(\"TCP connection already exists\");\n\t\t\t} else {\n\t\t\t\tNET_DBG(\"No free TCP backlog entries\");\n\t\t\t}\n\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tget_sockaddr_ptr(ip_hdr, tcp_hdr,\n\t\t\t\t net_context_get_family(context),\n\t\t\t\t &pkt_src_addr);\n\t\tsend_syn_ack(context, &pkt_src_addr, &remote_addr);\n\t\tnet_pkt_unref(pkt);\n\t\treturn NET_OK;\n\t}\n\n\t/*\n\t * See RFC 793 chapter 3.4 \"Reset Processing\" and RFC 793, page 65\n\t * for more details.\n\t */\n\tif (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_RST) {\n\n\t\tif (tcp_backlog_rst(pkt, ip_hdr, tcp_hdr) < 0) {\n\t\t\tnet_stats_update_tcp_seg_rsterr(net_pkt_iface(pkt));\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tnet_stats_update_tcp_seg_rst(net_pkt_iface(pkt));\n\n\t\tnet_tcp_print_recv_info(\"RST\", pkt, tcp_hdr->src_port);\n"
}