{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: [2, +oo] Size: 2 by call to `rl_bind_keyseq_in_map`.",
    "Code_line": "    rl_bind_keyseq_in_map (kseq, bash_complete_username, emacs_meta_keymap);",
    "Code_function": "initialize_readline ()\n{\n  rl_command_func_t *func;\n  char kseq[2];\n\n  if (bash_readline_initialized)\n    return;\n\n  rl_terminal_name = get_string_value (\"TERM\");\n  rl_instream = stdin;\n  rl_outstream = stderr;\n\n  /* Allow conditional parsing of the ~/.inputrc file. */\n  rl_readline_name = \"Bash\";\n\n  /* Add bindable names before calling rl_initialize so they may be\n     referenced in the various inputrc files. */\n  rl_add_defun (\"shell-expand-line\", shell_expand_line, -1);\n#ifdef BANG_HISTORY\n  rl_add_defun (\"history-expand-line\", history_expand_line, -1);\n  rl_add_defun (\"magic-space\", tcsh_magic_space, -1);\n#endif\n\n  rl_add_defun (\"shell-forward-word\", bash_forward_shellword, -1);\n  rl_add_defun (\"shell-backward-word\", bash_backward_shellword, -1);\n  rl_add_defun (\"shell-kill-word\", bash_kill_shellword, -1);\n  rl_add_defun (\"shell-backward-kill-word\", bash_backward_kill_shellword, -1);\n\n#ifdef ALIAS\n  rl_add_defun (\"alias-expand-line\", alias_expand_line, -1);\n#  ifdef BANG_HISTORY\n  rl_add_defun (\"history-and-alias-expand-line\", history_and_alias_expand_line, -1);\n#  endif\n#endif\n\n  /* Backwards compatibility. */\n  rl_add_defun (\"insert-last-argument\", rl_yank_last_arg, -1);\n\n  rl_add_defun (\"operate-and-get-next\", operate_and_get_next, -1);\n  rl_add_defun (\"display-shell-version\", display_shell_version, -1);\n  rl_add_defun (\"edit-and-execute-command\", emacs_edit_and_execute_command, -1);\n\n#if defined (BRACE_COMPLETION)\n  rl_add_defun (\"complete-into-braces\", bash_brace_completion, -1);\n#endif\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  rl_add_defun (\"complete-filename\", bash_complete_filename, -1);\n  rl_add_defun (\"possible-filename-completions\", bash_possible_filename_completions, -1);\n  rl_add_defun (\"complete-username\", bash_complete_username, -1);\n  rl_add_defun (\"possible-username-completions\", bash_possible_username_completions, -1);\n  rl_add_defun (\"complete-hostname\", bash_complete_hostname, -1);\n  rl_add_defun (\"possible-hostname-completions\", bash_possible_hostname_completions, -1);\n  rl_add_defun (\"complete-variable\", bash_complete_variable, -1);\n  rl_add_defun (\"possible-variable-completions\", bash_possible_variable_completions, -1);\n  rl_add_defun (\"complete-command\", bash_complete_command, -1);\n  rl_add_defun (\"possible-command-completions\", bash_possible_command_completions, -1);\n  rl_add_defun (\"glob-complete-word\", bash_glob_complete_word, -1);\n  rl_add_defun (\"glob-expand-word\", bash_glob_expand_word, -1);\n  rl_add_defun (\"glob-list-expansions\", bash_glob_list_expansions, -1);\n#endif\n\n  rl_add_defun (\"dynamic-complete-history\", dynamic_complete_history, -1);\n  rl_add_defun (\"dabbrev-expand\", bash_dabbrev_expand, -1);\n\n  /* Bind defaults before binding our custom shell keybindings. */\n  if (RL_ISSTATE(RL_STATE_INITIALIZED) == 0)\n    rl_initialize ();\n\n  /* Bind up our special shell functions. */\n  rl_bind_key_if_unbound_in_map (CTRL('E'), shell_expand_line, emacs_meta_keymap);\n\n#ifdef BANG_HISTORY\n  rl_bind_key_if_unbound_in_map ('^', history_expand_line, emacs_meta_keymap);\n#endif\n\n  rl_bind_key_if_unbound_in_map (CTRL ('O'), operate_and_get_next, emacs_standard_keymap);\n  rl_bind_key_if_unbound_in_map (CTRL ('V'), display_shell_version, emacs_ctlx_keymap);\n\n  /* In Bash, the user can switch editing modes with \"set -o [vi emacs]\",\n     so it is not necessary to allow C-M-j for context switching.  Turn\n     off this occasionally confusing behaviour. */\n  kseq[0] = CTRL('J');\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == rl_vi_editing_mode)\n    rl_unbind_key_in_map (CTRL('J'), emacs_meta_keymap);\n  kseq[0] = CTRL('M');\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == rl_vi_editing_mode)\n    rl_unbind_key_in_map (CTRL('M'), emacs_meta_keymap);\n#if defined (VI_MODE)\n  rl_unbind_key_in_map (CTRL('E'), vi_movement_keymap);\n#endif\n\n#if defined (BRACE_COMPLETION)\n  rl_bind_key_if_unbound_in_map ('{', bash_brace_completion, emacs_meta_keymap); /*}*/\n#endif /* BRACE_COMPLETION */\n\n#if defined (SPECIFIC_COMPLETION_FUNCTIONS)\n  rl_bind_key_if_unbound_in_map ('/', bash_complete_filename, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('/', bash_possible_filename_completions, emacs_ctlx_keymap);\n\n  /* Have to jump through hoops here because there is a default binding for\n     M-~ (rl_tilde_expand) */\n  kseq[0] = '~';\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == 0 || func == rl_tilde_expand)\n    rl_bind_keyseq_in_map (kseq, bash_complete_username, emacs_meta_keymap);\n\n  rl_bind_key_if_unbound_in_map ('~', bash_possible_username_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('@', bash_complete_hostname, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('@', bash_possible_hostname_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('$', bash_complete_variable, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('$', bash_possible_variable_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('!', bash_complete_command, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('!', bash_possible_command_completions, emacs_ctlx_keymap);\n\n  rl_bind_key_if_unbound_in_map ('g', bash_glob_complete_word, emacs_meta_keymap);\n  rl_bind_key_if_unbound_in_map ('*', bash_glob_expand_word, emacs_ctlx_keymap);\n  rl_bind_key_if_unbound_in_map ('g', bash_glob_list_expansions, emacs_ctlx_keymap);\n\n#endif /* SPECIFIC_COMPLETION_FUNCTIONS */\n\n  kseq[0] = TAB;\n  kseq[1] = '\\0';\n  func = rl_function_of_keyseq (kseq, emacs_meta_keymap, (int *)NULL);\n  if (func == 0 || func == rl_tab_insert)\n    rl_bind_key_in_map (TAB, dynamic_complete_history, emacs_meta_keymap);\n\n  /* Tell the completer that we want a crack first. */\n  rl_attempted_completion_function = attempt_shell_completion;\n\n  /* Tell the completer that we might want to follow symbolic links or\n     do other expansion on directory names. */\n  set_directory_hook ();\n\n  rl_filename_rewrite_hook = bash_filename_rewrite_hook;\n\n  rl_filename_stat_hook = bash_filename_stat_hook;\n\n  /* Tell the filename completer we want a chance to ignore some names. */\n  rl_ignore_some_completions_function = filename_completion_ignore;\n\n  /* Bind C-xC-e to invoke emacs and run result as commands. */\n  rl_bind_key_if_unbound_in_map (CTRL ('E'), emacs_edit_and_execute_command, emacs_ctlx_keymap);\n#if defined (VI_MODE)\n  rl_bind_key_if_unbound_in_map ('v', vi_edit_and_execute_command, vi_movement_keymap);\n#  if defined (ALIAS)\n  rl_bind_key_if_unbound_in_map ('@', posix_edit_macros, vi_movement_keymap);\n#  endif\n\n  rl_bind_key_in_map ('\\\\', bash_vi_complete, vi_movement_keymap);\n  rl_bind_key_in_map ('*', bash_vi_complete, vi_movement_keymap);\n  rl_bind_key_in_map ('=', bash_vi_complete, vi_movement_keymap);\n#endif\n\n  rl_completer_quote_characters = \"'\\\"\";\n\n  /* This sets rl_completer_word_break_characters and rl_special_prefixes\n     to the appropriate values, depending on whether or not hostname\n     completion is enabled. */\n  enable_hostname_completion (perform_hostname_completion);\n\n  /* characters that need to be quoted when appearing in filenames. */\n  rl_filename_quote_characters = default_filename_quote_characters;\n  set_filename_bstab (rl_filename_quote_characters);\n\n  rl_filename_quoting_function = bash_quote_filename;\n  rl_filename_dequoting_function = bash_dequote_filename;\n  rl_char_is_quoted_p = char_is_quoted;\n\n#if 0\n  /* This is superfluous and makes it impossible to use tab completion in\n     vi mode even when explicitly binding it in ~/.inputrc.  sv_strict_posix()\n     should already have called posix_readline_initialize() when\n     posixly_correct was set. */\n  if (posixly_correct)\n    posix_readline_initialize (1);\n#endif\n\n  bash_readline_initialized = 1;\n}"
}