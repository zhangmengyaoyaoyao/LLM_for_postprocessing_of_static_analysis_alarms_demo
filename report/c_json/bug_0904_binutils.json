{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "bfd/elflink.c",
    "message": "pointer `s` last assigned on line 6646 could be null and is dereferenced at line 6651, column 7.",
    "warning_function_name": "bfd_elf_size_dynsym_hash_dynstr",
    "warning_line": "s->size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);",
    "warning_context": "\t      amt = bucketcount * sizeof (unsigned long int) * 2;\n\t      amt += maskwords * sizeof (bfd_vma);\n\t      cinfo.bitmask = (bfd_vma *) bfd_malloc (amt);\n\t      if (cinfo.bitmask == NULL)\n\t\t{\n\t\t  free (cinfo.hashcodes);\n\t\t  return FALSE;\n\t\t}\n\n\t      cinfo.counts = (long unsigned int *) (cinfo.bitmask + maskwords);\n\t      cinfo.indx = cinfo.counts + bucketcount;\n\t      cinfo.symindx = dynsymcount - cinfo.nsyms;\n\t      memset (cinfo.bitmask, 0, maskwords * sizeof (bfd_vma));\n\n\t      /* Determine how often each hash bucket is used.  */\n\t      memset (cinfo.counts, 0, bucketcount * sizeof (cinfo.counts[0]));\n\t      for (i = 0; i < cinfo.nsyms; ++i)\n\t\t++cinfo.counts[cinfo.hashcodes[i] % bucketcount];\n\n\t      for (i = 0, cnt = cinfo.symindx; i < bucketcount; ++i)\n\t\tif (cinfo.counts[i] != 0)\n\t\t  {\n\t\t    cinfo.indx[i] = cnt;\n\t\t    cnt += cinfo.counts[i];\n\t\t  }\n\t      BFD_ASSERT (cnt == dynsymcount);\n\t      cinfo.bucketcount = bucketcount;\n\t      cinfo.local_indx = cinfo.min_dynindx;\n\n\t      s->size = (4 + bucketcount + cinfo.nsyms) * 4;\n\t      s->size += cinfo.maskbits / 8;\n\t      contents = (unsigned char *) bfd_zalloc (output_bfd, s->size);\n\t      if (contents == NULL)\n\t\t{\n\t\t  free (cinfo.bitmask);\n\t\t  free (cinfo.hashcodes);\n\t\t  return FALSE;\n\t\t}\n\n\t      s->contents = contents;\n\t      bfd_put_32 (output_bfd, bucketcount, contents);\n\t      bfd_put_32 (output_bfd, cinfo.symindx, contents + 4);\n\t      bfd_put_32 (output_bfd, maskwords, contents + 8);\n\t      bfd_put_32 (output_bfd, cinfo.shift2, contents + 12);\n\t      contents += 16 + cinfo.maskbits / 8;\n\n\t      for (i = 0; i < bucketcount; ++i)\n\t\t{\n\t\t  if (cinfo.counts[i] == 0)\n\t\t    bfd_put_32 (output_bfd, 0, contents);\n\t\t  else\n\t\t    bfd_put_32 (output_bfd, cinfo.indx[i], contents);\n\t\t  contents += 4;\n\t\t}\n\n\t      cinfo.contents = contents;\n\n\t      /* Renumber dynamic symbols, populate .gnu.hash section.  */\n\t      elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t\t      elf_renumber_gnu_hash_syms, &cinfo);\n\n\t      contents = s->contents + 16;\n\t      for (i = 0; i < maskwords; ++i)\n\t\t{\n\t\t  bfd_put (bed->s->arch_size, output_bfd, cinfo.bitmask[i],\n\t\t\t   contents);\n\t\t  contents += bed->s->arch_size / 8;\n\t\t}\n\n\t      free (cinfo.bitmask);\n\t      free (cinfo.hashcodes);\n\t    }\n\t}\n\n      s = bfd_get_linker_section (dynobj, \".dynstr\");\n      BFD_ASSERT (s != NULL);\n\n      elf_finalize_dynstr (output_bfd, info);\n\n      s->size = _bfd_elf_strtab_size (elf_hash_table (info)->dynstr);\n\n      for (dtagcount = 0; dtagcount <= info->spare_dynamic_tags; ++dtagcount)\n\tif (!_bfd_elf_add_dynamic_entry (info, DT_NULL, 0))\n\t  return FALSE;\n    }\n\n  return TRUE;\n}\n\n/* Make sure sec_info_type is cleared if sec_info is cleared too.  */\n\nstatic void\nmerge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,\n\t\t\t    asection *sec)\n{\n  BFD_ASSERT (sec->sec_info_type == SEC_INFO_TYPE_MERGE);\n  sec->sec_info_type = SEC_INFO_TYPE_NONE;\n}\n\n/* Finish SHF_MERGE section merging.  */\n\n"
}