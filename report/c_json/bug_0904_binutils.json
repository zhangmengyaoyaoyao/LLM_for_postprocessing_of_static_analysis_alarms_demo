{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "  if (!assign_section_numbers (abfd, link_info))",
    "Code_function": "_bfd_elf_compute_section_file_positions (bfd *abfd,\n\t\t\t\t\t struct bfd_link_info *link_info)\n{\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  struct fake_section_arg fsargs;\n  bfd_boolean failed;\n  struct bfd_strtab_hash *strtab = NULL;\n  Elf_Internal_Shdr *shstrtab_hdr;\n  bfd_boolean need_symtab;\n\n  if (abfd->output_has_begun)\n    return TRUE;\n\n  /* Do any elf backend specific processing first.  */\n  if (bed->elf_backend_begin_write_processing)\n    (*bed->elf_backend_begin_write_processing) (abfd, link_info);\n\n  if (! prep_headers (abfd))\n    return FALSE;\n\n  /* Post process the headers if necessary.  */\n  (*bed->elf_backend_post_process_headers) (abfd, link_info);\n\n  fsargs.failed = FALSE;\n  fsargs.link_info = link_info;\n  bfd_map_over_sections (abfd, elf_fake_sections, &fsargs);\n  if (fsargs.failed)\n    return FALSE;\n\n  if (!assign_section_numbers (abfd, link_info))\n    return FALSE;\n\n  /* The backend linker builds symbol table information itself.  */\n  need_symtab = (link_info == NULL\n\t\t && (bfd_get_symcount (abfd) > 0\n\t\t     || ((abfd->flags & (EXEC_P | DYNAMIC | HAS_RELOC))\n\t\t\t == HAS_RELOC)));\n  if (need_symtab)\n    {\n      /* Non-zero if doing a relocatable link.  */\n      int relocatable_p = ! (abfd->flags & (EXEC_P | DYNAMIC));\n\n      if (! swap_out_syms (abfd, &strtab, relocatable_p))\n\treturn FALSE;\n    }\n\n  failed = FALSE;\n  if (link_info == NULL)\n    {\n      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);\n      if (failed)\n\treturn FALSE;\n    }\n\n  shstrtab_hdr = &elf_tdata (abfd)->shstrtab_hdr;\n  /* sh_name was set in prep_headers.  */\n  shstrtab_hdr->sh_type = SHT_STRTAB;\n  shstrtab_hdr->sh_flags = 0;\n  shstrtab_hdr->sh_addr = 0;\n  shstrtab_hdr->sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));\n  shstrtab_hdr->sh_entsize = 0;\n  shstrtab_hdr->sh_link = 0;\n  shstrtab_hdr->sh_info = 0;\n  /* sh_offset is set in assign_file_positions_except_relocs.  */\n  shstrtab_hdr->sh_addralign = 1;\n\n  if (!assign_file_positions_except_relocs (abfd, link_info))\n    return FALSE;\n\n  if (need_symtab)\n    {\n      file_ptr off;\n      Elf_Internal_Shdr *hdr;\n\n      off = elf_next_file_pos (abfd);\n\n      hdr = &elf_tdata (abfd)->symtab_hdr;\n      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);\n\n      hdr = &elf_tdata (abfd)->symtab_shndx_hdr;\n      if (hdr->sh_size != 0)\n\toff = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);\n\n      hdr = &elf_tdata (abfd)->strtab_hdr;\n      off = _bfd_elf_assign_file_position_for_section (hdr, off, TRUE);\n\n      elf_next_file_pos (abfd) = off;\n\n      /* Now that we know where the .strtab section goes, write it\n\t out.  */\n      if (bfd_seek (abfd, hdr->sh_offset, SEEK_SET) != 0\n\t  || ! _bfd_stringtab_emit (abfd, strtab))\n\treturn FALSE;\n      _bfd_stringtab_free (strtab);\n    }\n\n  abfd->output_has_begun = TRUE;\n\n  return TRUE;\n}"
}