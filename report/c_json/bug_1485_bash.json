{
    "Project": "bash",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Message": "Access to field 'line' results in a dereference of a null pointer (loaded from variable 'tc')",
    "Code_line": "  line_number = function_line_number = tc->line;",
    "Code_function": "execute_function (var, words, flags, fds_to_close, async, subshell)\n     SHELL_VAR *var;\n     WORD_LIST *words;\n     int flags;\n     struct fd_bitmap *fds_to_close;\n     int async, subshell;\n{\n  int return_val, result;\n  COMMAND *tc, *fc, *save_current;\n  char *debug_trap, *error_trap, *return_trap;\n#if defined (ARRAY_VARS)\n  SHELL_VAR *funcname_v, *nfv, *bash_source_v, *bash_lineno_v;\n  ARRAY *funcname_a;\n  volatile ARRAY *bash_source_a;\n  volatile ARRAY *bash_lineno_a;\n#endif\n  FUNCTION_DEF *shell_fn;\n  char *sfile, *t;\n\n  USE_VAR(fc);\n\n  if (funcnest_max > 0 && funcnest >= funcnest_max)\n    {\n      internal_error (_(\"%s: maximum function nesting level exceeded (%d)\"), var->name, funcnest);\n      funcnest = 0;\t/* XXX - should we reset it somewhere else? */\n      jump_to_top_level (DISCARD);\n    }\n\n#if defined (ARRAY_VARS)\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", funcname_v, funcname_a);\n  GET_ARRAY_FROM_VAR (\"BASH_SOURCE\", bash_source_v, bash_source_a);\n  GET_ARRAY_FROM_VAR (\"BASH_LINENO\", bash_lineno_v, bash_lineno_a);\n#endif\n\n  tc = (COMMAND *)copy_command (function_cell (var));\n  if (tc && (flags & CMD_IGNORE_RETURN))\n    tc->flags |= CMD_IGNORE_RETURN;\n\n  if (subshell == 0)\n    {\n      begin_unwind_frame (\"function_calling\");\n      push_context (var->name, subshell, temporary_env);\n      add_unwind_protect (pop_context, (char *)NULL);\n      unwind_protect_int (line_number);\n      unwind_protect_int (return_catch_flag);\n      unwind_protect_jmp_buf (return_catch);\n      add_unwind_protect (dispose_command, (char *)tc);\n      unwind_protect_pointer (this_shell_function);\n      unwind_protect_int (loop_level);\n      unwind_protect_int (funcnest);\n    }\n  else\n    push_context (var->name, subshell, temporary_env);\t/* don't unwind-protect for subshells */\n\n  temporary_env = (HASH_TABLE *)NULL;\n\n  this_shell_function = var;\n  make_funcname_visible (1);\n\n  debug_trap = TRAP_STRING(DEBUG_TRAP);\n  error_trap = TRAP_STRING(ERROR_TRAP);\n  return_trap = TRAP_STRING(RETURN_TRAP);\n\n  /* The order of the unwind protects for debug_trap, error_trap and\n     return_trap is important here!  unwind-protect commands are run\n     in reverse order of registration.  If this causes problems, take\n     out the xfree unwind-protect calls and live with the small memory leak. */\n\n  /* function_trace_mode != 0 means that all functions inherit the DEBUG trap.\n     if the function has the trace attribute set, it inherits the DEBUG trap */\n  if (debug_trap && ((trace_p (var) == 0) && function_trace_mode == 0))\n    {\n      if (subshell == 0)\n\t{\n\t  debug_trap = savestring (debug_trap);\n\t  add_unwind_protect (xfree, debug_trap);\n\t  add_unwind_protect (set_debug_trap, debug_trap);\n\t}\n      restore_default_signal (DEBUG_TRAP);\n    }\n\n  /* error_trace_mode != 0 means that functions inherit the ERR trap. */\n  if (error_trap && error_trace_mode == 0)\n    {\n      if (subshell == 0)\n\t{\n\t  error_trap = savestring (error_trap);\n\t  add_unwind_protect (xfree, error_trap);\n\t  add_unwind_protect (set_error_trap, error_trap);\n\t}\n      restore_default_signal (ERROR_TRAP);\n    }\n\n  /* Shell functions inherit the RETURN trap if function tracing is on\n     globally or on individually for this function. */\n#if 0\n  if (return_trap && ((trace_p (var) == 0) && function_trace_mode == 0))\n#else\n  if (return_trap && (signal_in_progress (DEBUG_TRAP) || ((trace_p (var) == 0) && function_trace_mode == 0)))\n#endif\n    {\n      if (subshell == 0)\n\t{\n\t  return_trap = savestring (return_trap);\n\t  add_unwind_protect (xfree, return_trap);\n\t  add_unwind_protect (set_return_trap, return_trap);\n\t}\n      restore_default_signal (RETURN_TRAP);\n    }\n\n  funcnest++;\n#if defined (ARRAY_VARS)\n  /* This is quite similar to the code in shell.c and elsewhere. */\n  shell_fn = find_function_def (this_shell_function->name);\n  sfile = shell_fn ? shell_fn->source_file : \"\";\n  array_push ((ARRAY *)funcname_a, this_shell_function->name);\n\n  array_push ((ARRAY *)bash_source_a, sfile);\n  t = itos (executing_line_number ());\n  array_push ((ARRAY *)bash_lineno_a, t);\n  free (t);\n#endif\n\n  /* The temporary environment for a function is supposed to apply to\n     all commands executed within the function body. */\n\n  remember_args (words->next, 1);\n\n  /* Update BASH_ARGV and BASH_ARGC */\n  if (debugging_mode)\n    push_args (words->next);\n\n  /* Number of the line on which the function body starts. */\n  line_number = function_line_number = tc->line;\n\n#if defined (JOB_CONTROL)\n  if (subshell)\n    stop_pipeline (async, (COMMAND *)NULL);\n#endif\n\n  fc = tc;\n\n  return_catch_flag++;\n  return_val = setjmp_nosigs (return_catch);\n\n  if (return_val)\n    {\n      result = return_catch_value;\n      /* Run the RETURN trap in the function's context. */\n      save_current = currently_executing_command;\n      run_return_trap ();\n      currently_executing_command = save_current;\n    }\n  else\n    {\n      /* Run the debug trap here so we can trap at the start of a function's\n\t execution rather than the execution of the body's first command. */\n      showing_function_line = 1;\n      save_current = currently_executing_command;\n      result = run_debug_trap ();\n#if defined (DEBUGGER)\n      /* In debugging mode, if the DEBUG trap returns a non-zero status, we\n\t skip the command. */\n      if (debugging_mode == 0 || result == EXECUTION_SUCCESS)\n\t{\n\t  showing_function_line = 0;\n\t  currently_executing_command = save_current;\n\t  result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);\n\n\t  /* Run the RETURN trap in the function's context */\n\t  save_current = currently_executing_command;\n\t  run_return_trap ();\n\t  currently_executing_command = save_current;\n\t}\n#else\n      result = execute_command_internal (fc, 0, NO_PIPE, NO_PIPE, fds_to_close);\n\n      save_current = currently_executing_command;\n      run_return_trap ();\n      currently_executing_command = save_current;\n#endif\n      showing_function_line = 0;\n    }\n\n  /* Restore BASH_ARGC and BASH_ARGV */\n  if (debugging_mode)\n    pop_args ();\n\n  if (subshell == 0)\n    run_unwind_frame (\"function_calling\");\n\n#if defined (ARRAY_VARS)\n  /* These two variables cannot be unset, and cannot be affected by the\n     function. */\n  array_pop ((ARRAY *)bash_source_a);\n  array_pop ((ARRAY *)bash_lineno_a);\n\n  /* FUNCNAME can be unset, and so can potentially be changed by the\n     function. */\n  GET_ARRAY_FROM_VAR (\"FUNCNAME\", nfv, funcname_a);\n  if (nfv == funcname_v)\n    array_pop (funcname_a);\n#endif\n\n  if (variable_context == 0 || this_shell_function == 0)\n    {\n      make_funcname_visible (0);\n#if defined (PROCESS_SUBSTITUTION)\n      unlink_fifo_list ();\n#endif\n    }\n\n  return (result);\n}"
}