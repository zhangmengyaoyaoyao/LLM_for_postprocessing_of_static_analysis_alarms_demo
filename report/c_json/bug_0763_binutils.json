{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Message": "Offset: [-1+max(2, `rel->r_offset`), `rel->r_offset` - 1] (⇐ [max(2, `rel->r_offset`), `rel->r_offset`] + -1) Size: [1, +oo].",
    "Code_line": "      val = bfd_get_8 (abfd, contents + offset - 1);",
    "Code_function": "elf_x86_64_check_tls_transition (bfd *abfd,\n\t\t\t\t struct bfd_link_info *info,\n\t\t\t\t asection *sec,\n\t\t\t\t bfd_byte *contents,\n\t\t\t\t Elf_Internal_Shdr *symtab_hdr,\n\t\t\t\t struct elf_link_hash_entry **sym_hashes,\n\t\t\t\t unsigned int r_type,\n\t\t\t\t const Elf_Internal_Rela *rel,\n\t\t\t\t const Elf_Internal_Rela *relend)\n{\n  unsigned int val;\n  unsigned long r_symndx;\n  bfd_boolean largepic = FALSE;\n  struct elf_link_hash_entry *h;\n  bfd_vma offset;\n  struct elf_x86_64_link_hash_table *htab;\n\n  /* Get the section contents.  */\n  if (contents == NULL)\n    {\n      if (elf_section_data (sec)->this_hdr.contents != NULL)\n\tcontents = elf_section_data (sec)->this_hdr.contents;\n      else\n\t{\n\t  /* FIXME: How to better handle error condition?  */\n\t  if (!bfd_malloc_and_get_section (abfd, sec, &contents))\n\t    return FALSE;\n\n\t  /* Cache the section contents for elf_link_input_bfd.  */\n\t  elf_section_data (sec)->this_hdr.contents = contents;\n\t}\n    }\n\n  htab = elf_x86_64_hash_table (info);\n  offset = rel->r_offset;\n  switch (r_type)\n    {\n    case R_X86_64_TLSGD:\n    case R_X86_64_TLSLD:\n      if ((rel + 1) >= relend)\n\treturn FALSE;\n\n      if (r_type == R_X86_64_TLSGD)\n\t{\n\t  /* Check transition from GD access model.  For 64bit, only\n\t\t.byte 0x66; leaq foo@tlsgd(%rip), %rdi\n\t\t.word 0x6666; rex64; call __tls_get_addr\n\t     can transit to different access model.  For 32bit, only\n\t\tleaq foo@tlsgd(%rip), %rdi\n\t\t.word 0x6666; rex64; call __tls_get_addr\n\t     can transit to different access model.  For largepic\n\t     we also support:\n\t        leaq foo@tlsgd(%rip), %rdi\n\t        movabsq $__tls_get_addr@pltoff, %rax\n\t        addq $rbx, %rax\n\t        call *%rax.  */\n\n\t  static const unsigned char call[] = { 0x66, 0x66, 0x48, 0xe8 };\n\t  static const unsigned char leaq[] = { 0x66, 0x48, 0x8d, 0x3d };\n\n\t  if ((offset + 12) > sec->size)\n\t    return FALSE;\n\n\t  if (memcmp (contents + offset + 4, call, 4) != 0)\n\t    {\n\t      if (!ABI_64_P (abfd)\n\t\t  || (offset + 19) > sec->size\n\t\t  || offset < 3\n\t\t  || memcmp (contents + offset - 3, leaq + 1, 3) != 0\n\t\t  || memcmp (contents + offset + 4, \"\\x48\\xb8\", 2) != 0\n\t\t  || memcmp (contents + offset + 14, \"\\x48\\x01\\xd8\\xff\\xd0\", 5)\n\t\t     != 0)\n\t\treturn FALSE;\n\t      largepic = TRUE;\n\t    }\n\t  else if (ABI_64_P (abfd))\n\t    {\n\t      if (offset < 4\n\t\t  || memcmp (contents + offset - 4, leaq, 4) != 0)\n\t\treturn FALSE;\n\t    }\n\t  else\n\t    {\n\t      if (offset < 3\n\t\t  || memcmp (contents + offset - 3, leaq + 1, 3) != 0)\n\t\treturn FALSE;\n\t    }\n\t}\n      else\n\t{\n\t  /* Check transition from LD access model.  Only\n\t\tleaq foo@tlsld(%rip), %rdi;\n\t\tcall __tls_get_addr\n\t     can transit to different access model.  For largepic\n\t     we also support:\n\t        leaq foo@tlsld(%rip), %rdi\n\t        movabsq $__tls_get_addr@pltoff, %rax\n\t        addq $rbx, %rax\n\t        call *%rax.  */\n\n\t  static const unsigned char lea[] = { 0x48, 0x8d, 0x3d };\n\n\t  if (offset < 3 || (offset + 9) > sec->size)\n\t    return FALSE;\n\n\t  if (memcmp (contents + offset - 3, lea, 3) != 0)\n\t    return FALSE;\n\n\t  if (0xe8 != *(contents + offset + 4))\n\t    {\n\t      if (!ABI_64_P (abfd)\n\t\t  || (offset + 19) > sec->size\n\t\t  || memcmp (contents + offset + 4, \"\\x48\\xb8\", 2) != 0\n\t\t  || memcmp (contents + offset + 14, \"\\x48\\x01\\xd8\\xff\\xd0\", 5)\n\t\t     != 0)\n\t\treturn FALSE;\n\t      largepic = TRUE;\n\t    }\n\t}\n\n      r_symndx = htab->r_sym (rel[1].r_info);\n      if (r_symndx < symtab_hdr->sh_info)\n\treturn FALSE;\n\n      h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n      /* Use strncmp to check __tls_get_addr since __tls_get_addr\n\t may be versioned.  */\n      return (h != NULL\n\t      && h->root.root.string != NULL\n\t      && (largepic\n\t\t  ? ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLTOFF64\n\t\t  : (ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PC32\n\t\t     || ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLT32))\n\t      && (strncmp (h->root.root.string,\n\t\t\t   \"__tls_get_addr\", 14) == 0));\n\n    case R_X86_64_GOTTPOFF:\n      /* Check transition from IE access model:\n\t\tmov foo@gottpoff(%rip), %reg\n\t\tadd foo@gottpoff(%rip), %reg\n       */\n\n      /* Check REX prefix first.  */\n      if (offset >= 3 && (offset + 4) <= sec->size)\n\t{\n\t  val = bfd_get_8 (abfd, contents + offset - 3);\n\t  if (val != 0x48 && val != 0x4c)\n\t    {\n\t      /* X32 may have 0x44 REX prefix or no REX prefix.  */\n\t      if (ABI_64_P (abfd))\n\t\treturn FALSE;\n\t    }\n\t}\n      else\n\t{\n\t  /* X32 may not have any REX prefix.  */\n\t  if (ABI_64_P (abfd))\n\t    return FALSE;\n\t  if (offset < 2 || (offset + 3) > sec->size)\n\t    return FALSE;\n\t}\n\n      val = bfd_get_8 (abfd, contents + offset - 2);\n      if (val != 0x8b && val != 0x03)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      return (val & 0xc7) == 5;\n\n    case R_X86_64_GOTPC32_TLSDESC:\n      /* Check transition from GDesc access model:\n\t\tleaq x@tlsdesc(%rip), %rax\n\n\t Make sure it's a leaq adding rip to a 32-bit offset\n\t into any register, although it's probably almost always\n\t going to be rax.  */\n\n      if (offset < 3 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 3);\n      if ((val & 0xfb) != 0x48)\n\treturn FALSE;\n\n      if (bfd_get_8 (abfd, contents + offset - 2) != 0x8d)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      return (val & 0xc7) == 0x05;\n\n    case R_X86_64_TLSDESC_CALL:\n      /* Check transition from GDesc access model:\n\t\tcall *x@tlsdesc(%rax)\n       */\n      if (offset + 2 <= sec->size)\n\t{\n\t  /* Make sure that it's a call *x@tlsdesc(%rax).  */\n\t  static const unsigned char call[] = { 0xff, 0x10 };\n\t  return memcmp (contents + offset, call, 2) == 0;\n\t}\n\n      return FALSE;\n\n    default:\n      abort ();\n    }\n}"
}