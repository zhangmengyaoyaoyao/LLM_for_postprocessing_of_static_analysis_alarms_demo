{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);",
    "Code_function": "_bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n{\n  unsigned int count;\n  struct elf_segment_map *m;\n  asection **sections = NULL;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  bfd_boolean no_user_phdrs;\n\n  no_user_phdrs = elf_seg_map (abfd) == NULL;\n\n  if (info != NULL)\n    info->user_phdrs = !no_user_phdrs;\n\n  if (no_user_phdrs && bfd_count_sections (abfd) != 0)\n    {\n      asection *s;\n      unsigned int i;\n      struct elf_segment_map *mfirst;\n      struct elf_segment_map **pm;\n      asection *last_hdr;\n      bfd_vma last_size;\n      unsigned int phdr_index;\n      bfd_vma maxpagesize;\n      asection **hdrpp;\n      bfd_boolean phdr_in_segment = TRUE;\n      bfd_boolean writable;\n      int tls_count = 0;\n      asection *first_tls = NULL;\n      asection *dynsec, *eh_frame_hdr;\n      bfd_size_type amt;\n      bfd_vma addr_mask, wrap_to = 0;\n\n      /* Select the allocated sections, and sort them.  */\n\n      sections = (asection **) bfd_malloc2 (bfd_count_sections (abfd),\n                                            sizeof (asection *));\n      if (sections == NULL)\n\tgoto error_return;\n\n      /* Calculate top address, avoiding undefined behaviour of shift\n\t left operator when shift count is equal to size of type\n\t being shifted.  */\n      addr_mask = ((bfd_vma) 1 << (bfd_arch_bits_per_address (abfd) - 1)) - 1;\n      addr_mask = (addr_mask << 1) + 1;\n\n      i = 0;\n      for (s = abfd->sections; s != NULL; s = s->next)\n\t{\n\t  if ((s->flags & SEC_ALLOC) != 0)\n\t    {\n\t      sections[i] = s;\n\t      ++i;\n\t      /* A wrapping section potentially clashes with header.  */\n\t      if (((s->lma + s->size) & addr_mask) < (s->lma & addr_mask))\n\t\twrap_to = (s->lma + s->size) & addr_mask;\n\t    }\n\t}\n      BFD_ASSERT (i <= bfd_count_sections (abfd));\n      count = i;\n\n      qsort (sections, (size_t) count, sizeof (asection *), elf_sort_sections);\n\n      /* Build the mapping.  */\n\n      mfirst = NULL;\n      pm = &mfirst;\n\n      /* If we have a .interp section, then create a PT_PHDR segment for\n\t the program headers and a PT_INTERP segment for the .interp\n\t section.  */\n      s = bfd_get_section_by_name (abfd, \".interp\");\n      if (s != NULL && (s->flags & SEC_LOAD) != 0)\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_PHDR;\n\t  /* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */\n\t  m->p_flags = PF_R | PF_X;\n\t  m->p_flags_valid = 1;\n\t  m->includes_phdrs = 1;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_INTERP;\n\t  m->count = 1;\n\t  m->sections[0] = s;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      /* Look through the sections.  We put sections in the same program\n\t segment when the start of the second section can be placed within\n\t a few bytes of the end of the first section.  */\n      last_hdr = NULL;\n      last_size = 0;\n      phdr_index = 0;\n      maxpagesize = bed->maxpagesize;\n      /* PR 17512: file: c8455299.\n\t Avoid divide-by-zero errors later on.\n\t FIXME: Should we abort if the maxpagesize is zero ?  */\n      if (maxpagesize == 0)\n\tmaxpagesize = 1;\n      writable = FALSE;\n      dynsec = bfd_get_section_by_name (abfd, \".dynamic\");\n      if (dynsec != NULL\n\t  && (dynsec->flags & SEC_LOAD) == 0)\n\tdynsec = NULL;\n\n      /* Deal with -Ttext or something similar such that the first section\n\t is not adjacent to the program headers.  This is an\n\t approximation, since at this point we don't know exactly how many\n\t program headers we will need.  */\n      if (count > 0)\n\t{\n\t  bfd_size_type phdr_size = elf_program_header_size (abfd);\n\n\t  if (phdr_size == (bfd_size_type) -1)\n\t    phdr_size = get_program_header_size (abfd, info);\n\t  phdr_size += bed->s->sizeof_ehdr;\n\t  if ((abfd->flags & D_PAGED) == 0\n\t      || (sections[0]->lma & addr_mask) < phdr_size\n\t      || ((sections[0]->lma & addr_mask) % maxpagesize\n\t\t  < phdr_size % maxpagesize)\n\t      || (sections[0]->lma & addr_mask & -maxpagesize) < wrap_to)\n\t    phdr_in_segment = FALSE;\n\t}\n\n      for (i = 0, hdrpp = sections; i < count; i++, hdrpp++)\n\t{\n\t  asection *hdr;\n\t  bfd_boolean new_segment;\n\n\t  hdr = *hdrpp;\n\n\t  /* See if this section and the last one will fit in the same\n\t     segment.  */\n\n\t  if (last_hdr == NULL)\n\t    {\n\t      /* If we don't have a segment yet, then we don't need a new\n\t\t one (we build the last one after this loop).  */\n\t      new_segment = FALSE;\n\t    }\n\t  else if (last_hdr->lma - last_hdr->vma != hdr->lma - hdr->vma)\n\t    {\n\t      /* If this section has a different relation between the\n\t\t virtual address and the load address, then we need a new\n\t\t segment.  */\n\t      new_segment = TRUE;\n\t    }\n\t  else if (hdr->lma < last_hdr->lma + last_size\n\t\t   || last_hdr->lma + last_size < last_hdr->lma)\n\t    {\n\t      /* If this section has a load address that makes it overlap\n\t\t the previous section, then we need a new segment.  */\n\t      new_segment = TRUE;\n\t    }\n\t  /* In the next test we have to be careful when last_hdr->lma is close\n\t     to the end of the address space.  If the aligned address wraps\n\t     around to the start of the address space, then there are no more\n\t     pages left in memory and it is OK to assume that the current\n\t     section can be included in the current segment.  */\n\t  else if ((BFD_ALIGN (last_hdr->lma + last_size, maxpagesize) + maxpagesize\n\t\t    > last_hdr->lma)\n\t\t   && (BFD_ALIGN (last_hdr->lma + last_size, maxpagesize) + maxpagesize\n\t\t       <= hdr->lma))\n\t    {\n\t      /* If putting this section in this segment would force us to\n\t\t skip a page in the segment, then we need a new segment.  */\n\t      new_segment = TRUE;\n\t    }\n\t  else if ((last_hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) == 0\n\t\t   && (hdr->flags & (SEC_LOAD | SEC_THREAD_LOCAL)) != 0)\n\t    {\n\t      /* We don't want to put a loadable section after a\n\t\t nonloadable section in the same segment.\n\t\t Consider .tbss sections as loadable for this purpose.  */\n\t      new_segment = TRUE;\n\t    }\n\t  else if ((abfd->flags & D_PAGED) == 0)\n\t    {\n\t      /* If the file is not demand paged, which means that we\n\t\t don't require the sections to be correctly aligned in the\n\t\t file, then there is no other reason for a new segment.  */\n\t      new_segment = FALSE;\n\t    }\n\t  else if (! writable\n\t\t   && (hdr->flags & SEC_READONLY) == 0\n\t\t   && (((last_hdr->lma + last_size - 1) & -maxpagesize)\n\t\t       != (hdr->lma & -maxpagesize)))\n\t    {\n\t      /* We don't want to put a writable section in a read only\n\t\t segment, unless they are on the same page in memory\n\t\t anyhow.  We already know that the last section does not\n\t\t bring us past the current section on the page, so the\n\t\t only case in which the new section is not on the same\n\t\t page as the previous section is when the previous section\n\t\t ends precisely on a page boundary.  */\n\t      new_segment = TRUE;\n\t    }\n\t  else\n\t    {\n\t      /* Otherwise, we can use the same segment.  */\n\t      new_segment = FALSE;\n\t    }\n\n\t  /* Allow interested parties a chance to override our decision.  */\n\t  if (last_hdr != NULL\n\t      && info != NULL\n\t      && info->callbacks->override_segment_assignment != NULL)\n\t    new_segment\n\t      = info->callbacks->override_segment_assignment (info, abfd, hdr,\n\t\t\t\t\t\t\t      last_hdr,\n\t\t\t\t\t\t\t      new_segment);\n\n\t  if (! new_segment)\n\t    {\n\t      if ((hdr->flags & SEC_READONLY) == 0)\n\t\twritable = TRUE;\n\t      last_hdr = hdr;\n\t      /* .tbss sections effectively have zero size.  */\n\t      if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD))\n\t\t  != SEC_THREAD_LOCAL)\n\t\tlast_size = hdr->size;\n\t      else\n\t\tlast_size = 0;\n\t      continue;\n\t    }\n\n\t  /* We need a new program segment.  We must create a new program\n\t     header holding all the sections from phdr_index until hdr.  */\n\n\t  m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);\n\t  if (m == NULL)\n\t    goto error_return;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\n\t  if ((hdr->flags & SEC_READONLY) == 0)\n\t    writable = TRUE;\n\t  else\n\t    writable = FALSE;\n\n\t  last_hdr = hdr;\n\t  /* .tbss sections effectively have zero size.  */\n\t  if ((hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD)) != SEC_THREAD_LOCAL)\n\t    last_size = hdr->size;\n\t  else\n\t    last_size = 0;\n\t  phdr_index = i;\n\t  phdr_in_segment = FALSE;\n\t}\n\n      /* Create a final PT_LOAD program segment, but not if it's just\n\t for .tbss.  */\n      if (last_hdr != NULL\n\t  && (i - phdr_index != 1\n\t      || ((last_hdr->flags & (SEC_THREAD_LOCAL | SEC_LOAD))\n\t\t  != SEC_THREAD_LOCAL)))\n\t{\n\t  m = make_mapping (abfd, sections, phdr_index, i, phdr_in_segment);\n\t  if (m == NULL)\n\t    goto error_return;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      /* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */\n      if (dynsec != NULL)\n\t{\n\t  m = _bfd_elf_make_dynamic_segment (abfd, dynsec);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      /* For each batch of consecutive loadable .note sections,\n\t add a PT_NOTE segment.  We don't use bfd_get_section_by_name,\n\t because if we link together nonloadable .note sections and\n\t loadable .note sections, we will generate two .note sections\n\t in the output file.  FIXME: Using names for section types is\n\t bogus anyhow.  */\n      for (s = abfd->sections; s != NULL; s = s->next)\n\t{\n\t  if ((s->flags & SEC_LOAD) != 0\n\t      && CONST_STRNEQ (s->name, \".note\"))\n\t    {\n\t      asection *s2;\n\n\t      count = 1;\n\t      amt = sizeof (struct elf_segment_map);\n\t      if (s->alignment_power == 2)\n\t\tfor (s2 = s; s2->next != NULL; s2 = s2->next)\n\t\t  {\n\t\t    if (s2->next->alignment_power == 2\n\t\t\t&& (s2->next->flags & SEC_LOAD) != 0\n\t\t\t&& CONST_STRNEQ (s2->next->name, \".note\")\n\t\t\t&& align_power (s2->lma + s2->size, 2)\n\t\t\t   == s2->next->lma)\n\t\t      count++;\n\t\t    else\n\t\t      break;\n\t\t  }\n\t      amt += (count - 1) * sizeof (asection *);\n\t      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t      if (m == NULL)\n\t\tgoto error_return;\n\t      m->next = NULL;\n\t      m->p_type = PT_NOTE;\n\t      m->count = count;\n\t      while (count > 1)\n\t\t{\n\t\t  m->sections[m->count - count--] = s;\n\t\t  BFD_ASSERT ((s->flags & SEC_THREAD_LOCAL) == 0);\n\t\t  s = s->next;\n\t\t}\n\t      m->sections[m->count - 1] = s;\n\t      BFD_ASSERT ((s->flags & SEC_THREAD_LOCAL) == 0);\n\t      *pm = m;\n\t      pm = &m->next;\n\t    }\n\t  if (s->flags & SEC_THREAD_LOCAL)\n\t    {\n\t      if (! tls_count)\n\t\tfirst_tls = s;\n\t      tls_count++;\n\t    }\n\t}\n\n      /* If there are any SHF_TLS output sections, add PT_TLS segment.  */\n      if (tls_count > 0)\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  amt += (tls_count - 1) * sizeof (asection *);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_TLS;\n\t  m->count = tls_count;\n\t  /* Mandated PF_R.  */\n\t  m->p_flags = PF_R;\n\t  m->p_flags_valid = 1;\n\t  s = first_tls;\n\t  for (i = 0; i < (unsigned int) tls_count; ++i)\n\t    {\n\t      if ((s->flags & SEC_THREAD_LOCAL) == 0)\n\t\t{\n\t\t  _bfd_error_handler\n\t\t    (_(\"%B: TLS sections are not adjacent:\"), abfd);\n\t\t  s = first_tls;\n\t\t  i = 0;\n\t\t  while (i < (unsigned int) tls_count)\n\t\t    {\n\t\t      if ((s->flags & SEC_THREAD_LOCAL) != 0)\n\t\t\t{\n\t\t\t  _bfd_error_handler (_(\"\t    TLS: %A\"), s);\n\t\t\t  i++;\n\t\t\t}\n\t\t      else\n\t\t\t_bfd_error_handler (_(\"\tnon-TLS: %A\"), s);\n\t\t      s = s->next;\n\t\t    }\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t  goto error_return;\n\t\t}\n\t      m->sections[i] = s;\n\t      s = s->next;\n\t    }\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME\n\t segment.  */\n      eh_frame_hdr = elf_eh_frame_hdr (abfd);\n      if (eh_frame_hdr != NULL\n\t  && (eh_frame_hdr->output_section->flags & SEC_LOAD) != 0)\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_GNU_EH_FRAME;\n\t  m->count = 1;\n\t  m->sections[0] = eh_frame_hdr->output_section;\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      if (elf_stack_flags (abfd))\n\t{\n\t  amt = sizeof (struct elf_segment_map);\n\t  m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t  if (m == NULL)\n\t    goto error_return;\n\t  m->next = NULL;\n\t  m->p_type = PT_GNU_STACK;\n\t  m->p_flags = elf_stack_flags (abfd);\n\t  m->p_align = bed->stack_align;\n\t  m->p_flags_valid = 1;\n\t  m->p_align_valid = m->p_align != 0;\n\t  if (info->stacksize > 0)\n\t    {\n\t      m->p_size = info->stacksize;\n\t      m->p_size_valid = 1;\n\t    }\n\n\t  *pm = m;\n\t  pm = &m->next;\n\t}\n\n      if (info != NULL && info->relro)\n\t{\n\t  for (m = mfirst; m != NULL; m = m->next)\n\t    {\n\t      if (m->p_type == PT_LOAD\n\t\t  && m->count != 0\n\t\t  && m->sections[0]->vma >= info->relro_start\n\t\t  && m->sections[0]->vma < info->relro_end)\n\t\t{\n\t\t  i = m->count;\n\t\t  while (--i != (unsigned) -1)\n\t\t    if ((m->sections[i]->flags & (SEC_LOAD | SEC_HAS_CONTENTS))\n\t\t\t== (SEC_LOAD | SEC_HAS_CONTENTS))\n\t\t      break;\n\n\t\t  if (i != (unsigned) -1)\n\t\t    break;\n\t\t}\n\t    }\n\n\t  /* Make a PT_GNU_RELRO segment only when it isn't empty.  */\n\t  if (m != NULL)\n\t    {\n\t      amt = sizeof (struct elf_segment_map);\n\t      m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n\t      if (m == NULL)\n\t\tgoto error_return;\n\t      m->next = NULL;\n\t      m->p_type = PT_GNU_RELRO;\n\t      m->p_flags = PF_R;\n\t      m->p_flags_valid = 1;\n\n\t      *pm = m;\n\t      pm = &m->next;\n\t    }\n\t}\n\n      free (sections);\n      elf_seg_map (abfd) = mfirst;\n    }\n\n  if (!elf_modify_segment_map (abfd, info, no_user_phdrs))\n    return FALSE;\n\n  for (count = 0, m = elf_seg_map (abfd); m != NULL; m = m->next)\n    ++count;\n  elf_program_header_size (abfd) = count * bed->s->sizeof_phdr;\n\n  return TRUE;\n\n error_return:\n  if (sections != NULL)\n    free (sections);\n  return FALSE;\n}"
}