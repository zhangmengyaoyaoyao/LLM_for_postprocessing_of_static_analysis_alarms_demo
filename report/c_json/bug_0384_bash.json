{
    "Project": "bash",
    "Tool": "CSA",
    "category": "core.NullDereference",
    "file": "arrayfunc.c",
    "message": "Access to field 'max_index' results in a dereference of a null pointer (loaded from field 'value')",
    "warning_function_name": "assign_compound_array_list",
    "warning_line": "ind = array_max_index (array_cell (var)) + 1 + ind;",
    "warning_context": "{\n  ARRAY *a;\n  HASH_TABLE *h;\n  WORD_LIST *list;\n  char *w, *val, *nval;\n  int len, iflags, free_val;\n  arrayind_t ind, last_ind;\n  char *akey;\n\n  a = (var && array_p (var)) ? array_cell (var) : (ARRAY *)0;\n  h = (var && assoc_p (var)) ? assoc_cell (var) : (HASH_TABLE *)0;\n\n  akey = (char *)0;\n  ind = 0;\n\n  /* Now that we are ready to assign values to the array, kill the existing\n     value. */\n  if ((flags & ASS_APPEND) == 0)\n    {\n      if (a && array_p (var))\n\tarray_flush (a);\n      else if (h && assoc_p (var))\n\tassoc_flush (h);\n    }\n\n  last_ind = (a && (flags & ASS_APPEND)) ? array_max_index (a) + 1 : 0;\n\n  for (list = nlist; list; list = list->next)\n    {\n      iflags = flags;\n      w = list->word->word;\n\n      /* We have a word of the form [ind]=value */\n      if ((list->word->flags & W_ASSIGNMENT) && w[0] == '[')\n\t{\n\t  /* Don't have to handle embedded quotes specially any more, since\n\t     associative array subscripts have not been expanded yet (see\n\t     above). */\n\t  len = skipsubscript (w, 0, 0);\n\n\t  /* XXX - changes for `+=' */\n \t  if (w[len] != ']' || (w[len+1] != '=' && (w[len+1] != '+' || w[len+2] != '=')))\n\t    {\n\t      if (assoc_p (var))\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  continue;\n\t\t}\n\t      nval = make_variable_value (var, w, flags);\n\t      if (var->assign_func)\n\t\t(*var->assign_func) (var, nval, last_ind, 0);\n\t      else\n\t\tarray_insert (a, last_ind, nval);\n\t      FREE (nval);\n\t      last_ind++;\n\t      continue;\n\t    }\n\n\t  if (len == 1)\n\t    {\n\t      err_badarraysub (w);\n\t      continue;\n\t    }\n\n\t  if (ALL_ELEMENT_SUB (w[1]) && len == 2)\n\t    {\n\t      last_command_exit_value = 1;\n\t      if (assoc_p (var))\n\t\treport_error (_(\"%s: invalid associative array key\"), w);\n\t      else\n\t\treport_error (_(\"%s: cannot assign to non-numeric index\"), w);\n\t      continue;\n\t    }\n\n\t  if (array_p (var))\n\t    {\n\t      ind = array_expand_index (var, w + 1, len);\n\t      /* negative subscripts to indexed arrays count back from end */\n\t      if (ind < 0)\n\t\tind = array_max_index (array_cell (var)) + 1 + ind;\n\t      if (ind < 0)\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  continue;\n\t\t}\n\n\t      last_ind = ind;\n\t    }\n\t  else if (assoc_p (var))\n\t    {\n\t      /* This is not performed above, see expand_compound_array_assignment */\n\t      w[len] = '\\0';\t/*[*/\n\t      akey = expand_assignment_string_to_string (w+1, 0);\n\t      w[len] = ']';\n\t      /* And we need to expand the value also, see below */\n\t      if (akey == 0 || *akey == 0)\n\t\t{\n\t\t  err_badarraysub (w);\n\t\t  FREE (akey);\n\t\t  continue;\n\t\t}\n"
}