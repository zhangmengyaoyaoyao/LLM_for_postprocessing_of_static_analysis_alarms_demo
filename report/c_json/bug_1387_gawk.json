{
    "project": "gawk",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "dfa.c",
    "message": "Access to field 'ch_classes' results in a dereference of a null pointer (loaded from variable 'work_mbc')",
    "warning_function_name": "parse_bracket_exp",
    "warning_line": NaN,
    "warning_context": "                                    &dfa->mbcsets_alloc,\n                                    sizeof *dfa->mbcsets);\n\n      /* dfa->multibyte_prop[] hold the index of dfa->mbcsets.\n         We will update dfa->multibyte_prop[] in addtok, because we can't\n         decide the index in dfa->tokens[].  */\n\n      /* Initialize work area.  */\n      work_mbc = &(dfa->mbcsets[dfa->nmbcsets++]);\n      memset (work_mbc, 0, sizeof *work_mbc);\n    }\n  else\n    work_mbc = NULL;\n\n  memset (ccl, 0, sizeof ccl);\n  FETCH_WC (c, wc, _(\"unbalanced [\"));\n  if (c == '^')\n    {\n      FETCH_WC (c, wc, _(\"unbalanced [\"));\n      invert = true;\n      known_bracket_exp = using_simple_locale ();\n    }\n  else\n    invert = false;\n\n  colon_warning_state = (c == ':');\n  do\n    {\n      c1 = NOTCHAR;\t/* Mark c1 as not initialized.  */\n      colon_warning_state &= ~2;\n\n      /* Note that if we're looking at some other [:...:] construct,\n         we just treat it as a bunch of ordinary characters.  We can do\n         this because we assume regex has checked for syntax errors before\n         dfa is ever called.  */\n      if (c == '[')\n        {\n          FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n\n          if ((c1 == ':' && (syntax_bits & RE_CHAR_CLASSES))\n              || c1 == '.' || c1 == '=')\n            {\n              enum { MAX_BRACKET_STRING_LEN = 32 };\n              char str[MAX_BRACKET_STRING_LEN + 1];\n              size_t len = 0;\n              for (;;)\n                {\n                  FETCH_WC (c, wc, _(\"unbalanced [\"));\n                  if ((c == c1 && *lexptr == ']') || lexleft == 0)\n                    break;\n                  if (len < MAX_BRACKET_STRING_LEN)\n                    str[len++] = c;\n                  else\n                    /* This is in any case an invalid class name.  */\n                    str[0] = '\\0';\n                }\n              str[len] = '\\0';\n\n              /* Fetch bracket.  */\n              FETCH_WC (c, wc, _(\"unbalanced [\"));\n              if (c1 == ':')\n                /* Build character class.  POSIX allows character\n                   classes to match multicharacter collating elements,\n                   but the regex code does not support that, so do not\n                   worry about that possibility.  */\n                {\n                  char const *class\n                    = (case_fold && (STREQ (str, \"upper\")\n                                     || STREQ (str, \"lower\")) ? \"alpha\" : str);\n                  const struct dfa_ctype *pred = find_pred (class);\n                  if (!pred)\n                    dfaerror (_(\"invalid character class\"));\n\n                  if (dfa->multibyte && !pred->single_byte_only)\n                    {\n                      /* Store the character class as wctype_t.  */\n                      wctype_t wt = (wctype_t) wctype (class);\n\n                      work_mbc->ch_classes\n                        = maybe_realloc (work_mbc->ch_classes,\n                                         work_mbc->nch_classes, &ch_classes_al,\n                                         sizeof *work_mbc->ch_classes);\n                      work_mbc->ch_classes[work_mbc->nch_classes++] = wt;\n                    }\n\n                  for (c2 = 0; c2 < NOTCHAR; ++c2)\n                    if (pred->func (c2))\n                      setbit (c2, ccl);\n                }\n              else\n                known_bracket_exp = false;\n\n              colon_warning_state |= 8;\n\n              /* Fetch new lookahead character.  */\n              FETCH_WC (c1, wc1, _(\"unbalanced [\"));\n              continue;\n            }\n\n          /* We treat '[' as a normal character here.  c/c1/wc/wc1\n             are already set up.  */\n"
}