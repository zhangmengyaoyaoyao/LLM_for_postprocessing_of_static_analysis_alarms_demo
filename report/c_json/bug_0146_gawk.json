{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "\tmemset(*data, 0, alloc_size);",
    "Code_function": "api_flatten_array(awk_ext_id_t id,\n\t\tawk_array_t a_cookie,\n\t\tawk_flat_array_t **data)\n{\n\tNODE **list;\n\tsize_t i, j;\n\tNODE *array = (NODE *) a_cookie;\n\tsize_t alloc_size;\n\n\tif (   array == NULL\n\t    || array->type != Node_var_array\n\t    || array->table_size == 0\n\t    || data == NULL)\n\t\treturn awk_false;\n\n\talloc_size = sizeof(awk_flat_array_t) +\n\t\t\t(array->table_size - 1) * sizeof(awk_element_t);\n\n\temalloc(*data, awk_flat_array_t *, alloc_size,\n\t\t\t\"api_flatten_array\");\n\tmemset(*data, 0, alloc_size);\n\n\tlist = assoc_list(array, \"@unsorted\", ASORTI);\n\n\t(*data)->opaque1 = array;\n\t(*data)->opaque2 = list;\n\t(*data)->count = array->table_size;\n\n\tfor (i = j = 0; i < 2 * array->table_size; i += 2, j++) {\n\t\tNODE *index, *value;\n\n\t\tindex = list[i];\n\t\tvalue = list[i + 1]; /* number or string or subarray */\n\n\t\t/*\n\t\t * Convert index and value to ext types.  Force the\n\t\t * index to be a string, since indices are always\n\t\t * conceptually strings, regardless of internal optimizations\n\t\t * to treat them as integers in some cases.\n\t\t */\n\t\tif (! node_to_awk_value(index,\n\t\t\t\t& (*data)->elements[j].index, AWK_STRING)) {\n\t\t\tfatal(_(\"api_flatten_array: could not convert index %d\\n\"),\n\t\t\t\t\t\t(int) i);\n\t\t}\n\t\tif (! node_to_awk_value(value,\n\t\t\t\t& (*data)->elements[j].value, AWK_UNDEFINED)) {\n\t\t\tfatal(_(\"api_flatten_array: could not convert value %d\\n\"),\n\t\t\t\t\t\t(int) i);\n\t\t}\n\t}\n\treturn awk_true;\n}"
}