{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      last_made_pid = old_pid;",
    "Code_function": "command_substitute (string, quoted)\n     char *string;\n     int quoted;\n{\n  pid_t pid, old_pid, old_pipeline_pgrp, old_async_pid;\n  char *istring;\n  int result, fildes[2], function_value, pflags, rc, tflag;\n  WORD_DESC *ret;\n\n  istring = (char *)NULL;\n\n  /* Don't fork () if there is no need to.  In the case of no command to\n     run, just return NULL. */\n  if (!string || !*string || (string[0] == '\\n' && !string[1]))\n    return ((WORD_DESC *)NULL);\n\n  if (wordexp_only && read_but_dont_execute)\n    {\n      last_command_exit_value = EX_WEXPCOMSUB;\n      jump_to_top_level (EXITPROG);\n    }\n\n  /* We're making the assumption here that the command substitution will\n     eventually run a command from the file system.  Since we'll run\n     maybe_make_export_env in this subshell before executing that command,\n     the parent shell and any other shells it starts will have to remake\n     the environment.  If we make it before we fork, other shells won't\n     have to.  Don't bother if we have any temporary variable assignments,\n     though, because the export environment will be remade after this\n     command completes anyway, but do it if all the words to be expanded\n     are variable assignments. */\n  if (subst_assign_varlist == 0 || garglist == 0)\n    maybe_make_export_env ();\t/* XXX */\n\n  /* Flags to pass to parse_and_execute() */\n  pflags = (interactive && sourcelevel == 0) ? SEVAL_RESETLINE : 0;\n\n  /* Pipe the output of executing STRING into the current shell. */\n  if (pipe (fildes) < 0)\n    {\n      sys_error (_(\"cannot make pipe for command substitution\"));\n      goto error_exit;\n    }\n\n  old_pid = last_made_pid;\n#if defined (JOB_CONTROL)\n  old_pipeline_pgrp = pipeline_pgrp;\n  /* Don't reset the pipeline pgrp if we're already a subshell in a pipeline. */\n  if ((subshell_environment & SUBSHELL_PIPE) == 0)\n    pipeline_pgrp = shell_pgrp;\n  cleanup_the_pipeline ();\n#endif /* JOB_CONTROL */\n\n  old_async_pid = last_asynchronous_pid;\n  pid = make_child ((char *)NULL, subshell_environment&SUBSHELL_ASYNC);\n  last_asynchronous_pid = old_async_pid;\n\n  if (pid == 0)\n    {\n      /* Reset the signal handlers in the child, but don't free the\n\t trap strings.  Set a flag noting that we have to free the\n\t trap strings if we run trap to change a signal disposition. */\n      reset_signal_handlers ();\n      subshell_environment |= SUBSHELL_RESETTRAP;\n    }\n\n#if defined (JOB_CONTROL)\n  /* XXX DO THIS ONLY IN PARENT ? XXX */\n  set_sigchld_handler ();\n  stop_making_children ();\n  if (pid != 0)\n    pipeline_pgrp = old_pipeline_pgrp;\n#else\n  stop_making_children ();\n#endif /* JOB_CONTROL */\n\n  if (pid < 0)\n    {\n      sys_error (_(\"cannot make child for command substitution\"));\n    error_exit:\n\n      last_made_pid = old_pid;\n\n      FREE (istring);\n      close (fildes[0]);\n      close (fildes[1]);\n      return ((WORD_DESC *)NULL);\n    }\n\n  if (pid == 0)\n    {\n      set_sigint_handler ();\t/* XXX */\n\n      free_pushed_string_input ();\n\n      if (dup2 (fildes[1], 1) < 0)\n\t{\n\t  sys_error (_(\"command_substitute: cannot duplicate pipe as fd 1\"));\n\t  exit (EXECUTION_FAILURE);\n\t}\n\n      /* If standard output is closed in the parent shell\n\t (such as after `exec >&-'), file descriptor 1 will be\n\t the lowest available file descriptor, and end up in\n\t fildes[0].  This can happen for stdin and stderr as well,\n\t but stdout is more important -- it will cause no output\n\t to be generated from this command. */\n      if ((fildes[1] != fileno (stdin)) &&\n\t  (fildes[1] != fileno (stdout)) &&\n\t  (fildes[1] != fileno (stderr)))\n\tclose (fildes[1]);\n\n      if ((fildes[0] != fileno (stdin)) &&\n\t  (fildes[0] != fileno (stdout)) &&\n\t  (fildes[0] != fileno (stderr)))\n\tclose (fildes[0]);\n\n#ifdef __CYGWIN__\n      /* Let stdio know the fd may have changed from text to binary mode, and\n\t make sure to preserve stdout line buffering. */\n      freopen (NULL, \"w\", stdout);\n      sh_setlinebuf (stdout);\n#endif /* __CYGWIN__ */\n\n      /* The currently executing shell is not interactive. */\n      interactive = 0;\n\n      /* This is a subshell environment. */\n      subshell_environment |= SUBSHELL_COMSUB;\n\n      /* When not in POSIX mode, command substitution does not inherit\n\t the -e flag. */\n      if (posixly_correct == 0)\n        {\n          builtin_ignoring_errexit = 0;\n\t  change_flag ('e', FLAG_OFF);\n\t  set_shellopts ();\n        }\n\n      remove_quoted_escapes (string);\n\n      startup_state = 2;\t/* see if we can avoid a fork */\n      /* Give command substitution a place to jump back to on failure,\n\t so we don't go back up to main (). */\n      result = setjmp_nosigs (top_level);\n\n      /* If we're running a command substitution inside a shell function,\n\t trap `return' so we don't return from the function in the subshell\n\t and go off to never-never land. */\n      if (result == 0 && return_catch_flag)\n\tfunction_value = setjmp_nosigs (return_catch);\n      else\n\tfunction_value = 0;\n\n      if (result == ERREXIT)\n\trc = last_command_exit_value;\n      else if (result == EXITPROG)\n\trc = last_command_exit_value;\n      else if (result)\n\trc = EXECUTION_FAILURE;\n      else if (function_value)\n\trc = return_catch_value;\n      else\n\t{\n\t  subshell_level++;\n\t  rc = parse_and_execute (string, \"command substitution\", pflags|SEVAL_NOHIST);\n\t  subshell_level--;\n\t}\n\n      last_command_exit_value = rc;\n      rc = run_exit_trap ();\n#if defined (PROCESS_SUBSTITUTION)\n      unlink_fifo_list ();\n#endif\n      exit (rc);\n    }\n  else\n    {\n#if defined (JOB_CONTROL) && defined (PGRP_PIPE)\n      close_pgrp_pipe ();\n#endif /* JOB_CONTROL && PGRP_PIPE */\n\n      close (fildes[1]);\n\n      tflag = 0;\n      istring = read_comsub (fildes[0], quoted, &tflag);\n\n      close (fildes[0]);\n\n      current_command_subst_pid = pid;\n      last_command_exit_value = wait_for (pid);\n      last_command_subst_pid = pid;\n      last_made_pid = old_pid;\n\n#if defined (JOB_CONTROL)\n      /* If last_command_exit_value > 128, then the substituted command\n\t was terminated by a signal.  If that signal was SIGINT, then send\n\t SIGINT to ourselves.  This will break out of loops, for instance. */\n      if (last_command_exit_value == (128 + SIGINT) && last_command_exit_signal == SIGINT)\n\tkill (getpid (), SIGINT);\n\n      /* wait_for gives the terminal back to shell_pgrp.  If some other\n\t process group should have it, give it away to that group here.\n\t pipeline_pgrp is non-zero only while we are constructing a\n\t pipeline, so what we are concerned about is whether or not that\n\t pipeline was started in the background.  A pipeline started in\n\t the background should never get the tty back here. */\n      if (interactive && pipeline_pgrp != (pid_t)0 && (subshell_environment & SUBSHELL_ASYNC) == 0)\n\tgive_terminal_to (pipeline_pgrp, 0);\n#endif /* JOB_CONTROL */\n\n      ret = alloc_word_desc ();\n      ret->word = istring;\n      ret->flags = tflag;\n\n      return ret;\n    }\n}"
}