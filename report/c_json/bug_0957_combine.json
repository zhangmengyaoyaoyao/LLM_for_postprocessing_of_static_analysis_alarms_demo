{
    "Project": "combine",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/hash.c",
    "message": "The value read from i was never initialized.",
    "warning_function_name": "calc_hash_key",
    "warning_line": "i++;",
    "warning_context": "HASHTYPE\ncalc_hash_key (string)\n     STRINGTYPE *string;\n{\n  int i;\n  int j;\n  HASHTYPE hash_key;\n  HASHTYPE temp_key;\n  unsigned char *string_tmp;\n\n  j = 0;\n  hash_key = 0;\n\n  switch (gi_hashmovement_ind) {\n  case hm_binary:\n    /* Use all bits, as many at a time as will fit into HASHTYPE. */\n    string_tmp = string->string;\n    while (string_tmp < string->string + string->length) {\n      i = 0;\n      temp_key = 0;\n      while (i < sizeof (temp_key)\n\t     && string_tmp < string->string + string->length) {\n\ttemp_key <<= 8;\n\ttemp_key |= *string_tmp;\n\ti++;\n\tstring_tmp++;\n\t}\n      temp_key <<= j;\n      hash_key = (hash_key ^ temp_key);\n      j++;\n      }\n    break;\n  case hm_binary_long:\n    /* Not really binary.  This is more a generic string hash. */\n    string_tmp = string->string;\n    while (string_tmp < string->string + string->length) {\n      i = 0;\n      temp_key = 0;\n      while (i < sizeof (temp_key) * 2\n\t     && string_tmp < string->string + string->length) {\n\ttemp_key <<= 4;\n\ttemp_key |= (*string_tmp & 15);\n\ti++;\n\tstring_tmp++;\n\t}\n      temp_key <<= j;\n      hash_key = (hash_key ^ temp_key);\n      j++;\n      }\n    break;\n  case hm_number:\n    hash_key = dstrtonum (string, NULL, 10);\n    string_tmp = string->string;\n    while (string_tmp < string->string + string->length) {\n      hash_key *= 10;\n      hash_key += *string_tmp - '0';\n      string_tmp++;\n      }\n    break;\n  case hm_beginning:\n  case hm_end:\n\n    switch (gi_hashmovement_ind) {\n    case hm_beginning:\n      string_tmp = string->string;\n      while ((i < (sizeof hash_key) * 8 / 3)\n\t     && string_tmp < string->string + string->length) {\n\thash_key <<= 3;\n\thash_key |= (*string_tmp & 7);\n\ti++;\n\tstring_tmp++;\n\t}\n      break;\n    case hm_end:\n      string_tmp = string->string;\n      if (string->length > (sizeof hash_key) * 8 / 3) {\n\tstring_tmp += string->length - ((sizeof hash_key) * 8 / 3);\n\t}\n\n      while ((i < (sizeof hash_key) * 8 / 3)\n\t     && string_tmp < string->string + string->length) {\n\thash_key <<= 3;\n\thash_key |= (*string_tmp & 7);\n\ti++;\n\tstring_tmp++;\n\t}\n      break;\n      }\n    break;\n\n  default:\n    break;\n    }\n\n  return hash_key;\n  }\n"
}