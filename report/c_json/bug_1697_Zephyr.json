{
    "Project": "Zephyr",
    "Tool": "Infer",
    "category": "Null Dereference",
    "file": "kernel/mailbox.c",
    "message": "pointer `receiving_thread` last assigned on line 253 could be null and is dereferenced at line 254, column 33.",
    "warning_function_name": "mbox_message_put",
    "warning_line": "rx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;",
    "warning_context": "static int mbox_message_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,\n\t\t\t     s32_t timeout)\n{\n\tstruct k_thread *sending_thread;\n\tstruct k_thread *receiving_thread;\n\tstruct k_mbox_msg *rx_msg;\n\tk_spinlock_key_t key;\n\n\t/* save sender id so it can be used during message matching */\n\ttx_msg->rx_source_thread = _current;\n\n\t/* finish readying sending thread (actual or dummy) for send */\n\tsending_thread = tx_msg->_syncing_thread;\n\tsending_thread->base.swap_data = tx_msg;\n\n\t/* search mailbox's rx queue for a compatible receiver */\n\tkey = k_spin_lock(&mbox->lock);\n\n\t_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {\n\t\trx_msg = (struct k_mbox_msg *)receiving_thread->base.swap_data;\n\n\t\tif (mbox_message_match(tx_msg, rx_msg) == 0) {\n\t\t\t/* take receiver out of rx queue */\n\t\t\tz_unpend_thread(receiving_thread);\n\n\t\t\t/* ready receiver for execution */\n\t\t\tarch_thread_return_value_set(receiving_thread, 0);\n\t\t\tz_ready_thread(receiving_thread);\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t\t\t/*\n\t\t\t * asynchronous send: swap out current thread\n\t\t\t * if receiver has priority, otherwise let it continue\n\t\t\t *\n\t\t\t * note: dummy sending thread sits (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\tif ((sending_thread->base.thread_state & _THREAD_DUMMY)\n\t\t\t    != 0U) {\n\t\t\t\tz_reschedule(&mbox->lock, key);\n\t\t\t\treturn 0;\n\t\t\t}\n#endif\n\n\t\t\t/*\n\t\t\t * synchronous send: pend current thread (unqueued)\n\t\t\t * until the receiver consumes the message\n\t\t\t */\n\t\t\treturn z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);\n\n\t\t}\n\t}\n\n\t/* didn't find a matching receiver: don't wait for one */\n\tif (timeout == K_NO_WAIT) {\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn -ENOMSG;\n\t}\n\n#if (CONFIG_NUM_MBOX_ASYNC_MSGS > 0)\n\t/* asynchronous send: dummy thread waits on tx queue for receiver */\n\tif ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {\n\t\tz_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);\n\t\tk_spin_unlock(&mbox->lock, key);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* synchronous send: sender waits on tx queue for receiver or timeout */\n\treturn z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);\n}\n"
}