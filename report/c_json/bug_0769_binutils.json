{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "gas/dwarf2dbg.c",
    "message": "Offset: [-34359738348, +oo] (⇐ [-34359738348, 34359738371] + [0, +oo]) Size: [528, 34359738358] by call to `bfd_get_section_by_name`.",
    "warning_function_name": "dwarf2_finish",
    "warning_line": "line_seg = bfd_get_section_by_name (stdoutput, \".debug_line\");",
    "warning_context": "void\ndwarf2_finish (void)\n{\n  segT line_seg;\n  struct line_seg *s;\n  segT info_seg;\n  int emit_other_sections = 0;\n  int empty_debug_line = 0;\n\n  info_seg = bfd_get_section_by_name (stdoutput, \".debug_info\");\n  emit_other_sections = info_seg == NULL || !seg_not_empty_p (info_seg);\n\n  line_seg = bfd_get_section_by_name (stdoutput, \".debug_line\");\n  empty_debug_line = line_seg == NULL || !seg_not_empty_p (line_seg);\n\n  /* We can't construct a new debug_line section if we already have one.\n     Give an error.  */\n  if (all_segs && !empty_debug_line)\n    as_fatal (\"duplicate .debug_line sections\");\n\n  if ((!all_segs && emit_other_sections)\n      || (!emit_other_sections && !empty_debug_line))\n    /* If there is no line information and no non-empty .debug_info\n       section, or if there is both a non-empty .debug_info and a non-empty\n       .debug_line, then we do nothing.  */\n    return;\n\n  /* Calculate the size of an address for the target machine.  */\n  sizeof_address = DWARF2_ADDR_SIZE (stdoutput);\n\n  /* Create and switch to the line number section.  */\n  line_seg = subseg_new (\".debug_line\", 0);\n  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);\n\n  /* For each subsection, chain the debug entries together.  */\n  for (s = all_segs; s; s = s->next)\n    {\n      struct line_subseg *lss = s->head;\n      struct line_entry **ptail = lss->ptail;\n\n      while ((lss = lss->next) != NULL)\n\t{\n\t  *ptail = lss->head;\n\t  ptail = lss->ptail;\n\t}\n    }\n\n  out_debug_line (line_seg);\n\n  /* If this is assembler generated line info, and there is no\n     debug_info already, we need .debug_info and .debug_abbrev\n     sections as well.  */\n  if (emit_other_sections)\n    {\n      segT abbrev_seg;\n      segT aranges_seg;\n      segT ranges_seg;\n\n      gas_assert (all_segs);\n\n      info_seg = subseg_new (\".debug_info\", 0);\n      abbrev_seg = subseg_new (\".debug_abbrev\", 0);\n      aranges_seg = subseg_new (\".debug_aranges\", 0);\n\n      bfd_set_section_flags (stdoutput, info_seg,\n\t\t\t     SEC_READONLY | SEC_DEBUGGING);\n      bfd_set_section_flags (stdoutput, abbrev_seg,\n\t\t\t     SEC_READONLY | SEC_DEBUGGING);\n      bfd_set_section_flags (stdoutput, aranges_seg,\n\t\t\t     SEC_READONLY | SEC_DEBUGGING);\n\n      record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);\n\n      if (all_segs->next == NULL)\n\tranges_seg = NULL;\n      else\n\t{\n\t  ranges_seg = subseg_new (\".debug_ranges\", 0);\n\t  bfd_set_section_flags (stdoutput, ranges_seg,\n\t\t\t\t SEC_READONLY | SEC_DEBUGGING);\n\t  record_alignment (ranges_seg, ffs (2 * sizeof_address) - 1);\n\t  out_debug_ranges (ranges_seg);\n\t}\n\n      out_debug_aranges (aranges_seg, info_seg);\n      out_debug_abbrev (abbrev_seg, info_seg, line_seg);\n      out_debug_info (info_seg, abbrev_seg, line_seg, ranges_seg);\n    }\n}\n"
}