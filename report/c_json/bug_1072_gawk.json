{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "node.c",
    "message": "Offset added: [1+min(1, `buf.strlen`), 1+max(1, `buf.strlen`)] Size: [0, 2+max(1, `buf.strlen`)].",
    "warning_function_name": "r_format_val",
    "warning_line": "memcpy(s->stptr, sp, s->stlen + 1);",
    "warning_context": "NODE *\nr_format_val(const char *format, int index, NODE *s)\n{\n\tchar buf[BUFSIZ];\n\tchar *sp = buf;\n\tdouble val;\n\n\t/*\n\t * 2/2007: Simplify our lives here. Instead of worrying about\n\t * whether or not the value will fit into a long just so we\n\t * can use sprintf(\"%ld\", val) on it, always format it ourselves.\n\t * The only thing to worry about is that integral values always\n\t * format as integers. %.0f does that very well.\n\t *\n\t * 6/2008: Would that things were so simple. Always using %.0f\n\t * imposes a notable performance penalty for applications that\n\t * do a lot of conversion of integers to strings. So, we reinstate\n\t * the old code, but use %.0f for integral values that are outside\n\t * the range of a long.  This seems a reasonable compromise.\n\t *\n\t * 12/2009: Use <= and >= in the comparisons with LONG_xxx instead of\n\t * < and > so that things work correctly on systems with 64 bit integers.\n\t */\n\n\t/* not an integral value, or out of range */\n\tif ((val = double_to_int(s->numbr)) != s->numbr\n\t\t\t|| val <= LONG_MIN || val >= LONG_MAX\n\t) {\n\t\t/*\n\t\t * Once upon a time, we just blindly did this:\n\t\t *\tsprintf(sp, format, s->numbr);\n\t\t *\ts->stlen = strlen(sp);\n\t\t *\ts->stfmt = (char) index;\n\t\t * but that's no good if, e.g., OFMT is %s. So we punt,\n\t\t * and just always format the value ourselves.\n\t\t */\n\n\t\tNODE *dummy[2], *r;\n\t\tunsigned int oflags;\n\n\t\t/* create dummy node for a sole use of format_tree */\n\t\tdummy[1] = s;\n\t\toflags = s->flags;\n\n\t\tif (val == s->numbr) {\n\t\t\t/* integral value, but outside range of %ld, use %.0f */\n\t\t\tr = format_tree(\"%.0f\", 4, dummy, 2);\n\t\t\ts->stfmt = -1;\n\t\t} else {\n\t\t\tr = format_tree(format, fmt_list[index]->stlen, dummy, 2);\n\t\t\tassert(r != NULL);\n\t\t\ts->stfmt = (char) index;\n\t\t}\n\t\ts->flags = oflags;\n\t\ts->stlen = r->stlen;\n\t\tif ((s->flags & STRCUR) != 0)\n\t\t\tefree(s->stptr);\n\t\ts->stptr = r->stptr;\n\t\tfreenode(r);\t/* Do not unref(r)! We want to keep s->stptr == r->stpr.  */\n\n\t\tgoto no_malloc;\n\t} else {\n\t\t/*\n\t\t * integral value; force conversion to long only once.\n\t\t */\n\t\tlong num = (long) val;\n\n\t\tif (num < NVAL && num >= 0) {\n\t\t\tsp = (char *) values[num];\n\t\t\ts->stlen = 1;\n\t\t} else {\n\t\t\t(void) sprintf(sp, \"%ld\", num);\n\t\t\ts->stlen = strlen(sp);\n\t\t}\n\t\ts->stfmt = -1;\n\t\tif ((s->flags & INTIND) != 0) {\n\t\t\ts->flags &= ~(INTIND|NUMBER);\n\t\t\ts->flags |= STRING;\n\t\t}\n\t}\n\tif (s->stptr != NULL)\n\t\tefree(s->stptr);\n\temalloc(s->stptr, char *, s->stlen + 2, \"format_val\");\n\tmemcpy(s->stptr, sp, s->stlen + 1);\nno_malloc:\n\ts->flags |= STRCUR;\n\tfree_wstr(s);\n\treturn s;\n}\n"
}