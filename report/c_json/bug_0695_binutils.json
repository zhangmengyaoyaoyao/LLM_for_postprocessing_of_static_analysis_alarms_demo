{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "bfd/elf32-i386.c",
    "message": "Offset: [-1+max(2, `rel->r_offset`), `rel->r_offset` - 1] (⇐ [max(2, `rel->r_offset`), `rel->r_offset`] + -1) Size: [1, +oo].",
    "warning_function_name": "elf_i386_check_tls_transition",
    "warning_line": "val = bfd_get_8 (abfd, contents + offset - 1);",
    "warning_context": "\t\treturn FALSE;\n\n\t      if ((val & 0xc7) != 0x05 || val == (4 << 3))\n\t\treturn FALSE;\n\t    }\n\t  else\n\t    {\n\t      /* leal foo@tlsgd(%reg), %eax; call ___tls_get_addr; nop  */\n\t      if ((val & 0xf8) != 0x80 || (val & 7) == 4)\n\t\treturn FALSE;\n\n\t      if (bfd_get_8 (abfd, contents + offset + 9) != 0x90)\n\t\treturn FALSE;\n\t    }\n\t}\n      else\n\t{\n\t  /* Check transition from LD access model.  Only\n\t\tleal foo@tlsgd(%reg), %eax; call ___tls_get_addr\n\t     can transit to different access model.  */\n\t  if (type != 0x8d || (offset + 9) > sec->size)\n\t    return FALSE;\n\n\t  val = bfd_get_8 (abfd, contents + offset - 1);\n\t  if ((val & 0xf8) != 0x80 || (val & 7) == 4)\n\t    return FALSE;\n\t}\n\n      if (bfd_get_8 (abfd, contents + offset + 4) != 0xe8)\n\treturn FALSE;\n\n      r_symndx = ELF32_R_SYM (rel[1].r_info);\n      if (r_symndx < symtab_hdr->sh_info)\n\treturn FALSE;\n\n      h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n      /* Use strncmp to check ___tls_get_addr since ___tls_get_addr\n\t may be versioned.  */\n      return (h != NULL\n\t      && h->root.root.string != NULL\n\t      && (ELF32_R_TYPE (rel[1].r_info) == R_386_PC32\n\t\t  || ELF32_R_TYPE (rel[1].r_info) == R_386_PLT32)\n\t      && (strncmp (h->root.root.string, \"___tls_get_addr\",\n\t\t\t   15) == 0));\n\n    case R_386_TLS_IE:\n      /* Check transition from IE access model:\n\t\tmovl foo@indntpoff(%rip), %eax\n\t\tmovl foo@indntpoff(%rip), %reg\n\t\taddl foo@indntpoff(%rip), %reg\n       */\n\n      if (offset < 1 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      /* Check \"movl foo@tpoff(%rip), %eax\" first.  */\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      if (val == 0xa1)\n\treturn TRUE;\n\n      if (offset < 2)\n\treturn FALSE;\n\n      /* Check movl|addl foo@tpoff(%rip), %reg.   */\n      type = bfd_get_8 (abfd, contents + offset - 2);\n      return ((type == 0x8b || type == 0x03)\n\t      && (val & 0xc7) == 0x05);\n\n    case R_386_TLS_GOTIE:\n    case R_386_TLS_IE_32:\n      /* Check transition from {IE_32,GOTIE} access model:\n\t\tsubl foo@{tpoff,gontoff}(%reg1), %reg2\n\t\tmovl foo@{tpoff,gontoff}(%reg1), %reg2\n\t\taddl foo@{tpoff,gontoff}(%reg1), %reg2\n       */\n\n      if (offset < 2 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n      if ((val & 0xc0) != 0x80 || (val & 7) == 4)\n\treturn FALSE;\n\n      type = bfd_get_8 (abfd, contents + offset - 2);\n      return type == 0x8b || type == 0x2b || type == 0x03;\n\n    case R_386_TLS_GOTDESC:\n      /* Check transition from GDesc access model:\n\t\tleal x@tlsdesc(%ebx), %eax\n\n\t Make sure it's a leal adding ebx to a 32-bit offset\n\t into any register, although it's probably almost always\n\t going to be eax.  */\n\n      if (offset < 2 || (offset + 4) > sec->size)\n\treturn FALSE;\n\n      if (bfd_get_8 (abfd, contents + offset - 2) != 0x8d)\n\treturn FALSE;\n\n      val = bfd_get_8 (abfd, contents + offset - 1);\n"
}