{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "gas/macro.c",
    "message": "Offset: [`out->len` + 1, +oo] Size: [1, +oo] by call to `sb_add_char`.",
    "warning_function_name": "macro_expand_body",
    "warning_line": "sb_add_char (out, '&');",
    "warning_context": "static const char *\nmacro_expand_body (sb *in, sb *out, formal_entry *formals,\n\t\t   struct hash_control *formal_hash, const macro_entry *macro)\n{\n  sb t;\n  size_t src = 0;\n  int inquote = 0, macro_line = 0;\n  formal_entry *loclist = NULL;\n  const char *err = NULL;\n\n  sb_new (&t);\n\n  while (src < in->len && !err)\n    {\n      if (in->ptr[src] == '&')\n\t{\n\t  sb_reset (&t);\n\t  if (macro_mri)\n\t    {\n\t      if (src + 1 < in->len && in->ptr[src + 1] == '&')\n\t\tsrc = sub_actual (src + 2, in, &t, formal_hash, '\\'', out, 1);\n\t      else\n\t\tsb_add_char (out, in->ptr[src++]);\n\t    }\n\t  else\n\t    {\n\t      /* Permit macro parameter substition delineated with\n\t\t an '&' prefix and optional '&' suffix.  */\n\t      src = sub_actual (src + 1, in, &t, formal_hash, '&', out, 0);\n\t    }\n\t}\n      else if (in->ptr[src] == '\\\\')\n\t{\n\t  src++;\n\t  if (src < in->len && in->ptr[src] == '(')\n\t    {\n\t      /* Sub in till the next ')' literally.  */\n\t      src++;\n\t      while (src < in->len && in->ptr[src] != ')')\n\t\t{\n\t\t  sb_add_char (out, in->ptr[src++]);\n\t\t}\n\t      if (src < in->len)\n\t\tsrc++;\n\t      else if (!macro)\n\t\terr = _(\"missing `)'\");\n\t      else\n\t\tas_bad_where (macro->file, macro->line + macro_line, _(\"missing `)'\"));\n\t    }\n\t  else if (src < in->len && in->ptr[src] == '@')\n\t    {\n\t      /* Sub in the macro invocation number.  */\n\n\t      char buffer[10];\n\t      src++;\n\t      sprintf (buffer, \"%d\", macro_number);\n\t      sb_add_string (out, buffer);\n\t    }\n\t  else if (src < in->len && in->ptr[src] == '&')\n\t    {\n\t      /* This is a preprocessor variable name, we don't do them\n\t\t here.  */\n\t      sb_add_char (out, '\\\\');\n\t      sb_add_char (out, '&');\n\t      src++;\n\t    }\n\t  else if (macro_mri && src < in->len && ISALNUM (in->ptr[src]))\n\t    {\n\t      int ind;\n\t      formal_entry *f;\n\n\t      if (ISDIGIT (in->ptr[src]))\n\t\tind = in->ptr[src] - '0';\n\t      else if (ISUPPER (in->ptr[src]))\n\t\tind = in->ptr[src] - 'A' + 10;\n\t      else\n\t\tind = in->ptr[src] - 'a' + 10;\n\t      ++src;\n\t      for (f = formals; f != NULL; f = f->next)\n\t\t{\n\t\t  if (f->index == ind - 1)\n\t\t    {\n\t\t      if (f->actual.len != 0)\n\t\t\tsb_add_sb (out, &f->actual);\n\t\t      else\n\t\t\tsb_add_sb (out, &f->def);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      sb_reset (&t);\n\t      src = sub_actual (src, in, &t, formal_hash, '\\'', out, 0);\n\t    }\n\t}\n      else if ((macro_alternate || macro_mri)\n\t       && is_name_beginner (in->ptr[src])\n\t       && (! inquote\n\t\t   || ! macro_strip_at\n\t\t   || (src > 0 && in->ptr[src - 1] == '@')))\n"
}