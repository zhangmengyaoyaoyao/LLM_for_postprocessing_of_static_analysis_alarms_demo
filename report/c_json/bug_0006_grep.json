{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "                memmove(t, p->fts_name, p->fts_namelen + 1);",
    "Code_function": "fts_read (register FTS *sp)\n{\n        register FTSENT *p, *tmp;\n        register unsigned short int instr;\n        register char *t;\n\n        /* If finished or unrecoverable error, return NULL. */\n        if (sp->fts_cur == NULL || ISSET(FTS_STOP))\n                return (NULL);\n\n        /* Set current node pointer. */\n        p = sp->fts_cur;\n\n        /* Save and zero out user instructions. */\n        instr = p->fts_instr;\n        p->fts_instr = FTS_NOINSTR;\n\n        /* Any type of file may be re-visited; re-stat and re-turn. */\n        if (instr == FTS_AGAIN) {\n                p->fts_info = fts_stat(sp, p, false);\n                return (p);\n        }\n        Dprintf ((\"fts_read: p=%s\\n\",\n                  p->fts_info == FTS_INIT ? \"\" : p->fts_path));\n\n        /*\n         * Following a symlink -- SLNONE test allows application to see\n         * SLNONE and recover.  If indirecting through a symlink, have\n         * keep a pointer to current location.  If unable to get that\n         * pointer, follow fails.\n         */\n        if (instr == FTS_FOLLOW &&\n            (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n                p->fts_info = fts_stat(sp, p, true);\n                if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                        if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                p->fts_errno = errno;\n                                p->fts_info = FTS_ERR;\n                        } else\n                                p->fts_flags |= FTS_SYMFOLLOW;\n                }\n                goto check_for_dir;\n        }\n\n        /* Directory in pre-order. */\n        if (p->fts_info == FTS_D) {\n                /* If skipped or crossed mount point, do post-order visit. */\n                if (instr == FTS_SKIP ||\n                    (ISSET(FTS_XDEV) && p->fts_statp->st_dev != sp->fts_dev)) {\n                        if (p->fts_flags & FTS_SYMFOLLOW)\n                                (void)close(p->fts_symfd);\n                        if (sp->fts_child) {\n                                fts_lfree(sp->fts_child);\n                                sp->fts_child = NULL;\n                        }\n                        p->fts_info = FTS_DP;\n                        LEAVE_DIR (sp, p, \"1\");\n                        return (p);\n                }\n\n                /* Rebuild if only read the names and now traversing. */\n                if (sp->fts_child != NULL && ISSET(FTS_NAMEONLY)) {\n                        CLR(FTS_NAMEONLY);\n                        fts_lfree(sp->fts_child);\n                        sp->fts_child = NULL;\n                }\n\n                /*\n                 * Cd to the subdirectory.\n                 *\n                 * If have already read and now fail to chdir, whack the list\n                 * to make the names come out right, and set the parent errno\n                 * so the application will eventually get an error condition.\n                 * Set the FTS_DONTCHDIR flag so that when we logically change\n                 * directories back to the parent we don't do a chdir.\n                 *\n                 * If haven't read do so.  If the read fails, fts_build sets\n                 * FTS_STOP or the fts_info field of the node.\n                 */\n                if (sp->fts_child != NULL) {\n                        if (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n                                p->fts_errno = errno;\n                                p->fts_flags |= FTS_DONTCHDIR;\n                                for (p = sp->fts_child; p != NULL;\n                                     p = p->fts_link)\n                                        p->fts_accpath =\n                                            p->fts_parent->fts_accpath;\n                        }\n                } else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n                        if (ISSET(FTS_STOP))\n                                return (NULL);\n                        /* If fts_build's call to fts_safe_changedir failed\n                           because it was not able to fchdir into a\n                           subdirectory, tell the caller.  */\n                        if (p->fts_errno && p->fts_info != FTS_DNR)\n                                p->fts_info = FTS_ERR;\n                        LEAVE_DIR (sp, p, \"2\");\n                        return (p);\n                }\n                p = sp->fts_child;\n                sp->fts_child = NULL;\n                goto name;\n        }\n\n        /* Move to the next node on this level. */\nnext:   tmp = p;\n\n        /* If we have so many directory entries that we're reading them\n           in batches, and we've reached the end of the current batch,\n           read in a new batch.  */\n        if (p->fts_link == NULL && p->fts_parent->fts_dirp)\n          {\n            p = tmp->fts_parent;\n            sp->fts_cur = p;\n            sp->fts_path[p->fts_pathlen] = '\\0';\n\n            if ((p = fts_build (sp, BREAD)) == NULL)\n              {\n                if (ISSET(FTS_STOP))\n                  return NULL;\n                goto cd_dot_dot;\n              }\n\n            free(tmp);\n            goto name;\n          }\n\n        if ((p = p->fts_link) != NULL) {\n                sp->fts_cur = p;\n                free(tmp);\n\n                /*\n                 * If reached the top, return to the original directory (or\n                 * the root of the tree), and load the file names for the next\n                 * root.\n                 */\n                if (p->fts_level == FTS_ROOTLEVEL) {\n                        if (restore_initial_cwd(sp)) {\n                                SET(FTS_STOP);\n                                return (NULL);\n                        }\n                        free_dir(sp);\n                        fts_load(sp, p);\n                        setup_dir(sp);\n                        goto check_for_dir;\n                }\n\n                /*\n                 * User may have called fts_set on the node.  If skipped,\n                 * ignore.  If followed, get a file descriptor so we can\n                 * get back if necessary.\n                 */\n                if (p->fts_instr == FTS_SKIP)\n                        goto next;\n                if (p->fts_instr == FTS_FOLLOW) {\n                        p->fts_info = fts_stat(sp, p, true);\n                        if (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n                                if ((p->fts_symfd = diropen (sp, \".\")) < 0) {\n                                        p->fts_errno = errno;\n                                        p->fts_info = FTS_ERR;\n                                } else\n                                        p->fts_flags |= FTS_SYMFOLLOW;\n                        }\n                        p->fts_instr = FTS_NOINSTR;\n                }\n\nname:           t = sp->fts_path + NAPPEND(p->fts_parent);\n                *t++ = '/';\n                memmove(t, p->fts_name, p->fts_namelen + 1);\ncheck_for_dir:\n                sp->fts_cur = p;\n                if (p->fts_info == FTS_NSOK)\n                  {\n                    if (p->fts_statp->st_size == FTS_STAT_REQUIRED)\n                      {\n                        FTSENT *parent = p->fts_parent;\n                        if (FTS_ROOTLEVEL < p->fts_level\n                            /* ->fts_n_dirs_remaining is not valid\n                               for command-line-specified names.  */\n                            && parent->fts_n_dirs_remaining == 0\n                            && ISSET(FTS_NOSTAT)\n                            && ISSET(FTS_PHYSICAL)\n                            && link_count_optimize_ok (parent))\n                          {\n                            /* nothing more needed */\n                          }\n                        else\n                          {\n                            p->fts_info = fts_stat(sp, p, false);\n                            if (S_ISDIR(p->fts_statp->st_mode)\n                                && p->fts_level != FTS_ROOTLEVEL\n                                && parent->fts_n_dirs_remaining)\n                                  parent->fts_n_dirs_remaining--;\n                          }\n                      }\n                    else\n                      fts_assert (p->fts_statp->st_size == FTS_NO_STAT_REQUIRED);\n                  }\n\n                if (p->fts_info == FTS_D)\n                  {\n                    /* Now that P->fts_statp is guaranteed to be valid,\n                       if this is a command-line directory, record its\n                       device number, to be used for FTS_XDEV.  */\n                    if (p->fts_level == FTS_ROOTLEVEL)\n                      sp->fts_dev = p->fts_statp->st_dev;\n                    Dprintf ((\"  entering: %s\\n\", p->fts_path));\n                    if (! enter_dir (sp, p))\n                      {\n                        __set_errno (ENOMEM);\n                        return NULL;\n                      }\n                  }\n                return p;\n        }\ncd_dot_dot:\n\n        /* Move up to the parent node. */\n        p = tmp->fts_parent;\n        sp->fts_cur = p;\n        free(tmp);\n\n        if (p->fts_level == FTS_ROOTPARENTLEVEL) {\n                /*\n                 * Done; free everything up and set errno to 0 so the user\n                 * can distinguish between error and EOF.\n                 */\n                free(p);\n                __set_errno (0);\n                return (sp->fts_cur = NULL);\n        }\n\n        fts_assert (p->fts_info != FTS_NSOK);\n\n        /* NUL terminate the file name.  */\n        sp->fts_path[p->fts_pathlen] = '\\0';\n\n        /*\n         * Return to the parent directory.  If at a root node, restore\n         * the initial working directory.  If we came through a symlink,\n         * go back through the file descriptor.  Otherwise, move up\n         * one level, via \"..\".\n         */\n        if (p->fts_level == FTS_ROOTLEVEL) {\n                if (restore_initial_cwd(sp)) {\n                        p->fts_errno = errno;\n                        SET(FTS_STOP);\n                }\n        } else if (p->fts_flags & FTS_SYMFOLLOW) {\n                if (FCHDIR(sp, p->fts_symfd)) {\n                        int saved_errno = errno;\n                        (void)close(p->fts_symfd);\n                        __set_errno (saved_errno);\n                        p->fts_errno = errno;\n                        SET(FTS_STOP);\n                }\n                (void)close(p->fts_symfd);\n        } else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n                   fts_safe_changedir(sp, p->fts_parent, -1, \"..\")) {\n                p->fts_errno = errno;\n                SET(FTS_STOP);\n        }\n        p->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n        if (p->fts_errno == 0)\n                LEAVE_DIR (sp, p, \"3\");\n        return ISSET(FTS_STOP) ? NULL : p;\n}"
}