{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t  each = parse_comp_unit (stash, length, info_ptr_unit,",
    "Code_function": "_bfd_dwarf2_find_nearest_line (bfd *abfd,\n\t\t\t       asymbol **symbols,\n\t\t\t       asymbol *symbol,\n\t\t\t       asection *section,\n\t\t\t       bfd_vma offset,\n\t\t\t       const char **filename_ptr,\n\t\t\t       const char **functionname_ptr,\n\t\t\t       unsigned int *linenumber_ptr,\n\t\t\t       unsigned int *discriminator_ptr,\n\t\t\t       const struct dwarf_debug_section *debug_sections,\n\t\t\t       unsigned int addr_size,\n\t\t\t       void **pinfo)\n{\n  /* Read each compilation unit from the section .debug_info, and check\n     to see if it contains the address we are searching for.  If yes,\n     lookup the address, and return the line number info.  If no, go\n     on to the next compilation unit.\n\n     We keep a list of all the previously read compilation units, and\n     a pointer to the next un-read compilation unit.  Check the\n     previously read units before reading more.  */\n  struct dwarf2_debug *stash;\n  /* What address are we looking for?  */\n  bfd_vma addr;\n  struct comp_unit* each;\n  struct funcinfo *function = NULL;\n  bfd_boolean found = FALSE;\n  bfd_boolean do_line;\n\n  *filename_ptr = NULL;\n  if (functionname_ptr != NULL)\n    *functionname_ptr = NULL;\n  *linenumber_ptr = 0;\n  if (discriminator_ptr)\n    *discriminator_ptr = 0;\n\n  if (! _bfd_dwarf2_slurp_debug_info (abfd, NULL, debug_sections,\n\t\t\t\t      symbols, pinfo,\n\t\t\t\t      (abfd->flags & (EXEC_P | DYNAMIC)) == 0))\n    return FALSE;\n\n  stash = (struct dwarf2_debug *) *pinfo;\n\n  do_line = symbol != NULL;\n  if (do_line)\n    {\n      BFD_ASSERT (section == NULL && offset == 0 && functionname_ptr == NULL);\n      section = bfd_get_section (symbol);\n      addr = symbol->value;\n    }\n  else\n    {\n      BFD_ASSERT (section != NULL && functionname_ptr != NULL);\n      addr = offset;\n    }\n\n  if (section->output_section)\n    addr += section->output_section->vma + section->output_offset;\n  else\n    addr += section->vma;\n\n  /* A null info_ptr indicates that there is no dwarf2 info\n     (or that an error occured while setting up the stash).  */\n  if (! stash->info_ptr)\n    return FALSE;\n\n  stash->inliner_chain = NULL;\n\n  /* Check the previously read comp. units first.  */\n  if (do_line)\n    {\n      /* The info hash tables use quite a bit of memory.  We may not want to\n\t always use them.  We use some heuristics to decide if and when to\n\t turn it on.  */\n      if (stash->info_hash_status == STASH_INFO_HASH_OFF)\n\tstash_maybe_enable_info_hash_tables (abfd, stash);\n\n      /* Keep info hash table up to date if they are available.  Note that we\n\t may disable the hash tables if there is any error duing update. */\n      if (stash->info_hash_status == STASH_INFO_HASH_ON)\n\tstash_maybe_update_info_hash_tables (stash);\n\n      if (stash->info_hash_status == STASH_INFO_HASH_ON)\n\t{\n\t  found = stash_find_line_fast (stash, symbol, addr, filename_ptr,\n\t\t\t\t\tlinenumber_ptr);\n\t  if (found)\n\t    goto done;\n\t}\n      else\n\t{\n\t  /* Check the previously read comp. units first.  */\n\t  for (each = stash->all_comp_units; each; each = each->next_unit)\n\t    if ((symbol->flags & BSF_FUNCTION) == 0\n\t\t|| each->arange.high == 0\n\t\t|| comp_unit_contains_address (each, addr))\n\t      {\n\t\tfound = comp_unit_find_line (each, symbol, addr, filename_ptr,\n\t\t\t\t\t     linenumber_ptr, stash);\n\t\tif (found)\n\t\t  goto done;\n\t      }\n\t}\n    }\n  else\n    {\n      bfd_vma min_range = (bfd_vma) -1;\n      const char * local_filename = NULL;\n      struct funcinfo *local_function = NULL;\n      unsigned int local_linenumber = 0;\n      unsigned int local_discriminator = 0;\n\n      for (each = stash->all_comp_units; each; each = each->next_unit)\n\t{\n\t  bfd_vma range = (bfd_vma) -1;\n\n\t  found = ((each->arange.high == 0\n\t\t    || comp_unit_contains_address (each, addr))\n\t\t   && (range = comp_unit_find_nearest_line (each, addr,\n\t\t\t\t\t\t\t    & local_filename,\n\t\t\t\t\t\t\t    & local_function,\n\t\t\t\t\t\t\t    & local_linenumber,\n\t\t\t\t\t\t\t    & local_discriminator,\n\t\t\t\t\t\t\t    stash)) != 0);\n\t  if (found)\n\t    {\n\t      /* PRs 15935 15994: Bogus debug information may have provided us\n\t\t with an erroneous match.  We attempt to counter this by\n\t\t selecting the match that has the smallest address range\n\t\t associated with it.  (We are assuming that corrupt debug info\n\t\t will tend to result in extra large address ranges rather than\n\t\t extra small ranges).\n\n\t\t This does mean that we scan through all of the CUs associated\n\t\t with the bfd each time this function is called.  But this does\n\t\t have the benefit of producing consistent results every time the\n\t\t function is called.  */\n\t      if (range <= min_range)\n\t\t{\n\t\t  if (filename_ptr && local_filename)\n\t\t    * filename_ptr = local_filename;\n\t\t  if (local_function)\n\t\t    function = local_function;\n\t\t  if (discriminator_ptr && local_discriminator)\n\t\t    * discriminator_ptr = local_discriminator;\n\t\t  if (local_linenumber)\n\t\t    * linenumber_ptr = local_linenumber;\n\t\t  min_range = range;\n\t\t}\n\t    }\n\t}\n\n      if (* linenumber_ptr)\n\t{\n\t  found = TRUE;\n\t  goto done;\n\t}\n    }\n\n  /* The DWARF2 spec says that the initial length field, and the\n     offset of the abbreviation table, should both be 4-byte values.\n     However, some compilers do things differently.  */\n  if (addr_size == 0)\n    addr_size = 4;\n  BFD_ASSERT (addr_size == 4 || addr_size == 8);\n\n  /* Read each remaining comp. units checking each as they are read.  */\n  while (stash->info_ptr < stash->info_ptr_end)\n    {\n      bfd_vma length;\n      unsigned int offset_size = addr_size;\n      bfd_byte *info_ptr_unit = stash->info_ptr;\n\n      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr, stash->info_ptr_end);\n      /* A 0xffffff length is the DWARF3 way of indicating\n\t we use 64-bit offsets, instead of 32-bit offsets.  */\n      if (length == 0xffffffff)\n\t{\n\t  offset_size = 8;\n\t  length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);\n\t  stash->info_ptr += 12;\n\t}\n      /* A zero length is the IRIX way of indicating 64-bit offsets,\n\t mostly because the 64-bit length will generally fit in 32\n\t bits, and the endianness helps.  */\n      else if (length == 0)\n\t{\n\t  offset_size = 8;\n\t  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);\n\t  stash->info_ptr += 8;\n\t}\n      /* In the absence of the hints above, we assume 32-bit DWARF2\n\t offsets even for targets with 64-bit addresses, because:\n\t   a) most of the time these targets will not have generated\n\t      more than 2Gb of debug info and so will not need 64-bit\n\t      offsets,\n\t and\n\t   b) if they do use 64-bit offsets but they are not using\n\t      the size hints that are tested for above then they are\n\t      not conforming to the DWARF3 standard anyway.  */\n      else if (addr_size == 8)\n\t{\n\t  offset_size = 4;\n\t  stash->info_ptr += 4;\n\t}\n      else\n\tstash->info_ptr += 4;\n\n      if (length > 0)\n\t{\n\t  bfd_byte * new_ptr;\n\n\t  each = parse_comp_unit (stash, length, info_ptr_unit,\n\t\t\t\t  offset_size);\n\t  if (!each)\n\t    /* The dwarf information is damaged, don't trust it any\n\t       more.  */\n\t    break;\n\n\t  new_ptr = stash->info_ptr + length;\n\t  /* PR 17512: file: 1500698c.  */\n\t  if (new_ptr < stash->info_ptr)\n\t    {\n\t      /* A corrupt length value - do not trust the info any more.  */\n\t      found = FALSE;\n\t      break;\n\t    }\n\t  else\n\t    stash->info_ptr = new_ptr;\n\n\t  if (stash->all_comp_units)\n\t    stash->all_comp_units->prev_unit = each;\n\t  else\n\t    stash->last_comp_unit = each;\n\n\t  each->next_unit = stash->all_comp_units;\n\t  stash->all_comp_units = each;\n\n\t  /* DW_AT_low_pc and DW_AT_high_pc are optional for\n\t     compilation units.  If we don't have them (i.e.,\n\t     unit->high == 0), we need to consult the line info table\n\t     to see if a compilation unit contains the given\n\t     address.  */\n\t  if (do_line)\n\t    found = (((symbol->flags & BSF_FUNCTION) == 0\n\t\t      || each->arange.high == 0\n\t\t      || comp_unit_contains_address (each, addr))\n\t\t     && comp_unit_find_line (each, symbol, addr,\n\t\t\t\t\t     filename_ptr,\n\t\t\t\t\t     linenumber_ptr,\n\t\t\t\t\t     stash));\n\t  else\n\t    found = ((each->arange.high == 0\n\t\t      || comp_unit_contains_address (each, addr))\n\t\t     && comp_unit_find_nearest_line (each, addr,\n\t\t\t\t\t\t     filename_ptr,\n\t\t\t\t\t\t     &function,\n\t\t\t\t\t\t     linenumber_ptr,\n\t\t\t\t\t\t     discriminator_ptr,\n\t\t\t\t\t\t     stash) != 0);\n\n\t  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)\n\t      == stash->sec->size)\n\t    {\n\t      stash->sec = find_debug_info (stash->bfd_ptr, debug_sections,\n\t\t\t\t\t    stash->sec);\n\t      stash->sec_info_ptr = stash->info_ptr;\n\t    }\n\n\t  if (found)\n\t    goto done;\n\t}\n    }\n\n done:\n  if (function)\n    {\n      if (!function->is_linkage\n\t  && _bfd_elf_find_function (abfd, symbols, section, offset,\n\t\t\t\t     *filename_ptr ? NULL : filename_ptr,\n\t\t\t\t     functionname_ptr))\n\t{\n\t  function->name = *functionname_ptr;\n\t  function->is_linkage = TRUE;\n\t}\n      else\n\t*functionname_ptr = function->name;\n    }\n  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0)\n    unset_sections (stash);\n\n  return found;\n}"
}