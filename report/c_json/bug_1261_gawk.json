{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "builtin.c",
    "message": "Offset: [1, +oo] Size: [0, +oo] by call to `make_str_node`.",
    "warning_function_name": "do_match",
    "warning_line": "sub = make_string(buf, slen);",
    "warning_context": "\tsize_t subseplen;\n\n\tdest = NULL;\n\tif (nargs == 3) {\t/* 3rd optional arg for the subpatterns */\n\t\tdest = POP_PARAM();\n\t\tif (dest->type != Node_var_array)\n\t\t\tfatal(_(\"match: third argument is not an array\"));\n\t\tassoc_clear(dest);\n\t}\n\ttre = POP();\n\trp = re_update(tre);\n\tt1 = POP_STRING();\n\t\n\trstart = research(rp, t1->stptr, 0, t1->stlen, RE_NEED_START);\n\tif (rstart >= 0) {\t/* match succeded */\n\t\tsize_t *wc_indices = NULL;\n\n\t\trlength = REEND(rp, t1->stptr) - RESTART(rp, t1->stptr);\t/* byte length */\n\t\tif (rlength > 0 && gawk_mb_cur_max > 1) {\n\t\t\tt1 = str2wstr(t1, & wc_indices);\n\t\t\trlength = wc_indices[rstart + rlength - 1] - wc_indices[rstart] + 1;\n\t\t\trstart = wc_indices[rstart];\n\t\t}\n\n\t\trstart++;\t/* now it's 1-based indexing */\n\t\n\t\t/* Build the array only if the caller wants the optional subpatterns */\n\t\tif (dest != NULL) {\n\t\t\tsubsepstr = SUBSEP_node->var_value->stptr;\n\t\t\tsubseplen = SUBSEP_node->var_value->stlen;\n\n\t\t\tfor (ii = 0; ii < NUMSUBPATS(rp, t1->stptr); ii++) {\n\t\t\t\t/*\n\t\t\t\t * Loop over all the subpats; some of them may have\n\t\t\t\t * matched even if all of them did not.\n\t\t\t\t */\n\t\t\t\tif ((s = SUBPATSTART(rp, t1->stptr, ii)) != -1) {\n\t\t\t\t\tsize_t subpat_start;\n\t\t\t\t\tsize_t subpat_len;\n\t\t\t\t\tNODE **lhs;\n\t\t\t\t\tNODE *sub;\n\t\t\t\t\t\n\t\t\t\t\tstart = t1->stptr + s;\n\t\t\t\t\tsubpat_start = s;\n\t\t\t\t\tsubpat_len = len = SUBPATEND(rp, t1->stptr, ii) - s;\n\t\t\t\t\tif (len > 0 && gawk_mb_cur_max > 1) {\n\t\t\t\t\t\tsubpat_start = wc_indices[s];\n\t\t\t\t\t\tsubpat_len = wc_indices[s + len - 1] - subpat_start + 1;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tit = make_string(start, len);\n\t\t\t\t\tit->flags |= MAYBE_NUM;\t/* user input */\n\n\t\t\t\t\tsub = make_number((AWKNUM) (ii));\n\t\t\t\t\tlhs = assoc_lookup(dest, sub);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = it;\n\t\t\t\t\t/* execute post-assignment routine if any */\n\t\t\t\t\tif (dest->astore != NULL)\n\t\t\t\t\t\t(*dest->astore)(dest, sub);\n\t\t\t\t\tunref(sub);\n\n\t\t\t\t\tsprintf(buff, \"%d\", ii);\n\t\t\t\t\tilen = strlen(buff);\n\t\t\t\t\tamt = ilen + subseplen + strlen(\"length\") + 2;\n\t\n\t\t\t\t\tif (oldamt == 0) {\n\t\t\t\t\t\temalloc(buf, char *, amt, \"do_match\");\n\t\t\t\t\t} else if (amt > oldamt) {\n\t\t\t\t\t\terealloc(buf, char *, amt, \"do_match\");\n\t\t\t\t\t}\n\t\t\t\t\toldamt = amt;\n\t\t\t\t\tmemcpy(buf, buff, ilen);\n\t\t\t\t\tmemcpy(buf + ilen, subsepstr, subseplen);\n\t\t\t\t\tmemcpy(buf + ilen + subseplen, \"start\", 6);\n\t\n\t\t\t\t\tslen = ilen + subseplen + 5;\n\t\n\t\t\t\t\tit = make_number((AWKNUM) subpat_start + 1);\n\t\t\t\t\tsub = make_string(buf, slen);\n\t\t\t\t\tlhs = assoc_lookup(dest, sub);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = it;\n\t\t\t\t\tif (dest->astore != NULL)\n\t\t\t\t\t\t(*dest->astore)(dest, sub);\n\t\t\t\t\tunref(sub);\n\t\n\t\t\t\t\tmemcpy(buf, buff, ilen);\n\t\t\t\t\tmemcpy(buf + ilen, subsepstr, subseplen);\n\t\t\t\t\tmemcpy(buf + ilen + subseplen, \"length\", 7);\n\t\n\t\t\t\t\tslen = ilen + subseplen + 6;\n\t\n\t\t\t\t\tit = make_number((AWKNUM) subpat_len);\n\t\t\t\t\tsub = make_string(buf, slen);\n\t\t\t\t\tlhs = assoc_lookup(dest, sub);\n\t\t\t\t\tunref(*lhs);\n\t\t\t\t\t*lhs = it;\n\t\t\t\t\tif (dest->astore != NULL)\n\t\t\t\t\t\t(*dest->astore)(dest, sub);\n\t\t\t\t\tunref(sub);\n"
}