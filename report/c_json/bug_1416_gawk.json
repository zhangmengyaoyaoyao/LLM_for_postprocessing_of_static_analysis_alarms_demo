{
    "project": "gawk",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "debug.c",
    "message": "Dereference of null pointer",
    "warning_function_name": "print_instruction",
    "warning_line": "func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,",
    "warning_context": "\tcase Op_field_spec_lhs:\n\t\tprint_func(fp, \"[target_assign = %p] [do_reference = %s]\\n\",\n\t\t\t\tpc->target_assign, pc->do_reference ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_func:\n\t\tprint_func(fp, \"[param_cnt = %d] [source_file = %s]\\n\", pcount,\n\t\t\t\tpc->source_file ? pc->source_file : \"cmd. line\");\n\t\tbreak;\n\n\tcase Op_K_getline_redir:\n\t\tprint_func(fp, \"[into_var = %s] [redir_type = \\\"%s\\\"]\\n\",\n\t\t                pc->into_var ? \"true\" : \"false\",\n\t\t                redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_K_getline:\n\t\tprint_func(fp, \"[into_var = %s]\\n\", pc->into_var ? \"true\" : \"false\");\n\t\tprint_func(fp, \"%*s[target_beginfile = %p] [target_endfile = %p]\\n\",\n\t\t                noffset, \"\",\n\t\t                (pc + 1)->target_beginfile, (pc + 1)->target_endfile);\n\t\tbreak;\n\n\tcase Op_K_print_rec:\n\t\tprint_func(fp, \"[redir_type = \\\"%s\\\"]\\n\", redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_K_print:\n\tcase Op_K_printf:\n\t\tprint_func(fp, \"[expr_count = %ld] [redir_type = \\\"%s\\\"]\\n\",\n\t\t                pc->expr_count, redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_indirect_func_call:\n\tcase Op_func_call:\n\t\tprint_func(fp, \"[func_name = %s] [arg_count = %ld]\\n\",\n\t\t                pc->func_name, (pc + 1)->expr_count);\n\t\tbreak;\n\n\tcase Op_K_nextfile:\n\t\tprint_func(fp, \"[target_newfile = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_newfile, pc->target_endfile);\n\t\tbreak;\n\n\tcase Op_newfile:\n\t\tprint_func(fp, \"[target_jmp = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_jmp, pc->target_endfile);\n\t\tprint_func(fp, \"%*s[target_get_record = %p]\\n\",\n\t\t                noffset, \"\", (pc + 1)->target_get_record);\n\t\tbreak;\n\n\tcase Op_get_record:\n\t\tprint_func(fp, \"[target_newfile = %p]\\n\", pc->target_newfile);\n\t\tbreak;\n\n\tcase Op_jmp:\n\tcase Op_jmp_false:\n\tcase Op_jmp_true:\n\tcase Op_and:\n\tcase Op_or:\n\tcase Op_K_next:\n\tcase Op_arrayfor_init:\n\tcase Op_K_break:\n\tcase Op_K_continue:\n\t\tprint_func(fp, \"[target_jmp = %p]\\n\", pc->target_jmp);\n\t\tbreak;\n\tcase Op_K_exit:\n\t\tprint_func(fp, \"[target_end = %p] [target_atexit = %p]\\n\",\n\t\t\t\t\t\tpc->target_end, pc->target_atexit);\n\t\tbreak;\n\n\tcase Op_K_case:\n\t\tprint_func(fp, \"[target_jmp = %p] [match_exp = %s]\\n\",\n\t\t\t\t\t\tpc->target_jmp,\t(pc + 1)->match_exp ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_arrayfor_incr:\n\t\tprint_func(fp, \"[array_var = %s] [target_jmp = %p]\\n\",\n\t\t                pc->array_var->type == Node_param_list ?\n\t\t                   func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,\n\t\t                pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_line_range:\n\t\tprint_func(fp, \"[triggered = %ld] [target_jmp = %p]\\n\",\n\t\t                pc->triggered, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_cond_pair:\n\t\tprint_func(fp, \"[line_range = %p] [target_jmp = %p]\\n\",\n\t\t                pc->line_range, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_sub_builtin:\n\t{\n\t\tconst char *fname = \"sub\";\n\t\tstatic const struct flagtab values[] = {\n\t\t\t{ GSUB, \"GSUB\" },\n\t\t\t{ GENSUB, \"GENSUB\" },\n\t\t\t{ LITERAL, \"LITERAL\" },\n\t\t\t{ 0, NULL }\n"
}