{
    "Project": "combine",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "src/process_files.c",
    "message": "pointer `tmp_str` last assigned on line 90 could be null and is dereferenced by call to `strcpy()` at line 90, column 2.",
    "warning_function_name": "process_reference_files",
    "warning_line": "FATAL_PERROR (REFINFO[i].file_name);",
    "warning_context": "int\nprocess_reference_files ()\n{\n  STRINGTYPE *key_value;\n  STRINGTYPE *hrchy_key_value;\n  STRINGTYPE **ref_output_fields;\n  STRINGTYPE *input_record_desc;\n  HASHTYPE hash_index;\n  long int i;\n  long int j;\n  COUNTTYPE temp_number;\n  int return_code;\n  FILE *reference_file;\n\n  for (i = 0; i < gi_reference_file_count; i++) {\n\n    /* Allocate the hash table(s). */\n    REFINFO[i].hash_table\n      = calloc (REFINFO[i].hash_size, sizeof (*REFINFO[i].hash_table));\n    if (REFINFO[i].hash_table == NULL) {\n      FATAL_ERROR3 (_\n\t\t    (\"unable to allocate hash table for %s -- wanted %ld things of size %ld bytes\\n\"),\n\t\t    REFINFO[i].file_name, REFINFO[i].hash_size,\n\t\t    sizeof (*REFINFO[i].hash_table));\n      }\n\n    /* We'll have a second hash for the hierarchy only if we are headed down.\n     * That means we are looking for the present key in a different field on \n     * the next record.\n     */\n    if ((REFINFO[i].hrchy_key_range_count != 0\n\t || REFINFO[i].hrchy_key_end_start != 0)\n\t&& REFINFO[i].hrchy_direction == 0) {\n      REFINFO[i].hrchy_hash_table\n\t= calloc (REFINFO[i].hash_size, sizeof (*REFINFO[i].hash_table));\n      if (REFINFO[i].hrchy_hash_table == NULL) {\n\tFATAL_ERROR3 (_\n\t\t      (\"unable to allocate hash table for %s -- wanted %ld things of size %ld bytes\\n\"),\n\t\t      REFINFO[i].file_name, REFINFO[i].hash_size,\n\t\t      sizeof (*REFINFO[i].hash_table));\n\t}\n      }\n    else\n      REFINFO[i].hrchy_hash_table = NULL;\n\n    /* Open the reference file. */\n    if (strcmp (REFINFO[i].file_name, \"-\") == 0)\n      reference_file = stdin;\n    else {\n      reference_file = fopen (REFINFO[i].file_name, \"r\");\n      if (reference_file == NULL)\n\tFATAL_PERROR (REFINFO[i].file_name);\n      }\n\n    /* Read all the records and put data in the hash table. */\n    input_record_desc\n      = df_get_next_record (reference_file, &(REFINFO[i].input_buffer),\n\t\t\t    &(REFINFO[i].input_buffer_pos),\n\t\t\t    &(REFINFO[i].input_buffer_size),\n\t\t\t    REFINFO[i].input_record_delimiter,\n\t\t\t    REFINFO[i].input_record_length);\n    while (input_record_desc != NULL) {\n      int keep_record;\n\n      REFINFO[i].records_read++;\n      keep_record = 1;\n\n      if (gi_verbose_ind != 0 && (REFINFO[i].records_read % 1000) == 0)\n\tfprintf (stderr,\n\t\t _(\"\\rReading from reference file (%ld) %s: %12d records\"),\n\t\t i + 1, REFINFO[i].file_name, REFINFO[i].records_read);\n\n      /* If we need to do anything to the entire record, do it */\n#ifdef HAVE_LIBGUILE\n      if (REFINFO[i].ext_record_read_command != NULL) {\n\tchar *command_string;\n\tSTRINGTYPE *result_string;\n\tSCM return_val;\n\tsize_t return_length;\n\n\tcommand_string\n\t  = malloc (REFINFO[i].ext_record_read_command->length\n\t\t    + input_record_desc->length + 1);\n\tif (command_string == NULL)\n\t  FATAL_ERROR (_(\"unable to allocate memory\"));\n\treturn_length\n\t  = sprintf (command_string, REFINFO[i].ext_record_read_command->string,\n\t\t     input_record_desc->length, input_record_desc->string);\n\tif (return_length\n\t    > REFINFO[i].ext_record_read_command->length\n\t    + input_record_desc->length)\n\t  FATAL_ERROR1 (_(\"sprintf overflow in %s\"),\n\t\t\t\"reference record command\");\n\tresult_string = eval_scheme_string_function (command_string);\n\tif (input_record_desc->own_string == DStr_own)\n\t  free (input_record_desc->string);\n\tinput_record_desc->string = result_string->string;\n\tinput_record_desc->length = result_string->length;\n\tinput_record_desc->own_string = DStr_not_own;\n        result_string->own_string = DStr_not_own;\n\tdstrfree (result_string);\n"
}