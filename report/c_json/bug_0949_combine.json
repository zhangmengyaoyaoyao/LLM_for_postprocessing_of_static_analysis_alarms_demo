{
    "project": "combine",
    "tool": "Cppcheck",
    "category": "uninitvar",
    "file": "src/index.c",
    "message": "Uninitialized variable: *next",
    "warning_function_name": "find_index_key",
    "warning_line": "if (*next == -1) {",
    "warning_context": "INDEXNUM\nfind_index_key (entries, number_size, hash_method, index_file, key, next,\n\t\tposition, length)\n     INDEXNUM entries;\n     INDEXNUM number_size;\n     INDEXNUM hash_method;\n     FILE *index_file;\n     STRINGTYPE *key;\n     INDEXNUM *next;\n     INDEXNUM *position;\n     INDEXNUM *length;\n{\n  HASHTYPE hash_key;\n  INDEXNUM start_pos;\n  INDEXNUM curr_pos;\n  comb_hash_entry_ll index_entry;\n  int return_val;\n\n  if (*next == -1) {\n    INDEXNUM orig_pos;\n    start_pos = -1;\n    hash_key = calc_hash_key (key);\n    curr_pos = hash_key % entries;\n    orig_pos = curr_pos;\n    do {\n      char *test_key;\n      /* Get the index entry */\n      return_val\n\t= fseek (index_file,\n\t\t sizeof (comb_index_hdr) + sizeof (comb_index_hdr_ll)\n\t\t + curr_pos * sizeof (comb_hash_entry_ll), SEEK_SET);\n      if (return_val != 0)\n\tFATAL_ERROR (_(\"unable to reposition within index\"));\n      return_val = fread (&index_entry, sizeof (index_entry), 1, index_file);\n      if (return_val != 1)\n\tFATAL_ERROR (_(\"error reading index file\"));\n\n      /* Get the index key */\n      test_key = malloc (index_entry.key_length);\n      if (test_key == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      return_val\n\t= fseek (index_file,\n\t\t sizeof (comb_index_hdr) + sizeof (comb_index_hdr_ll)\n\t\t + entries * sizeof (comb_hash_entry_ll)\n\t\t + index_entry.key_position, SEEK_SET);\n      if (return_val != 0)\n\tFATAL_ERROR (_(\"unable to reposition within index\"));\n      return_val = fread (test_key, index_entry.key_length, 1, index_file);\n      if (return_val != 1)\n\tFATAL_ERROR (_(\"error reading index file\"));\n\n      if (key->length == index_entry.key_length\n\t  && memcmp (key->string, test_key, key->length) == 0) {\n\tstart_pos = curr_pos;\n\torig_pos = curr_pos;\n\t}\n      else\n\tcurr_pos = (curr_pos + 1) % entries;\n      free (test_key);\n      }\n    while (curr_pos != orig_pos);\n\n    }\n  else {\n    start_pos = *next;\n    /* Get the index entry */\n    return_val\n      = fseek (index_file,\n\t       sizeof (comb_index_hdr) + sizeof (comb_index_hdr_ll)\n\t       + start_pos * sizeof (comb_hash_entry_ll), SEEK_SET);\n    if (return_val != 0)\n      FATAL_ERROR (_(\"unable to reposition within index\"));\n    return_val = fread (&index_entry, sizeof (index_entry), 1, index_file);\n    if (return_val != 1)\n      FATAL_ERROR (_(\"error reading index file\"));\n    }\n\n  if (start_pos == -1)\n    return -1;\n\n  if (next != NULL)\n    *next = index_entry.next_same_key;\n  if (position != NULL)\n    *position = index_entry.file_position;\n  if (length != NULL)\n    *length = index_entry.record_length;\n  return 0;\n\n  }\n"
}