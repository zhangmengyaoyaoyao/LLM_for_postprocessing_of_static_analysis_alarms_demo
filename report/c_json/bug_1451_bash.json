{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from temp was never initialized.",
    "Code_line": "  return temp;",
    "Code_function": "parameter_brace_casemod (varname, value, ind, modspec, patspec, quoted, flags)\n     char *varname, *value;\n     int ind, modspec;\n     char *patspec;\n     int quoted, flags;\n{\n  int vtype, starsub, modop, mflags, x;\n  char *val, *temp, *pat, *p, *lpat, *tt;\n  SHELL_VAR *v;\n\n  if (value == 0)\n    return ((char *)NULL);\n\n  this_command_name = varname;\n\n  vtype = get_var_and_type (varname, value, ind, quoted, flags, &v, &val);\n  if (vtype == -1)\n    return ((char *)NULL);\n\n  starsub = vtype & VT_STARSUB;\n  vtype &= ~VT_STARSUB;\n\n  modop = 0;\n  mflags = 0;\n  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n    mflags |= MATCH_QUOTED;\n  if (starsub)\n    mflags |= MATCH_STARSUB;\n\n  p = patspec;\n  if (modspec == '^')\n    {\n      x = p && p[0] == modspec;\n      modop = x ? CASE_UPPER : CASE_UPFIRST;\n      p += x;\n    }\n  else if (modspec == ',')\n    {\n      x = p && p[0] == modspec;\n      modop = x ? CASE_LOWER : CASE_LOWFIRST;\n      p += x;\n    }\n  else if (modspec == '~')\n    {\n      x = p && p[0] == modspec;\n      modop = x ? CASE_TOGGLEALL : CASE_TOGGLE;\n      p += x;\n    }\n\n  lpat = p ? savestring (p) : 0;\n  /* Perform the same expansions on the pattern as performed by the\n     pattern removal expansions.  FOR LATER */\n  pat = lpat ? getpattern (lpat, quoted, 1) : 0;\n\n  /* OK, now we do the case modification. */\n  switch (vtype)\n    {\n    case VT_VARIABLE:\n    case VT_ARRAYMEMBER:\n      temp = sh_modcase (val, pat, modop);\n      if (vtype == VT_VARIABLE)\n\tFREE (val);\n      if (temp)\n\t{\n\t  tt = (mflags & MATCH_QUOTED) ? quote_string (temp) : quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n\n    case VT_POSPARMS:\n      temp = pos_params_modcase (val, pat, modop, mflags);\n      if (temp && (mflags & MATCH_QUOTED)  == 0)\n\t{\n\t  tt = quote_escapes (temp);\n\t  free (temp);\n\t  temp = tt;\n\t}\n      break;\n\n#if defined (ARRAY_VARS)\n    case VT_ARRAYVAR:\n      temp = assoc_p (v) ? assoc_modcase (assoc_cell (v), pat, modop, mflags)\n\t\t\t : array_modcase (array_cell (v), pat, modop, mflags);\n      /* Don't call quote_escapes; array_modcase calls array_quote_escapes\n\t as appropriate before adding the space separators; ditto for\n\t assoc_modcase. */\n      break;\n#endif\n    }\n\n  FREE (pat);\n  free (lpat);\n\n  return temp;\n}"
}