{
    "Project": "RIOT",
    "Tool": "Infer",
    "category": "Buffer Overrun L2",
    "file": "sys/net/gnrc/netif/gnrc_netif.c",
    "message": "Offset: [0, 4294967294] Size: 2.",
    "warning_function_name": "rc_netif_ipv6_addr_add_internal(g",
    "warning_line": "netif->ipv6.addrs_flags[idx] = flags;",
    "warning_context": "int gnrc_netif_ipv6_addr_add_internal(gnrc_netif_t *netif,\n                                      const ipv6_addr_t *addr,\n                                      unsigned pfx_len, uint8_t flags)\n{\n    unsigned idx = UINT_MAX;\n\n    assert((netif != NULL) && (addr != NULL));\n    assert(!(ipv6_addr_is_multicast(addr) || ipv6_addr_is_unspecified(addr) ||\n             ipv6_addr_is_loopback(addr)));\n    assert((pfx_len > 0) && (pfx_len <= 128));\n    gnrc_netif_acquire(netif);\n    if ((flags & GNRC_NETIF_IPV6_ADDRS_FLAGS_STATE_MASK) ==\n        GNRC_NETIF_IPV6_ADDRS_FLAGS_STATE_TENTATIVE) {\n        /* set to first retransmission */\n        flags &= ~GNRC_NETIF_IPV6_ADDRS_FLAGS_STATE_TENTATIVE;\n        flags |= 0x1;\n    }\n    for (unsigned i = 0; i < CONFIG_GNRC_NETIF_IPV6_ADDRS_NUMOF; i++) {\n        if (ipv6_addr_equal(&netif->ipv6.addrs[i], addr)) {\n            gnrc_netif_release(netif);\n            return i;\n        }\n        if ((idx == UINT_MAX) && (netif->ipv6.addrs_flags[i] == 0)) {\n            idx = i;\n        }\n    }\n    if (idx == UINT_MAX) {\n        gnrc_netif_release(netif);\n        return -ENOMEM;\n    }\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_ARSM)\n    ipv6_addr_t sol_nodes;\n    int res;\n\n    /* TODO: SHOULD delay join between 0 and MAX_RTR_SOLICITATION_DELAY\n     * for SLAAC */\n    ipv6_addr_set_solicited_nodes(&sol_nodes, addr);\n    res = gnrc_netif_ipv6_group_join_internal(netif, &sol_nodes);\n    if (res < 0) {\n        DEBUG(\"gnrc_netif: Can't join solicited-nodes of %s on interface %\"\n              PRIkernel_pid \"\\n\",\n              ipv6_addr_to_str(addr_str, addr, sizeof(addr_str)),\n              netif->pid);\n        return res;\n    }\n#else  /* CONFIG_GNRC_IPV6_NIB_ARSM */\n    if (!gnrc_netif_is_6ln(netif)) {\n        LOG_WARNING(\"Address-resolution state-machine not activated. Neighbors \"\n                    \"from interface %u\\nwill not be able to resolve address \"\n                    \"%s\\n\"\n                    \"    Use CONFIG_GNRC_IPV6_NIB_ARSM=1 to activate.\\n\",\n                    netif->pid, ipv6_addr_to_str(addr_str, addr,\n                                                 sizeof(addr_str)));\n    }\n#endif /* CONFIG_GNRC_IPV6_NIB_ARSM */\n    netif->ipv6.addrs_flags[idx] = flags;\n    memcpy(&netif->ipv6.addrs[idx], addr, sizeof(netif->ipv6.addrs[idx]));\n#ifdef MODULE_GNRC_IPV6_NIB\n    if (_get_state(netif, idx) == GNRC_NETIF_IPV6_ADDRS_FLAGS_STATE_VALID) {\n        void *state = NULL;\n        gnrc_ipv6_nib_pl_t ple;\n        bool in_pl = false;\n\n        while (gnrc_ipv6_nib_pl_iter(netif->pid, &state, &ple)) {\n            if (ipv6_addr_match_prefix(&ple.pfx, addr) >= pfx_len) {\n                in_pl = true;\n            }\n        }\n        if (!in_pl) {\n            gnrc_ipv6_nib_pl_set(netif->pid, addr, pfx_len,\n                                 UINT32_MAX, UINT32_MAX);\n        }\n    }\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_SLAAC)\n    else if (!gnrc_netif_is_6ln(netif)) {\n        /* cast to remove const qualifier (will still be used NIB internally as\n         * const) */\n        msg_t msg = { .type = GNRC_IPV6_NIB_DAD,\n                      .content = { .ptr = &netif->ipv6.addrs[idx] } };\n\n        msg_send(&msg, gnrc_ipv6_pid);\n    }\n#endif\n#else\n    (void)pfx_len;\n#endif\n    gnrc_netif_release(netif);\n    return idx;\n}\n"
}