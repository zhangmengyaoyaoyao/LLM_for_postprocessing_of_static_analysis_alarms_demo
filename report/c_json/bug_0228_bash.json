{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/termcap/termcap.c",
    "message": "The value read from end was never initialized.",
    "warning_function_name": "scan_file",
    "warning_line": "return end + 1;",
    "warning_context": "      c1 = *str1++;\n      c2 = *str2++;\n      while (c1 == '\\\\' && *str1 == '\\n')\n\t{\n\t  str1++;\n\t  while ((c1 = *str1++) == ' ' || c1 == '\\t');\n\t}\n      if (c2 == '\\0')\n\t{\n\t  /* End of type being looked up.  */\n\t  if (c1 == '|' || c1 == ':')\n\t    /* If end of name in data base, we win.  */\n\t    return 0;\n\t  else\n\t    return 1;\n        }\n      else if (c1 != c2)\n\treturn 1;\n    }\n}\n\n/* Make sure that the buffer <- BUFP contains a full line\n   of the file open on FD, starting at the place BUFP->ptr\n   points to.  Can read more of the file, discard stuff before\n   BUFP->ptr, or make the buffer bigger.\n\n   Return the pointer to after the newline ending the line,\n   or to the end of the file, if there is no newline to end it.\n\n   Can also merge on continuation lines.  If APPEND_END is\n   non-null, it points past the newline of a line that is\n   continued; we add another line onto it and regard the whole\n   thing as one line.  The caller decides when a line is continued.  */\n\nstatic char *\ngobble_line (fd, bufp, append_end)\n     int fd;\n     register struct buffer *bufp;\n     char *append_end;\n{\n  register char *end;\n  register int nread;\n  register char *buf = bufp->beg;\n  register char *tem;\n\n  if (!append_end)\n    append_end = bufp->ptr;\n\n  while (1)\n    {\n      end = append_end;\n      while (*end && *end != '\\n') end++;\n      if (*end)\n        break;\n      if (bufp->ateof)\n\treturn buf + bufp->full;\n      if (bufp->ptr == buf)\n\t{\n\t  if (bufp->full == bufp->size)\n\t    {\n\t      bufp->size *= 2;\n\t      /* Add 1 to size to ensure room for terminating null.  */\n\t      tem = (char *) xrealloc (buf, bufp->size + 1);\n\t      bufp->ptr = (bufp->ptr - buf) + tem;\n\t      append_end = (append_end - buf) + tem;\n\t      bufp->beg = buf = tem;\n\t    }\n\t}\n      else\n\t{\n\t  append_end -= bufp->ptr - buf;\n\t  bcopy (bufp->ptr, buf, bufp->full -= bufp->ptr - buf);\n\t  bufp->ptr = buf;\n\t}\n      if (!(nread = read (fd, buf + bufp->full, bufp->size - bufp->full)))\n\tbufp->ateof = 1;\n      bufp->full += nread;\n      buf[bufp->full] = '\\0';\n    }\n  return end + 1;\n}\n\n#ifdef TEST\n\n#ifdef NULL\n#undef NULL\n#endif\n\n#include <stdio.h>\n\nmain (argc, argv)\n     int argc;\n     char **argv;\n{\n  char *term;\n  char *buf;\n\n  term = argv[1];\n  printf (\"TERM: %s\\n\", term);\n\n  buf = (char *) tgetent (0, term);\n"
}