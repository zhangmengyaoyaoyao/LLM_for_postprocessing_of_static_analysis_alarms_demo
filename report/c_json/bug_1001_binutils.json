{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t      print_displacement (scratchbuf, disp);",
    "Code_function": "OP_E_memory (int bytemode, int sizeflag)\n{\n  bfd_vma disp = 0;\n  int add = (rex & REX_B) ? 8 : 0;\n  int riprel = 0;\n  int shift;\n\n  if (vex.evex)\n    {\n      /* In EVEX, if operand doesn't allow broadcast, vex.b should be 0.  */\n      if (vex.b\n\t  && bytemode != x_mode\n\t  && bytemode != xmmq_mode\n\t  && bytemode != evex_half_bcst_xmmq_mode)\n\t{\n\t  BadOp ();\n\t  return;\n\t}\n      switch (bytemode)\n\t{\n\tcase dqw_mode:\n\tcase dw_mode:\n\tcase dqw_swap_mode:\n\t  shift = 1;\n\t  break;\n\tcase dqb_mode:\n\tcase db_mode:\n\t  shift = 0;\n\t  break;\n\tcase vex_vsib_d_w_dq_mode:\n\tcase vex_vsib_d_w_d_mode:\n\tcase vex_vsib_q_w_dq_mode:\n\tcase vex_vsib_q_w_d_mode:\n\tcase evex_x_gscat_mode:\n\tcase xmm_mdq_mode:\n\t  shift = vex.w ? 3 : 2;\n\t  break;\n\tcase x_mode:\n\tcase evex_half_bcst_xmmq_mode:\n\tcase xmmq_mode:\n\t  if (vex.b)\n\t    {\n\t      shift = vex.w ? 3 : 2;\n\t      break;\n\t    }\n\t  /* Fall through if vex.b == 0.  */\n\tcase xmmqd_mode:\n\tcase xmmdw_mode:\n\tcase ymmq_mode:\n\tcase evex_x_nobcst_mode:\n\tcase x_swap_mode:\n\t  switch (vex.length)\n\t    {\n\t    case 128:\n\t      shift = 4;\n\t      break;\n\t    case 256:\n\t      shift = 5;\n\t      break;\n\t    case 512:\n\t      shift = 6;\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t  break;\n\tcase ymm_mode:\n\t  shift = 5;\n\t  break;\n\tcase xmm_mode:\n\t  shift = 4;\n\t  break;\n\tcase xmm_mq_mode:\n\tcase q_mode:\n\tcase q_scalar_mode:\n\tcase q_swap_mode:\n\tcase q_scalar_swap_mode:\n\t  shift = 3;\n\t  break;\n\tcase dqd_mode:\n\tcase xmm_md_mode:\n\tcase d_mode:\n\tcase d_scalar_mode:\n\tcase d_swap_mode:\n\tcase d_scalar_swap_mode:\n\t  shift = 2;\n\t  break;\n\tcase xmm_mw_mode:\n\t  shift = 1;\n\t  break;\n\tcase xmm_mb_mode:\n\t  shift = 0;\n\t  break;\n\tdefault:\n\t  abort ();\n\t}\n      /* Make necessary corrections to shift for modes that need it.\n\t For these modes we currently have shift 4, 5 or 6 depending on\n\t vex.length (it corresponds to xmmword, ymmword or zmmword\n\t operand).  We might want to make it 3, 4 or 5 (e.g. for\n\t xmmq_mode).  In case of broadcast enabled the corrections\n\t aren't needed, as element size is always 32 or 64 bits.  */\n      if (!vex.b\n\t  && (bytemode == xmmq_mode\n\t      || bytemode == evex_half_bcst_xmmq_mode))\n\tshift -= 1;\n      else if (bytemode == xmmqd_mode)\n\tshift -= 2;\n      else if (bytemode == xmmdw_mode)\n\tshift -= 3;\n      else if (bytemode == ymmq_mode && vex.length == 128)\n\tshift -= 1;\n    }\n  else\n    shift = 0;\n\n  USED_REX (REX_B);\n  if (intel_syntax)\n    intel_operand_size (bytemode, sizeflag);\n  append_seg ();\n\n  if ((sizeflag & AFLAG) || address_mode == mode_64bit)\n    {\n      /* 32/64 bit address mode */\n      int havedisp;\n      int havesib;\n      int havebase;\n      int haveindex;\n      int needindex;\n      int base, rbase;\n      int vindex = 0;\n      int scale = 0;\n      int addr32flag = !((sizeflag & AFLAG)\n\t\t\t || bytemode == v_bnd_mode\n\t\t\t || bytemode == bnd_mode);\n      const char **indexes64 = names64;\n      const char **indexes32 = names32;\n\n      havesib = 0;\n      havebase = 1;\n      haveindex = 0;\n      base = modrm.rm;\n\n      if (base == 4)\n\t{\n\t  havesib = 1;\n\t  vindex = sib.index;\n\t  USED_REX (REX_X);\n\t  if (rex & REX_X)\n\t    vindex += 8;\n\t  switch (bytemode)\n\t    {\n\t    case vex_vsib_d_w_dq_mode:\n\t    case vex_vsib_d_w_d_mode:\n\t    case vex_vsib_q_w_dq_mode:\n\t    case vex_vsib_q_w_d_mode:\n\t      if (!need_vex)\n\t\tabort ();\n\t      if (vex.evex)\n\t\t{\n\t\t  if (!vex.v)\n\t\t    vindex += 16;\n\t\t}\n\n\t      haveindex = 1;\n\t      switch (vex.length)\n\t\t{\n\t\tcase 128:\n\t\t  indexes64 = indexes32 = names_xmm;\n\t\t  break;\n\t\tcase 256:\n\t\t  if (!vex.w\n\t\t      || bytemode == vex_vsib_q_w_dq_mode\n\t\t      || bytemode == vex_vsib_q_w_d_mode)\n\t\t    indexes64 = indexes32 = names_ymm;\n\t\t  else\n\t\t    indexes64 = indexes32 = names_xmm;\n\t\t  break;\n\t\tcase 512:\n\t\t  if (!vex.w\n\t\t      || bytemode == vex_vsib_q_w_dq_mode\n\t\t      || bytemode == vex_vsib_q_w_d_mode)\n\t\t    indexes64 = indexes32 = names_zmm;\n\t\t  else\n\t\t    indexes64 = indexes32 = names_ymm;\n\t\t  break;\n\t\tdefault:\n\t\t  abort ();\n\t\t}\n\t      break;\n\t    default:\n\t      haveindex = vindex != 4;\n\t      break;\n\t    }\n\t  scale = sib.scale;\n\t  base = sib.base;\n\t  codep++;\n\t}\n      rbase = base + add;\n\n      switch (modrm.mod)\n\t{\n\tcase 0:\n\t  if (base == 5)\n\t    {\n\t      havebase = 0;\n\t      if (address_mode == mode_64bit && !havesib)\n\t\triprel = 1;\n\t      disp = get32s ();\n\t    }\n\t  break;\n\tcase 1:\n\t  FETCH_DATA (the_info, codep + 1);\n\t  disp = *codep++;\n\t  if ((disp & 0x80) != 0)\n\t    disp -= 0x100;\n\t  if (vex.evex && shift > 0)\n\t    disp <<= shift;\n\t  break;\n\tcase 2:\n\t  disp = get32s ();\n\t  break;\n\t}\n\n      /* In 32bit mode, we need index register to tell [offset] from\n\t [eiz*1 + offset].  */\n      needindex = (havesib\n\t\t   && !havebase\n\t\t   && !haveindex\n\t\t   && address_mode == mode_32bit);\n      havedisp = (havebase\n\t\t  || needindex\n\t\t  || (havesib && (haveindex || scale != 0)));\n\n      if (!intel_syntax)\n\tif (modrm.mod != 0 || base == 5)\n\t  {\n\t    if (havedisp || riprel)\n\t      print_displacement (scratchbuf, disp);\n\t    else\n\t      print_operand_value (scratchbuf, 1, disp);\n\t    oappend (scratchbuf);\n\t    if (riprel)\n\t      {\n\t\tset_op (disp, 1);\n\t\toappend (sizeflag & AFLAG ? \"(%rip)\" : \"(%eip)\");\n\t      }\n\t  }\n\n      if ((havebase || haveindex || riprel)\n\t  && (bytemode != v_bnd_mode)\n\t  && (bytemode != bnd_mode))\n\tused_prefixes |= PREFIX_ADDR;\n\n      if (havedisp || (intel_syntax && riprel))\n\t{\n\t  *obufp++ = open_char;\n\t  if (intel_syntax && riprel)\n\t    {\n\t      set_op (disp, 1);\n\t      oappend (sizeflag & AFLAG ? \"rip\" : \"eip\");\n\t    }\n\t  *obufp = '\\0';\n\t  if (havebase)\n\t    oappend (address_mode == mode_64bit && !addr32flag\n\t\t     ? names64[rbase] : names32[rbase]);\n\t  if (havesib)\n\t    {\n\t      /* ESP/RSP won't allow index.  If base isn't ESP/RSP,\n\t\t print index to tell base + index from base.  */\n\t      if (scale != 0\n\t\t  || needindex\n\t\t  || haveindex\n\t\t  || (havebase && base != ESP_REG_NUM))\n\t\t{\n\t\t  if (!intel_syntax || havebase)\n\t\t    {\n\t\t      *obufp++ = separator_char;\n\t\t      *obufp = '\\0';\n\t\t    }\n\t\t  if (haveindex)\n\t\t    oappend (address_mode == mode_64bit && !addr32flag\n\t\t\t     ? indexes64[vindex] : indexes32[vindex]);\n\t\t  else\n\t\t    oappend (address_mode == mode_64bit && !addr32flag\n\t\t\t     ? index64 : index32);\n\n\t\t  *obufp++ = scale_char;\n\t\t  *obufp = '\\0';\n\t\t  sprintf (scratchbuf, \"%d\", 1 << scale);\n\t\t  oappend (scratchbuf);\n\t\t}\n\t    }\n\t  if (intel_syntax\n\t      && (disp || modrm.mod != 0 || base == 5))\n\t    {\n\t      if (!havedisp || (bfd_signed_vma) disp >= 0)\n\t\t{\n\t\t  *obufp++ = '+';\n\t\t  *obufp = '\\0';\n\t\t}\n\t      else if (modrm.mod != 1 && disp != -disp)\n\t\t{\n\t\t  *obufp++ = '-';\n\t\t  *obufp = '\\0';\n\t\t  disp = - (bfd_signed_vma) disp;\n\t\t}\n\n\t      if (havedisp)\n\t\tprint_displacement (scratchbuf, disp);\n\t      else\n\t\tprint_operand_value (scratchbuf, 1, disp);\n\t      oappend (scratchbuf);\n\t    }\n\n\t  *obufp++ = close_char;\n\t  *obufp = '\\0';\n\t}\n      else if (intel_syntax)\n\t{\n\t  if (modrm.mod != 0 || base == 5)\n\t    {\n\t      if (!active_seg_prefix)\n\t\t{\n\t\t  oappend (names_seg[ds_reg - es_reg]);\n\t\t  oappend (\":\");\n\t\t}\n\t      print_operand_value (scratchbuf, 1, disp);\n\t      oappend (scratchbuf);\n\t    }\n\t}\n    }\n  else\n    {\n      /* 16 bit address mode */\n      used_prefixes |= prefixes & PREFIX_ADDR;\n      switch (modrm.mod)\n\t{\n\tcase 0:\n\t  if (modrm.rm == 6)\n\t    {\n\t      disp = get16 ();\n\t      if ((disp & 0x8000) != 0)\n\t\tdisp -= 0x10000;\n\t    }\n\t  break;\n\tcase 1:\n\t  FETCH_DATA (the_info, codep + 1);\n\t  disp = *codep++;\n\t  if ((disp & 0x80) != 0)\n\t    disp -= 0x100;\n\t  break;\n\tcase 2:\n\t  disp = get16 ();\n\t  if ((disp & 0x8000) != 0)\n\t    disp -= 0x10000;\n\t  break;\n\t}\n\n      if (!intel_syntax)\n\tif (modrm.mod != 0 || modrm.rm == 6)\n\t  {\n\t    print_displacement (scratchbuf, disp);\n\t    oappend (scratchbuf);\n\t  }\n\n      if (modrm.mod != 0 || modrm.rm != 6)\n\t{\n\t  *obufp++ = open_char;\n\t  *obufp = '\\0';\n\t  oappend (index16[modrm.rm]);\n\t  if (intel_syntax\n\t      && (disp || modrm.mod != 0 || modrm.rm == 6))\n\t    {\n\t      if ((bfd_signed_vma) disp >= 0)\n\t\t{\n\t\t  *obufp++ = '+';\n\t\t  *obufp = '\\0';\n\t\t}\n\t      else if (modrm.mod != 1)\n\t\t{\n\t\t  *obufp++ = '-';\n\t\t  *obufp = '\\0';\n\t\t  disp = - (bfd_signed_vma) disp;\n\t\t}\n\n\t      print_displacement (scratchbuf, disp);\n\t      oappend (scratchbuf);\n\t    }\n\n\t  *obufp++ = close_char;\n\t  *obufp = '\\0';\n\t}\n      else if (intel_syntax)\n\t{\n\t  if (!active_seg_prefix)\n\t    {\n\t      oappend (names_seg[ds_reg - es_reg]);\n\t      oappend (\":\");\n\t    }\n\t  print_operand_value (scratchbuf, 1, disp & 0xffff);\n\t  oappend (scratchbuf);\n\t}\n    }\n  if (vex.evex && vex.b\n      && (bytemode == x_mode\n\t  || bytemode == xmmq_mode\n\t  || bytemode == evex_half_bcst_xmmq_mode))\n    {\n      if (vex.w\n\t  || bytemode == xmmq_mode\n\t  || bytemode == evex_half_bcst_xmmq_mode)\n\t{\n\t  switch (vex.length)\n\t    {\n\t    case 128:\n\t      oappend (\"{1to2}\");\n\t      break;\n\t    case 256:\n\t      oappend (\"{1to4}\");\n\t      break;\n\t    case 512:\n\t      oappend (\"{1to8}\");\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t}\n      else\n\t{\n\t  switch (vex.length)\n\t    {\n\t    case 128:\n\t      oappend (\"{1to4}\");\n\t      break;\n\t    case 256:\n\t      oappend (\"{1to8}\");\n\t      break;\n\t    case 512:\n\t      oappend (\"{1to16}\");\n\t      break;\n\t    default:\n\t      abort ();\n\t    }\n\t}\n    }\n}"
}