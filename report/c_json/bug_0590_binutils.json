{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/app.c",
    "message": "The value read from fromlen was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "ch = GET ();",
    "warning_context": "\t  ch2 = GET ();\n\t  if (ch2 != '-')\n\t    {\n\t      if (ch2 != EOF)\n\t\tUNGET (ch2);\n\t      goto de_fault;\n\t    }\n\t  /* Read and skip to end of line.  */\n\t  do\n\t    {\n\t      ch = GET ();\n\t    }\n\t  while (ch != EOF && ch != '\\n');\n\n\t  if (ch == EOF)\n\t    as_warn (_(\"end of file in comment; newline inserted\"));\n\n\t  state = 0;\n\t  PUT ('\\n');\n\t  break;\n#endif\n#ifdef DOUBLEBAR_PARALLEL\n\tcase LEX_IS_DOUBLEBAR_1ST:\n\t  ch2 = GET ();\n\t  if (ch2 != EOF)\n\t    UNGET (ch2);\n\t  if (ch2 != '|')\n\t    goto de_fault;\n\n\t  /* Handle '||' in two states as invoking PUT twice might\n\t     result in the first one jumping out of this loop.  We'd\n\t     then lose track of the state and one '|' char.  */\n\t  state = 13;\n\t  PUT ('|');\n\t  break;\n#endif\n\tcase LEX_IS_LINE_COMMENT_START:\n\t  /* FIXME-someday: The two character comment stuff was badly\n\t     thought out.  On i386, we want '/' as line comment start\n\t     AND we want C style comments.  hence this hack.  The\n\t     whole lexical process should be reworked.  xoxorich.  */\n\t  if (ch == '/')\n\t    {\n\t      ch2 = GET ();\n\t      if (ch2 == '*')\n\t\t{\n\t\t  old_state = 3;\n\t\t  state = -2;\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  UNGET (ch2);\n\t\t}\n\t    }\n\n\t  if (state == 0 || state == 1)\t/* Only comment at start of line.  */\n\t    {\n\t      int startch;\n\n\t      startch = ch;\n\n\t      do\n\t\t{\n\t\t  ch = GET ();\n\t\t}\n\t      while (ch != EOF && IS_WHITESPACE (ch));\n\n\t      if (ch == EOF)\n\t\t{\n\t\t  as_warn (_(\"end of file in comment; newline inserted\"));\n\t\t  PUT ('\\n');\n\t\t  break;\n\t\t}\n\n\t      if (ch < '0' || ch > '9' || state != 0 || startch != '#')\n\t\t{\n\t\t  /* Not a cpp line.  */\n\t\t  while (ch != EOF && !IS_NEWLINE (ch))\n\t\t    ch = GET ();\n\t\t  if (ch == EOF)\n\t\t    {\n\t\t      as_warn (_(\"end of file in comment; newline inserted\"));\n\t\t      PUT ('\\n');\n\t\t    }\n\t\t  else /* IS_NEWLINE (ch) */\n\t\t    {\n\t\t      /* To process non-zero add_newlines.  */\n\t\t      UNGET (ch);\n\t\t    }\n\t\t  state = 0;\n\t\t  break;\n\t\t}\n\t      /* Looks like `# 123 \"filename\"' from cpp.  */\n\t      UNGET (ch);\n\t      old_state = 4;\n\t      state = -1;\n\t      if (scrub_m68k_mri)\n\t\tout_string = \"\\tlinefile \";\n\t      else\n\t\tout_string = \"\\t.linefile \";\n"
}