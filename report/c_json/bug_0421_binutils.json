{
    "Project": "binutils",
    "Tool": "Cppcheck",
    "category": "uninitvar",
    "file": "bfd/elf32-arm.c",
    "message": "Uninitialized variables: &key.destination, &key.hash, &key.sym_name, &key.r_type, &key.branch_type, &key.non_a8_stub",
    "warning_function_name": "cortex_a8_erratum_scan",
    "warning_line": "bsearch (&key, a8_relocs, num_a8_relocs,",
    "warning_context": "\t  || (section->output_section == bfd_abs_section_ptr))\n\tcontinue;\n\n      base_vma = section->output_section->vma + section->output_offset;\n\n      if (elf_section_data (section)->this_hdr.contents != NULL)\n\tcontents = elf_section_data (section)->this_hdr.contents;\n      else if (! bfd_malloc_and_get_section (input_bfd, section, &contents))\n\treturn TRUE;\n\n      sec_data = elf32_arm_section_data (section);\n\n      for (span = 0; span < sec_data->mapcount; span++)\n\t{\n\t  unsigned int span_start = sec_data->map[span].vma;\n\t  unsigned int span_end = (span == sec_data->mapcount - 1)\n\t    ? section->size : sec_data->map[span + 1].vma;\n\t  unsigned int i;\n\t  char span_type = sec_data->map[span].type;\n\t  bfd_boolean last_was_32bit = FALSE, last_was_branch = FALSE;\n\n\t  if (span_type != 't')\n\t    continue;\n\n\t  /* Span is entirely within a single 4KB region: skip scanning.  */\n\t  if (((base_vma + span_start) & ~0xfff)\n\t      == ((base_vma + span_end) & ~0xfff))\n\t    continue;\n\n\t  /* Scan for 32-bit Thumb-2 branches which span two 4K regions, where:\n\n\t       * The opcode is BLX.W, BL.W, B.W, Bcc.W\n\t       * The branch target is in the same 4KB region as the\n\t\t first half of the branch.\n\t       * The instruction before the branch is a 32-bit\n\t\t length non-branch instruction.  */\n\t  for (i = span_start; i < span_end;)\n\t    {\n\t      unsigned int insn = bfd_getl16 (&contents[i]);\n\t      bfd_boolean insn_32bit = FALSE, is_blx = FALSE, is_b = FALSE;\n\t      bfd_boolean is_bl = FALSE, is_bcc = FALSE, is_32bit_branch;\n\n\t      if ((insn & 0xe000) == 0xe000 && (insn & 0x1800) != 0x0000)\n\t\tinsn_32bit = TRUE;\n\n\t      if (insn_32bit)\n\t\t{\n\t\t  /* Load the rest of the insn (in manual-friendly order).  */\n\t\t  insn = (insn << 16) | bfd_getl16 (&contents[i + 2]);\n\n\t\t  /* Encoding T4: B<c>.W.  */\n\t\t  is_b = (insn & 0xf800d000) == 0xf0009000;\n\t\t  /* Encoding T1: BL<c>.W.  */\n\t\t  is_bl = (insn & 0xf800d000) == 0xf000d000;\n\t\t  /* Encoding T2: BLX<c>.W.  */\n\t\t  is_blx = (insn & 0xf800d000) == 0xf000c000;\n\t\t  /* Encoding T3: B<c>.W (not permitted in IT block).  */\n\t\t  is_bcc = (insn & 0xf800d000) == 0xf0008000\n\t\t\t   && (insn & 0x07f00000) != 0x03800000;\n\t\t}\n\n\t      is_32bit_branch = is_b || is_bl || is_blx || is_bcc;\n\n\t      if (((base_vma + i) & 0xfff) == 0xffe\n\t\t  && insn_32bit\n\t\t  && is_32bit_branch\n\t\t  && last_was_32bit\n\t\t  && ! last_was_branch)\n\t\t{\n\t\t  bfd_signed_vma offset = 0;\n\t\t  bfd_boolean force_target_arm = FALSE;\n\t\t  bfd_boolean force_target_thumb = FALSE;\n\t\t  bfd_vma target;\n\t\t  enum elf32_arm_stub_type stub_type = arm_stub_none;\n\t\t  struct a8_erratum_reloc key, *found;\n\t\t  bfd_boolean use_plt = FALSE;\n\n\t\t  key.from = base_vma + i;\n\t\t  found = (struct a8_erratum_reloc *)\n\t\t      bsearch (&key, a8_relocs, num_a8_relocs,\n\t\t\t       sizeof (struct a8_erratum_reloc),\n\t\t\t       &a8_reloc_compare);\n\n\t\t  if (found)\n\t\t    {\n\t\t      char *error_message = NULL;\n\t\t      struct elf_link_hash_entry *entry;\n\n\t\t      /* We don't care about the error returned from this\n\t\t\t function, only if there is glue or not.  */\n\t\t      entry = find_thumb_glue (info, found->sym_name,\n\t\t\t\t\t       &error_message);\n\n\t\t      if (entry)\n\t\t\tfound->non_a8_stub = TRUE;\n\n\t\t      /* Keep a simpler condition, for the sake of clarity.  */\n\t\t      if (htab->root.splt != NULL && found->hash != NULL\n\t\t\t  && found->hash->root.plt.offset != (bfd_vma) -1)\n\t\t\tuse_plt = TRUE;\n\n"
}