{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      ADVANCE_CHAR (ret, end, start);",
    "Code_function": "sh_modcase (string, pat, flags)\n     const char *string;\n     char *pat;\n     int flags;\n{\n  int start, next, end;\n  int inword, c, nc, nop, match, usewords;\n  char *ret, *s;\n  wchar_t wc;\n#if defined (HANDLE_MULTIBYTE)\n  wchar_t nwc;\n  char mb[MB_LEN_MAX+1];\n  int mlen;\n  size_t m;\n  mbstate_t state;\n#endif\n\n  if (string == 0 || *string == 0)\n    {\n      ret = (char *)xmalloc (1);\n      ret[0] = '\\0';\n      return ret;\n    }\n\n#if defined (HANDLE_MULTIBYTE)\n  memset (&state, 0, sizeof (mbstate_t));\n#endif\n\n  start = 0;\n  end = strlen (string);\n\n  ret = (char *)xmalloc (end + 1);\n  strcpy (ret, string);\n\n  /* See if we are supposed to split on alphanumerics and operate on each word */\n  usewords = (flags & CASE_USEWORDS);\n  flags &= ~CASE_USEWORDS;\n\n  inword = 0;\n  while (start < end)\n    {\n      wc = cval (ret, start);\n\n      if (iswalnum (wc) == 0)\n\t{\n\t  inword = 0;\n#if 0\n\t  ADVANCE_CHAR (ret, end, start);\n\t  continue;\n#endif\n\t}\n\n      if (pat)\n\t{\n\t  next = start;\n\t  ADVANCE_CHAR (ret, end, next);\n\t  s = substring (ret, start, next);\n\t  match = strmatch (pat, s, FNM_EXTMATCH) != FNM_NOMATCH;\n\t  free (s);\n\t  if (match == 0)\n            {\n              start = next;\n              inword = 1;\n              continue;\n            }\n\t}\n\n      /* XXX - for now, the toggling operators work on the individual\n\t words in the string, breaking on alphanumerics.  Should I\n\t leave the capitalization operators to do that also? */\n      if (flags == CASE_CAPITALIZE)\n\t{\n\t  if (usewords)\n\t    nop = inword ? CASE_LOWER : CASE_UPPER;\n\t  else\n\t    nop = (start > 0) ? CASE_LOWER : CASE_UPPER;\n\t  inword = 1;\n\t}\n      else if (flags == CASE_UNCAP)\n\t{\n\t  if (usewords)\n\t    nop = inword ? CASE_UPPER : CASE_LOWER;\n\t  else\n\t    nop = (start > 0) ? CASE_UPPER : CASE_LOWER;\n\t  inword = 1;\n\t}\n      else if (flags == CASE_UPFIRST)\n \t{\n \t  if (usewords)\n\t    nop = inword ? CASE_NOOP : CASE_UPPER;\n\t  else\n\t    nop = (start > 0) ? CASE_NOOP : CASE_UPPER;\n \t  inword = 1;\n \t}\n      else if (flags == CASE_LOWFIRST)\n \t{\n \t  if (usewords)\n\t    nop = inword ? CASE_NOOP : CASE_LOWER;\n\t  else\n\t    nop = (start > 0) ? CASE_NOOP : CASE_LOWER;\n \t  inword = 1;\n \t}\n      else if (flags == CASE_TOGGLE)\n\t{\n\t  nop = inword ? CASE_NOOP : CASE_TOGGLE;\n\t  inword = 1;\n\t}\n      else\n\tnop = flags;\n\n      /* Need to check UCHAR_MAX since wc may have already been converted to a\n\t wide character by cval() */\n      if (MB_CUR_MAX == 1 || (wc <= UCHAR_MAX && is_basic ((int)wc)))\n\t{\nsinglebyte:\n\t  switch (nop)\n\t  {\n\t  default:\n\t  case CASE_NOOP:  nc = wc; break;\n\t  case CASE_UPPER:  nc = TOUPPER (wc); break;\n\t  case CASE_LOWER:  nc = TOLOWER (wc); break;\n\t  case CASE_TOGGLEALL:\n\t  case CASE_TOGGLE: nc = TOGGLE (wc); break;\n\t  }\n\t  ret[start] = nc;\n\t}\n#if defined (HANDLE_MULTIBYTE)\n      else\n\t{\n\t  m = mbrtowc (&wc, string + start, end - start, &state);\n\t  if (MB_INVALIDCH (m))\n\t    {\n\t      wc = (unsigned char)string[start];\n\t      goto singlebyte;\n\t    }\n\t  else if (MB_NULLWCH (m))\n\t    wc = L'\\0';\n\t  switch (nop)\n\t  {\n\t  default:\n\t  case CASE_NOOP:  nwc = wc; break;\n\t  case CASE_UPPER:  nwc = _to_wupper (wc); break;\n\t  case CASE_LOWER:  nwc = _to_wlower (wc); break;\n\t  case CASE_TOGGLEALL:\n\t  case CASE_TOGGLE: nwc = TOGGLE (wc); break;\n\t  }\n\t  if  (nwc != wc)\t/*  just skip unchanged characters */\n\t    {\n\t      mlen = wcrtomb (mb, nwc, &state);\n\t      if (mlen > 0)\n\t\tmb[mlen] = '\\0';\n\t      /* Assume the same width */\n\t      strncpy (ret + start, mb, mlen);\n\t    }\n\t}\n#endif\n\n      /*  This assumes that the upper and lower case versions are the same width. */\n      ADVANCE_CHAR (ret, end, start);\n    }\n\n  return ret;\n}"
}