{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [12, +oo] (⇐ [0, +oo] + 12) Size: [0, +oo] by call to `_bfd_coff_link_input_bfd`.",
    "Code_line": "\t\t  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))",
    "Code_function": "_bfd_coff_final_link (bfd *abfd,\n\t\t      struct bfd_link_info *info)\n{\n  bfd_size_type symesz;\n  struct coff_final_link_info flaginfo;\n  bfd_boolean debug_merge_allocated;\n  bfd_boolean long_section_names;\n  asection *o;\n  struct bfd_link_order *p;\n  bfd_size_type max_sym_count;\n  bfd_size_type max_lineno_count;\n  bfd_size_type max_reloc_count;\n  bfd_size_type max_output_reloc_count;\n  bfd_size_type max_contents_size;\n  file_ptr rel_filepos;\n  unsigned int relsz;\n  file_ptr line_filepos;\n  unsigned int linesz;\n  bfd *sub;\n  bfd_byte *external_relocs = NULL;\n  char strbuf[STRING_SIZE_SIZE];\n  bfd_size_type amt;\n\n  symesz = bfd_coff_symesz (abfd);\n\n  flaginfo.info = info;\n  flaginfo.output_bfd = abfd;\n  flaginfo.strtab = NULL;\n  flaginfo.section_info = NULL;\n  flaginfo.last_file_index = -1;\n  flaginfo.last_bf_index = -1;\n  flaginfo.internal_syms = NULL;\n  flaginfo.sec_ptrs = NULL;\n  flaginfo.sym_indices = NULL;\n  flaginfo.outsyms = NULL;\n  flaginfo.linenos = NULL;\n  flaginfo.contents = NULL;\n  flaginfo.external_relocs = NULL;\n  flaginfo.internal_relocs = NULL;\n  flaginfo.global_to_static = FALSE;\n  debug_merge_allocated = FALSE;\n\n  coff_data (abfd)->link_info = info;\n\n  flaginfo.strtab = _bfd_stringtab_init ();\n  if (flaginfo.strtab == NULL)\n    goto error_return;\n\n  if (! coff_debug_merge_hash_table_init (&flaginfo.debug_merge))\n    goto error_return;\n  debug_merge_allocated = TRUE;\n\n  /* Compute the file positions for all the sections.  */\n  if (! abfd->output_has_begun)\n    {\n      if (! bfd_coff_compute_section_file_positions (abfd))\n\tgoto error_return;\n    }\n\n  /* Count the line numbers and relocation entries required for the\n     output file.  Set the file positions for the relocs.  */\n  rel_filepos = obj_relocbase (abfd);\n  relsz = bfd_coff_relsz (abfd);\n  max_contents_size = 0;\n  max_lineno_count = 0;\n  max_reloc_count = 0;\n\n  long_section_names = FALSE;\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      o->reloc_count = 0;\n      o->lineno_count = 0;\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  if (p->type == bfd_indirect_link_order)\n\t    {\n\t      asection *sec;\n\n\t      sec = p->u.indirect.section;\n\n\t      /* Mark all sections which are to be included in the\n\t\t link.  This will normally be every section.  We need\n\t\t to do this so that we can identify any sections which\n\t\t the linker has decided to not include.  */\n\t      sec->linker_mark = TRUE;\n\n\t      if (info->strip == strip_none\n\t\t  || info->strip == strip_some)\n\t\to->lineno_count += sec->lineno_count;\n\n\t      if (info->relocatable)\n\t\to->reloc_count += sec->reloc_count;\n\n\t      if (sec->rawsize > max_contents_size)\n\t\tmax_contents_size = sec->rawsize;\n\t      if (sec->size > max_contents_size)\n\t\tmax_contents_size = sec->size;\n\t      if (sec->lineno_count > max_lineno_count)\n\t\tmax_lineno_count = sec->lineno_count;\n\t      if (sec->reloc_count > max_reloc_count)\n\t\tmax_reloc_count = sec->reloc_count;\n\t    }\n\t  else if (info->relocatable\n\t\t   && (p->type == bfd_section_reloc_link_order\n\t\t       || p->type == bfd_symbol_reloc_link_order))\n\t    ++o->reloc_count;\n\t}\n      if (o->reloc_count == 0)\n\to->rel_filepos = 0;\n      else\n\t{\n\t  o->flags |= SEC_RELOC;\n\t  o->rel_filepos = rel_filepos;\n\t  rel_filepos += o->reloc_count * relsz;\n\t  /* In PE COFF, if there are at least 0xffff relocations an\n\t     extra relocation will be written out to encode the count.  */\n\t  if (obj_pe (abfd) && o->reloc_count >= 0xffff)\n\t    rel_filepos += relsz;\n\t}\n\n      if (bfd_coff_long_section_names (abfd)\n\t  && strlen (o->name) > SCNNMLEN)\n\t{\n\t  /* This section has a long name which must go in the string\n             table.  This must correspond to the code in\n             coff_write_object_contents which puts the string index\n             into the s_name field of the section header.  That is why\n             we pass hash as FALSE.  */\n\t  if (_bfd_stringtab_add (flaginfo.strtab, o->name, FALSE, FALSE)\n\t      == (bfd_size_type) -1)\n\t    goto error_return;\n\t  long_section_names = TRUE;\n\t}\n    }\n\n  /* If doing a relocatable link, allocate space for the pointers we\n     need to keep.  */\n  if (info->relocatable)\n    {\n      unsigned int i;\n\n      /* We use section_count + 1, rather than section_count, because\n         the target_index fields are 1 based.  */\n      amt = abfd->section_count + 1;\n      amt *= sizeof (struct coff_link_section_info);\n      flaginfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);\n      if (flaginfo.section_info == NULL)\n\tgoto error_return;\n      for (i = 0; i <= abfd->section_count; i++)\n\t{\n\t  flaginfo.section_info[i].relocs = NULL;\n\t  flaginfo.section_info[i].rel_hashes = NULL;\n\t}\n    }\n\n  /* We now know the size of the relocs, so we can determine the file\n     positions of the line numbers.  */\n  line_filepos = rel_filepos;\n  linesz = bfd_coff_linesz (abfd);\n  max_output_reloc_count = 0;\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      if (o->lineno_count == 0)\n\to->line_filepos = 0;\n      else\n\t{\n\t  o->line_filepos = line_filepos;\n\t  line_filepos += o->lineno_count * linesz;\n\t}\n\n      if (o->reloc_count != 0)\n\t{\n\t  /* We don't know the indices of global symbols until we have\n             written out all the local symbols.  For each section in\n             the output file, we keep an array of pointers to hash\n             table entries.  Each entry in the array corresponds to a\n             reloc.  When we find a reloc against a global symbol, we\n             set the corresponding entry in this array so that we can\n             fix up the symbol index after we have written out all the\n             local symbols.\n\n\t     Because of this problem, we also keep the relocs in\n\t     memory until the end of the link.  This wastes memory,\n\t     but only when doing a relocatable link, which is not the\n\t     common case.  */\n\t  BFD_ASSERT (info->relocatable);\n\t  amt = o->reloc_count;\n\t  amt *= sizeof (struct internal_reloc);\n\t  flaginfo.section_info[o->target_index].relocs =\n              (struct internal_reloc *) bfd_malloc (amt);\n\t  amt = o->reloc_count;\n\t  amt *= sizeof (struct coff_link_hash_entry *);\n\t  flaginfo.section_info[o->target_index].rel_hashes =\n              (struct coff_link_hash_entry **) bfd_malloc (amt);\n\t  if (flaginfo.section_info[o->target_index].relocs == NULL\n\t      || flaginfo.section_info[o->target_index].rel_hashes == NULL)\n\t    goto error_return;\n\n\t  if (o->reloc_count > max_output_reloc_count)\n\t    max_output_reloc_count = o->reloc_count;\n\t}\n\n      /* Reset the reloc and lineno counts, so that we can use them to\n\t count the number of entries we have output so far.  */\n      o->reloc_count = 0;\n      o->lineno_count = 0;\n    }\n\n  obj_sym_filepos (abfd) = line_filepos;\n\n  /* Figure out the largest number of symbols in an input BFD.  Take\n     the opportunity to clear the output_has_begun fields of all the\n     input BFD's.  */\n  max_sym_count = 0;\n  for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n    {\n      size_t sz;\n\n      sub->output_has_begun = FALSE;\n      sz = bfd_family_coff (sub) ? obj_raw_syment_count (sub) : 2;\n      if (sz > max_sym_count)\n\tmax_sym_count = sz;\n    }\n\n  /* Allocate some buffers used while linking.  */\n  amt = max_sym_count * sizeof (struct internal_syment);\n  flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);\n  amt = max_sym_count * sizeof (asection *);\n  flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);\n  amt = max_sym_count * sizeof (long);\n  flaginfo.sym_indices = (long int *) bfd_malloc (amt);\n  flaginfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);\n  amt = max_lineno_count * bfd_coff_linesz (abfd);\n  flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);\n  flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);\n  amt = max_reloc_count * relsz;\n  flaginfo.external_relocs = (bfd_byte *) bfd_malloc (amt);\n  if (! info->relocatable)\n    {\n      amt = max_reloc_count * sizeof (struct internal_reloc);\n      flaginfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);\n    }\n  if ((flaginfo.internal_syms == NULL && max_sym_count > 0)\n      || (flaginfo.sec_ptrs == NULL && max_sym_count > 0)\n      || (flaginfo.sym_indices == NULL && max_sym_count > 0)\n      || flaginfo.outsyms == NULL\n      || (flaginfo.linenos == NULL && max_lineno_count > 0)\n      || (flaginfo.contents == NULL && max_contents_size > 0)\n      || (flaginfo.external_relocs == NULL && max_reloc_count > 0)\n      || (! info->relocatable\n\t  && flaginfo.internal_relocs == NULL\n\t  && max_reloc_count > 0))\n    goto error_return;\n\n  /* We now know the position of everything in the file, except that\n     we don't know the size of the symbol table and therefore we don't\n     know where the string table starts.  We just build the string\n     table in memory as we go along.  We process all the relocations\n     for a single input file at once.  */\n  obj_raw_syment_count (abfd) = 0;\n\n  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)\n    {\n      if (! bfd_coff_start_final_link (abfd, info))\n\tgoto error_return;\n    }\n\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  if (p->type == bfd_indirect_link_order\n\t      && bfd_family_coff (p->u.indirect.section->owner))\n\t    {\n\t      sub = p->u.indirect.section->owner;\n\t      if (! bfd_coff_link_output_has_begun (sub, & flaginfo))\n\t\t{\n\t\t  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))\n\t\t    goto error_return;\n\t\t  sub->output_has_begun = TRUE;\n\t\t}\n\t    }\n\t  else if (p->type == bfd_section_reloc_link_order\n\t\t   || p->type == bfd_symbol_reloc_link_order)\n\t    {\n\t      if (! _bfd_coff_reloc_link_order (abfd, &flaginfo, o, p))\n\t\tgoto error_return;\n\t    }\n\t  else\n\t    {\n\t      if (! _bfd_default_link_order (abfd, info, o, p))\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  if (flaginfo.info->strip != strip_all && flaginfo.info->discard != discard_all)\n    {\n      /* Add local symbols from foreign inputs.  */\n      for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n\t{\n\t  unsigned int i;\n\n\t  if (bfd_family_coff (sub) || ! bfd_get_outsymbols (sub))\n\t    continue;\n\t  for (i = 0; i < bfd_get_symcount (sub); ++i)\n\t    {\n\t      asymbol *sym = bfd_get_outsymbols (sub) [i];\n\t      file_ptr pos;\n\t      struct internal_syment isym;\n\t      bfd_size_type string_size = 0;\n\t      bfd_vma written = 0;\n\t      bfd_boolean rewrite = FALSE;\n\n\t      if (! (sym->flags & BSF_LOCAL)\n\t\t  || (sym->flags & (BSF_SECTION_SYM | BSF_DEBUGGING_RELOC\n\t\t\t\t    | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC\n\t\t\t\t    | BSF_SYNTHETIC))\n\t\t  || ((sym->flags & BSF_DEBUGGING)\n\t\t      && ! (sym->flags & BSF_FILE)))\n\t\tcontinue;\n\n\t      /* See if we are discarding symbols with this name.  */\n\t      if ((flaginfo.info->strip == strip_some\n\t\t   && (bfd_hash_lookup (flaginfo.info->keep_hash,\n\t\t\t\t\tbfd_asymbol_name(sym), FALSE, FALSE)\n\t\t       == NULL))\n\t\t  || (((flaginfo.info->discard == discard_sec_merge\n\t\t\t&& (bfd_get_section (sym)->flags & SEC_MERGE)\n\t\t\t&& ! flaginfo.info->relocatable)\n\t\t       || flaginfo.info->discard == discard_l)\n\t\t      && bfd_is_local_label_name (sub, bfd_asymbol_name(sym))))\n\t\tcontinue;\n\n\t      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd)\n\t\t\t\t\t     * symesz;\n\t      if (bfd_seek (abfd, pos, SEEK_SET) != 0)\n\t\tgoto error_return;\n\t      if (! coff_write_alien_symbol(abfd, sym, &isym, &written,\n\t\t\t\t\t    &string_size, NULL, NULL))\n\t\tgoto error_return;\n\n\t      if (string_size)\n\t\t{\n\t\t  bfd_boolean hash = ! (abfd->flags & BFD_TRADITIONAL_FORMAT);\n\t\t  bfd_size_type indx;\n\n\t\t  indx = _bfd_stringtab_add (flaginfo.strtab,\n\t\t\t\t\t     bfd_asymbol_name (sym), hash,\n\t\t\t\t\t     FALSE);\n\t\t  if (indx == (bfd_size_type) -1)\n\t\t    goto error_return;\n\t\t  isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n\t\t  bfd_coff_swap_sym_out (abfd, &isym, flaginfo.outsyms);\n\t\t  rewrite = TRUE;\n\t\t}\n\n\t      if (isym.n_sclass == C_FILE)\n\t\t{\n\t\t  if (flaginfo.last_file_index != -1)\n\t\t    {\n\t\t      flaginfo.last_file.n_value = obj_raw_syment_count (abfd);\n\t\t      bfd_coff_swap_sym_out (abfd, &flaginfo.last_file,\n\t\t\t\t\t     flaginfo.outsyms);\n\t\t      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index\n\t\t\t\t\t\t     * symesz;\n\t\t      rewrite = TRUE;\n\t\t    }\n\t\t  flaginfo.last_file_index = obj_raw_syment_count (abfd);\n\t\t  flaginfo.last_file = isym;\n\t\t}\n\n\t      if (rewrite\n\t\t  && (bfd_seek (abfd, pos, SEEK_SET) != 0\n\t\t      || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz))\n\t\tgoto error_return;\n\n\t      obj_raw_syment_count (abfd) += written;\n\t    }\n\t}\n    }\n\n  if (! bfd_coff_final_link_postscript (abfd, & flaginfo))\n    goto error_return;\n\n  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */\n\n  coff_debug_merge_hash_table_free (&flaginfo.debug_merge);\n  debug_merge_allocated = FALSE;\n\n  if (flaginfo.internal_syms != NULL)\n    {\n      free (flaginfo.internal_syms);\n      flaginfo.internal_syms = NULL;\n    }\n  if (flaginfo.sec_ptrs != NULL)\n    {\n      free (flaginfo.sec_ptrs);\n      flaginfo.sec_ptrs = NULL;\n    }\n  if (flaginfo.sym_indices != NULL)\n    {\n      free (flaginfo.sym_indices);\n      flaginfo.sym_indices = NULL;\n    }\n  if (flaginfo.linenos != NULL)\n    {\n      free (flaginfo.linenos);\n      flaginfo.linenos = NULL;\n    }\n  if (flaginfo.contents != NULL)\n    {\n      free (flaginfo.contents);\n      flaginfo.contents = NULL;\n    }\n  if (flaginfo.external_relocs != NULL)\n    {\n      free (flaginfo.external_relocs);\n      flaginfo.external_relocs = NULL;\n    }\n  if (flaginfo.internal_relocs != NULL)\n    {\n      free (flaginfo.internal_relocs);\n      flaginfo.internal_relocs = NULL;\n    }\n\n  /* The value of the last C_FILE symbol is supposed to be the symbol\n     index of the first external symbol.  Write it out again if\n     necessary.  */\n  if (flaginfo.last_file_index != -1\n      && (unsigned int) flaginfo.last_file.n_value != obj_raw_syment_count (abfd))\n    {\n      file_ptr pos;\n\n      flaginfo.last_file.n_value = obj_raw_syment_count (abfd);\n      bfd_coff_swap_sym_out (abfd, &flaginfo.last_file,\n\t\t\t     flaginfo.outsyms);\n\n      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index * symesz;\n      if (bfd_seek (abfd, pos, SEEK_SET) != 0\n\t  || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz)\n\treturn FALSE;\n    }\n\n  /* If doing task linking (ld --task-link) then make a pass through the\n     global symbols, writing out any that are defined, and making them\n     static.  */\n  if (info->task_link)\n    {\n      flaginfo.failed = FALSE;\n      coff_link_hash_traverse (coff_hash_table (info),\n\t\t\t       _bfd_coff_write_task_globals, &flaginfo);\n      if (flaginfo.failed)\n\tgoto error_return;\n    }\n\n  /* Write out the global symbols.  */\n  flaginfo.failed = FALSE;\n  bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &flaginfo);\n  if (flaginfo.failed)\n    goto error_return;\n\n  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */\n  if (flaginfo.outsyms != NULL)\n    {\n      free (flaginfo.outsyms);\n      flaginfo.outsyms = NULL;\n    }\n\n  if (info->relocatable && max_output_reloc_count > 0)\n    {\n      /* Now that we have written out all the global symbols, we know\n\t the symbol indices to use for relocs against them, and we can\n\t finally write out the relocs.  */\n      amt = max_output_reloc_count * relsz;\n      external_relocs = (bfd_byte *) bfd_malloc (amt);\n      if (external_relocs == NULL)\n\tgoto error_return;\n\n      for (o = abfd->sections; o != NULL; o = o->next)\n\t{\n\t  struct internal_reloc *irel;\n\t  struct internal_reloc *irelend;\n\t  struct coff_link_hash_entry **rel_hash;\n\t  bfd_byte *erel;\n\n\t  if (o->reloc_count == 0)\n\t    continue;\n\n\t  irel = flaginfo.section_info[o->target_index].relocs;\n\t  irelend = irel + o->reloc_count;\n\t  rel_hash = flaginfo.section_info[o->target_index].rel_hashes;\n\t  erel = external_relocs;\n\t  for (; irel < irelend; irel++, rel_hash++, erel += relsz)\n\t    {\n\t      if (*rel_hash != NULL)\n\t\t{\n\t\t  BFD_ASSERT ((*rel_hash)->indx >= 0);\n\t\t  irel->r_symndx = (*rel_hash)->indx;\n\t\t}\n\t      bfd_coff_swap_reloc_out (abfd, irel, erel);\n\t    }\n\n\t  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)\n\t    goto error_return;\n\t  if (obj_pe (abfd) && o->reloc_count >= 0xffff)\n\t    {\n\t      /* In PE COFF, write the count of relocs as the first\n\t\t reloc.  The header overflow bit will be set\n\t\t elsewhere. */\n\t      struct internal_reloc incount;\n\t      bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);\n\n\t      memset (&incount, 0, sizeof (incount));\n\t      incount.r_vaddr = o->reloc_count + 1;\n\t      bfd_coff_swap_reloc_out (abfd, &incount, excount);\n\t      if (bfd_bwrite (excount, relsz, abfd) != relsz)\n\t\t/* We'll leak, but it's an error anyway. */\n\t\tgoto error_return;\n\t      free (excount);\n\t    }\n\t  if (bfd_bwrite (external_relocs,\n\t\t\t  (bfd_size_type) relsz * o->reloc_count, abfd)\n\t      != (bfd_size_type) relsz * o->reloc_count)\n\t    goto error_return;\n\t}\n\n      free (external_relocs);\n      external_relocs = NULL;\n    }\n\n  /* Free up the section information.  */\n  if (flaginfo.section_info != NULL)\n    {\n      unsigned int i;\n\n      for (i = 0; i < abfd->section_count; i++)\n\t{\n\t  if (flaginfo.section_info[i].relocs != NULL)\n\t    free (flaginfo.section_info[i].relocs);\n\t  if (flaginfo.section_info[i].rel_hashes != NULL)\n\t    free (flaginfo.section_info[i].rel_hashes);\n\t}\n      free (flaginfo.section_info);\n      flaginfo.section_info = NULL;\n    }\n\n  /* If we have optimized stabs strings, output them.  */\n  if (coff_hash_table (info)->stab_info.stabstr != NULL)\n    {\n      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))\n\treturn FALSE;\n    }\n\n  /* Write out the string table.  */\n  if (obj_raw_syment_count (abfd) != 0 || long_section_names)\n    {\n      file_ptr pos;\n\n      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;\n      if (bfd_seek (abfd, pos, SEEK_SET) != 0)\n\treturn FALSE;\n\n#if STRING_SIZE_SIZE == 4\n      H_PUT_32 (abfd,\n\t\t_bfd_stringtab_size (flaginfo.strtab) + STRING_SIZE_SIZE,\n\t\tstrbuf);\n#else\n #error Change H_PUT_32 above\n#endif\n\n      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)\n\t  != STRING_SIZE_SIZE)\n\treturn FALSE;\n\n      if (! _bfd_stringtab_emit (abfd, flaginfo.strtab))\n\treturn FALSE;\n\n      obj_coff_strings_written (abfd) = TRUE;\n    }\n\n  _bfd_stringtab_free (flaginfo.strtab);\n\n  /* Setting bfd_get_symcount to 0 will cause write_object_contents to\n     not try to write out the symbols.  */\n  bfd_get_symcount (abfd) = 0;\n\n  return TRUE;\n\n error_return:\n  if (debug_merge_allocated)\n    coff_debug_merge_hash_table_free (&flaginfo.debug_merge);\n  if (flaginfo.strtab != NULL)\n    _bfd_stringtab_free (flaginfo.strtab);\n  if (flaginfo.section_info != NULL)\n    {\n      unsigned int i;\n\n      for (i = 0; i < abfd->section_count; i++)\n\t{\n\t  if (flaginfo.section_info[i].relocs != NULL)\n\t    free (flaginfo.section_info[i].relocs);\n\t  if (flaginfo.section_info[i].rel_hashes != NULL)\n\t    free (flaginfo.section_info[i].rel_hashes);\n\t}\n      free (flaginfo.section_info);\n    }\n  if (flaginfo.internal_syms != NULL)\n    free (flaginfo.internal_syms);\n  if (flaginfo.sec_ptrs != NULL)\n    free (flaginfo.sec_ptrs);\n  if (flaginfo.sym_indices != NULL)\n    free (flaginfo.sym_indices);\n  if (flaginfo.outsyms != NULL)\n    free (flaginfo.outsyms);\n  if (flaginfo.linenos != NULL)\n    free (flaginfo.linenos);\n  if (flaginfo.contents != NULL)\n    free (flaginfo.contents);\n  if (flaginfo.external_relocs != NULL)\n    free (flaginfo.external_relocs);\n  if (flaginfo.internal_relocs != NULL)\n    free (flaginfo.internal_relocs);\n  if (external_relocs != NULL)\n    free (external_relocs);\n  return FALSE;\n}"
}