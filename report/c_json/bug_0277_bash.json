{
    "project": "bash",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "extract_delimited_string",
    "warning_line": "ADVANCE_CHAR (string, slen, i);",
    "warning_context": "\t{\n\t  pass_character = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n\n      /* Not exactly right yet; should handle shell metacharacters and\n\t multibyte characters, too.  See COMMENT_BEGIN define in parse.y */\n      if ((flags & SX_COMMAND) && c == '#' && (i == 0 || string[i - 1] == '\\n' || shellblank (string[i - 1])))\n\t{\n          in_comment = 1;\n          ADVANCE_CHAR (string, slen, i);\n          continue;\n\t}\n        \n      if (c == CTLESC || c == '\\\\')\n\t{\n\t  pass_character++;\n\t  i++;\n\t  continue;\n\t}\n\n      /* Process a nested command substitution, but only if we're parsing an\n\t arithmetic substitution. */\n      if ((flags & SX_COMMAND) && string[i] == '$' && string[i+1] == LPAREN)\n        {\n          si = i + 2;\n          t = extract_command_subst (string, &si, flags|SX_NOALLOC);\n          i = si + 1;\n          continue;\n        }\n\n      /* Process a nested OPENER. */\n      if (STREQN (string + i, opener, len_opener))\n\t{\n\t  si = i + len_opener;\n\t  t = extract_delimited_string (string, &si, opener, alt_opener, closer, flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* Process a nested ALT_OPENER */\n      if (len_alt_opener && STREQN (string + i, alt_opener, len_alt_opener))\n\t{\n\t  si = i + len_alt_opener;\n\t  t = extract_delimited_string (string, &si, alt_opener, alt_opener, closer, flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* If the current substring terminates the delimited string, decrement\n\t the nesting level. */\n      if (STREQN (string + i, closer, len_closer))\n\t{\n\t  i += len_closer - 1;\t/* move to last byte of the closer */\n\t  nesting_level--;\n\t  if (nesting_level == 0)\n\t    break;\n\t}\n\n      /* Pass old-style command substitution through verbatim. */\n      if (c == '`')\n\t{\n\t  si = i + 1;\n\t  t = string_extract (string, &si, \"`\", flags|SX_NOALLOC);\n\t  i = si + 1;\n\t  continue;\n\t}\n\n      /* Pass single-quoted and double-quoted strings through verbatim. */\n      if (c == '\\'' || c == '\"')\n\t{\n\t  si = i + 1;\n\t  i = (c == '\\'') ? skip_single_quoted (string, slen, si)\n\t\t\t  : skip_double_quoted (string, slen, si);\n\t  continue;\n\t}\n\n      /* move past this character, which was not special. */\n      ADVANCE_CHAR (string, slen, i);\n    }\n\n  if (c == 0 && nesting_level)\n    {\n      if (no_longjmp_on_fatal_error == 0)\n\t{\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  report_error (_(\"bad substitution: no closing `%s' in %s\"), closer, string);\n\t  exp_jump_to_top_level (DISCARD);\n\t}\n      else\n\t{\n\t  *sindex = i;\n\t  return (char *)NULL;\n\t}\n    }\n\n  si = i - *sindex - len_closer + 1;\n  if (flags & SX_NOALLOC)\n    result = (char *)NULL;\n  else    \n"
}