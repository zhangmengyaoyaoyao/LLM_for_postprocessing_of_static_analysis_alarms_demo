{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-20, 267] (⇐ [-132, 155] + 112) Size: 4064 by call to `bfd_zalloc`.",
    "Code_line": "\t  t = (struct bfd_elf_version_tree *) bfd_zalloc (info->output_bfd, amt);",
    "Code_function": "_bfd_elf_link_assign_sym_version (struct elf_link_hash_entry *h, void *data)\n{\n  struct elf_info_failed *sinfo;\n  struct bfd_link_info *info;\n  const struct elf_backend_data *bed;\n  struct elf_info_failed eif;\n  char *p;\n  bfd_size_type amt;\n\n  sinfo = (struct elf_info_failed *) data;\n  info = sinfo->info;\n\n  /* Fix the symbol flags.  */\n  eif.failed = FALSE;\n  eif.info = info;\n  if (! _bfd_elf_fix_symbol_flags (h, &eif))\n    {\n      if (eif.failed)\n\tsinfo->failed = TRUE;\n      return FALSE;\n    }\n\n  /* We only need version numbers for symbols defined in regular\n     objects.  */\n  if (!h->def_regular)\n    return TRUE;\n\n  bed = get_elf_backend_data (info->output_bfd);\n  p = strchr (h->root.root.string, ELF_VER_CHR);\n  if (p != NULL && h->verinfo.vertree == NULL)\n    {\n      struct bfd_elf_version_tree *t;\n      bfd_boolean hidden;\n\n      hidden = TRUE;\n\n      /* There are two consecutive ELF_VER_CHR characters if this is\n\t not a hidden symbol.  */\n      ++p;\n      if (*p == ELF_VER_CHR)\n\t{\n\t  hidden = FALSE;\n\t  ++p;\n\t}\n\n      /* If there is no version string, we can just return out.  */\n      if (*p == '\\0')\n\t{\n\t  if (hidden)\n\t    h->hidden = 1;\n\t  return TRUE;\n\t}\n\n      /* Look for the version.  If we find it, it is no longer weak.  */\n      for (t = sinfo->info->version_info; t != NULL; t = t->next)\n\t{\n\t  if (strcmp (t->name, p) == 0)\n\t    {\n\t      size_t len;\n\t      char *alc;\n\t      struct bfd_elf_version_expr *d;\n\n\t      len = p - h->root.root.string;\n\t      alc = (char *) bfd_malloc (len);\n\t      if (alc == NULL)\n\t\t{\n\t\t  sinfo->failed = TRUE;\n\t\t  return FALSE;\n\t\t}\n\t      memcpy (alc, h->root.root.string, len - 1);\n\t      alc[len - 1] = '\\0';\n\t      if (alc[len - 2] == ELF_VER_CHR)\n\t\talc[len - 2] = '\\0';\n\n\t      h->verinfo.vertree = t;\n\t      t->used = TRUE;\n\t      d = NULL;\n\n\t      if (t->globals.list != NULL)\n\t\td = (*t->match) (&t->globals, NULL, alc);\n\n\t      /* See if there is anything to force this symbol to\n\t\t local scope.  */\n\t      if (d == NULL && t->locals.list != NULL)\n\t\t{\n\t\t  d = (*t->match) (&t->locals, NULL, alc);\n\t\t  if (d != NULL\n\t\t      && h->dynindx != -1\n\t\t      && ! info->export_dynamic)\n\t\t    (*bed->elf_backend_hide_symbol) (info, h, TRUE);\n\t\t}\n\n\t      free (alc);\n\t      break;\n\t    }\n\t}\n\n      /* If we are building an application, we need to create a\n\t version node for this version.  */\n      if (t == NULL && info->executable)\n\t{\n\t  struct bfd_elf_version_tree **pp;\n\t  int version_index;\n\n\t  /* If we aren't going to export this symbol, we don't need\n\t     to worry about it.  */\n\t  if (h->dynindx == -1)\n\t    return TRUE;\n\n\t  amt = sizeof *t;\n\t  t = (struct bfd_elf_version_tree *) bfd_zalloc (info->output_bfd, amt);\n\t  if (t == NULL)\n\t    {\n\t      sinfo->failed = TRUE;\n\t      return FALSE;\n\t    }\n\n\t  t->name = p;\n\t  t->name_indx = (unsigned int) -1;\n\t  t->used = TRUE;\n\n\t  version_index = 1;\n\t  /* Don't count anonymous version tag.  */\n\t  if (sinfo->info->version_info != NULL\n\t      && sinfo->info->version_info->vernum == 0)\n\t    version_index = 0;\n\t  for (pp = &sinfo->info->version_info;\n\t       *pp != NULL;\n\t       pp = &(*pp)->next)\n\t    ++version_index;\n\t  t->vernum = version_index;\n\n\t  *pp = t;\n\n\t  h->verinfo.vertree = t;\n\t}\n      else if (t == NULL)\n\t{\n\t  /* We could not find the version for a symbol when\n\t     generating a shared archive.  Return an error.  */\n\t  (*_bfd_error_handler)\n\t    (_(\"%B: version node not found for symbol %s\"),\n\t     info->output_bfd, h->root.root.string);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  sinfo->failed = TRUE;\n\t  return FALSE;\n\t}\n\n      if (hidden)\n\th->hidden = 1;\n    }\n\n  /* If we don't have a version for this symbol, see if we can find\n     something.  */\n  if (h->verinfo.vertree == NULL && sinfo->info->version_info != NULL)\n    {\n      bfd_boolean hide;\n\n      h->verinfo.vertree\n\t= bfd_find_version_for_sym (sinfo->info->version_info,\n\t\t\t\t    h->root.root.string, &hide);\n      if (h->verinfo.vertree != NULL && hide)\n\t(*bed->elf_backend_hide_symbol) (info, h, TRUE);\n    }\n\n  return TRUE;\n}"
}