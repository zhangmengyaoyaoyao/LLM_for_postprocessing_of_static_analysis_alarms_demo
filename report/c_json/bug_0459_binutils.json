{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/stabs.c",
    "message": "Offset: [4, +oo] (⇐ [0, +oo] + 4) Size: [1, +oo].",
    "warning_function_name": "_bfd_link_section_stabs",
    "warning_line": "type = sym[TYPEOFF];",
    "warning_context": "    /* We shouldn't see relocations in the strings, and we aren't\n       prepared to handle them.  */\n    return TRUE;\n\n  if (bfd_is_abs_section (stabsec->output_section)\n      || bfd_is_abs_section (stabstrsec->output_section))\n    /* At least one of the sections is being discarded from the\n       link, so we should just ignore them.  */\n    return TRUE;\n\n  first = FALSE;\n\n  if (sinfo->stabstr == NULL)\n    {\n      flagword flags;\n\n      /* Initialize the stabs information we need to keep track of.  */\n      first = TRUE;\n      sinfo->strings = _bfd_stringtab_init ();\n      if (sinfo->strings == NULL)\n\tgoto error_return;\n      /* Make sure the first byte is zero.  */\n      (void) _bfd_stringtab_add (sinfo->strings, \"\", TRUE, TRUE);\n      if (! bfd_hash_table_init (&sinfo->includes,\n\t\t\t\t stab_link_includes_newfunc,\n\t\t\t\t sizeof (struct stab_link_includes_entry)))\n\tgoto error_return;\n      flags = (SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING\n\t       | SEC_LINKER_CREATED);\n      sinfo->stabstr = bfd_make_section_anyway_with_flags (abfd, \".stabstr\",\n\t\t\t\t\t\t\t   flags);\n      if (sinfo->stabstr == NULL)\n\tgoto error_return;\n    }\n\n  /* Initialize the information we are going to store for this .stab\n     section.  */\n  count = stabsec->size / STABSIZE;\n\n  amt = sizeof (struct stab_section_info);\n  amt += (count - 1) * sizeof (bfd_size_type);\n  *psecinfo = bfd_alloc (abfd, amt);\n  if (*psecinfo == NULL)\n    goto error_return;\n\n  secinfo = (struct stab_section_info *) *psecinfo;\n  secinfo->excls = NULL;\n  stabsec->rawsize = stabsec->size;\n  secinfo->cumulative_skips = NULL;\n  memset (secinfo->stridxs, 0, (size_t) count * sizeof (bfd_size_type));\n\n  /* Read the stabs information from abfd.  */\n  if (!bfd_malloc_and_get_section (abfd, stabsec, &stabbuf)\n      || !bfd_malloc_and_get_section (abfd, stabstrsec, &stabstrbuf))\n    goto error_return;\n\n  /* Look through the stabs symbols, work out the new string indices,\n     and identify N_BINCL symbols which can be eliminated.  */\n  stroff = 0;\n  /* The stabs sections can be split when\n     -split-by-reloc/-split-by-file is used.  We must keep track of\n     each stab section's place in the single concatenated string\n     table.  */\n  next_stroff = pstring_offset ? *pstring_offset : 0;\n  skip = 0;\n\n  symend = stabbuf + stabsec->size;\n  for (sym = stabbuf, pstridx = secinfo->stridxs;\n       sym < symend;\n       sym += STABSIZE, ++pstridx)\n    {\n      bfd_size_type symstroff;\n      int type;\n      const char *string;\n\n      if (*pstridx != 0)\n\t/* This symbol has already been handled by an N_BINCL pass.  */\n\tcontinue;\n\n      type = sym[TYPEOFF];\n\n      if (type == 0)\n\t{\n\t  /* Special type 0 stabs indicate the offset to the next\n\t     string table.  We only copy the very first one.  */\n\t  stroff = next_stroff;\n\t  next_stroff += bfd_get_32 (abfd, sym + 8);\n\t  if (pstring_offset)\n\t    *pstring_offset = next_stroff;\n\t  if (! first)\n\t    {\n\t      *pstridx = (bfd_size_type) -1;\n\t      ++skip;\n\t      continue;\n\t    }\n\t  first = FALSE;\n\t}\n\n      /* Store the string in the hash table, and record the index.  */\n      symstroff = stroff + bfd_get_32 (abfd, sym + STRDXOFF);\n      if (symstroff >= stabstrsec->size)\n"
}