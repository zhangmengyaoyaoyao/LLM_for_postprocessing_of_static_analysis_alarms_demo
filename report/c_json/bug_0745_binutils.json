{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "binutils/objdump.c",
    "message": "Offset: [-1, +oo] (⇐ [0, +oo] + -1) Size: 50.",
    "warning_function_name": "disassemble_bytes",
    "warning_line": "*--s = '0';",
    "warning_context": "\n      bfd_sprintf_vma (aux->abfd, buf, section->vma + section->size / opb);\n\n      while (buf[skip_addr_chars] == '0')\n\t++skip_addr_chars;\n\n      /* Don't discard zeros on overflow.  */\n      if (buf[skip_addr_chars] == '\\0' && section->vma != 0)\n\tskip_addr_chars = 0;\n\n      if (skip_addr_chars != 0)\n\tskip_addr_chars = (skip_addr_chars - 1) & -4;\n    }\n\n  inf->insn_info_valid = 0;\n\n  addr_offset = start_offset;\n  while (addr_offset < stop_offset)\n    {\n      bfd_vma z;\n      bfd_boolean need_nl = FALSE;\n      int previous_octets;\n\n      /* Remember the length of the previous instruction.  */\n      previous_octets = octets;\n      octets = 0;\n\n      /* Make sure we don't use relocs from previous instructions.  */\n      aux->reloc = NULL;\n\n      /* If we see more than SKIP_ZEROES octets of zeroes, we just\n\t print `...'.  */\n      for (z = addr_offset * opb; z < stop_offset * opb; z++)\n\tif (data[z] != 0)\n\t  break;\n      if (! disassemble_zeroes\n\t  && (inf->insn_info_valid == 0\n\t      || inf->branch_delay_insns == 0)\n\t  && (z - addr_offset * opb >= skip_zeroes\n\t      || (z == stop_offset * opb &&\n\t\t  z - addr_offset * opb < skip_zeroes_at_end)))\n\t{\n\t  /* If there are more nonzero octets to follow, we only skip\n\t     zeroes in multiples of 4, to try to avoid running over\n\t     the start of an instruction which happens to start with\n\t     zero.  */\n\t  if (z != stop_offset * opb)\n\t    z = addr_offset * opb + ((z - addr_offset * opb) &~ 3);\n\n\t  octets = z - addr_offset * opb;\n\n\t  /* If we are going to display more data, and we are displaying\n\t     file offsets, then tell the user how many zeroes we skip\n\t     and the file offset from where we resume dumping.  */\n\t  if (display_file_offsets && ((addr_offset + (octets / opb)) < stop_offset))\n\t    printf (\"\\t... (skipping %d zeroes, resuming at file offset: 0x%lx)\\n\",\n\t\t    octets / opb,\n\t\t    (unsigned long) (section->filepos\n\t\t\t\t     + (addr_offset + (octets / opb))));\n\t  else\n\t    printf (\"\\t...\\n\");\n\t}\n      else\n\t{\n\t  char buf[50];\n\t  int bpc = 0;\n\t  int pb = 0;\n\n\t  if (with_line_numbers || with_source_code)\n\t    show_line (aux->abfd, section, addr_offset);\n\n\t  if (! prefix_addresses)\n\t    {\n\t      char *s;\n\n\t      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);\n\t      for (s = buf + skip_addr_chars; *s == '0'; s++)\n\t\t*s = ' ';\n\t      if (*s == '\\0')\n\t\t*--s = '0';\n\t      printf (\"%s:\\t\", buf + skip_addr_chars);\n\t    }\n\t  else\n\t    {\n\t      aux->require_sec = TRUE;\n\t      objdump_print_address (section->vma + addr_offset, inf);\n\t      aux->require_sec = FALSE;\n\t      putchar (' ');\n\t    }\n\n\t  if (insns)\n\t    {\n\t      sfile.pos = 0;\n\t      inf->fprintf_func = (fprintf_ftype) objdump_sprintf;\n\t      inf->stream = &sfile;\n\t      inf->bytes_per_line = 0;\n\t      inf->bytes_per_chunk = 0;\n\t      inf->flags = disassemble_all ? DISASSEMBLE_DATA : 0;\n\t      if (machine)\n\t\tinf->flags |= USER_SPECIFIED_MACHINE_TYPE;\n\n"
}