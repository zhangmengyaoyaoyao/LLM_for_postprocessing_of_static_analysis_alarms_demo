{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [14, +oo] Size: [0, +oo] by call to `bfd_elf_set_obj_attr_contents`.",
    "Code_line": "      bfd_elf_set_obj_attr_contents (abfd, contents, attr_size);",
    "Code_function": "bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n{\n  bfd_boolean dynamic;\n  bfd_boolean emit_relocs;\n  bfd *dynobj;\n  struct elf_final_link_info flinfo;\n  asection *o;\n  struct bfd_link_order *p;\n  bfd *sub;\n  bfd_size_type max_contents_size;\n  bfd_size_type max_external_reloc_size;\n  bfd_size_type max_internal_reloc_count;\n  bfd_size_type max_sym_count;\n  bfd_size_type max_sym_shndx_count;\n  Elf_Internal_Sym elfsym;\n  unsigned int i;\n  Elf_Internal_Shdr *symtab_hdr;\n  Elf_Internal_Shdr *symtab_shndx_hdr;\n  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n  struct elf_outext_info eoinfo;\n  bfd_boolean merged;\n  size_t relativecount = 0;\n  asection *reldyn = 0;\n  bfd_size_type amt;\n  asection *attr_section = NULL;\n  bfd_vma attr_size = 0;\n  const char *std_attrs_section;\n\n  if (! is_elf_hash_table (info->hash))\n    return FALSE;\n\n  if (info->shared)\n    abfd->flags |= DYNAMIC;\n\n  dynamic = elf_hash_table (info)->dynamic_sections_created;\n  dynobj = elf_hash_table (info)->dynobj;\n\n  emit_relocs = (info->relocatable\n\t\t || info->emitrelocations);\n\n  flinfo.info = info;\n  flinfo.output_bfd = abfd;\n  flinfo.symstrtab = _bfd_elf_stringtab_init ();\n  if (flinfo.symstrtab == NULL)\n    return FALSE;\n\n  if (! dynamic)\n    {\n      flinfo.dynsym_sec = NULL;\n      flinfo.hash_sec = NULL;\n      flinfo.symver_sec = NULL;\n    }\n  else\n    {\n      flinfo.dynsym_sec = bfd_get_linker_section (dynobj, \".dynsym\");\n      flinfo.hash_sec = bfd_get_linker_section (dynobj, \".hash\");\n      /* Note that dynsym_sec can be NULL (on VMS).  */\n      flinfo.symver_sec = bfd_get_linker_section (dynobj, \".gnu.version\");\n      /* Note that it is OK if symver_sec is NULL.  */\n    }\n\n  flinfo.contents = NULL;\n  flinfo.external_relocs = NULL;\n  flinfo.internal_relocs = NULL;\n  flinfo.external_syms = NULL;\n  flinfo.locsym_shndx = NULL;\n  flinfo.internal_syms = NULL;\n  flinfo.indices = NULL;\n  flinfo.sections = NULL;\n  flinfo.symbuf = NULL;\n  flinfo.symshndxbuf = NULL;\n  flinfo.symbuf_count = 0;\n  flinfo.shndxbuf_size = 0;\n  flinfo.filesym_count = 0;\n\n  /* The object attributes have been merged.  Remove the input\n     sections from the link, and set the contents of the output\n     secton.  */\n  std_attrs_section = get_elf_backend_data (abfd)->obj_attrs_section;\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      if ((std_attrs_section && strcmp (o->name, std_attrs_section) == 0)\n\t  || strcmp (o->name, \".gnu.attributes\") == 0)\n\t{\n\t  for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t    {\n\t      asection *input_section;\n\n\t      if (p->type != bfd_indirect_link_order)\n\t\tcontinue;\n\t      input_section = p->u.indirect.section;\n\t      /* Hack: reset the SEC_HAS_CONTENTS flag so that\n\t\t elf_link_input_bfd ignores this section.  */\n\t      input_section->flags &= ~SEC_HAS_CONTENTS;\n\t    }\n\n\t  attr_size = bfd_elf_obj_attr_size (abfd);\n\t  if (attr_size)\n\t    {\n\t      bfd_set_section_size (abfd, o, attr_size);\n\t      attr_section = o;\n\t      /* Skip this section later on.  */\n\t      o->map_head.link_order = NULL;\n\t    }\n\t  else\n\t    o->flags |= SEC_EXCLUDE;\n\t}\n    }\n\n  /* Count up the number of relocations we will output for each output\n     section, so that we know the sizes of the reloc sections.  We\n     also figure out some maximum sizes.  */\n  max_contents_size = 0;\n  max_external_reloc_size = 0;\n  max_internal_reloc_count = 0;\n  max_sym_count = 0;\n  max_sym_shndx_count = 0;\n  merged = FALSE;\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      struct bfd_elf_section_data *esdo = elf_section_data (o);\n      o->reloc_count = 0;\n\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  unsigned int reloc_count = 0;\n\t  struct bfd_elf_section_data *esdi = NULL;\n\n\t  if (p->type == bfd_section_reloc_link_order\n\t      || p->type == bfd_symbol_reloc_link_order)\n\t    reloc_count = 1;\n\t  else if (p->type == bfd_indirect_link_order)\n\t    {\n\t      asection *sec;\n\n\t      sec = p->u.indirect.section;\n\t      esdi = elf_section_data (sec);\n\n\t      /* Mark all sections which are to be included in the\n\t\t link.  This will normally be every section.  We need\n\t\t to do this so that we can identify any sections which\n\t\t the linker has decided to not include.  */\n\t      sec->linker_mark = TRUE;\n\n\t      if (sec->flags & SEC_MERGE)\n\t\tmerged = TRUE;\n\n\t      if (esdo->this_hdr.sh_type == SHT_REL\n\t\t  || esdo->this_hdr.sh_type == SHT_RELA)\n\t\t/* Some backends use reloc_count in relocation sections\n\t\t   to count particular types of relocs.  Of course,\n\t\t   reloc sections themselves can't have relocations.  */\n\t\treloc_count = 0;\n\t      else if (info->relocatable || info->emitrelocations)\n\t\treloc_count = sec->reloc_count;\n\t      else if (bed->elf_backend_count_relocs)\n\t\treloc_count = (*bed->elf_backend_count_relocs) (info, sec);\n\n\t      if (sec->rawsize > max_contents_size)\n\t\tmax_contents_size = sec->rawsize;\n\t      if (sec->size > max_contents_size)\n\t\tmax_contents_size = sec->size;\n\n\t      /* We are interested in just local symbols, not all\n\t\t symbols.  */\n\t      if (bfd_get_flavour (sec->owner) == bfd_target_elf_flavour\n\t\t  && (sec->owner->flags & DYNAMIC) == 0)\n\t\t{\n\t\t  size_t sym_count;\n\n\t\t  if (elf_bad_symtab (sec->owner))\n\t\t    sym_count = (elf_tdata (sec->owner)->symtab_hdr.sh_size\n\t\t\t\t / bed->s->sizeof_sym);\n\t\t  else\n\t\t    sym_count = elf_tdata (sec->owner)->symtab_hdr.sh_info;\n\n\t\t  if (sym_count > max_sym_count)\n\t\t    max_sym_count = sym_count;\n\n\t\t  if (sym_count > max_sym_shndx_count\n\t\t      && elf_symtab_shndx (sec->owner) != 0)\n\t\t    max_sym_shndx_count = sym_count;\n\n\t\t  if ((sec->flags & SEC_RELOC) != 0)\n\t\t    {\n\t\t      size_t ext_size = 0;\n\n\t\t      if (esdi->rel.hdr != NULL)\n\t\t\text_size = esdi->rel.hdr->sh_size;\n\t\t      if (esdi->rela.hdr != NULL)\n\t\t\text_size += esdi->rela.hdr->sh_size;\n\n\t\t      if (ext_size > max_external_reloc_size)\n\t\t\tmax_external_reloc_size = ext_size;\n\t\t      if (sec->reloc_count > max_internal_reloc_count)\n\t\t\tmax_internal_reloc_count = sec->reloc_count;\n\t\t    }\n\t\t}\n\t    }\n\n\t  if (reloc_count == 0)\n\t    continue;\n\n\t  o->reloc_count += reloc_count;\n\n\t  if (p->type == bfd_indirect_link_order\n\t      && (info->relocatable || info->emitrelocations))\n\t    {\n\t      if (esdi->rel.hdr)\n\t\tesdo->rel.count += NUM_SHDR_ENTRIES (esdi->rel.hdr);\n\t      if (esdi->rela.hdr)\n\t\tesdo->rela.count += NUM_SHDR_ENTRIES (esdi->rela.hdr);\n\t    }\n\t  else\n\t    {\n\t      if (o->use_rela_p)\n\t\tesdo->rela.count += reloc_count;\n\t      else\n\t\tesdo->rel.count += reloc_count;\n\t    }\n\t}\n\n      if (o->reloc_count > 0)\n\to->flags |= SEC_RELOC;\n      else\n\t{\n\t  /* Explicitly clear the SEC_RELOC flag.  The linker tends to\n\t     set it (this is probably a bug) and if it is set\n\t     assign_section_numbers will create a reloc section.  */\n\t  o->flags &=~ SEC_RELOC;\n\t}\n\n      /* If the SEC_ALLOC flag is not set, force the section VMA to\n\t zero.  This is done in elf_fake_sections as well, but forcing\n\t the VMA to 0 here will ensure that relocs against these\n\t sections are handled correctly.  */\n      if ((o->flags & SEC_ALLOC) == 0\n\t  && ! o->user_set_vma)\n\to->vma = 0;\n    }\n\n  if (! info->relocatable && merged)\n    elf_link_hash_traverse (elf_hash_table (info),\n\t\t\t    _bfd_elf_link_sec_merge_syms, abfd);\n\n  /* Figure out the file positions for everything but the symbol table\n     and the relocs.  We set symcount to force assign_section_numbers\n     to create a symbol table.  */\n  bfd_get_symcount (abfd) = info->strip != strip_all || emit_relocs;\n  BFD_ASSERT (! abfd->output_has_begun);\n  if (! _bfd_elf_compute_section_file_positions (abfd, info))\n    goto error_return;\n\n  /* Set sizes, and assign file positions for reloc sections.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      struct bfd_elf_section_data *esdo = elf_section_data (o);\n      if ((o->flags & SEC_RELOC) != 0)\n\t{\n\t  if (esdo->rel.hdr\n\t      && !(_bfd_elf_link_size_reloc_section (abfd, &esdo->rel)))\n\t    goto error_return;\n\n\t  if (esdo->rela.hdr\n\t      && !(_bfd_elf_link_size_reloc_section (abfd, &esdo->rela)))\n\t    goto error_return;\n\t}\n\n      /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them\n\t to count upwards while actually outputting the relocations.  */\n      esdo->rel.count = 0;\n      esdo->rela.count = 0;\n    }\n\n  /* We have now assigned file positions for all the sections except\n     .symtab, .strtab, and non-loaded reloc sections.  We start the\n     .symtab section at the current file position, and write directly\n     to it.  We build the .strtab section in memory.  */\n  bfd_get_symcount (abfd) = 0;\n  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n  /* sh_name is set in prep_headers.  */\n  symtab_hdr->sh_type = SHT_SYMTAB;\n  /* sh_flags, sh_addr and sh_size all start off zero.  */\n  symtab_hdr->sh_entsize = bed->s->sizeof_sym;\n  /* sh_link is set in assign_section_numbers.  */\n  /* sh_info is set below.  */\n  /* sh_offset is set just below.  */\n  symtab_hdr->sh_addralign = (bfd_vma) 1 << bed->s->log_file_align;\n\n  /* Allocate a buffer to hold swapped out symbols.  This is to avoid\n     continuously seeking to the right position in the file.  */\n  if (! info->keep_memory || max_sym_count < 20)\n    flinfo.symbuf_size = 20;\n  else\n    flinfo.symbuf_size = max_sym_count;\n  amt = flinfo.symbuf_size;\n  amt *= bed->s->sizeof_sym;\n  flinfo.symbuf = (bfd_byte *) bfd_malloc (amt);\n  if (flinfo.symbuf == NULL)\n    goto error_return;\n  if (elf_numsections (abfd) > (SHN_LORESERVE & 0xFFFF))\n    {\n      /* Wild guess at number of output symbols.  realloc'd as needed.  */\n      amt = 2 * max_sym_count + elf_numsections (abfd) + 1000;\n      flinfo.shndxbuf_size = amt;\n      amt *= sizeof (Elf_External_Sym_Shndx);\n      flinfo.symshndxbuf = (Elf_External_Sym_Shndx *) bfd_zmalloc (amt);\n      if (flinfo.symshndxbuf == NULL)\n\tgoto error_return;\n    }\n\n  if (info->strip != strip_all || emit_relocs)\n    {\n      file_ptr off = elf_next_file_pos (abfd);\n\n      _bfd_elf_assign_file_position_for_section (symtab_hdr, off, TRUE);\n\n      /* Note that at this point elf_next_file_pos (abfd) is\n\t incorrect.  We do not yet know the size of the .symtab section.\n\t We correct next_file_pos below, after we do know the size.  */\n\n      /* Start writing out the symbol table.  The first symbol is always a\n\t dummy symbol.  */\n      elfsym.st_value = 0;\n      elfsym.st_size = 0;\n      elfsym.st_info = 0;\n      elfsym.st_other = 0;\n      elfsym.st_shndx = SHN_UNDEF;\n      elfsym.st_target_internal = 0;\n      if (elf_link_output_sym (&flinfo, NULL, &elfsym, bfd_und_section_ptr,\n\t\t\t       NULL) != 1)\n\tgoto error_return;\n\n      /* Output a symbol for each section.  We output these even if we are\n\t discarding local symbols, since they are used for relocs.  These\n\t symbols have no names.  We store the index of each one in the\n\t index field of the section, so that we can find it again when\n\t outputting relocs.  */\n\n      elfsym.st_size = 0;\n      elfsym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);\n      elfsym.st_other = 0;\n      elfsym.st_value = 0;\n      elfsym.st_target_internal = 0;\n      for (i = 1; i < elf_numsections (abfd); i++)\n\t{\n\t  o = bfd_section_from_elf_index (abfd, i);\n\t  if (o != NULL)\n\t    {\n\t      o->target_index = bfd_get_symcount (abfd);\n\t      elfsym.st_shndx = i;\n\t      if (!info->relocatable)\n\t\telfsym.st_value = o->vma;\n\t      if (elf_link_output_sym (&flinfo, NULL, &elfsym, o, NULL) != 1)\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  /* Allocate some memory to hold information read in from the input\n     files.  */\n  if (max_contents_size != 0)\n    {\n      flinfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);\n      if (flinfo.contents == NULL)\n\tgoto error_return;\n    }\n\n  if (max_external_reloc_size != 0)\n    {\n      flinfo.external_relocs = bfd_malloc (max_external_reloc_size);\n      if (flinfo.external_relocs == NULL)\n\tgoto error_return;\n    }\n\n  if (max_internal_reloc_count != 0)\n    {\n      amt = max_internal_reloc_count * bed->s->int_rels_per_ext_rel;\n      amt *= sizeof (Elf_Internal_Rela);\n      flinfo.internal_relocs = (Elf_Internal_Rela *) bfd_malloc (amt);\n      if (flinfo.internal_relocs == NULL)\n\tgoto error_return;\n    }\n\n  if (max_sym_count != 0)\n    {\n      amt = max_sym_count * bed->s->sizeof_sym;\n      flinfo.external_syms = (bfd_byte *) bfd_malloc (amt);\n      if (flinfo.external_syms == NULL)\n\tgoto error_return;\n\n      amt = max_sym_count * sizeof (Elf_Internal_Sym);\n      flinfo.internal_syms = (Elf_Internal_Sym *) bfd_malloc (amt);\n      if (flinfo.internal_syms == NULL)\n\tgoto error_return;\n\n      amt = max_sym_count * sizeof (long);\n      flinfo.indices = (long int *) bfd_malloc (amt);\n      if (flinfo.indices == NULL)\n\tgoto error_return;\n\n      amt = max_sym_count * sizeof (asection *);\n      flinfo.sections = (asection **) bfd_malloc (amt);\n      if (flinfo.sections == NULL)\n\tgoto error_return;\n    }\n\n  if (max_sym_shndx_count != 0)\n    {\n      amt = max_sym_shndx_count * sizeof (Elf_External_Sym_Shndx);\n      flinfo.locsym_shndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);\n      if (flinfo.locsym_shndx == NULL)\n\tgoto error_return;\n    }\n\n  if (elf_hash_table (info)->tls_sec)\n    {\n      bfd_vma base, end = 0;\n      asection *sec;\n\n      for (sec = elf_hash_table (info)->tls_sec;\n\t   sec && (sec->flags & SEC_THREAD_LOCAL);\n\t   sec = sec->next)\n\t{\n\t  bfd_size_type size = sec->size;\n\n\t  if (size == 0\n\t      && (sec->flags & SEC_HAS_CONTENTS) == 0)\n\t    {\n\t      struct bfd_link_order *ord = sec->map_tail.link_order;\n\n\t      if (ord != NULL)\n\t\tsize = ord->offset + ord->size;\n\t    }\n\t  end = sec->vma + size;\n\t}\n      base = elf_hash_table (info)->tls_sec->vma;\n      /* Only align end of TLS section if static TLS doesn't have special\n\t alignment requirements.  */\n      if (bed->static_tls_alignment == 1)\n\tend = align_power (end,\n\t\t\t   elf_hash_table (info)->tls_sec->alignment_power);\n      elf_hash_table (info)->tls_size = end - base;\n    }\n\n  /* Reorder SHF_LINK_ORDER sections.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      if (!elf_fixup_link_order (abfd, o))\n\treturn FALSE;\n    }\n\n  /* Since ELF permits relocations to be against local symbols, we\n     must have the local symbols available when we do the relocations.\n     Since we would rather only read the local symbols once, and we\n     would rather not keep them in memory, we handle all the\n     relocations for a single input file at the same time.\n\n     Unfortunately, there is no way to know the total number of local\n     symbols until we have seen all of them, and the local symbol\n     indices precede the global symbol indices.  This means that when\n     we are generating relocatable output, and we see a reloc against\n     a global symbol, we can not know the symbol index until we have\n     finished examining all the local symbols to see which ones we are\n     going to output.  To deal with this, we keep the relocations in\n     memory, and don't output them until the end of the link.  This is\n     an unfortunate waste of memory, but I don't see a good way around\n     it.  Fortunately, it only happens when performing a relocatable\n     link, which is not the common case.  FIXME: If keep_memory is set\n     we could write the relocs out and then read them again; I don't\n     know how bad the memory loss will be.  */\n\n  for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n    sub->output_has_begun = FALSE;\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  if (p->type == bfd_indirect_link_order\n\t      && (bfd_get_flavour ((sub = p->u.indirect.section->owner))\n\t\t  == bfd_target_elf_flavour)\n\t      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass)\n\t    {\n\t      if (! sub->output_has_begun)\n\t\t{\n\t\t  if (! elf_link_input_bfd (&flinfo, sub))\n\t\t    goto error_return;\n\t\t  sub->output_has_begun = TRUE;\n\t\t}\n\t    }\n\t  else if (p->type == bfd_section_reloc_link_order\n\t\t   || p->type == bfd_symbol_reloc_link_order)\n\t    {\n\t      if (! elf_reloc_link_order (abfd, info, o, p))\n\t\tgoto error_return;\n\t    }\n\t  else\n\t    {\n\t      if (! _bfd_default_link_order (abfd, info, o, p))\n\t\t{\n\t\t  if (p->type == bfd_indirect_link_order\n\t\t      && (bfd_get_flavour (sub)\n\t\t\t  == bfd_target_elf_flavour)\n\t\t      && (elf_elfheader (sub)->e_ident[EI_CLASS]\n\t\t\t  != bed->s->elfclass))\n\t\t    {\n\t\t      const char *iclass, *oclass;\n\n\t\t      if (bed->s->elfclass == ELFCLASS64)\n\t\t\t{\n\t\t\t  iclass = \"ELFCLASS32\";\n\t\t\t  oclass = \"ELFCLASS64\";\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  iclass = \"ELFCLASS64\";\n\t\t\t  oclass = \"ELFCLASS32\";\n\t\t\t}\n\n\t\t      bfd_set_error (bfd_error_wrong_format);\n\t\t      (*_bfd_error_handler)\n\t\t\t(_(\"%B: file class %s incompatible with %s\"),\n\t\t\t sub, iclass, oclass);\n\t\t    }\n\n\t\t  goto error_return;\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Free symbol buffer if needed.  */\n  if (!info->reduce_memory_overheads)\n    {\n      for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n\tif (bfd_get_flavour (sub) == bfd_target_elf_flavour\n\t    && elf_tdata (sub)->symbuf)\n\t  {\n\t    free (elf_tdata (sub)->symbuf);\n\t    elf_tdata (sub)->symbuf = NULL;\n\t  }\n    }\n\n  /* Output any global symbols that got converted to local in a\n     version script or due to symbol visibility.  We do this in a\n     separate step since ELF requires all local symbols to appear\n     prior to any global symbols.  FIXME: We should only do this if\n     some global symbols were, in fact, converted to become local.\n     FIXME: Will this work correctly with the Irix 5 linker?  */\n  eoinfo.failed = FALSE;\n  eoinfo.flinfo = &flinfo;\n  eoinfo.localsyms = TRUE;\n  eoinfo.need_second_pass = FALSE;\n  eoinfo.second_pass = FALSE;\n  eoinfo.file_sym_done = FALSE;\n  bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);\n  if (eoinfo.failed)\n    return FALSE;\n\n  if (eoinfo.need_second_pass)\n    {\n      eoinfo.second_pass = TRUE;\n      bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);\n      if (eoinfo.failed)\n\treturn FALSE;\n    }\n\n  /* If backend needs to output some local symbols not present in the hash\n     table, do it now.  */\n  if (bed->elf_backend_output_arch_local_syms\n      && (info->strip != strip_all || emit_relocs))\n    {\n      typedef int (*out_sym_func)\n\t(void *, const char *, Elf_Internal_Sym *, asection *,\n\t struct elf_link_hash_entry *);\n\n      if (! ((*bed->elf_backend_output_arch_local_syms)\n\t     (abfd, info, &flinfo, (out_sym_func) elf_link_output_sym)))\n\treturn FALSE;\n    }\n\n  /* That wrote out all the local symbols.  Finish up the symbol table\n     with the global symbols. Even if we want to strip everything we\n     can, we still need to deal with those global symbols that got\n     converted to local in a version script.  */\n\n  /* The sh_info field records the index of the first non local symbol.  */\n  symtab_hdr->sh_info = bfd_get_symcount (abfd);\n\n  if (dynamic\n      && flinfo.dynsym_sec != NULL\n      && flinfo.dynsym_sec->output_section != bfd_abs_section_ptr)\n    {\n      Elf_Internal_Sym sym;\n      bfd_byte *dynsym = flinfo.dynsym_sec->contents;\n      long last_local = 0;\n\n      /* Write out the section symbols for the output sections.  */\n      if (info->shared || elf_hash_table (info)->is_relocatable_executable)\n\t{\n\t  asection *s;\n\n\t  sym.st_size = 0;\n\t  sym.st_name = 0;\n\t  sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);\n\t  sym.st_other = 0;\n\t  sym.st_target_internal = 0;\n\n\t  for (s = abfd->sections; s != NULL; s = s->next)\n\t    {\n\t      int indx;\n\t      bfd_byte *dest;\n\t      long dynindx;\n\n\t      dynindx = elf_section_data (s)->dynindx;\n\t      if (dynindx <= 0)\n\t\tcontinue;\n\t      indx = elf_section_data (s)->this_idx;\n\t      BFD_ASSERT (indx > 0);\n\t      sym.st_shndx = indx;\n\t      if (! check_dynsym (abfd, &sym))\n\t\treturn FALSE;\n\t      sym.st_value = s->vma;\n\t      dest = dynsym + dynindx * bed->s->sizeof_sym;\n\t      if (last_local < dynindx)\n\t\tlast_local = dynindx;\n\t      bed->s->swap_symbol_out (abfd, &sym, dest, 0);\n\t    }\n\t}\n\n      /* Write out the local dynsyms.  */\n      if (elf_hash_table (info)->dynlocal)\n\t{\n\t  struct elf_link_local_dynamic_entry *e;\n\t  for (e = elf_hash_table (info)->dynlocal; e ; e = e->next)\n\t    {\n\t      asection *s;\n\t      bfd_byte *dest;\n\n\t      /* Copy the internal symbol and turn off visibility.\n\t\t Note that we saved a word of storage and overwrote\n\t\t the original st_name with the dynstr_index.  */\n\t      sym = e->isym;\n\t      sym.st_other &= ~ELF_ST_VISIBILITY (-1);\n\n\t      s = bfd_section_from_elf_index (e->input_bfd,\n\t\t\t\t\t      e->isym.st_shndx);\n\t      if (s != NULL)\n\t\t{\n\t\t  sym.st_shndx =\n\t\t    elf_section_data (s->output_section)->this_idx;\n\t\t  if (! check_dynsym (abfd, &sym))\n\t\t    return FALSE;\n\t\t  sym.st_value = (s->output_section->vma\n\t\t\t\t  + s->output_offset\n\t\t\t\t  + e->isym.st_value);\n\t\t}\n\n\t      if (last_local < e->dynindx)\n\t\tlast_local = e->dynindx;\n\n\t      dest = dynsym + e->dynindx * bed->s->sizeof_sym;\n\t      bed->s->swap_symbol_out (abfd, &sym, dest, 0);\n\t    }\n\t}\n\n      elf_section_data (flinfo.dynsym_sec->output_section)->this_hdr.sh_info =\n\tlast_local + 1;\n    }\n\n  /* We get the global symbols from the hash table.  */\n  eoinfo.failed = FALSE;\n  eoinfo.localsyms = FALSE;\n  eoinfo.flinfo = &flinfo;\n  bfd_hash_traverse (&info->hash->table, elf_link_output_extsym, &eoinfo);\n  if (eoinfo.failed)\n    return FALSE;\n\n  /* If backend needs to output some symbols not present in the hash\n     table, do it now.  */\n  if (bed->elf_backend_output_arch_syms\n      && (info->strip != strip_all || emit_relocs))\n    {\n      typedef int (*out_sym_func)\n\t(void *, const char *, Elf_Internal_Sym *, asection *,\n\t struct elf_link_hash_entry *);\n\n      if (! ((*bed->elf_backend_output_arch_syms)\n\t     (abfd, info, &flinfo, (out_sym_func) elf_link_output_sym)))\n\treturn FALSE;\n    }\n\n  /* Flush all symbols to the file.  */\n  if (! elf_link_flush_output_syms (&flinfo, bed))\n    return FALSE;\n\n  /* Now we know the size of the symtab section.  */\n  if (bfd_get_symcount (abfd) > 0)\n    {\n      /* Finish up and write out the symbol string table (.strtab)\n\t section.  */\n      Elf_Internal_Shdr *symstrtab_hdr;\n      file_ptr off = symtab_hdr->sh_offset + symtab_hdr->sh_size;\n\n      symtab_shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;\n      if (symtab_shndx_hdr->sh_name != 0)\n\t{\n\t  symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;\n\t  symtab_shndx_hdr->sh_entsize = sizeof (Elf_External_Sym_Shndx);\n\t  symtab_shndx_hdr->sh_addralign = sizeof (Elf_External_Sym_Shndx);\n\t  amt = bfd_get_symcount (abfd) * sizeof (Elf_External_Sym_Shndx);\n\t  symtab_shndx_hdr->sh_size = amt;\n\n\t  off = _bfd_elf_assign_file_position_for_section (symtab_shndx_hdr,\n\t\t\t\t\t\t\t   off, TRUE);\n\n\t  if (bfd_seek (abfd, symtab_shndx_hdr->sh_offset, SEEK_SET) != 0\n\t      || (bfd_bwrite (flinfo.symshndxbuf, amt, abfd) != amt))\n\t    return FALSE;\n\t}\n\n      symstrtab_hdr = &elf_tdata (abfd)->strtab_hdr;\n      /* sh_name was set in prep_headers.  */\n      symstrtab_hdr->sh_type = SHT_STRTAB;\n      symstrtab_hdr->sh_flags = 0;\n      symstrtab_hdr->sh_addr = 0;\n      symstrtab_hdr->sh_size = _bfd_stringtab_size (flinfo.symstrtab);\n      symstrtab_hdr->sh_entsize = 0;\n      symstrtab_hdr->sh_link = 0;\n      symstrtab_hdr->sh_info = 0;\n      /* sh_offset is set just below.  */\n      symstrtab_hdr->sh_addralign = 1;\n\n      off = _bfd_elf_assign_file_position_for_section (symstrtab_hdr,\n\t\t\t\t\t\t       off, TRUE);\n      elf_next_file_pos (abfd) = off;\n\n      if (bfd_seek (abfd, symstrtab_hdr->sh_offset, SEEK_SET) != 0\n\t  || ! _bfd_stringtab_emit (abfd, flinfo.symstrtab))\n\treturn FALSE;\n    }\n\n  /* Adjust the relocs to have the correct symbol indices.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      struct bfd_elf_section_data *esdo = elf_section_data (o);\n      bfd_boolean sort;\n      if ((o->flags & SEC_RELOC) == 0)\n\tcontinue;\n\n      sort = bed->sort_relocs_p == NULL || (*bed->sort_relocs_p) (o);\n      if (esdo->rel.hdr != NULL)\n\telf_link_adjust_relocs (abfd, &esdo->rel, sort);\n      if (esdo->rela.hdr != NULL)\n\telf_link_adjust_relocs (abfd, &esdo->rela, sort);\n\n      /* Set the reloc_count field to 0 to prevent write_relocs from\n\t trying to swap the relocs out itself.  */\n      o->reloc_count = 0;\n    }\n\n  if (dynamic && info->combreloc && dynobj != NULL)\n    relativecount = elf_link_sort_relocs (abfd, info, &reldyn);\n\n  /* If we are linking against a dynamic object, or generating a\n     shared library, finish up the dynamic linking information.  */\n  if (dynamic)\n    {\n      bfd_byte *dyncon, *dynconend;\n\n      /* Fix up .dynamic entries.  */\n      o = bfd_get_linker_section (dynobj, \".dynamic\");\n      BFD_ASSERT (o != NULL);\n\n      dyncon = o->contents;\n      dynconend = o->contents + o->size;\n      for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)\n\t{\n\t  Elf_Internal_Dyn dyn;\n\t  const char *name;\n\t  unsigned int type;\n\n\t  bed->s->swap_dyn_in (dynobj, dyncon, &dyn);\n\n\t  switch (dyn.d_tag)\n\t    {\n\t    default:\n\t      continue;\n\t    case DT_NULL:\n\t      if (relativecount > 0 && dyncon + bed->s->sizeof_dyn < dynconend)\n\t\t{\n\t\t  switch (elf_section_data (reldyn)->this_hdr.sh_type)\n\t\t    {\n\t\t    case SHT_REL: dyn.d_tag = DT_RELCOUNT; break;\n\t\t    case SHT_RELA: dyn.d_tag = DT_RELACOUNT; break;\n\t\t    default: continue;\n\t\t    }\n\t\t  dyn.d_un.d_val = relativecount;\n\t\t  relativecount = 0;\n\t\t  break;\n\t\t}\n\t      continue;\n\n\t    case DT_INIT:\n\t      name = info->init_function;\n\t      goto get_sym;\n\t    case DT_FINI:\n\t      name = info->fini_function;\n\t    get_sym:\n\t      {\n\t\tstruct elf_link_hash_entry *h;\n\n\t\th = elf_link_hash_lookup (elf_hash_table (info), name,\n\t\t\t\t\t  FALSE, FALSE, TRUE);\n\t\tif (h != NULL\n\t\t    && (h->root.type == bfd_link_hash_defined\n\t\t\t|| h->root.type == bfd_link_hash_defweak))\n\t\t  {\n\t\t    dyn.d_un.d_ptr = h->root.u.def.value;\n\t\t    o = h->root.u.def.section;\n\t\t    if (o->output_section != NULL)\n\t\t      dyn.d_un.d_ptr += (o->output_section->vma\n\t\t\t\t\t + o->output_offset);\n\t\t    else\n\t\t      {\n\t\t\t/* The symbol is imported from another shared\n\t\t\t   library and does not apply to this one.  */\n\t\t\tdyn.d_un.d_ptr = 0;\n\t\t      }\n\t\t    break;\n\t\t  }\n\t      }\n\t      continue;\n\n\t    case DT_PREINIT_ARRAYSZ:\n\t      name = \".preinit_array\";\n\t      goto get_size;\n\t    case DT_INIT_ARRAYSZ:\n\t      name = \".init_array\";\n\t      goto get_size;\n\t    case DT_FINI_ARRAYSZ:\n\t      name = \".fini_array\";\n\t    get_size:\n\t      o = bfd_get_section_by_name (abfd, name);\n\t      if (o == NULL)\n\t\t{\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"%B: could not find output section %s\"), abfd, name);\n\t\t  goto error_return;\n\t\t}\n\t      if (o->size == 0)\n\t\t(*_bfd_error_handler)\n\t\t  (_(\"warning: %s section has zero size\"), name);\n\t      dyn.d_un.d_val = o->size;\n\t      break;\n\n\t    case DT_PREINIT_ARRAY:\n\t      name = \".preinit_array\";\n\t      goto get_vma;\n\t    case DT_INIT_ARRAY:\n\t      name = \".init_array\";\n\t      goto get_vma;\n\t    case DT_FINI_ARRAY:\n\t      name = \".fini_array\";\n\t      goto get_vma;\n\n\t    case DT_HASH:\n\t      name = \".hash\";\n\t      goto get_vma;\n\t    case DT_GNU_HASH:\n\t      name = \".gnu.hash\";\n\t      goto get_vma;\n\t    case DT_STRTAB:\n\t      name = \".dynstr\";\n\t      goto get_vma;\n\t    case DT_SYMTAB:\n\t      name = \".dynsym\";\n\t      goto get_vma;\n\t    case DT_VERDEF:\n\t      name = \".gnu.version_d\";\n\t      goto get_vma;\n\t    case DT_VERNEED:\n\t      name = \".gnu.version_r\";\n\t      goto get_vma;\n\t    case DT_VERSYM:\n\t      name = \".gnu.version\";\n\t    get_vma:\n\t      o = bfd_get_section_by_name (abfd, name);\n\t      if (o == NULL)\n\t\t{\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"%B: could not find output section %s\"), abfd, name);\n\t\t  goto error_return;\n\t\t}\n\t      if (elf_section_data (o->output_section)->this_hdr.sh_type == SHT_NOTE)\n\t\t{\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"warning: section '%s' is being made into a note\"), name);\n\t\t  bfd_set_error (bfd_error_nonrepresentable_section);\n\t\t  goto error_return;\n\t\t}\n\t      dyn.d_un.d_ptr = o->vma;\n\t      break;\n\n\t    case DT_REL:\n\t    case DT_RELA:\n\t    case DT_RELSZ:\n\t    case DT_RELASZ:\n\t      if (dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)\n\t\ttype = SHT_REL;\n\t      else\n\t\ttype = SHT_RELA;\n\t      dyn.d_un.d_val = 0;\n\t      dyn.d_un.d_ptr = 0;\n\t      for (i = 1; i < elf_numsections (abfd); i++)\n\t\t{\n\t\t  Elf_Internal_Shdr *hdr;\n\n\t\t  hdr = elf_elfsections (abfd)[i];\n\t\t  if (hdr->sh_type == type\n\t\t      && (hdr->sh_flags & SHF_ALLOC) != 0)\n\t\t    {\n\t\t      if (dyn.d_tag == DT_RELSZ || dyn.d_tag == DT_RELASZ)\n\t\t\tdyn.d_un.d_val += hdr->sh_size;\n\t\t      else\n\t\t\t{\n\t\t\t  if (dyn.d_un.d_ptr == 0\n\t\t\t      || hdr->sh_addr < dyn.d_un.d_ptr)\n\t\t\t    dyn.d_un.d_ptr = hdr->sh_addr;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      break;\n\t    }\n\t  bed->s->swap_dyn_out (dynobj, &dyn, dyncon);\n\t}\n    }\n\n  /* If we have created any dynamic sections, then output them.  */\n  if (dynobj != NULL)\n    {\n      if (! (*bed->elf_backend_finish_dynamic_sections) (abfd, info))\n\tgoto error_return;\n\n      /* Check for DT_TEXTREL (late, in case the backend removes it).  */\n      if (((info->warn_shared_textrel && info->shared)\n\t   || info->error_textrel)\n\t  && (o = bfd_get_linker_section (dynobj, \".dynamic\")) != NULL)\n\t{\n\t  bfd_byte *dyncon, *dynconend;\n\n\t  dyncon = o->contents;\n\t  dynconend = o->contents + o->size;\n\t  for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)\n\t    {\n\t      Elf_Internal_Dyn dyn;\n\n\t      bed->s->swap_dyn_in (dynobj, dyncon, &dyn);\n\n\t      if (dyn.d_tag == DT_TEXTREL)\n\t\t{\n\t\t  if (info->error_textrel)\n\t\t    info->callbacks->einfo\n\t\t      (_(\"%P%X: read-only segment has dynamic relocations.\\n\"));\n\t\t  else\n\t\t    info->callbacks->einfo\n\t\t      (_(\"%P: warning: creating a DT_TEXTREL in a shared object.\\n\"));\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      for (o = dynobj->sections; o != NULL; o = o->next)\n\t{\n\t  if ((o->flags & SEC_HAS_CONTENTS) == 0\n\t      || o->size == 0\n\t      || o->output_section == bfd_abs_section_ptr)\n\t    continue;\n\t  if ((o->flags & SEC_LINKER_CREATED) == 0)\n\t    {\n\t      /* At this point, we are only interested in sections\n\t\t created by _bfd_elf_link_create_dynamic_sections.  */\n\t      continue;\n\t    }\n\t  if (elf_hash_table (info)->stab_info.stabstr == o)\n\t    continue;\n\t  if (elf_hash_table (info)->eh_info.hdr_sec == o)\n\t    continue;\n\t  if (strcmp (o->name, \".dynstr\") != 0)\n\t    {\n\t      /* FIXME: octets_per_byte.  */\n\t      if (! bfd_set_section_contents (abfd, o->output_section,\n\t\t\t\t\t      o->contents,\n\t\t\t\t\t      (file_ptr) o->output_offset,\n\t\t\t\t\t      o->size))\n\t\tgoto error_return;\n\t    }\n\t  else\n\t    {\n\t      /* The contents of the .dynstr section are actually in a\n\t\t stringtab.  */\n\t      file_ptr off;\n\n\t      off = elf_section_data (o->output_section)->this_hdr.sh_offset;\n\t      if (bfd_seek (abfd, off, SEEK_SET) != 0\n\t\t  || ! _bfd_elf_strtab_emit (abfd,\n\t\t\t\t\t     elf_hash_table (info)->dynstr))\n\t\tgoto error_return;\n\t    }\n\t}\n    }\n\n  if (info->relocatable)\n    {\n      bfd_boolean failed = FALSE;\n\n      bfd_map_over_sections (abfd, bfd_elf_set_group_contents, &failed);\n      if (failed)\n\tgoto error_return;\n    }\n\n  /* If we have optimized stabs strings, output them.  */\n  if (elf_hash_table (info)->stab_info.stabstr != NULL)\n    {\n      if (! _bfd_write_stab_strings (abfd, &elf_hash_table (info)->stab_info))\n\tgoto error_return;\n    }\n\n  if (! _bfd_elf_write_section_eh_frame_hdr (abfd, info))\n    goto error_return;\n\n  elf_final_link_free (abfd, &flinfo);\n\n  elf_linker (abfd) = TRUE;\n\n  if (attr_section)\n    {\n      bfd_byte *contents = (bfd_byte *) bfd_malloc (attr_size);\n      if (contents == NULL)\n\treturn FALSE;\t/* Bail out and fail.  */\n      bfd_elf_set_obj_attr_contents (abfd, contents, attr_size);\n      bfd_set_section_contents (abfd, attr_section, contents, 0, attr_size);\n      free (contents);\n    }\n\n  return TRUE;\n\n error_return:\n  elf_final_link_free (abfd, &flinfo);\n  return FALSE;\n}"
}