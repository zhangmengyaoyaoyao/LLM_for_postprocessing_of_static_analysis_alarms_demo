{
    "Project": "RIOT",
    "Tool": "Infer",
    "category": "Buffer Overrun L2",
    "file": "sys/net/gnrc/network_layer/ipv6/nib/nib.c",
    "message": "Offset: [0, 3] Size: 2.",
    "warning_function_name": "handle_nbr_sol(",
    "warning_line": "if (netif->ipv6.addrs_flags[tgt_idx] & GNRC_NETIF_IPV6_ADDRS_FLAGS_ANYCAST) {",
    "warning_context": "            DEBUG(\"nib: Option of length 0 detected. \"\n                  \"Discarding neighbor solicitation silently\\n\");\n            return;\n        }\n    }\n    DEBUG(\"nib: Received valid neighbor solicitation:\\n\");\n    DEBUG(\"     - Target address: %s\\n\",\n          ipv6_addr_to_str(addr_str, &nbr_sol->tgt, sizeof(addr_str)));\n    DEBUG(\"     - Source address: %s\\n\",\n          ipv6_addr_to_str(addr_str, &ipv6->src, sizeof(addr_str)));\n    DEBUG(\"     - Destination address: %s\\n\",\n          ipv6_addr_to_str(addr_str, &ipv6->dst, sizeof(addr_str)));\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_SLAAC)\n    gnrc_netif_t *tgt_netif = gnrc_netif_get_by_ipv6_addr(&nbr_sol->tgt);\n\n    if (tgt_netif != NULL) {\n        int idx = gnrc_netif_ipv6_addr_idx(tgt_netif, &nbr_sol->tgt);\n\n        if (gnrc_netif_ipv6_addr_dad_trans(tgt_netif, idx)) {\n            if (!ipv6_addr_is_unspecified(&ipv6->src)) {\n                /* (see https://tools.ietf.org/html/rfc4862#section-5.4.3) */\n                DEBUG(\"nib: Neighbor is performing AR, but target address is \"\n                      \"still TENTATIVE for us => Ignoring NS\\n\");\n                return;\n            }\n            /* cancel validation timer */\n            evtimer_del(&_nib_evtimer,\n                        &tgt_netif->ipv6.addrs_timers[idx].event);\n            _remove_tentative_addr(tgt_netif, &nbr_sol->tgt);\n            return;\n        }\n    }\n#endif  /* CONFIG_GNRC_IPV6_NIB_SLAAC */\n    if (ipv6_addr_is_unspecified(&ipv6->src)) {\n        gnrc_ndp_nbr_adv_send(&nbr_sol->tgt, netif, &ipv6->src, false, NULL);\n    }\n    else {\n        gnrc_pktsnip_t *reply_aro = NULL;\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR)\n        ndp_opt_t *sl2ao = NULL;\n        sixlowpan_nd_opt_ar_t *aro = NULL;\n#else   /* CONFIG_GNRC_IPV6_NIB_6LR */\n#define sl2ao   (NULL)\n#define aro     (NULL)\n#endif  /* CONFIG_GNRC_IPV6_NIB_6LR */\n        tmp_len = icmpv6_len - sizeof(ndp_nbr_sol_t);\n\n        if (!(netif->flags & GNRC_NETIF_FLAGS_HAS_L2ADDR)) {\n            /* Set STALE NCE if link-layer has no addresses */\n            _nib_nc_add(&ipv6->src, netif->pid,\n                        GNRC_IPV6_NIB_NC_INFO_NUD_STATE_STALE);\n        }\n        FOREACH_OPT(nbr_sol, opt, tmp_len) {\n            switch (opt->type) {\n                case NDP_OPT_SL2A:\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR)\n                    if (gnrc_netif_is_6lr(netif)) {\n                        DEBUG(\"nib: Storing SL2AO for later handling\\n\");\n                        sl2ao = opt;\n                        break;\n                    }\n#endif  /* CONFIG_GNRC_IPV6_NIB_6LR */\n                    _handle_sl2ao(netif, ipv6, (const icmpv6_hdr_t *)nbr_sol,\n                                  opt);\n                    break;\n#if IS_ACTIVE(CONFIG_GNRC_IPV6_NIB_6LR)\n                case NDP_OPT_AR:\n                    DEBUG(\"nib: Storing ARO for later handling\\n\");\n                    aro = (sixlowpan_nd_opt_ar_t *)opt;\n                    break;\n#endif  /* CONFIG_GNRC_IPV6_NIB_6LR */\n                default:\n                    DEBUG(\"nib: Ignoring unrecognized option type %u for NS\\n\",\n                          opt->type);\n                    break;\n            }\n        }\n        reply_aro = _copy_and_handle_aro(netif, ipv6, nbr_sol, aro, sl2ao);\n        /* check if target address is anycast */\n        if (netif->ipv6.addrs_flags[tgt_idx] & GNRC_NETIF_IPV6_ADDRS_FLAGS_ANYCAST) {\n            _send_delayed_nbr_adv(netif, &nbr_sol->tgt, ipv6, reply_aro);\n        }\n        else {\n            gnrc_ndp_nbr_adv_send(&nbr_sol->tgt, netif, &ipv6->src,\n                                  ipv6_addr_is_multicast(&ipv6->dst),\n                                  reply_aro);\n        }\n    }\n}\n\nstatic void _handle_nbr_adv(gnrc_netif_t *netif, const ipv6_hdr_t *ipv6,\n                            const ndp_nbr_adv_t *nbr_adv, size_t icmpv6_len)\n{\n    size_t tmp_len = icmpv6_len - sizeof(ndp_nbr_adv_t);\n    ndp_opt_t *opt;\n    _nib_onl_entry_t *nce;\n\n    /* check validity, see: https://tools.ietf.org/html/rfc4861#section-7.1.2 */\n    /* checksum is checked by GNRC's ICMPv6 module */\n    if ((ipv6->hl != NDP_HOP_LIMIT) || (nbr_adv->code != 0U) ||\n        (icmpv6_len < sizeof(ndp_nbr_adv_t)) ||\n"
}