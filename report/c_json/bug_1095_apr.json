{
    "Project": "apr",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "        ref = &allocator->free[index];",
    "Code_function": "apr_memnode_t *allocator_alloc(apr_allocator_t *allocator, apr_size_t in_size)\n{\n    apr_memnode_t *node, **ref;\n    apr_uint32_t max_index;\n    apr_size_t size, i, index;\n\n    /* Round up the block size to the next boundary, but always\n     * allocate at least a certain size (MIN_ALLOC).\n     */\n    size = APR_ALIGN(in_size + APR_MEMNODE_T_SIZE, BOUNDARY_SIZE);\n    if (size < in_size) {\n        return NULL;\n    }\n    if (size < MIN_ALLOC)\n        size = MIN_ALLOC;\n\n    /* Find the index for this node size by\n     * dividing its size by the boundary size\n     */\n    index = (size >> BOUNDARY_INDEX) - 1;\n\n    if (index > APR_UINT32_MAX) {\n        return NULL;\n    }\n\n    /* First see if there are any nodes in the area we know\n     * our node will fit into.\n     */\n    if (index <= allocator->max_index) {\n#if APR_HAS_THREADS\n        if (allocator->mutex)\n            apr_thread_mutex_lock(allocator->mutex);\n#endif /* APR_HAS_THREADS */\n\n        /* Walk the free list to see if there are\n         * any nodes on it of the requested size\n         *\n         * NOTE: an optimization would be to check\n         * allocator->free[index] first and if no\n         * node is present, directly use\n         * allocator->free[max_index].  This seems\n         * like overkill though and could cause\n         * memory waste.\n         */\n        max_index = allocator->max_index;\n        ref = &allocator->free[index];\n        i = index;\n        while (*ref == NULL && i < max_index) {\n           ref++;\n           i++;\n        }\n\n        if ((node = *ref) != NULL) {\n            /* If we have found a node and it doesn't have any\n             * nodes waiting in line behind it _and_ we are on\n             * the highest available index, find the new highest\n             * available index\n             */\n            if ((*ref = node->next) == NULL && i >= max_index) {\n                do {\n                    ref--;\n                    max_index--;\n                }\n                while (*ref == NULL && max_index > 0);\n\n                allocator->max_index = max_index;\n            }\n\n            allocator->current_free_index += node->index + 1;\n            if (allocator->current_free_index > allocator->max_free_index)\n                allocator->current_free_index = allocator->max_free_index;\n\n#if APR_HAS_THREADS\n            if (allocator->mutex)\n                apr_thread_mutex_unlock(allocator->mutex);\n#endif /* APR_HAS_THREADS */\n\n            node->next = NULL;\n            node->first_avail = (char *)node + APR_MEMNODE_T_SIZE;\n\n            return node;\n        }\n\n#if APR_HAS_THREADS\n        if (allocator->mutex)\n            apr_thread_mutex_unlock(allocator->mutex);\n#endif /* APR_HAS_THREADS */\n    }\n\n    /* If we found nothing, seek the sink (at index 0), if\n     * it is not empty.\n     */\n    else if (allocator->free[0]) {\n#if APR_HAS_THREADS\n        if (allocator->mutex)\n            apr_thread_mutex_lock(allocator->mutex);\n#endif /* APR_HAS_THREADS */\n\n        /* Walk the free list to see if there are\n         * any nodes on it of the requested size\n         */\n        ref = &allocator->free[0];\n        while ((node = *ref) != NULL && index > node->index)\n            ref = &node->next;\n\n        if (node) {\n            *ref = node->next;\n\n            allocator->current_free_index += node->index + 1;\n            if (allocator->current_free_index > allocator->max_free_index)\n                allocator->current_free_index = allocator->max_free_index;\n\n#if APR_HAS_THREADS\n            if (allocator->mutex)\n                apr_thread_mutex_unlock(allocator->mutex);\n#endif /* APR_HAS_THREADS */\n\n            node->next = NULL;\n            node->first_avail = (char *)node + APR_MEMNODE_T_SIZE;\n\n            return node;\n        }\n\n#if APR_HAS_THREADS\n        if (allocator->mutex)\n            apr_thread_mutex_unlock(allocator->mutex);\n#endif /* APR_HAS_THREADS */\n    }\n\n    /* If we haven't got a suitable node, malloc a new one\n     * and initialize it.\n     */\n#if APR_ALLOCATOR_USES_MMAP\n    if ((node = mmap(NULL, size, PROT_READ|PROT_WRITE,\n                     MAP_PRIVATE|MAP_ANON, -1, 0)) == MAP_FAILED)\n#else\n    if ((node = malloc(size)) == NULL)\n#endif\n        return NULL;\n\n    node->next = NULL;\n    node->index = (APR_UINT32_TRUNC_CAST)index;\n    node->first_avail = (char *)node + APR_MEMNODE_T_SIZE;\n    node->endp = (char *)node + size;\n\n    return node;\n}"
}