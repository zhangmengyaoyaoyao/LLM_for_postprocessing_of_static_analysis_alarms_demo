{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset added: [1, 10] Size: 2 by call to `i386_align_code`.",
    "Code_line": "      HANDLE_ALIGN (fragP);",
    "Code_function": "cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)\n{\n  switch (fragP->fr_type)\n    {\n    case rs_align:\n    case rs_align_code:\n    case rs_align_test:\n    case rs_org:\n    case rs_space:\n#ifdef HANDLE_ALIGN\n      HANDLE_ALIGN (fragP);\n#endif\n      know (fragP->fr_next != NULL);\n      fragP->fr_offset = (fragP->fr_next->fr_address\n\t\t\t  - fragP->fr_address\n\t\t\t  - fragP->fr_fix) / fragP->fr_var;\n      if (fragP->fr_offset < 0)\n\t{\n\t  as_bad_where (fragP->fr_file, fragP->fr_line,\n\t\t\t_(\"attempt to .org/.space backwards? (%ld)\"),\n\t\t\t(long) fragP->fr_offset);\n\t  fragP->fr_offset = 0;\n\t}\n      fragP->fr_type = rs_fill;\n      break;\n\n    case rs_fill:\n      break;\n\n    case rs_leb128:\n      {\n\tvalueT value = S_GET_VALUE (fragP->fr_symbol);\n\tint size;\n\n\tsize = output_leb128 (fragP->fr_literal + fragP->fr_fix, value,\n\t\t\t      fragP->fr_subtype);\n\n\tfragP->fr_fix += size;\n\tfragP->fr_type = rs_fill;\n\tfragP->fr_var = 0;\n\tfragP->fr_offset = 0;\n\tfragP->fr_symbol = NULL;\n      }\n      break;\n\n    case rs_cfa:\n      eh_frame_convert_frag (fragP);\n      break;\n\n    case rs_dwarf2dbg:\n      dwarf2dbg_convert_frag (fragP);\n      break;\n\n    case rs_machine_dependent:\n      md_convert_frag (stdoutput, sec, fragP);\n\n      gas_assert (fragP->fr_next == NULL\n\t      || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)\n\t\t  == fragP->fr_fix));\n\n      /* After md_convert_frag, we make the frag into a \".space 0\".\n\t md_convert_frag() should set up any fixSs and constants\n\t required.  */\n      frag_wane (fragP);\n      break;\n\n#ifndef WORKING_DOT_WORD\n    case rs_broken_word:\n      {\n\tstruct broken_word *lie;\n\n\tif (fragP->fr_subtype)\n\t  {\n\t    fragP->fr_fix += md_short_jump_size;\n\t    for (lie = (struct broken_word *) (fragP->fr_symbol);\n\t\t lie && lie->dispfrag == fragP;\n\t\t lie = lie->next_broken_word)\n\t      if (lie->added == 1)\n\t\tfragP->fr_fix += md_long_jump_size;\n\t  }\n\tfrag_wane (fragP);\n      }\n      break;\n#endif\n\n    default:\n      BAD_CASE (fragP->fr_type);\n      break;\n    }\n#ifdef md_frag_check\n  md_frag_check (fragP);\n#endif\n}"
}