{
    "project": "bash",
    "tool": "Cppcheck",
    "category": "memleak",
    "file": "lib/readline/histfile.c",
    "message": "Memory leak: buffer",
    "warning_function_name": "read_history_range",
    "warning_line": "return (chars_read);",
    "warning_context": "int\nread_history_range (filename, from, to)\n     const char *filename;\n     int from, to;\n{\n  register char *line_start, *line_end, *p;\n  char *input, *buffer, *bufend, *last_ts;\n  int file, current_line, chars_read;\n  struct stat finfo;\n  size_t file_size;\n#if defined (EFBIG)\n  int overflow_errno = EFBIG;\n#elif defined (EOVERFLOW)\n  int overflow_errno = EOVERFLOW;\n#else\n  int overflow_errno = EIO;\n#endif\n\n  buffer = last_ts = (char *)NULL;\n  input = history_filename (filename);\n  file = input ? open (input, O_RDONLY|O_BINARY, 0666) : -1;\n\n  if ((file < 0) || (fstat (file, &finfo) == -1))\n    goto error_and_exit;\n\n  file_size = (size_t)finfo.st_size;\n\n  /* check for overflow on very large files */\n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      errno = overflow_errno;\n      goto error_and_exit;\n    }\n\n#ifdef HISTORY_USE_MMAP\n  /* We map read/write and private so we can change newlines to NULs without\n     affecting the underlying object. */\n  buffer = (char *)mmap (0, file_size, PROT_READ|PROT_WRITE, MAP_RFLAGS, file, 0);\n  if ((void *)buffer == MAP_FAILED)\n    {\n      errno = overflow_errno;\n      goto error_and_exit;\n    }\n  chars_read = file_size;\n#else\n  buffer = (char *)malloc (file_size + 1);\n  if (buffer == 0)\n    {\n      errno = overflow_errno;\n      goto error_and_exit;\n    }\n\n  chars_read = read (file, buffer, file_size);\n#endif\n  if (chars_read < 0)\n    {\n  error_and_exit:\n      if (errno != 0)\n\tchars_read = errno;\n      else\n\tchars_read = EIO;\n      if (file >= 0)\n\tclose (file);\n\n      FREE (input);\n#ifndef HISTORY_USE_MMAP\n      FREE (buffer);\n#endif\n\n      return (chars_read);\n    }\n\n  close (file);\n\n  /* Set TO to larger than end of file if negative. */\n  if (to < 0)\n    to = chars_read;\n\n  /* Start at beginning of file, work to end. */\n  bufend = buffer + chars_read;\n  current_line = 0;\n\n  /* Skip lines until we are at FROM. */\n  for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)\n    if (*line_end == '\\n')\n      {\n      \tp = line_end + 1;\n      \t/* If we see something we think is a timestamp, continue with this\n\t   line.  We should check more extensively here... */\n\tif (HIST_TIMESTAMP_START(p) == 0)\n\t  current_line++;\n\tline_start = p;\n      }\n\n  /* If there are lines left to gobble, then gobble them now. */\n  for (line_end = line_start; line_end < bufend; line_end++)\n    if (*line_end == '\\n')\n      {\n\t/* Change to allow Windows-like \\r\\n end of line delimiter. */\n\tif (line_end > line_start && line_end[-1] == '\\r')\n\t  line_end[-1] = '\\0';\n"
}