{
    "project": "bash",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "alias.c",
    "message": "pointer `token` last assigned on line 475 could be null and is dereferenced at line 489, column 7.",
    "warning_function_name": "alias_expand",
    "warning_line": "token[0] = 0;",
    "warning_context": "char *\nalias_expand (string)\n     char *string;\n{\n  register int i, j, start;\n  char *line, *token;\n  int line_len, tl, real_start, expand_next, expand_this_token;\n  alias_t *alias;\n\n  line_len = strlen (string) + 1;\n  line = (char *)xmalloc (line_len);\n  token = (char *)xmalloc (line_len);\n\n  line[0] = i = 0;\n  expand_next = 0;\n  command_word = 1; /* initialized to expand the first word on the line */\n\n  /* Each time through the loop we find the next word in line.  If it\n     has an alias, substitute the alias value.  If the value ends in ` ',\n     then try again with the next word.  Else, if there is no value, or if\n     the value does not end in space, we are done. */\n\n  for (;;)\n    {\n\n      token[0] = 0;\n      start = i;\n\n      /* Skip white space and quoted characters */\n      i = skipws (string, start);\n\n      if (start == i && string[i] == '\\0')\n\t{\n\t  free (token);\n\t  return (line);\n\t}\n\n      /* copy the just-skipped characters into the output string,\n\t expanding it if there is not enough room. */\n      j = strlen (line);\n      tl = i - start;\t/* number of characters just skipped */\n      RESIZE_MALLOCED_BUFFER (line, j, (tl + 1), line_len, (tl + 50));\n      strncpy (line + j, string + start, tl);\n      line[j + tl] = '\\0';\n\n      real_start = i;\n\n      command_word = command_word || (command_separator (string[i]));\n      expand_this_token = (command_word || expand_next);\n      expand_next = 0;\n\n      /* Read the next token, and copy it into TOKEN. */\n      start = i;\n      i = rd_token (string, start);\n\n      tl = i - start;\t/* token length */\n\n      /* If tl == 0, but we're not at the end of the string, then we have a\n\t single-character token, probably a delimiter */\n      if (tl == 0 && string[i] != '\\0')\n\t{\n\t  tl = 1;\n\t  i++;\t\t/* move past it */\n\t}\n\n      strncpy (token, string + start, tl);\n      token [tl] = '\\0';\n\n      /* If there is a backslash-escaped character quoted in TOKEN,\n\t then we don't do alias expansion.  This should check for all\n\t other quoting characters, too. */\n      if (mbschr (token, '\\\\'))\n\texpand_this_token = 0;\n\n      /* If we should be expanding here, if we are expanding all words, or if\n\t we are in a location in the string where an expansion is supposed to\n\t take place, see if this word has a substitution.  If it does, then do\n\t the expansion.  Note that we defer the alias value lookup until we\n\t are sure we are expanding this token. */\n\n      if ((token[0]) &&\n\t  (expand_this_token || alias_expand_all) &&\n\t  (alias = find_alias (token)))\n\t{\n\t  char *v;\n\t  int vlen, llen;\n\n\t  v = alias->value;\n\t  vlen = strlen (v);\n\t  llen = strlen (line);\n\n\t  /* +3 because we possibly add one more character below. */\n\t  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));\n\n\t  strcpy (line + llen, v);\n\n\t  if ((expand_this_token && vlen && whitespace (v[vlen - 1])) ||\n\t      alias_expand_all)\n\t    expand_next = 1;\n\t}\n      else\n"
}