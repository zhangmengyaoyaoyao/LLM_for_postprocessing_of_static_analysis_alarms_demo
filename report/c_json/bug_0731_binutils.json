{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Message": "Offset added: [5, 10] Size: 6.",
    "Code_line": "                          memcpy (d, special[k][1], slen);",
    "Code_function": "ada_demangle (const char *mangled, int option ATTRIBUTE_UNUSED)\n{\n  int len0;\n  const char* p;\n  char *d;\n  char *demangled;\n\n  /* Discard leading _ada_, which is used for library level subprograms.  */\n  if (strncmp (mangled, \"_ada_\", 5) == 0)\n    mangled += 5;\n\n  /* All ada unit names are lower-case.  */\n  if (!ISLOWER (mangled[0]))\n    goto unknown;\n\n  /* Most of the demangling will trivially remove chars.  Operator names\n     may add one char but because they are always preceeded by '__' which is\n     replaced by '.', they eventually never expand the size.\n     A few special names such as '___elabs' add a few chars (at most 7), but\n     they occur only once.  */\n  len0 = strlen (mangled) + 7 + 1;\n  demangled = XNEWVEC (char, len0);\n\n  d = demangled;\n  p = mangled;\n  while (1)\n    {\n      /* An entity names is expected.  */\n      if (ISLOWER (*p))\n        {\n          /* An identifier, which is always lower case.  */\n          do\n            *d++ = *p++;\n          while (ISLOWER(*p) || ISDIGIT (*p)\n                 || (p[0] == '_' && (ISLOWER (p[1]) || ISDIGIT (p[1]))));\n        }\n      else if (p[0] == 'O')\n        {\n          /* An operator name.  */\n          static const char * const operators[][2] =\n            {{\"Oabs\", \"abs\"},  {\"Oand\", \"and\"},    {\"Omod\", \"mod\"},\n             {\"Onot\", \"not\"},  {\"Oor\", \"or\"},      {\"Orem\", \"rem\"},\n             {\"Oxor\", \"xor\"},  {\"Oeq\", \"=\"},       {\"One\", \"/=\"},\n             {\"Olt\", \"<\"},     {\"Ole\", \"<=\"},      {\"Ogt\", \">\"},\n             {\"Oge\", \">=\"},    {\"Oadd\", \"+\"},      {\"Osubtract\", \"-\"},\n             {\"Oconcat\", \"&\"}, {\"Omultiply\", \"*\"}, {\"Odivide\", \"/\"},\n             {\"Oexpon\", \"**\"}, {NULL, NULL}};\n          int k;\n\n          for (k = 0; operators[k][0] != NULL; k++)\n            {\n              size_t slen = strlen (operators[k][0]);\n              if (strncmp (p, operators[k][0], slen) == 0)\n                {\n                  p += slen;\n                  slen = strlen (operators[k][1]);\n                  *d++ = '\"';\n                  memcpy (d, operators[k][1], slen);\n                  d += slen;\n                  *d++ = '\"';\n                  break;\n                }\n            }\n          /* Operator not found.  */\n          if (operators[k][0] == NULL)\n            goto unknown;\n        }\n      else\n        {\n          /* Not a GNAT encoding.  */\n          goto unknown;\n        }\n\n      /* The name can be directly followed by some uppercase letters.  */\n      if (p[0] == 'T' && p[1] == 'K')\n        {\n          /* Task stuff.  */\n          if (p[2] == 'B' && p[3] == 0)\n            {\n              /* Subprogram for task body.  */\n              break;\n            }\n          else if (p[2] == '_' && p[3] == '_')\n            {\n              /* Inner declarations in a task.  */\n              p += 4;\n              *d++ = '.';\n              continue;\n            }\n          else\n            goto unknown;\n        }\n      if (p[0] == 'E' && p[1] == 0)\n        {\n          /* Exception name.  */\n          goto unknown;\n        }\n      if ((p[0] == 'P' || p[0] == 'N') && p[1] == 0)\n        {\n          /* Protected type subprogram.  */\n          break;\n        }\n      if ((*p == 'N' || *p == 'S') && p[1] == 0)\n        {\n          /* Enumerated type name table.  */\n          goto unknown;\n        }\n      if (p[0] == 'X')\n        {\n          /* Body nested.  */\n          p++;\n          while (p[0] == 'n' || p[0] == 'b')\n            p++;\n        }\n      if (p[0] == 'S' && p[1] != 0 && (p[2] == '_' || p[2] == 0))\n        {\n          /* Stream operations.  */\n          const char *name;\n          switch (p[1])\n            {\n            case 'R':\n              name = \"'Read\";\n              break;\n            case 'W':\n              name = \"'Write\";\n              break;\n            case 'I':\n              name = \"'Input\";\n              break;\n            case 'O':\n              name = \"'Output\";\n              break;\n            default:\n              goto unknown;\n            }\n          p += 2;\n          strcpy (d, name);\n          d += strlen (name);\n        }\n      else if (p[0] == 'D')\n        {\n          /* Controlled type operation.  */\n          const char *name;\n          switch (p[1])\n            {\n            case 'F':\n              name = \".Finalize\";\n              break;\n            case 'A':\n              name = \".Adjust\";\n              break;\n            default:\n              goto unknown;\n            }\n          strcpy (d, name);\n          d += strlen (name);\n          break;\n        }\n\n      if (p[0] == '_')\n        {\n          /* Separator.  */\n          if (p[1] == '_')\n            {\n              /* Standard separator.  Handled first.  */\n              p += 2;\n\n              if (ISDIGIT (*p))\n                {\n                  /* Overloading number.  */\n                  do\n                    p++;\n                  while (ISDIGIT (*p) || (p[0] == '_' && ISDIGIT (p[1])));\n                  if (*p == 'X')\n                    {\n                      p++;\n                      while (p[0] == 'n' || p[0] == 'b')\n                        p++;\n                    }\n                }\n              else if (p[0] == '_' && p[1] != '_')\n                {\n                  /* Special names.  */\n                  static const char * const special[][2] = {\n                    { \"_elabb\", \"'Elab_Body\" },\n                    { \"_elabs\", \"'Elab_Spec\" },\n                    { \"_size\", \"'Size\" },\n                    { \"_alignment\", \"'Alignment\" },\n                    { \"_assign\", \".\\\":=\\\"\" },\n                    { NULL, NULL }\n                  };\n                  int k;\n\n                  for (k = 0; special[k][0] != NULL; k++)\n                    {\n                      size_t slen = strlen (special[k][0]);\n                      if (strncmp (p, special[k][0], slen) == 0)\n                        {\n                          p += slen;\n                          slen = strlen (special[k][1]);\n                          memcpy (d, special[k][1], slen);\n                          d += slen;\n                          break;\n                        }\n                    }\n                  if (special[k][0] != NULL)\n                    break;\n                  else\n                    goto unknown;\n                }\n              else\n                {\n                  *d++ = '.';\n                  continue;\n                }\n            }\n          else if (p[1] == 'B' || p[1] == 'E')\n            {\n              /* Entry Body or barrier Evaluation.  */\n              p += 2;\n              while (ISDIGIT (*p))\n                p++;\n              if (p[0] == 's' && p[1] == 0)\n                break;\n              else\n                goto unknown;\n            }\n          else\n            goto unknown;\n        }\n\n      if (p[0] == '.' && ISDIGIT (p[1]))\n        {\n          /* Nested subprogram.  */\n          p += 2;\n          while (ISDIGIT (*p))\n            p++;\n        }\n      if (*p == 0)\n        {\n          /* End of mangled name.  */\n          break;\n        }\n      else\n        goto unknown;\n    }\n  *d = 0;\n  return demangled;\n\n unknown:\n  len0 = strlen (mangled);\n  demangled = XNEWVEC (char, len0 + 3);\n\n  if (mangled[0] == '<')\n     strcpy (demangled, mangled);\n  else\n    sprintf (demangled, \"<%s>\", mangled);\n\n  return demangled;\n}"
}