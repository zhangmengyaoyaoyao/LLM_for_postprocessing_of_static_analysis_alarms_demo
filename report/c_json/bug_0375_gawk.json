{
    "Project": "gawk",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Message": "Array access (from variable 'optarg') results in a null pointer dereference",
    "Code_line": "\t\t\tif (optarg[0] == '\\0')",
    "Code_function": "parse_args(int argc, char **argv)\n{\n\t/*\n\t * The + on the front tells GNU getopt not to rearrange argv.\n\t */\n\tconst char *optlist = \"+F:f:v:W;bcCd::D::e:E:ghi:l:L:nNo::Op::MPrStVYZ:\";\n\tint old_optind;\n\tint c;\n\tchar *scan;\n\tchar *src;\n\n\t/* we do error messages ourselves on invalid options */\n\topterr = false;\n\n\t/* copy argv before getopt gets to it; used to restart the debugger */\n\tsave_argv(argc, argv);\n\n\t/* option processing. ready, set, go! */\n\tfor (optopt = 0, old_optind = 1;\n\t     (c = getopt_long(argc, argv, optlist, optab, NULL)) != EOF;\n\t     optopt = 0, old_optind = optind) {\n\t\tif (do_posix)\n\t\t\topterr = true;\n\n\t\tswitch (c) {\n\t\tcase 'F':\n\t\t\tadd_preassign(PRE_ASSIGN_FS, optarg);\n\t\t\tbreak;\n\n\t\tcase 'E':\n\t\t\tdisallow_var_assigns = true;\n\t\t\t/* fall through */\n\t\tcase 'f':\n\t\t\t/*\n\t\t\t * Allow multiple -f options.\n\t\t\t * This makes function libraries real easy.\n\t\t\t * Most of the magic is in the scanner.\n\t\t\t *\n\t\t\t * The following is to allow for whitespace at the end\n\t\t\t * of a #! /bin/gawk line in an executable file\n\t\t\t */\n\t\t\tscan = optarg;\n\t\t\tif (argv[optind-1] != optarg)\n\t\t\t\twhile (isspace((unsigned char) *scan))\n\t\t\t\t\tscan++;\n\t\t\tsrc = (*scan == '\\0' ? argv[optind++] : optarg);\n\t\t\t(void) add_srcfile((src && src[0] == '-' && src[1] == '\\0') ?\n\t\t\t\t\tSRC_STDIN : SRC_FILE,\n\t\t\t\t\tsrc, srcfiles, NULL, NULL);\n\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tadd_preassign(PRE_ASSIGN, optarg);\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\t\tdo_binary = true;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tdo_flags |= DO_TRADITIONAL;\n\t\t\tbreak;\n\n\t\tcase 'C':\n\t\t\tcopyleft();\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tdo_flags |= DO_DUMP_VARS;\n\t\t\tif (optarg != NULL && optarg[0] != '\\0')\n\t\t\t\tvarfile = optarg;\n\t\t\tbreak;\n\n\t\tcase 'D':\n\t\t\tdo_flags |= DO_DEBUG;\n\t\t\tif (optarg != NULL && optarg[0] != '\\0')\n\t\t\t\tcommand_file = optarg;\n\t\t\tbreak;\n\n\t\tcase 'e':\n\t\t\tif (optarg[0] == '\\0')\n\t\t\t\twarning(_(\"empty argument to `-e/--source' ignored\"));\n\t\t\telse\n\t\t\t\t(void) add_srcfile(SRC_CMDLINE, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\tdo_flags |= DO_INTL;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\t/* write usage to stdout, per GNU coding stds */\n\t\t\tusage(EXIT_SUCCESS, stdout);\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\t(void) add_srcfile(SRC_INC, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n\t\tcase 'l':\n\t\t\t(void) add_srcfile(SRC_EXTLIB, optarg, srcfiles, NULL, NULL);\n\t\t\tbreak;\n\n#ifndef NO_LINT\n\t\tcase 'L':\n\t\t\tdo_flags |= DO_LINT_ALL;\n\t\t\tif (optarg != NULL) {\n\t\t\t\tif (strcmp(optarg, \"fatal\") == 0)\n\t\t\t\t\tlintfunc = r_fatal;\n\t\t\t\telse if (strcmp(optarg, \"invalid\") == 0) {\n\t\t\t\t\tdo_flags &= ~DO_LINT_ALL;\n\t\t\t\t\tdo_flags |= DO_LINT_INVALID;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 't':\n\t\t\tdo_flags |= DO_LINT_OLD;\n\t\t\tbreak;\n#else\n\t\tcase 'L':\n\t\tcase 't':\n\t\t\tbreak;\n#endif\n\n\t\tcase 'n':\n\t\t\tdo_flags |= DO_NON_DEC_DATA;\n\t\t\tbreak;\n\n\t\tcase 'N':\n\t\t\tuse_lc_numeric = true;\n\t\t\tbreak;\n\n\t\tcase 'O':\n\t\t\tdo_optimize = true;\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tdo_flags |= DO_PROFILE;\n\t\t\t/* fall through */\n\t\tcase 'o':\n\t\t\tdo_flags |= DO_PRETTY_PRINT;\n\t\t\tif (optarg != NULL)\n\t\t\t\tset_prof_file(optarg);\n\t\t\telse\n\t\t\t\tset_prof_file(DEFAULT_PROFILE);\n\t\t\tbreak;\n\n\t\tcase 'M':\n#ifdef HAVE_MPFR\n\t\t\tdo_flags |= DO_MPFR;\n#else\n\t\t\twarning(_(\"-M ignored: MPFR/GMP support not compiled in\"));\n#endif\n\t\t\tbreak;\n\n\t\tcase 'P':\n\t\t\tdo_flags |= DO_POSIX;\n\t\t\tbreak;\n\n\t\tcase 'r':\n\t\t\tdo_flags |= DO_INTERVALS;\n \t\t\tbreak;\n\n\t\tcase 'S':\n\t\t\tdo_flags |= DO_SANDBOX;\n  \t\t\tbreak;\n\n\t\tcase 'V':\n\t\t\tdo_version = true;\n\t\t\tbreak;\n\n\t\tcase 'W':       /* gawk specific options - now in getopt_long */\n\t\t\tfprintf(stderr, _(\"%s: option `-W %s' unrecognized, ignored\\n\"),\n\t\t\t\targv[0], optarg);\n\t\t\tbreak;\n\n\t\tcase 0:\n\t\t\t/*\n\t\t\t * getopt_long found an option that sets a variable\n\t\t\t * instead of returning a letter. Do nothing, just\n\t\t\t * cycle around for the next one.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase 'Y':\n\t\tcase 'Z':\n#if defined(YYDEBUG) || defined(GAWKDEBUG)\n\t\t\tif (c == 'Y') {\n\t\t\t\tyydebug = 2;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#if defined(LOCALEDEBUG)\n\t\t\tif (c == 'Z') {\n\t\t\t\tlocale = optarg;\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* if not debugging, fall through */\n\t\tcase '?':\n\t\tdefault:\n\t\t\t/*\n\t\t\t * If not posix, an unrecognized option stops argument\n\t\t\t * processing so that it can go into ARGV for the awk\n\t\t\t * program to see. This makes use of ``#! /bin/gawk -f''\n\t\t\t * easier.\n\t\t\t *\n\t\t\t * However, it's never simple. If optopt is set,\n\t\t\t * an option that requires an argument didn't get the\n\t\t\t * argument. We care because if opterr is 0, then\n\t\t\t * getopt_long won't print the error message for us.\n\t\t\t */\n\t\t\tif (! do_posix\n\t\t\t    && (optopt == '\\0' || strchr(optlist, optopt) == NULL)) {\n\t\t\t\t/*\n\t\t\t\t * can't just do optind--. In case of an\n\t\t\t\t * option with >= 2 letters, getopt_long\n\t\t\t\t * won't have incremented optind.\n\t\t\t\t */\n\t\t\t\toptind = old_optind;\n\t\t\t\tstopped_early = true;\n\t\t\t\tgoto out;\n\t\t\t} else if (optopt != '\\0') {\n\t\t\t\t/* Use POSIX required message format */\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t_(\"%s: option requires an argument -- %c\\n\"),\n\t\t\t\t\tmyname, optopt);\n\t\t\t\tusage(EXIT_FAILURE, stderr);\n\t\t\t}\n\t\t\t/* else\n\t\t\t\tlet getopt print error message for us */\n\t\t\tbreak;\n\t\t}\n\t\tif (c == 'E')\t/* --exec ends option processing */\n\t\t\tbreak;\n\t}\nout:\n\treturn;\n}"
}