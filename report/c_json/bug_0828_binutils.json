{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "binutils/dwarf.c",
    "message": "Offset added: [37, +oo] (⇐ [1, +oo] + 36) Size: 10.",
    "warning_function_name": "display_debug_lines_decoded",
    "warning_line": "strncpy (newFileName,",
    "warning_context": "\t\t   break;\n\n\t\t case DW_LNS_set_basic_block:\n\t\t   state_machine_regs.basic_block = 1;\n\t\t   break;\n\n\t\t case DW_LNS_const_add_pc:\n\t\t   uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);\n\t\t   if (linfo.li_max_ops_per_insn == 1)\n\t\t     {\n\t\t       uladv *= linfo.li_min_insn_length;\n\t\t       state_machine_regs.address += uladv;\n\t\t     }\n\t\t   else\n\t\t     {\n\t\t       state_machine_regs.address\n\t\t\t += ((state_machine_regs.op_index + uladv)\n\t\t\t     / linfo.li_max_ops_per_insn)\n\t\t\t * linfo.li_min_insn_length;\n\t\t       state_machine_regs.op_index\n\t\t\t = (state_machine_regs.op_index + uladv)\n\t\t\t % linfo.li_max_ops_per_insn;\n\t\t     }\n\t\t   break;\n\n\t\t case DW_LNS_fixed_advance_pc:\n\t\t   SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);\n\t\t   state_machine_regs.address += uladv;\n\t\t   state_machine_regs.op_index = 0;\n\t\t   break;\n\n\t\t case DW_LNS_set_prologue_end:\n\t\t   break;\n\n\t\t case DW_LNS_set_epilogue_begin:\n\t\t   break;\n\n\t\t case DW_LNS_set_isa:\n\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n\t\t   data += bytes_read;\n\t\t   printf (_(\"  Set ISA to %lu\\n\"), uladv);\n\t\t   break;\n\n\t\t default:\n\t\t   printf (_(\"  Unknown opcode %d with operands: \"), op_code);\n\n\t\t   if (standard_opcodes != NULL)\n\t\t     for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)\n\t\t       {\n\t\t\t printf (\"0x%s%s\", dwarf_vmatoa (\"x\", read_uleb128 (data,\n\t\t\t\t\t\t\t\t\t    &bytes_read, end)),\n\t\t\t\t i == 1 ? \"\" : \", \");\n\t\t\t data += bytes_read;\n\t\t       }\n\t\t   putchar ('\\n');\n\t\t   break;\n\t\t }\n\n\t  /* Only Special opcodes, DW_LNS_copy and DW_LNE_end_sequence adds a row\n\t     to the DWARF address/line matrix.  */\n\t  if ((is_special_opcode) || (op_code == DW_LNE_end_sequence)\n\t      || (op_code == DW_LNS_copy))\n\t    {\n\t      const unsigned int MAX_FILENAME_LENGTH = 35;\n\t      char *fileName;\n\t      char *newFileName = NULL;\n\t      size_t fileNameLength;\n\n\t      if (file_table)\n\t\tfileName = (char *) file_table[state_machine_regs.file - 1].name;\n\t      else\n\t\tfileName = \"<unknown>\";\n\n\t      fileNameLength = strlen (fileName);\n\n\t      if ((fileNameLength > MAX_FILENAME_LENGTH) && (!do_wide))\n\t\t{\n\t\t  newFileName = (char *) xmalloc (MAX_FILENAME_LENGTH + 1);\n\t\t  /* Truncate file name */\n\t\t  strncpy (newFileName,\n\t\t\t   fileName + fileNameLength - MAX_FILENAME_LENGTH,\n\t\t\t   MAX_FILENAME_LENGTH + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  newFileName = (char *) xmalloc (fileNameLength + 1);\n\t\t  strncpy (newFileName, fileName, fileNameLength + 1);\n\t\t}\n\n\t      if (!do_wide || (fileNameLength <= MAX_FILENAME_LENGTH))\n\t\t{\n\t\t  if (linfo.li_max_ops_per_insn == 1)\n\t\t    printf (\"%-35s  %11d  %#18\" DWARF_VMA_FMT \"x\\n\",\n\t\t\t    newFileName, state_machine_regs.line,\n\t\t\t    state_machine_regs.address);\n\t\t  else\n\t\t    printf (\"%-35s  %11d  %#18\" DWARF_VMA_FMT \"x[%d]\\n\",\n\t\t\t    newFileName, state_machine_regs.line,\n\t\t\t    state_machine_regs.address,\n\t\t\t    state_machine_regs.op_index);\n\t\t}\n"
}