{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "      strcpy (tmpdir, base);",
    "Code_function": "choose_tmpdir (void)\n{\n  if (!memoized_tmpdir)\n    {\n#if !defined(_WIN32) || defined(__CYGWIN__)\n      const char *base = 0;\n      char *tmpdir;\n      unsigned int len;\n\n#ifdef VMS\n      /* Try VMS standard temp logical.  */\n      base = try_dir (\"/sys$scratch\", base);\n#else\n      base = try_dir (getenv (\"TMPDIR\"), base);\n      base = try_dir (getenv (\"TMP\"), base);\n      base = try_dir (getenv (\"TEMP\"), base);\n#endif\n\n#ifdef P_tmpdir\n      /* We really want a directory name here as if concatenated with say \\dir\n\t we do not end up with a double \\\\ which defines an UNC path.  */\n      if (strcmp (P_tmpdir, \"\\\\\") == 0)\n\tbase = try_dir (\"\\\\.\", base);\n      else\n\tbase = try_dir (P_tmpdir, base);\n#endif\n\n      /* Try /var/tmp, /usr/tmp, then /tmp.  */\n      base = try_dir (vartmp, base);\n      base = try_dir (usrtmp, base);\n      base = try_dir (tmp, base);\n\n      /* If all else fails, use the current directory!  */\n      if (base == 0)\n\tbase = \".\";\n      /* Append DIR_SEPARATOR to the directory we've chosen\n\t and return it.  */\n      len = strlen (base);\n      tmpdir = XNEWVEC (char, len + 2);\n      strcpy (tmpdir, base);\n      tmpdir[len] = DIR_SEPARATOR;\n      tmpdir[len+1] = '\\0';\n      memoized_tmpdir = tmpdir;\n#else /* defined(_WIN32) && !defined(__CYGWIN__) */\n      DWORD len;\n\n      /* Figure out how much space we need.  */\n      len = GetTempPath(0, NULL);\n      if (len)\n\t{\n\t  memoized_tmpdir = XNEWVEC (char, len);\n\t  if (!GetTempPath(len, memoized_tmpdir))\n\t    {\n\t      XDELETEVEC (memoized_tmpdir);\n\t      memoized_tmpdir = NULL;\n\t    }\n\t}\n      if (!memoized_tmpdir)\n\t/* If all else fails, use the current directory.  */\n\tmemoized_tmpdir = xstrdup (\".\\\\\");\n#endif /* defined(_WIN32) && !defined(__CYGWIN__) */\n    }\n\n  return memoized_tmpdir;\n}"
}