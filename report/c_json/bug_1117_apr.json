{
    "Project": "apr",
    "Tool": "CSA",
    "Bug Type": "core.NullDereference",
    "Message": "Access to field 'data' results in a dereference of a null pointer (loaded from variable 'ret')",
    "Code_line": "            ni = apr_skiplist_insert_compare(sli, ret->data, sli->compare);",
    "Code_function": "APR_DECLARE(apr_skiplistnode *) apr_skiplist_insert_compare(apr_skiplist *sl, void *data,\n                                      apr_skiplist_compare comp)\n{\n    apr_skiplistnode *m, *p, *tmp, *ret = NULL;\n    int ch, nh = 1;\n\n    if (!comp) {\n        return NULL;\n    }\n\n    ch = skiplist_height(sl);\n    if (sl->preheight) {\n        while (nh < sl->preheight && get_b_rand()) {\n            nh++;\n        }\n    }\n    else {\n        while (nh <= ch && get_b_rand()) {\n            nh++;\n        }\n    }\n\n    /* Now we have in nh the height at which we wish to insert our new node,\n     * and in ch the current height: don't create skip paths to the inserted\n     * element until the walk down through the tree (which decrements ch)\n     * reaches nh. From there, any walk down pushes the current node on a\n     * stack (the node(s) after which we would insert) to pop back through\n     * for insertion later.\n     */\n    m = sl->top;\n    while (m) {\n        if (m->next) {\n            int compared = comp(data, m->next->data);\n            if (compared == 0) {\n                /* Keep the existing element(s) */\n                skiplist_qclear(&sl->stack_q);\n                return NULL;\n            }\n            if (compared > 0) {\n                m = m->next;\n                continue;\n            }\n        }\n        if (ch <= nh) {\n            /* push on stack */\n            skiplist_qpush(&sl->stack_q, m);\n        }\n        m = m->down;\n        ch--;\n    }\n    /* Pop the stack and insert nodes */\n    p = NULL;\n    while ((m = skiplist_qpop(&sl->stack_q))) {\n        tmp = skiplist_new_node(sl);\n        tmp->next = m->next;\n        if (m->next) {\n            m->next->prev = tmp;\n        }\n        m->next = tmp;\n        tmp->prev = m;\n        tmp->up = NULL;\n        tmp->nextindex = tmp->previndex = NULL;\n        tmp->down = p;\n        if (p) {\n            p->up = tmp;\n        }\n        else {\n            /* This sets ret to the bottom-most node we are inserting */\n            ret = tmp;\n        }\n        tmp->data = data;\n        tmp->sl = sl;\n        p = tmp;\n    }\n\n    /* Now we are sure the node is inserted, grow our tree to 'nh' tall */\n    for (; sl->height < nh; sl->height++) {\n        m = skiplist_new_node(sl);\n        tmp = skiplist_new_node(sl);\n        m->up = m->prev = m->nextindex = m->previndex = NULL;\n        m->next = tmp;\n        m->down = sl->top;\n        m->data = NULL;\n        m->sl = sl;\n        if (sl->top) {\n            sl->top->up = m;\n        }\n        else {\n            sl->bottom = sl->bottomend = m;\n        }\n        sl->top = sl->topend = tmp->prev = m;\n        tmp->up = tmp->next = tmp->nextindex = tmp->previndex = NULL;\n        tmp->down = p;\n        tmp->data = data;\n        tmp->sl = sl;\n        if (p) {\n            p->up = tmp;\n        }\n        else {\n            /* This sets ret to the bottom-most node we are inserting */\n            ret = tmp;\n        }\n        p = tmp;\n    }\n    if (sl->index != NULL) {\n        /*\n         * this is a external insertion, we must insert into each index as\n         * well\n         */\n        apr_skiplistnode *ni, *li;\n        li = ret;\n        for (p = apr_skiplist_getlist(sl->index); p; apr_skiplist_next(sl->index, &p)) {\n            apr_skiplist *sli = (apr_skiplist *)p->data;\n            ni = apr_skiplist_insert_compare(sli, ret->data, sli->compare);\n            li->nextindex = ni;\n            ni->previndex = li;\n            li = ni;\n        }\n    }\n    sl->size++;\n    return ret;\n}"
}