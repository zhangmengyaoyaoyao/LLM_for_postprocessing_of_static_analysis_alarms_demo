{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "libiberty/cp-demangle.c",
    "message": "pointer `code` last assigned on line 3173 could be null and is dereferenced by call to `strcmp()` at line 3244, column 11.",
    "warning_function_name": "d_expression_1",
    "warning_line": "if (!strcmp (code, \"cl\"))",
    "warning_context": "\ttype = cplus_demangle_type (di);\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_INITIALIZER_LIST,\n\t\t\t  type, d_exprlist (di, 'E'));\n    }\n  else\n    {\n      struct demangle_component *op;\n      const char *code = NULL;\n      int args;\n\n      op = d_operator_name (di);\n      if (op == NULL)\n\treturn NULL;\n\n      if (op->type == DEMANGLE_COMPONENT_OPERATOR)\n\t{\n\t  code = op->u.s_operator.op->code;\n\t  di->expansion += op->u.s_operator.op->len - 2;\n\t  if (strcmp (code, \"st\") == 0)\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\tcplus_demangle_type (di));\n\t}\n\n      switch (op->type)\n\t{\n\tdefault:\n\t  return NULL;\n\tcase DEMANGLE_COMPONENT_OPERATOR:\n\t  args = op->u.s_operator.op->args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n\t  args = op->u.s_extended_operator.args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_CAST:\n\t  args = 1;\n\t  break;\n\t}\n\n      switch (args)\n\t{\n\tcase 0:\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_NULLARY, op, NULL);\n\n\tcase 1:\n\t  {\n\t    struct demangle_component *operand;\n\t    int suffix = 0;\n\n\t    if (code && (code[0] == 'p' || code[0] == 'm')\n\t\t&& code[1] == code[0])\n\t      /* pp_ and mm_ are the prefix variants.  */\n\t      suffix = !d_check_char (di, '_');\n\n\t    if (op->type == DEMANGLE_COMPONENT_CAST\n\t\t&& d_check_char (di, '_'))\n\t      operand = d_exprlist (di, 'E');\n\t    else\n\t      operand = d_expression_1 (di);\n\n\t    if (suffix)\n\t      /* Indicate the suffix variant for d_print_comp.  */\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  d_make_comp (di,\n\t\t\t\t\t       DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t       operand, operand));\n\t    else\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  operand);\n\t  }\n\tcase 2:\n\t  {\n\t    struct demangle_component *left;\n\t    struct demangle_component *right;\n\n\t    if (op_is_new_cast (op))\n\t      left = cplus_demangle_type (di);\n\t    else\n\t      left = d_expression_1 (di);\n\t    if (!strcmp (code, \"cl\"))\n\t      right = d_exprlist (di, 'E');\n\t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n\t      {\n\t\tright = d_unqualified_name (di);\n\t\tif (d_peek_char (di) == 'I')\n\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n\t\t\t\t       right, d_template_args (di));\n\t      }\n\t    else\n\t      right = d_expression_1 (di);\n\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t     left, right));\n\t  }\n\tcase 3:\n\t  {\n\t    struct demangle_component *first;\n\t    struct demangle_component *second;\n\t    struct demangle_component *third;\n"
}