{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/linker.c",
    "message": "Offset added: [2, +oo] (⇐ [0, +oo] + [2, +oo]) Size: [1, +oo] by call to `_bfd_default_link_order`.",
    "warning_function_name": "_bfd_generic_final_link",
    "warning_line": "if (! _bfd_default_link_order (abfd, info, o, p))",
    "warning_context": "  if (! generic_add_output_symbol (abfd, &outsymalloc, NULL))\n    return FALSE;\n\n  if (info->relocatable)\n    {\n      /* Allocate space for the output relocs for each section.  */\n      for (o = abfd->sections; o != NULL; o = o->next)\n\t{\n\t  o->reloc_count = 0;\n\t  for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t    {\n\t      if (p->type == bfd_section_reloc_link_order\n\t\t  || p->type == bfd_symbol_reloc_link_order)\n\t\t++o->reloc_count;\n\t      else if (p->type == bfd_indirect_link_order)\n\t\t{\n\t\t  asection *input_section;\n\t\t  bfd *input_bfd;\n\t\t  long relsize;\n\t\t  arelent **relocs;\n\t\t  asymbol **symbols;\n\t\t  long reloc_count;\n\n\t\t  input_section = p->u.indirect.section;\n\t\t  input_bfd = input_section->owner;\n\t\t  relsize = bfd_get_reloc_upper_bound (input_bfd,\n\t\t\t\t\t\t       input_section);\n\t\t  if (relsize < 0)\n\t\t    return FALSE;\n\t\t  relocs = (arelent **) bfd_malloc (relsize);\n\t\t  if (!relocs && relsize != 0)\n\t\t    return FALSE;\n\t\t  symbols = _bfd_generic_link_get_symbols (input_bfd);\n\t\t  reloc_count = bfd_canonicalize_reloc (input_bfd,\n\t\t\t\t\t\t\tinput_section,\n\t\t\t\t\t\t\trelocs,\n\t\t\t\t\t\t\tsymbols);\n\t\t  free (relocs);\n\t\t  if (reloc_count < 0)\n\t\t    return FALSE;\n\t\t  BFD_ASSERT ((unsigned long) reloc_count\n\t\t\t      == input_section->reloc_count);\n\t\t  o->reloc_count += reloc_count;\n\t\t}\n\t    }\n\t  if (o->reloc_count > 0)\n\t    {\n\t      bfd_size_type amt;\n\n\t      amt = o->reloc_count;\n\t      amt *= sizeof (arelent *);\n\t      o->orelocation = (struct reloc_cache_entry **) bfd_alloc (abfd, amt);\n\t      if (!o->orelocation)\n\t\treturn FALSE;\n\t      o->flags |= SEC_RELOC;\n\t      /* Reset the count so that it can be used as an index\n\t\t when putting in the output relocs.  */\n\t      o->reloc_count = 0;\n\t    }\n\t}\n    }\n\n  /* Handle all the link order information for the sections.  */\n  for (o = abfd->sections; o != NULL; o = o->next)\n    {\n      for (p = o->map_head.link_order; p != NULL; p = p->next)\n\t{\n\t  switch (p->type)\n\t    {\n\t    case bfd_section_reloc_link_order:\n\t    case bfd_symbol_reloc_link_order:\n\t      if (! _bfd_generic_reloc_link_order (abfd, info, o, p))\n\t\treturn FALSE;\n\t      break;\n\t    case bfd_indirect_link_order:\n\t      if (! default_indirect_link_order (abfd, info, o, p, TRUE))\n\t\treturn FALSE;\n\t      break;\n\t    default:\n\t      if (! _bfd_default_link_order (abfd, info, o, p))\n\t\treturn FALSE;\n\t      break;\n\t    }\n\t}\n    }\n\n  return TRUE;\n}\n\n/* Add an output symbol to the output BFD.  */\n\nstatic bfd_boolean\ngeneric_add_output_symbol (bfd *output_bfd, size_t *psymalloc, asymbol *sym)\n{\n  if (bfd_get_symcount (output_bfd) >= *psymalloc)\n    {\n      asymbol **newsyms;\n      bfd_size_type amt;\n\n      if (*psymalloc == 0)\n\t*psymalloc = 124;\n"
}