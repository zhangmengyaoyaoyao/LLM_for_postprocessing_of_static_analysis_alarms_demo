{
    "project": "binutils",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "gas/app.c",
    "message": "The value read from fromlen was never initialized.",
    "warning_function_name": "process_escape",
    "warning_line": "ch = GET ();",
    "warning_context": "     I added state 11 so that something like \"Lfoo add %r25,%r26,%r27\" works\n     correctly on the PA (and any other target where colons are optional).\n     Jeff Law, law@cs.utah.edu.\n\n     I added state 13 so that something like \"cmp r1, r2 || trap #1\" does not\n     get squashed into \"cmp r1,r2||trap#1\", with the all important space\n     between the 'trap' and the '#1' being eliminated.  nickc@cygnus.com  */\n\n  /* This macro gets the next input character.  */\n\n#define GET()\t\t\t\t\t\t\t\\\n  (from < fromend\t\t\t\t\t\t\\\n   ? * (unsigned char *) (from++)\t\t\t\t\\\n   : (saved_input = NULL,\t\t\t\t\t\\\n      fromlen = (*get) (input_buffer, sizeof input_buffer),\t\\\n      from = input_buffer,\t\t\t\t\t\\\n      fromend = from + fromlen,\t\t\t\t\t\\\n      (fromlen == 0\t\t\t\t\t\t\\\n       ? EOF\t\t\t\t\t\t\t\\\n       : * (unsigned char *) (from++))))\n\n  /* This macro pushes a character back on the input stream.  */\n\n#define UNGET(uch) (*--from = (uch))\n\n  /* This macro puts a character into the output buffer.  If this\n     character fills the output buffer, this macro jumps to the label\n     TOFULL.  We use this rather ugly approach because we need to\n     handle two different termination conditions: EOF on the input\n     stream, and a full output buffer.  It would be simpler if we\n     always read in the entire input stream before processing it, but\n     I don't want to make such a significant change to the assembler's\n     memory usage.  */\n\n#define PUT(pch)\t\t\t\t\\\n  do\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n      *to++ = (pch);\t\t\t\t\\\n      if (to >= toend)\t\t\t\t\\\n\tgoto tofull;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n  while (0)\n\n  if (saved_input != NULL)\n    {\n      from = saved_input;\n      fromend = from + saved_input_len;\n    }\n  else\n    {\n      fromlen = (*get) (input_buffer, sizeof input_buffer);\n      if (fromlen == 0)\n\treturn 0;\n      from = input_buffer;\n      fromend = from + fromlen;\n    }\n\n  while (1)\n    {\n      /* The cases in this switch end with continue, in order to\n\t branch back to the top of this while loop and generate the\n\t next output character in the appropriate state.  */\n      switch (state)\n\t{\n\tcase -1:\n\t  ch = *out_string++;\n\t  if (*out_string == '\\0')\n\t    {\n\t      state = old_state;\n\t      old_state = 3;\n\t    }\n\t  PUT (ch);\n\t  continue;\n\n\tcase -2:\n\t  for (;;)\n\t    {\n\t      do\n\t\t{\n\t\t  ch = GET ();\n\n\t\t  if (ch == EOF)\n\t\t    {\n\t\t      as_warn (_(\"end of file in comment\"));\n\t\t      goto fromeof;\n\t\t    }\n\n\t\t  if (ch == '\\n')\n\t\t    PUT ('\\n');\n\t\t}\n\t      while (ch != '*');\n\n\t      while ((ch = GET ()) == '*')\n\t\t;\n\n\t      if (ch == EOF)\n\t\t{\n\t\t  as_warn (_(\"end of file in comment\"));\n\t\t  goto fromeof;\n\t\t}\n\n"
}