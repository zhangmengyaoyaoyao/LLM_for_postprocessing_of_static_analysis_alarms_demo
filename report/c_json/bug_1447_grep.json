{
    "Project": "grep",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/grep.c",
    "message": "The value read from fillsize was never initialized.",
    "warning_function_name": "fillbuf",
    "warning_line": "fillsize = undossify_input (readbuf, fillsize);",
    "warning_context": "      size_t newsize;\n      size_t newalloc;\n      char *newbuf;\n\n      /* Grow newsize until it is at least as great as minsize.  */\n      for (newsize = bufalloc - pagesize - sizeof (uword);\n           newsize < minsize;\n           newsize *= 2)\n        if ((SIZE_MAX - pagesize - sizeof (uword)) / 2 < newsize)\n          xalloc_die ();\n\n      /* Try not to allocate more memory than the file size indicates,\n         as that might cause unnecessary memory exhaustion if the file\n         is large.  However, do not use the original file size as a\n         heuristic if we've already read past the file end, as most\n         likely the file is growing.  */\n      if (usable_st_size (st))\n        {\n          off_t to_be_read = st->st_size - bufoffset;\n          off_t maxsize_off = save + to_be_read;\n          if (0 <= to_be_read && to_be_read <= maxsize_off\n              && maxsize_off == (size_t) maxsize_off\n              && minsize <= (size_t) maxsize_off\n              && (size_t) maxsize_off < newsize)\n            newsize = maxsize_off;\n        }\n\n      /* Add enough room so that the buffer is aligned and has room\n         for byte sentinels fore and aft, and so that a uword can\n         be read aft.  */\n      newalloc = newsize + pagesize + sizeof (uword);\n\n      newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;\n      readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);\n      bufbeg = readbuf - save;\n      memmove (bufbeg, buffer + saved_offset, save);\n      bufbeg[-1] = eolbyte;\n      if (newbuf != buffer)\n        {\n          free (buffer);\n          buffer = newbuf;\n        }\n    }\n\n  readsize = buffer + bufalloc - sizeof (uword) - readbuf;\n  readsize -= readsize % pagesize;\n\n  while (true)\n    {\n      fillsize = safe_read (bufdesc, readbuf, readsize);\n      if (fillsize == SAFE_READ_ERROR)\n        {\n          fillsize = 0;\n          cc = false;\n        }\n      bufoffset += fillsize;\n\n      if (fillsize == 0 || !skip_nuls || !all_zeros (readbuf, fillsize))\n        break;\n      totalnl = add_count (totalnl, fillsize);\n\n      if (SEEK_DATA != SEEK_SET && !seek_data_failed)\n        {\n          /* Solaris SEEK_DATA fails with errno == ENXIO in a hole at EOF.  */\n          off_t data_start = lseek (bufdesc, bufoffset, SEEK_DATA);\n          if (data_start < 0 && errno == ENXIO\n              && usable_st_size (st) && bufoffset < st->st_size)\n            data_start = lseek (bufdesc, 0, SEEK_END);\n\n          if (data_start < 0)\n            seek_data_failed = true;\n          else\n            {\n              totalnl = add_count (totalnl, data_start - bufoffset);\n              bufoffset = data_start;\n            }\n        }\n    }\n\n  fillsize = undossify_input (readbuf, fillsize);\n  buflim = readbuf + fillsize;\n  return cc;\n}\n\n/* Flags controlling the style of output. */\nstatic enum\n{\n  BINARY_BINARY_FILES,\n  TEXT_BINARY_FILES,\n  WITHOUT_MATCH_BINARY_FILES\n} binary_files;\t\t/* How to handle binary files.  */\n\nstatic int filename_mask;\t/* If zero, output nulls after filenames.  */\nstatic bool out_quiet;\t\t/* Suppress all normal output. */\nstatic bool out_invert;\t\t/* Print nonmatching stuff. */\nstatic int out_file;\t\t/* Print filenames. */\nstatic bool out_line;\t\t/* Print line numbers. */\nstatic bool out_byte;\t\t/* Print byte offsets. */\nstatic intmax_t out_before;\t/* Lines of leading context. */\nstatic intmax_t out_after;\t/* Lines of trailing context. */\nstatic bool count_matches;\t/* Count matching lines.  */\n"
}