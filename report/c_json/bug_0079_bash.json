{
    "project": "bash",
    "tool": "Cppcheck",
    "category": "uninitvar",
    "file": "lib/readline/signals.c",
    "message": "Uninitialized variables: &old_handler.sa_mask, &old_handler.sa_flags",
    "warning_function_name": "_rl_handle_signal",
    "warning_line": "memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));",
    "warning_context": "    }\n\n  RL_UNSETSTATE(RL_STATE_SIGHANDLER);\n  SIGHANDLER_RETURN;\n}\n\n#if defined (SIGWINCH)\nstatic RETSIGTYPE\nrl_sigwinch_handler (sig)\n     int sig;\n{\n  SigHandler *oh;\n\n#if defined (MUST_REINSTALL_SIGHANDLERS)\n  sighandler_cxt dummy_winch;\n\n  /* We don't want to change old_winch -- it holds the state of SIGWINCH\n     disposition set by the calling application.  We need this state\n     because we call the application's SIGWINCH handler after updating\n     our own idea of the screen size. */\n  rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);\n#endif\n\n  RL_SETSTATE(RL_STATE_SIGHANDLER);\n  _rl_caught_signal = sig;\n\n  /* If another sigwinch handler has been installed, call it. */\n  oh = (SigHandler *)old_winch.sa_handler;\n  if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)\n    (*oh) (sig);\n\n  RL_UNSETSTATE(RL_STATE_SIGHANDLER);\n  SIGHANDLER_RETURN;\n}\n#endif  /* SIGWINCH */\n\n/* Functions to manage signal handling. */\n\n#if !defined (HAVE_POSIX_SIGNALS)\nstatic int\nrl_sigaction (sig, nh, oh)\n     int sig;\n     sighandler_cxt *nh, *oh;\n{\n  oh->sa_handler = signal (sig, nh->sa_handler);\n  return 0;\n}\n#endif /* !HAVE_POSIX_SIGNALS */\n\n/* Set up a readline-specific signal handler, saving the old signal\n   information in OHANDLER.  Return the old signal handler, like\n   signal(). */\nstatic SigHandler *\nrl_set_sighandler (sig, handler, ohandler)\n     int sig;\n     SigHandler *handler;\n     sighandler_cxt *ohandler;\n{\n  sighandler_cxt old_handler;\n#if defined (HAVE_POSIX_SIGNALS)\n  struct sigaction act;\n\n  act.sa_handler = handler;\n#  if defined (SIGWINCH)\n  act.sa_flags = (sig == SIGWINCH) ? SA_RESTART : 0;\n#  else\n  act.sa_flags = 0;\n#  endif /* SIGWINCH */\n  sigemptyset (&act.sa_mask);\n  sigemptyset (&ohandler->sa_mask);\n  sigaction (sig, &act, &old_handler);\n#else\n  old_handler.sa_handler = (SigHandler *)signal (sig, handler);\n#endif /* !HAVE_POSIX_SIGNALS */\n\n  /* XXX -- assume we have memcpy */\n  /* If rl_set_signals is called twice in a row, don't set the old handler to\n     rl_signal_handler, because that would cause infinite recursion. */\n  if (handler != rl_signal_handler || old_handler.sa_handler != rl_signal_handler)\n    memcpy (ohandler, &old_handler, sizeof (sighandler_cxt));\n\n  return (ohandler->sa_handler);\n}\n\n/* Set disposition of SIG to HANDLER, returning old state in OHANDLER.  Don't\n   change disposition if OHANDLER indicates the signal was ignored. */\nstatic void\nrl_maybe_set_sighandler (sig, handler, ohandler)\n     int sig;\n     SigHandler *handler;\n     sighandler_cxt *ohandler;\n{\n  sighandler_cxt dummy;\n  SigHandler *oh;\n\n  sigemptyset (&dummy.sa_mask);\n  dummy.sa_flags = 0;\n  oh = rl_set_sighandler (sig, handler, ohandler);\n  if (oh == (SigHandler *)SIG_IGN)\n    rl_sigaction (sig, ohandler, &dummy);\n}\n"
}