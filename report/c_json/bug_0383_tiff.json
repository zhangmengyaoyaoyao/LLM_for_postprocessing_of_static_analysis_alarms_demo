{
    "Project": "tiff",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "\t\t\tTIFFSetFieldBit(tif, fip->field_bit);",
    "Code_function": "TIFFReadDirectory(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFReadDirectory\";\n\n\tint n;\n\tTIFFDirectory* td;\n\tTIFFDirEntry *dp, *dir = NULL;\n\tuint16 iv;\n\tuint32 v;\n\tconst TIFFFieldInfo* fip;\n\tsize_t fix;\n\tuint16 dircount;\n\tuint16 previous_tag = 0;\n\tint diroutoforderwarning = 0, compressionknown = 0;\n\tint haveunknowntags = 0;\n\n\ttif->tif_diroff = tif->tif_nextdiroff;\n\t/*\n\t * Check whether we have the last offset or bad offset (IFD looping).\n\t */\n\tif (!TIFFCheckDirOffset(tif, tif->tif_nextdiroff))\n\t\treturn 0;\n\t/*\n\t * Cleanup any previous compression state.\n\t */\n\t(*tif->tif_cleanup)(tif);\n\ttif->tif_curdir++;\n\tdircount = TIFFFetchDirectory(tif, tif->tif_nextdiroff,\n\t\t\t\t      &dir, &tif->tif_nextdiroff);\n\tif (!dircount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: Failed to read directory at offset %u\",\n\t\t\t     tif->tif_name, tif->tif_nextdiroff);\n\t\treturn 0;\n\t}\n\t{\n\t\tTIFFDirEntry* ma;\n\t\tuint16 mb;\n\t\tfor (ma=dir, mb=0; mb<dircount; ma++, mb++)\n\t\t{\n\t\t\tTIFFDirEntry* na;\n\t\t\tuint16 nb;\n\t\t\tfor (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)\n\t\t\t{\n\t\t\t\tif (ma->tdir_tag==na->tdir_tag)\n\t\t\t\t\tna->tdir_tag=IGNORE;\n\t\t\t}\n\t\t}\n\t}\n\ttif->tif_flags &= ~TIFF_BEENWRITING;\t/* reset before new dir */\n\t/*\n\t * Setup default value and then make a pass over\n\t * the fields to check type and tag information,\n\t * and to extract info required to size data\n\t * structures.  A second pass is made afterwards\n\t * to read in everthing not taken in the first pass.\n\t */\n\ttd = &tif->tif_dir;\n\t/* free any old stuff and reinit */\n\tTIFFFreeDirectory(tif);\n\tTIFFDefaultDirectory(tif);\n\t/*\n\t * Electronic Arts writes gray-scale TIFF files\n\t * without a PlanarConfiguration directory entry.\n\t * Thus we setup a default value here, even though\n\t * the TIFF spec says there is no default value.\n\t */\n\tTIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);\n\n\t/*\n\t * Sigh, we must make a separate pass through the\n\t * directory for the following reason:\n\t *\n\t * We must process the Compression tag in the first pass\n\t * in order to merge in codec-private tag definitions (otherwise\n\t * we may get complaints about unknown tags).  However, the\n\t * Compression tag may be dependent on the SamplesPerPixel\n\t * tag value because older TIFF specs permited Compression\n\t * to be written as a SamplesPerPixel-count tag entry.\n\t * Thus if we don't first figure out the correct SamplesPerPixel\n\t * tag value then we may end up ignoring the Compression tag\n\t * value because it has an incorrect count value (if the\n\t * true value of SamplesPerPixel is not 1).\n\t *\n\t * It sure would have been nice if Aldus had really thought\n\t * this stuff through carefully.\n\t */\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (tif->tif_flags & TIFF_SWAB) {\n\t\t\tTIFFSwabArrayOfShort(&dp->tdir_tag, 2);\n\t\t\tTIFFSwabArrayOfLong(&dp->tdir_count, 2);\n\t\t}\n\t\tif (dp->tdir_tag == TIFFTAG_SAMPLESPERPIXEL) {\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t}\n\t}\n\t/*\n\t * First real pass over the directory.\n\t */\n\tfix = 0;\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Silicon Beach (at least) writes unordered\n\t\t * directory tags (violating the spec).  Handle\n\t\t * it here, but be obnoxious (maybe they'll fix it?).\n\t\t */\n\t\tif (dp->tdir_tag < previous_tag) {\n\t\t\tif (!diroutoforderwarning) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: invalid TIFF directory; tags are not sorted in ascending order\",\n\t\t\t\t\t    tif->tif_name);\n\t\t\t\tdiroutoforderwarning = 1;\n\t\t\t}\n\t\t}\n\t\tprevious_tag = dp->tdir_tag;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag)\n\t\t\tfix = 0;\t\t\t/* O(n^2) */\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\t\t\t/* Unknown tag ... we'll deal with it below */\n\t\t\thaveunknowntags = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Null out old tags that we ignore.\n\t\t */\n\t\tif (tif->tif_fieldinfo[fix]->field_bit == FIELD_IGNORE) {\n\tignore:\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n\t\t\tfip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tgoto ignore;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Check count if known in advance.\n\t\t */\n\t\tif (fip->field_readcount != TIFF_VARIABLE\n\t\t    && fip->field_readcount != TIFF_VARIABLE2) {\n\t\t\tuint32 expected = (fip->field_readcount == TIFF_SPP) ?\n\t\t\t    (uint32) td->td_samplesperpixel :\n\t\t\t    (uint32) fip->field_readcount;\n\t\t\tif (!CheckDirCount(tif, dp, expected, TRUE))\n\t\t\t\tgoto ignore;\n\t\t}\n\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t\telse\n\t\t\t\t\tcompressionknown = 1;\n\t\t\t\tbreak;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv)\n\t\t\t\t    || !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tTIFFSetFieldBit(tif, fip->field_bit);\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\tcase TIFFTAG_TILELENGTH:\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\tif (!TIFFFetchNormalTag(tif, dp))\n\t\t\t\tgoto bad;\n\t\t\tdp->tdir_tag = IGNORE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we saw any unknown tags, make an extra pass over the directory\n\t * to deal with them.  This must be done separately because the tags\n\t * could have become known when we registered a codec after finding\n\t * the Compression tag.  In a correctly-sorted directory there's\n\t * no problem because Compression will come before any codec-private\n\t * tags, but if the sorting is wrong that might not hold.\n\t */\n\tif (haveunknowntags) {\n\t    fix = 0;\n\t    for (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    dp->tdir_tag < tif->tif_fieldinfo[fix]->field_tag)\n\t\t\tfix = 0;\t\t\t/* O(n^2) */\n\t\twhile (fix < tif->tif_nfields &&\n\t\t    tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\tfix++;\n\t\tif (fix >= tif->tif_nfields ||\n\t\t    tif->tif_fieldinfo[fix]->field_tag != dp->tdir_tag) {\n\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n                        \"%s: unknown field with tag %d (0x%x) encountered\",\n\t\t\t\t\t\t       tif->tif_name,\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\n\t\t\t\t\tif (!_TIFFMergeFieldInfo(tif,\n\t\t\t\t\t\t_TIFFCreateAnonFieldInfo(tif,\n\t\t\t\t\t\tdp->tdir_tag,\n\t\t\t\t\t\t(TIFFDataType) dp->tdir_type),\n\t\t\t\t\t\t1))\n\t\t\t\t\t{\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t\t       module,\n\t\t\t\"Registering anonymous field with tag %d (0x%x) failed\",\n\t\t\t\t\t\t       dp->tdir_tag,\n\t\t\t\t\t\t       dp->tdir_tag);\n\t\t\t\t\tdp->tdir_tag = IGNORE;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\tfix = 0;\n\t\t\twhile (fix < tif->tif_nfields &&\n\t\t\t       tif->tif_fieldinfo[fix]->field_tag < dp->tdir_tag)\n\t\t\t\tfix++;\n\t\t}\n\t\t/*\n\t\t * Check data type.\n\t\t */\n\t\tfip = tif->tif_fieldinfo[fix];\n\t\twhile (dp->tdir_type != (unsigned short) fip->field_type\n\t\t    && fix < tif->tif_nfields) {\n\t\t\tif (fip->field_type == TIFF_ANY)\t/* wildcard */\n\t\t\t\tbreak;\n\t\t\tfip = tif->tif_fieldinfo[++fix];\n\t\t\tif (fix >= tif->tif_nfields ||\n\t\t\t    fip->field_tag != dp->tdir_tag) {\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\"%s: wrong data type %d for \\\"%s\\\"; tag ignored\",\n\t\t\t\t\t    tif->tif_name, dp->tdir_type,\n\t\t\t\t\t    tif->tif_fieldinfo[fix-1]->field_name);\n\t\t\t\tdp->tdir_tag = IGNORE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * XXX: OJPEG hack.\n\t * If a) compression is OJPEG, b) planarconfig tag says it's separate,\n\t * c) strip offsets/bytecounts tag are both present and\n\t * d) both contain exactly one value, then we consistently find\n\t * that the buggy implementation of the buggy compression scheme\n\t * matches contig planarconfig best. So we 'fix-up' the tag here\n\t */\n\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t    (td->td_planarconfig==PLANARCONFIG_SEPARATE)) {\n\t\tdp = TIFFReadDirectoryFind(dir,dircount,TIFFTAG_STRIPOFFSETS);\n\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\tdp = TIFFReadDirectoryFind(dir, dircount,\n\t\t\t\t\t\t   TIFFTAG_STRIPBYTECOUNTS);\n\t\t\tif ((dp!=0) && (dp->tdir_count==1)) {\n\t\t\t\ttd->td_planarconfig=PLANARCONFIG_CONTIG;\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"Planarconfig tag value assumed incorrect, \"\n\t\t\t\t\"assuming data is contig instead of chunky\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Allocate directory structure and setup defaults.\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {\n\t\tMissingRequired(tif, \"ImageLength\");\n\t\tgoto bad;\n\t}\n\t/*\n\t * Setup appropriate structures (by strip or by tile)\n\t */\n\tif (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {\n\t\ttd->td_nstrips = TIFFNumberOfStrips(tif);\n\t\ttd->td_tilewidth = td->td_imagewidth;\n\t\ttd->td_tilelength = td->td_rowsperstrip;\n\t\ttd->td_tiledepth = td->td_imagedepth;\n\t\ttif->tif_flags &= ~TIFF_ISTILED;\n\t} else {\n\t\ttd->td_nstrips = TIFFNumberOfTiles(tif);\n\t\ttif->tif_flags |= TIFF_ISTILED;\n\t}\n\tif (!td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero number of %s\",\n\t\t\t     tif->tif_name, isTiled(tif) ? \"tiles\" : \"strips\");\n\t\tgoto bad;\n\t}\n\ttd->td_stripsperimage = td->td_nstrips;\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\ttd->td_stripsperimage /= td->td_samplesperpixel;\n\tif (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {\n\t\tif ((td->td_compression==COMPRESSION_OJPEG) &&\n\t\t    (isTiled(tif)==0) &&\n\t\t    (td->td_nstrips==1)) {\n\t\t\t/*\n\t\t\t * XXX: OJPEG hack.\n\t\t\t * If a) compression is OJPEG, b) it's not a tiled TIFF,\n\t\t\t * and c) the number of strips is 1,\n\t\t\t * then we tolerate the absence of stripoffsets tag,\n\t\t\t * because, presumably, all required data is in the\n\t\t\t * JpegInterchangeFormat stream.\n\t\t\t */\n\t\t\tTIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);\n\t\t} else {\n\t\t\tMissingRequired(tif,\n\t\t\t\tisTiled(tif) ? \"TileOffsets\" : \"StripOffsets\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\t/*\n\t * Second pass: extract other information.\n\t */\n\tfor (dp = dir, n = dircount; n > 0; n--, dp++) {\n\t\tif (dp->tdir_tag == IGNORE)\n\t\t\tcontinue;\n\t\tswitch (dp->tdir_tag) {\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\tcase TIFFTAG_DATATYPE:\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t/*\n\t\t\t * The 5.0 spec says the Compression tag has\n\t\t\t * one value, while earlier specs say it has\n\t\t\t * one value per sample.  Because of this, we\n\t\t\t * accept the tag if one value is supplied.\n\t\t\t *\n\t\t\t * The MinSampleValue, MaxSampleValue, BitsPerSample\n\t\t\t * DataType and SampleFormat tags are supposed to be\n\t\t\t * written as one value/sample, but some vendors\n\t\t\t * incorrectly write one value only -- so we accept\n\t\t\t * that as well (yech). Other vendors write correct\n\t\t\t * value for NumberOfSamples, but incorrect one for\n\t\t\t * BitsPerSample and friends, and we will read this\n\t\t\t * too.\n\t\t\t */\n\t\t\tif (dp->tdir_count == 1) {\n\t\t\t\tv = TIFFExtractData(tif,\n\t\t\t\t    dp->tdir_type, dp->tdir_offset);\n\t\t\t\tif (!TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t/* XXX: workaround for broken TIFFs */\n\t\t\t} else if (dp->tdir_tag == TIFFTAG_BITSPERSAMPLE\n\t\t\t\t   && dp->tdir_type == TIFF_LONG) {\n\t\t\t\tif (!TIFFFetchPerSampleLongs(tif, dp, &v) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, (uint16)v))\n\t\t\t\t\tgoto bad;\n\t\t\t} else {\n\t\t\t\tif (!TIFFFetchPerSampleShorts(tif, dp, &iv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, iv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\t{\n\t\t\t\tdouble minv = 0.0, maxv = 0.0;\n\t\t\t\tif (!TIFFFetchPerSampleAnys(tif, dp, &minv, &maxv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, minv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\t{\n\t\t\t\tdouble minv = 0.0, maxv = 0.0;\n\t\t\t\tif (!TIFFFetchPerSampleAnys(tif, dp, &minv, &maxv) ||\n\t\t\t\t    !TIFFSetField(tif, dp->tdir_tag, maxv))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripoffset))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\tif (!TIFFFetchStripThing(tif, dp,\n\t\t\t    td->td_nstrips, &td->td_stripbytecount))\n\t\t\t\tgoto bad;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t{\n\t\t\t\tchar* cp;\n\t\t\t\t/*\n\t\t\t\t * TransferFunction can have either 1x or 3x\n\t\t\t\t * data values; Colormap can have only 3x\n\t\t\t\t * items.\n\t\t\t\t */\n\t\t\t\tv = 1L<<td->td_bitspersample;\n\t\t\t\tif (dp->tdir_tag == TIFFTAG_COLORMAP ||\n\t\t\t\t    dp->tdir_count != v) {\n\t\t\t\t\tif (!CheckDirCount(tif, dp, 3 * v, TRUE))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv *= sizeof(uint16);\n\t\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t\t\t\t\t      dp->tdir_count,\n\t\t\t\t\t\t\t      sizeof (uint16),\n\t\t\t\t\t\"to read \\\"TransferFunction\\\" tag\");\n\t\t\t\tif (cp != NULL) {\n\t\t\t\t\tif (TIFFFetchData(tif, dp, cp)) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This deals with there being\n\t\t\t\t\t\t * only one array to apply to\n\t\t\t\t\t\t * all samples.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint32 c = 1L << td->td_bitspersample;\n\t\t\t\t\t\tif (dp->tdir_count == c)\n\t\t\t\t\t\t\tv = 0L;\n\t\t\t\t\t\tTIFFSetField(tif, dp->tdir_tag,\n\t\t\t\t\t\t    cp, cp+v, cp+2*v);\n\t\t\t\t\t}\n\t\t\t\t\t_TIFFfree(cp);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\tcase TIFFTAG_DOTRANGE:\n\t\t\t(void) TIFFFetchShortPair(tif, dp);\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t(void) TIFFFetchRefBlackWhite(tif, dp);\n\t\t\tbreak;\n/* BEGIN REV 4.0 COMPATIBILITY */\n\t\tcase TIFFTAG_OSUBFILETYPE:\n\t\t\tv = 0L;\n\t\t\tswitch (TIFFExtractData(tif, dp->tdir_type,\n\t\t\t    dp->tdir_offset)) {\n\t\t\tcase OFILETYPE_REDUCEDIMAGE:\n\t\t\t\tv = FILETYPE_REDUCEDIMAGE;\n\t\t\t\tbreak;\n\t\t\tcase OFILETYPE_PAGE:\n\t\t\t\tv = FILETYPE_PAGE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v)\n\t\t\t\tTIFFSetField(tif, TIFFTAG_SUBFILETYPE, v);\n\t\t\tbreak;\n/* END REV 4.0 COMPATIBILITY */\n\t\tdefault:\n\t\t\t(void) TIFFFetchNormalTag(tif, dp);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * - If a) compression is OJPEG, and b) photometric tag is missing,\n\t * then we consistently find that photometric should be YCbCr\n\t * - If a) compression is OJPEG, and b) photometric tag says it's RGB,\n\t * then we consistently find that the buggy implementation of the\n\t * buggy compression scheme matches photometric YCbCr instead.\n\t * - If a) compression is OJPEG, and b) bitspersample tag is missing,\n\t * then we consistently find bitspersample should be 8.\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is RGB or YCbCr, then we consistently find\n\t * samplesperpixel should be 3\n\t * - If a) compression is OJPEG, b) samplesperpixel tag is missing,\n\t * and c) photometric is MINISWHITE or MINISBLACK, then we consistently\n\t * find samplesperpixel should be 3\n\t */\n\tif (td->td_compression==COMPRESSION_OJPEG)\n\t{\n\t\tif (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag is missing, assuming data is YCbCr\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse if (td->td_photometric==PHOTOMETRIC_RGB)\n\t\t{\n\t\t\ttd->td_photometric=PHOTOMETRIC_YCBCR;\n\t\t\tTIFFWarningExt(tif->tif_clientdata, \"TIFFReadDirectory\",\n\t\t\t\"Photometric tag value assumed incorrect, \"\n\t\t\t\"assuming data is YCbCr instead of RGB\");\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t{\n\t\t\tTIFFWarningExt(tif->tif_clientdata,\"TIFFReadDirectory\",\n\t\t\"BitsPerSample tag is missing, assuming 8 bits per sample\");\n\t\t\tif (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))\n\t\t\t\tgoto bad;\n\t\t}\n\t\tif (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t{\n\t\t\tif (td->td_photometric==PHOTOMETRIC_RGB)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"assuming correct SamplesPerPixel value is 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (td->td_photometric==PHOTOMETRIC_YCBCR)\n\t\t\t{\n\t\t\t\tTIFFWarningExt(tif->tif_clientdata,\n\t\t\t\t\t       \"TIFFReadDirectory\",\n\t\t\t\t\"SamplesPerPixel tag is missing, \"\n\t\t\t\t\"applying correct SamplesPerPixel value of 3\");\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\telse if ((td->td_photometric==PHOTOMETRIC_MINISWHITE)\n\t\t\t\t || (td->td_photometric==PHOTOMETRIC_MINISBLACK))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * SamplesPerPixel tag is missing, but is not required\n\t\t\t\t * by spec.  Assume correct SamplesPerPixel value of 1.\n\t\t\t\t */\n\t\t\t\tif (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Verify Palette image has a Colormap.\n\t */\n\tif (td->td_photometric == PHOTOMETRIC_PALETTE &&\n\t    !TIFFFieldSet(tif, FIELD_COLORMAP)) {\n\t\tif ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_RGB;\n\t\telse if (tif->tif_dir.td_bitspersample>=8)\n\t\t\ttif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;\n\t\telse {\n\t\t\tMissingRequired(tif, \"Colormap\");\n\t\t\tgoto bad;\n\t\t}\n\t}\n\t/*\n\t * OJPEG hack:\n\t * We do no further messing with strip/tile offsets/bytecounts in OJPEG\n\t * TIFFs\n\t */\n\tif (td->td_compression!=COMPRESSION_OJPEG)\n\t{\n\t\t/*\n\t\t * Attempt to deal with a missing StripByteCounts tag.\n\t\t */\n\t\tif (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {\n\t\t\t/*\n\t\t\t * Some manufacturers violate the spec by not giving\n\t\t\t * the size of the strips.  In this case, assume there\n\t\t\t * is one uncompressed strip of data.\n\t\t\t */\n\t\t\tif ((td->td_planarconfig == PLANARCONFIG_CONTIG &&\n\t\t\t    td->td_nstrips > 1) ||\n\t\t\t    (td->td_planarconfig == PLANARCONFIG_SEPARATE &&\n\t\t\t     td->td_nstrips != td->td_samplesperpixel)) {\n\t\t\t    MissingRequired(tif, \"StripByteCounts\");\n\t\t\t    goto bad;\n\t\t\t}\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\"%s: TIFF directory is missing required \"\n\t\t\t\t\"\\\"%s\\\" field, calculating from imagelength\",\n\t\t\t\ttif->tif_name,\n\t\t\t\t_TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t/*\n\t\t * Assume we have wrong StripByteCount value (in case\n\t\t * of single strip) in following cases:\n\t\t *   - it is equal to zero along with StripOffset;\n\t\t *   - it is larger than file itself (in case of uncompressed\n\t\t *     image);\n\t\t *   - it is smaller than the size of the bytes per row\n\t\t *     multiplied on the number of rows.  The last case should\n\t\t *     not be checked in the case of writing new image,\n\t\t *     because we may do not know the exact strip size\n\t\t *     until the whole image will be written and directory\n\t\t *     dumped out.\n\t\t */\n\t\t#define\tBYTECOUNTLOOKSBAD \\\n\t\t    ( (td->td_stripbytecount[0] == 0 && td->td_stripoffset[0] != 0) || \\\n\t\t      (td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] > TIFFGetFileSize(tif) - td->td_stripoffset[0]) || \\\n\t\t      (tif->tif_mode == O_RDONLY && \\\n\t\t       td->td_compression == COMPRESSION_NONE && \\\n\t\t       td->td_stripbytecount[0] < TIFFScanlineSize(tif) * td->td_imagelength) )\n\n\t\t} else if (td->td_nstrips == 1\n\t\t\t   && td->td_stripoffset[0] != 0\n\t\t\t   && BYTECOUNTLOOKSBAD) {\n\t\t\t/*\n\t\t\t * XXX: Plexus (and others) sometimes give a value of\n\t\t\t * zero for a tag when they don't know what the\n\t\t\t * correct value is!  Try and handle the simple case\n\t\t\t * of estimating the size of a one strip image.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Bogus \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif(EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t} else if (td->td_planarconfig == PLANARCONFIG_CONTIG\n\t\t\t   && td->td_nstrips > 2\n\t\t\t   && td->td_compression == COMPRESSION_NONE\n\t\t\t   && td->td_stripbytecount[0] != td->td_stripbytecount[1]\n                           && td->td_stripbytecount[0] != 0\n                           && td->td_stripbytecount[1] != 0 ) {\n\t\t\t/*\n\t\t\t * XXX: Some vendors fill StripByteCount array with\n                         * absolutely wrong values (it can be equal to\n                         * StripOffset array, for example). Catch this case\n                         * here.\n\t\t\t */\n\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\"%s: Wrong \\\"%s\\\" field, ignoring and calculating from imagelength\",\n\t\t\t\t    tif->tif_name,\n\t\t\t\t    _TIFFFieldWithTag(tif,TIFFTAG_STRIPBYTECOUNTS)->field_name);\n\t\t\tif (EstimateStripByteCounts(tif, dir, dircount) < 0)\n\t\t\t    goto bad;\n\t\t}\n\t}\n\tif (dir) {\n\t\t_TIFFfree((char *)dir);\n\t\tdir = NULL;\n\t}\n\tif (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))\n\t\ttd->td_maxsamplevalue = (uint16)((1L<<td->td_bitspersample)-1);\n\t/*\n\t * Setup default compression scheme.\n\t */\n\n\t/*\n\t * XXX: We can optimize checking for the strip bounds using the sorted\n\t * bytecounts array. See also comments for TIFFAppendToStrip()\n\t * function in tif_write.c.\n\t */\n\tif (td->td_nstrips > 1) {\n\t\ttstrip_t strip;\n\n\t\ttd->td_stripbytecountsorted = 1;\n\t\tfor (strip = 1; strip < td->td_nstrips; strip++) {\n\t\t\tif (td->td_stripoffset[strip - 1] >\n\t\t\t    td->td_stripoffset[strip]) {\n\t\t\t\ttd->td_stripbytecountsorted = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!TIFFFieldSet(tif, FIELD_COMPRESSION))\n\t\tTIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE);\n\t/*\n\t * Some manufacturers make life difficult by writing\n\t * large amounts of uncompressed data as a single strip.\n\t * This is contrary to the recommendations of the spec.\n\t * The following makes an attempt at breaking such images\n\t * into strips closer to the recommended 8k bytes.  A\n\t * side effect, however, is that the RowsPerStrip tag\n\t * value may be changed.\n\t */\n\tif (td->td_nstrips == 1 && td->td_compression == COMPRESSION_NONE &&\n\t    (tif->tif_flags & (TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP)\n\t\tChopUpSingleUncompressedStrip(tif);\n\n\t/*\n\t * Reinitialize i/o since we are starting on a new directory.\n\t */\n\ttif->tif_row = (uint32) -1;\n\ttif->tif_curstrip = (tstrip_t) -1;\n\ttif->tif_col = (uint32) -1;\n\ttif->tif_curtile = (ttile_t) -1;\n\ttif->tif_tilesize = (tsize_t) -1;\n\n\ttif->tif_scanlinesize = TIFFScanlineSize(tif);\n\tif (!tif->tif_scanlinesize) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%s: cannot handle zero scanline size\",\n\t\t\t     tif->tif_name);\n\t\treturn (0);\n\t}\n\n\tif (isTiled(tif)) {\n\t\ttif->tif_tilesize = TIFFTileSize(tif);\n\t\tif (!tif->tif_tilesize) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero tile size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t} else {\n\t\tif (!TIFFStripSize(tif)) {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t     \"%s: cannot handle zero strip size\",\n\t\t\t\t     tif->tif_name);\n\t\t\treturn (0);\n\t\t}\n\t}\n\treturn (1);\nbad:\n\tif (dir)\n\t\t_TIFFfree(dir);\n\treturn (0);\n}"
}