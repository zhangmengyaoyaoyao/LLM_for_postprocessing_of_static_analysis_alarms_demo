{
    "Project": "sed",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "lib/tempname.c",
    "message": "Offset: [-61, 61] Size: 63.",
    "warning_function_name": "__gen_tempname",
    "warning_line": "XXXXXX[0] = letters[v % 62];",
    "warning_context": "int\n__gen_tempname (char *tmpl, int kind)\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n  struct_stat64 st;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 || strcmp (&tmpl[len - 6], \"XXXXXX\"))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      switch (kind)\n\t{\n\tcase __GT_FILE:\n\t  fd = small_open (tmpl, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n\t  break;\n\n\tcase __GT_BIGFILE:\n\t  fd = large_open (tmpl, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n\t  break;\n\n\tcase __GT_DIR:\n\t  fd = __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n\t  break;\n\n\tcase __GT_NOCREATE:\n\t  /* This case is backward from the other three.  __gen_tempname\n\t     succeeds if __xstat fails because the name does not exist.\n\t     Note the continue to bypass the common logic at the bottom\n\t     of the loop.  */\n\t  if (__lxstat64 (_STAT_VER, tmpl, &st) < 0)\n\t    {\n\t      if (errno == ENOENT)\n\t\t{\n\t\t  __set_errno (save_errno);\n\t\t  return 0;\n\t\t}\n\t      else\n\t\t/* Give up now. */\n\t\treturn -1;\n\t    }\n\t  continue;\n\n\tdefault:\n\t  assert (! \"invalid KIND in __gen_tempname\");\n"
}