{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L2",
    "Code_line": "\t      ADD_STRING (mb);",
    "Code_function": "history_expand (hstring, output)\n     char *hstring;\n     char **output;\n{\n  register int j;\n  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, squote, flag;\n  char *string;\n\n  /* The output string, and its length. */\n  int result_len;\n  char *result;\n\n#if defined (HANDLE_MULTIBYTE)\n  char mb[MB_LEN_MAX];\n  mbstate_t ps;\n#endif\n\n  /* Used when adding the string. */\n  char *temp;\n\n  if (output == 0)\n    return 0;\n\n  /* Setting the history expansion character to 0 inhibits all\n     history expansion. */\n  if (history_expansion_char == 0)\n    {\n      *output = savestring (hstring);\n      return (0);\n    }\n\n  /* Prepare the buffer for printing error messages. */\n  result = (char *)xmalloc (result_len = 256);\n  result[0] = '\\0';\n\n  only_printing = modified = 0;\n  l = strlen (hstring);\n\n  /* Grovel the string.  Only backslash and single quotes can quote the\n     history escape character.  We also handle arg specifiers. */\n\n  /* Before we grovel forever, see if the history_expansion_char appears\n     anywhere within the text. */\n\n  /* The quick substitution character is a history expansion all right.  That\n     is to say, \"^this^that^\" is equivalent to \"!!:s^this^that^\", and in fact,\n     that is the substitution that we do. */\n  if (hstring[0] == history_subst_char)\n    {\n      string = (char *)xmalloc (l + 5);\n\n      string[0] = string[1] = history_expansion_char;\n      string[2] = ':';\n      string[3] = 's';\n      strcpy (string + 4, hstring);\n      l += 4;\n    }\n  else\n    {\n#if defined (HANDLE_MULTIBYTE)\n      memset (&ps, 0, sizeof (mbstate_t));\n#endif\n\n      string = hstring;\n      /* If not quick substitution, still maybe have to do expansion. */\n\n      /* `!' followed by one of the characters in history_no_expand_chars\n\t is NOT an expansion. */\n      for (i = dquote = squote = 0; string[i]; i++)\n\t{\n#if defined (HANDLE_MULTIBYTE)\n\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t    {\n\t      int v;\n\t      v = _rl_get_char_len (string + i, &ps);\n\t      if (v > 1)\n\t\t{\n\t\t  i += v - 1;\n\t\t  continue;\n\t\t}\n\t    }\n#endif /* HANDLE_MULTIBYTE */\n\n\t  cc = string[i + 1];\n\t  /* The history_comment_char, if set, appearing at the beginning\n\t     of a word signifies that the rest of the line should not have\n\t     history expansion performed on it.\n\t     Skip the rest of the line and break out of the loop. */\n\t  if (history_comment_char && string[i] == history_comment_char &&\n\t      (i == 0 || member (string[i - 1], history_word_delimiters)))\n\t    {\n\t      while (string[i])\n\t\ti++;\n\t      break;\n\t    }\n\t  else if (string[i] == history_expansion_char)\n\t    {\n\t      if (cc == 0 || member (cc, history_no_expand_chars))\n\t\tcontinue;\n\t      /* DQUOTE won't be set unless history_quotes_inhibit_expansion\n\t\t is set.  The idea here is to treat double-quoted strings the\n\t\t same as the word outside double quotes; in effect making the\n\t\t double quote part of history_no_expand_chars when DQUOTE is\n\t\t set. */\n\t      else if (dquote && cc == '\"')\n\t\tcontinue;\n\t      /* If the calling application has set\n\t\t history_inhibit_expansion_function to a function that checks\n\t\t for special cases that should not be history expanded,\n\t\t call the function and skip the expansion if it returns a\n\t\t non-zero value. */\n\t      else if (history_inhibit_expansion_function &&\n\t\t\t(*history_inhibit_expansion_function) (string, i))\n\t\tcontinue;\n\t      else\n\t\tbreak;\n\t    }\n\t  /* Shell-like quoting: allow backslashes to quote double quotes\n\t     inside a double-quoted string. */\n\t  else if (dquote && string[i] == '\\\\' && cc == '\"')\n\t    i++;\n\t  /* More shell-like quoting:  if we're paying attention to single\n\t     quotes and letting them quote the history expansion character,\n\t     then we need to pay attention to double quotes, because single\n\t     quotes are not special inside double-quoted strings. */\n\t  else if (history_quotes_inhibit_expansion && string[i] == '\"')\n\t    {\n\t      dquote = 1 - dquote;\n\t    }\n\t  else if (dquote == 0 && history_quotes_inhibit_expansion && string[i] == '\\'')\n\t    {\n\t      /* If this is bash, single quotes inhibit history expansion. */\n\t      flag = (i > 0 && string[i - 1] == '$');\n\t      i++;\n\t      hist_string_extract_single_quoted (string, &i, flag);\n\t    }\n\t  else if (history_quotes_inhibit_expansion && string[i] == '\\\\')\n\t    {\n\t      /* If this is bash, allow backslashes to quote single\n\t\t quotes and the history expansion character. */\n\t      if (cc == '\\'' || cc == history_expansion_char)\n\t\ti++;\n\t    }\n\n\t}\n\n      if (string[i] != history_expansion_char)\n\t{\n\t  xfree (result);\n\t  *output = savestring (string);\n\t  return (0);\n\t}\n    }\n\n  /* Extract and perform the substitution. */\n  for (passc = dquote = squote = i = j = 0; i < l; i++)\n    {\n      int qc, tchar = string[i];\n\n      if (passc)\n\t{\n\t  passc = 0;\n\t  ADD_CHAR (tchar);\n\t  continue;\n\t}\n\n#if defined (HANDLE_MULTIBYTE)\n      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n\t{\n\t  int k, c;\n\n\t  c = tchar;\n\t  memset (mb, 0, sizeof (mb));\n\t  for (k = 0; k < MB_LEN_MAX; k++)\n\t    {\n\t      mb[k] = (char)c;\n\t      memset (&ps, 0, sizeof (mbstate_t));\n\t      if (_rl_get_char_len (mb, &ps) == -2)\n\t\tc = string[++i];\n\t      else\n\t\tbreak;\n\t    }\n\t  if (strlen (mb) > 1)\n\t    {\n\t      ADD_STRING (mb);\n\t      continue;\n\t    }\n\t}\n#endif /* HANDLE_MULTIBYTE */\n\n      if (tchar == history_expansion_char)\n\ttchar = -3;\n      else if (tchar == history_comment_char)\n\ttchar = -2;\n\n      switch (tchar)\n\t{\n\tdefault:\n\t  ADD_CHAR (string[i]);\n\t  break;\n\n\tcase '\\\\':\n\t  passc++;\n\t  ADD_CHAR (tchar);\n\t  break;\n\n\tcase '\"':\n\t  dquote = 1 - dquote;\n\t  ADD_CHAR (tchar);\n\t  break;\n\n\tcase '\\'':\n\t  {\n\t    /* If history_quotes_inhibit_expansion is set, single quotes\n\t       inhibit history expansion, otherwise they are treated like\n\t       double quotes. */\n\t    if (squote)\n\t      {\n\t        squote = 0;\n\t        ADD_CHAR (tchar);\n\t      }\n\t    else if (dquote == 0 && history_quotes_inhibit_expansion)\n\t      {\n\t\tint quote, slen;\n\n\t\tflag = (i > 0 && string[i - 1] == '$');\n\t\tquote = i++;\n\t\thist_string_extract_single_quoted (string, &i, flag);\n\n\t\tslen = i - quote + 2;\n\t\ttemp = (char *)xmalloc (slen);\n\t\tstrncpy (temp, string + quote, slen);\n\t\ttemp[slen - 1] = '\\0';\n\t\tADD_STRING (temp);\n\t\txfree (temp);\n\t      }\n\t    else if (dquote == 0 && squote == 0 && history_quotes_inhibit_expansion == 0)\n\t      {\n\t        squote = 1;\n\t        ADD_CHAR (string[i]);\n\t      }\n\t    else\n\t      ADD_CHAR (string[i]);\n\t    break;\n\t  }\n\n\tcase -2:\t\t/* history_comment_char */\n\t  if (i == 0 || member (string[i - 1], history_word_delimiters))\n\t    {\n\t      temp = (char *)xmalloc (l - i + 1);\n\t      strcpy (temp, string + i);\n\t      ADD_STRING (temp);\n\t      xfree (temp);\n\t      i = l;\n\t    }\n\t  else\n\t    ADD_CHAR (string[i]);\n\t  break;\n\n\tcase -3:\t\t/* history_expansion_char */\n\t  cc = string[i + 1];\n\n\t  /* If the history_expansion_char is followed by one of the\n\t     characters in history_no_expand_chars, then it is not a\n\t     candidate for expansion of any kind. */\n\t  if (cc == 0 || member (cc, history_no_expand_chars) ||\n\t\t\t (dquote && cc == '\"') ||\n\t  \t\t (history_inhibit_expansion_function && (*history_inhibit_expansion_function) (string, i)))\n\t    {\n\t      ADD_CHAR (string[i]);\n\t      break;\n\t    }\n\n#if defined (NO_BANG_HASH_MODIFIERS)\n\t  /* There is something that is listed as a `word specifier' in csh\n\t     documentation which means `the expanded text to this point'.\n\t     That is not a word specifier, it is an event specifier.  If we\n\t     don't want to allow modifiers with `!#', just stick the current\n\t     output line in again. */\n\t  if (cc == '#')\n\t    {\n\t      if (result)\n\t\t{\n\t\t  temp = (char *)xmalloc (1 + strlen (result));\n\t\t  strcpy (temp, result);\n\t\t  ADD_STRING (temp);\n\t\t  xfree (temp);\n\t\t}\n\t      i++;\n\t      break;\n\t    }\n#endif\n\t  qc = squote ? '\\'' : (dquote ? '\"' : 0);\n\t  r = history_expand_internal (string, i, qc, &eindex, &temp, result);\n\t  if (r < 0)\n\t    {\n\t      *output = temp;\n\t      xfree (result);\n\t      if (string != hstring)\n\t\txfree (string);\n\t      return -1;\n\t    }\n\t  else\n\t    {\n\t      if (temp)\n\t\t{\n\t\t  modified++;\n\t\t  if (*temp)\n\t\t    ADD_STRING (temp);\n\t\t  xfree (temp);\n\t\t}\n\t      only_printing = r == 1;\n\t      i = eindex;\n\t    }\n\t  break;\n\t}\n    }\n\n  *output = result;\n  if (string != hstring)\n    xfree (string);\n\n  if (only_printing)\n    {\n#if 0\n      add_history (result);\n#endif\n      return (2);\n    }\n\n  return (modified != 0);\n}"
}