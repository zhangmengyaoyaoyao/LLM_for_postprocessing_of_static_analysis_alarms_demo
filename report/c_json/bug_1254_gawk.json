{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "builtin.c",
    "message": "The value read from buflen was never initialized.",
    "warning_function_name": "do_strftime",
    "warning_line": "ret = make_string(bufp, buflen);",
    "warning_context": "\t\t\tt3 = POP_SCALAR();\n\t\t\tif ((t3->flags & (NUMCUR|NUMBER)) != 0)\n\t\t\t\tdo_gmt = (t3->numbr != 0);\n\t\t\telse\n\t\t\t\tdo_gmt = (t3->stlen > 0);\n\t\t\tDEREF(t3);\n\t\t}\n\n\t\tif (nargs >= 2) {\n\t\t\tt2 = POP_SCALAR();\n\t\t\tif (do_lint && (t2->flags & (NUMCUR|NUMBER)) == 0)\n\t\t\t\tlintwarn(_(\"strftime: received non-numeric second argument\"));\n\t\t\t(void) force_number(t2);\n\t\t\tclock_val = get_number_d(t2);\n\t\t\tfclock = (time_t) clock_val;\n\t\t\t/*\n\t\t\t * Protect against negative value being assigned\n\t\t\t * to unsigned time_t.\n\t\t\t */\n\t\t\tif (clock_val < 0 && fclock > 0) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"strftime: second argument less than 0 or too big for time_t\"));\n\t\t\t\treturn make_string(\"\", 0);\n\t\t\t}\n\n\t\t\t/* And check that the value is in range */\n\t\t\tif (clock_val < time_t_min || clock_val > time_t_max) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"strftime: second argument out of range for time_t\"));\n\t\t\t\treturn make_string(\"\", 0);\n\t\t\t}\n\n\t\t\tDEREF(t2);\n\t\t}\n\n\t\ttmp = POP_SCALAR();\n\t\tif (do_lint && (tmp->flags & (STRING|STRCUR)) == 0)\n\t\t\tlintwarn(_(\"strftime: received non-string first argument\"));\n\t\n\t\tt1 = force_string(tmp);\n\t\tformat = t1->stptr;\n\t\tformatlen = t1->stlen;\n\t\tif (formatlen == 0) {\n\t\t\tif (do_lint)\n\t\t\t\tlintwarn(_(\"strftime: received empty format string\"));\n\t\t\tDEREF(t1);\n\t\t\treturn make_string(\"\", 0);\n\t\t}\n\t}\n\n\tif (do_gmt)\n\t\ttm = gmtime(& fclock);\n\telse\n\t\ttm = localtime(& fclock);\n\n\tif (tm == NULL)\n\t\treturn make_string(\"\", 0);\n\n\tbufp = buf;\n\tbufsize = sizeof(buf);\n\tfor (;;) {\n\t\t*bufp = '\\0';\n\t\tbuflen = strftime(bufp, bufsize, format, tm);\n\t\t/*\n\t\t * buflen can be zero EITHER because there's not enough\n\t\t * room in the string, or because the control command\n\t\t * goes to the empty string. Make a reasonable guess that\n\t\t * if the buffer is 1024 times bigger than the length of the\n\t\t * format string, it's not failing for lack of room.\n\t\t * Thanks to Paul Eggert for pointing out this issue.\n\t\t */\n\t\tif (buflen > 0 || bufsize >= 1024 * formatlen)\n\t\t\tbreak;\n\t\tbufsize *= 2;\n\t\tif (bufp == buf)\n\t\t\temalloc(bufp, char *, bufsize, \"do_strftime\");\n\t\telse\n\t\t\terealloc(bufp, char *, bufsize, \"do_strftime\");\n\t}\n\tret = make_string(bufp, buflen);\n\tif (bufp != buf)\n\t\tefree(bufp);\n\tif (t1)\n\t\tDEREF(t1);\n\treturn ret;\n}\n\n/* do_systime --- get the time of day */\n\nNODE *\ndo_systime(int nargs ATTRIBUTE_UNUSED)\n{\n\ttime_t lclock;\n\n\t(void) time(& lclock);\n\treturn make_number((AWKNUM) lclock);\n}\n\n/* do_mktime --- turn a time string into a timestamp */\n\nNODE *\n"
}