{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t      if (regpos[reg].offset == i - 1)",
    "Code_function": "decode_tic6x_unwind_bytecode (struct arm_unw_aux_info *aux,\n\t\t\t    unsigned int word, unsigned int remaining,\n\t\t\t    unsigned int more_words,\n\t\t\t    bfd_vma data_offset, Elf_Internal_Shdr *data_sec,\n\t\t\t    struct arm_section *data_arm_sec)\n{\n  struct absaddr addr;\n\n  /* Decode the unwinding instructions.  */\n  while (1)\n    {\n      unsigned int op, op2;\n\n      ADVANCE;\n      if (remaining == 0)\n\tbreak;\n      remaining--;\n      op = word >> 24;\n      word <<= 8;\n\n      printf (\"  0x%02x \", op);\n\n      if ((op & 0xc0) == 0x00)\n\t{\n\t  int offset = ((op & 0x3f) << 3) + 8;\n\t  printf (\"     sp = sp + %d\", offset);\n\t}\n      else if ((op & 0xc0) == 0x80)\n\t{\n\t  GET_OP (op2);\n\t  if (op == 0x80 && op2 == 0)\n\t    printf (_(\"Refuse to unwind\"));\n\t  else\n\t    {\n\t      unsigned int mask = ((op & 0x1f) << 8) | op2;\n\t      if (op & 0x20)\n\t\tprintf (\"pop compact {\");\n\t      else\n\t\tprintf (\"pop {\");\n\n\t      decode_tic6x_unwind_regmask (mask);\n\t      printf(\"}\");\n\t    }\n\t}\n      else if ((op & 0xf0) == 0xc0)\n\t{\n\t  unsigned int reg;\n\t  unsigned int nregs;\n\t  unsigned int i;\n\t  const char *name;\n\t  struct\n\t  {\n\t      unsigned int offset;\n\t      unsigned int reg;\n\t  } regpos[16];\n\n\t  /* Scan entire instruction first so that GET_OP output is not\n\t     interleaved with disassembly.  */\n\t  nregs = 0;\n\t  for (i = 0; nregs < (op & 0xf); i++)\n\t    {\n\t      GET_OP (op2);\n\t      reg = op2 >> 4;\n\t      if (reg != 0xf)\n\t\t{\n\t\t  regpos[nregs].offset = i * 2;\n\t\t  regpos[nregs].reg = reg;\n\t\t  nregs++;\n\t\t}\n\n\t      reg = op2 & 0xf;\n\t      if (reg != 0xf)\n\t\t{\n\t\t  regpos[nregs].offset = i * 2 + 1;\n\t\t  regpos[nregs].reg = reg;\n\t\t  nregs++;\n\t\t}\n\t    }\n\n\t  printf (_(\"pop frame {\"));\n\t  reg = nregs - 1;\n\t  for (i = i * 2; i > 0; i--)\n\t    {\n\t      if (regpos[reg].offset == i - 1)\n\t\t{\n\t\t  name = tic6x_unwind_regnames[regpos[reg].reg];\n\t\t  if (reg > 0)\n\t\t    reg--;\n\t\t}\n\t      else\n\t\tname = _(\"[pad]\");\n\n\t      fputs (name, stdout);\n\t      if (i > 1)\n\t\tprintf (\", \");\n\t    }\n\n\t  printf (\"}\");\n\t}\n      else if (op == 0xd0)\n\tprintf (\"     MOV FP, SP\");\n      else if (op == 0xd1)\n\tprintf (\"     __c6xabi_pop_rts\");\n      else if (op == 0xd2)\n\t{\n\t  unsigned char buf[9];\n\t  unsigned int i, len;\n\t  unsigned long offset;\n\n\t  for (i = 0; i < sizeof (buf); i++)\n\t    {\n\t      GET_OP (buf[i]);\n\t      if ((buf[i] & 0x80) == 0)\n\t\tbreak;\n\t    }\n\t  /* PR 17531: file: id:000001,src:001906+004739,op:splice,rep:2.  */\n\t  if (i == sizeof (buf))\n\t    {\n\t      printf (\"<corrupt sp adjust>\\n\");\n\t      warn (_(\"Corrupt stack pointer adjustment detected\\n\"));\n\t      return;\n\t    }\n\n\t  offset = read_uleb128 (buf, &len, buf + i + 1);\n\t  assert (len == i + 1);\n\t  offset = offset * 8 + 0x408;\n\t  printf (_(\"sp = sp + %ld\"), offset);\n\t}\n      else if ((op & 0xf0) == 0xe0)\n\t{\n\t  if ((op & 0x0f) == 7)\n\t    printf (\"     RETURN\");\n\t  else\n\t    printf (\"     MV %s, B3\", tic6x_unwind_regnames[op & 0x0f]);\n\t}\n      else\n\t{\n\t  printf (_(\"     [unsupported opcode]\"));\n\t}\n      putchar ('\\n');\n    }\n}"
}