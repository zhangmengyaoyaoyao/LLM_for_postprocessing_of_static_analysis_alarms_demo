{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t  ADVANCE_CHAR (amble, alen, j);",
    "Code_function": "brace_expand (text)\n     char *text;\n{\n  register int start;\n  size_t tlen;\n  char *preamble, *postamble, *amble;\n  size_t alen;\n  char **tack, **result;\n  int i, j, c, c1;\n\n  DECLARE_MBSTATE;\n\n  /* Find the text of the preamble. */\n  tlen = strlen (text);\n  i = 0;\n#if defined (CSH_BRACE_COMPAT)\n  c = brace_gobbler (text, tlen, &i, '{');\t/* } */\n#else\n  /* Make sure that when we exit this loop, c == 0 or text[i] begins a\n     valid brace expansion sequence. */\n  do\n    {\n      c = brace_gobbler (text, tlen, &i, '{');\t/* } */\n      c1 = c;\n      /* Verify that c begins a valid brace expansion word.  If it doesn't, we\n\t go on.  Loop stops when there are no more open braces in the word. */\n      if (c)\n\t{\n\t  start = j = i + 1;\t/* { */\n\t  c = brace_gobbler (text, tlen, &j, '}');\n\t  if (c == 0)\t\t/* it's not */\n\t    {\n\t      i++;\n\t      c = c1;\n\t      continue;\n\t    }\n\t  else\t\t\t/* it is */\n\t    {\n\t      c = c1;\n\t      break;\n\t    }\n\t}\n      else\n\tbreak;\n    }\n  while (c);\n#endif /* !CSH_BRACE_COMPAT */\n\n  preamble = (char *)xmalloc (i + 1);\n  if (i > 0)\n    strncpy (preamble, text, i);\n  preamble[i] = '\\0';\n\n  result = (char **)xmalloc (2 * sizeof (char *));\n  result[0] = preamble;\n  result[1] = (char *)NULL;\n\n  /* Special case.  If we never found an exciting character, then\n     the preamble is all of the text, so just return that. */\n  if (c != '{')\n    return (result);\n\n  /* Find the amble.  This is the stuff inside this set of braces. */\n  start = ++i;\n  c = brace_gobbler (text, tlen, &i, '}');\n\n  /* What if there isn't a matching close brace? */\n  if (c == 0)\n    {\n#if defined (NOTDEF)\n      /* Well, if we found an unquoted BRACE_ARG_SEPARATOR between START\n\t and I, then this should be an error.  Otherwise, it isn't. */\n      j = start;\n      while (j < i)\n\t{\n\t  if (text[j] == '\\\\')\n\t    {\n\t      j++;\n\t      ADVANCE_CHAR (text, tlen, j);\n\t      continue;\n\t    }\n\n\t  if (text[j] == brace_arg_separator)\n\t    {\t/* { */\n\t      strvec_dispose (result);\n\t      last_command_exit_value = 1;\n\t      report_error (\"no closing `%c' in %s\", '}', text);\n\t      throw_to_top_level ();\n\t    }\n\t  ADVANCE_CHAR (text, tlen, j);\n\t}\n#endif\n      free (preamble);\t\t/* Same as result[0]; see initialization. */\n      result[0] = savestring (text);\n      return (result);\n    }\n\n#if defined (SHELL)\n  amble = substring (text, start, i);\n  alen = i - start;\n#else\n  amble = (char *)xmalloc (1 + (i - start));\n  strncpy (amble, &text[start], (i - start));\n  alen = i - start;\n  amble[alen] = '\\0';\n#endif\n\n#if defined (SHELL)\n  INITIALIZE_MBSTATE;\n\n  /* If the amble does not contain an unquoted BRACE_ARG_SEPARATOR, then\n     just return without doing any expansion.  */\n  j = 0;\n  while (amble[j])\n    {\n      if (amble[j] == '\\\\')\n\t{\n\t  j++;\n\t  ADVANCE_CHAR (amble, alen, j);\n\t  continue;\n\t}\n\n      if (amble[j] == brace_arg_separator)\n\tbreak;\n\n      ADVANCE_CHAR (amble, alen, j);\n    }\n\n  if (amble[j] == 0)\n    {\n      tack = expand_seqterm (amble, alen);\n      if (tack)\n\tgoto add_tack;\n      else if (text[i + 1])\n\t{\n\t  /* If the sequence expansion fails (e.g., because the integers\n\t     overflow), but there is more in the string, try and process\n\t     the rest of the string, which may contain additional brace\n\t     expansions.  Treat the unexpanded sequence term as a simple\n\t     string (including the braces). */\n\t  tack = strvec_create (2);\n\t  tack[0] = savestring (text+start-1);\n\t  tack[0][i-start+2] = '\\0';\n\t  tack[1] = (char *)0;\n\t  goto add_tack;\n\t}\n      else\n\t{\n\t  free (amble);\n\t  free (preamble);\n\t  result[0] = savestring (text);\n\t  return (result);\n\t}\n    }\n#endif /* SHELL */\n\n  tack = expand_amble (amble, alen, 0);\nadd_tack:\n  result = array_concat (result, tack);\n  free (amble);\n  if (tack != result)\n    strvec_dispose (tack);\n\n  postamble = text + i + 1;\n\n  if (postamble && *postamble)\n    {\n      tack = brace_expand (postamble);\n      result = array_concat (result, tack);\n      if (tack != result)\n\tstrvec_dispose (tack);\n    }\n\n  return (result);\n}"
}