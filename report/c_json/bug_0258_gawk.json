{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: 33 (⇐ 1 + 32) Size: [0, +oo] by call to `bcalloc`.",
    "Code_line": "\t\t\t\texpr = list_create(instruction(Op_push_i));",
    "Code_function": "snode(INSTRUCTION *subn, INSTRUCTION *r)\n{\n\tINSTRUCTION *arg;\n\tINSTRUCTION *ip;\n\tNODE *n;\n\tint nexp = 0;\n\tint args_allowed;\n\tint idx = r->builtin_idx;\n\n\tif (subn != NULL) {\n\t\tINSTRUCTION *tp;\n\t\tfor (tp = subn->nexti; tp; tp = tp->nexti) {\n\t\t\ttp = tp->lasti;\n\t\t\tnexp++;\n\t\t}\n\t\tassert(nexp > 0);\n\t}\n\n\t/* check against how many args. are allowed for this builtin */\n\targs_allowed = tokentab[idx].flags & ARGS;\n\tif (args_allowed && (args_allowed & A(nexp)) == 0) {\n\t\tyyerror(_(\"%d is invalid as number of arguments for %s\"),\n\t\t\t\tnexp, tokentab[idx].operator);\n\t\treturn NULL;\n\t}\n\n\t/* special processing for sub, gsub and gensub */\n\n\tif (tokentab[idx].value == Op_sub_builtin) {\n\t\tconst char *operator = tokentab[idx].operator;\n\n\t\tr->sub_flags = 0;\n\n\t\targ = subn->nexti;\t\t/* first arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (strcmp(operator, \"gensub\") != 0) {\n\t\t\t/* sub and gsub */\n\n\t\t\tif (strcmp(operator, \"gsub\") == 0)\n\t\t\t\tr->sub_flags |= GSUB;\n\n\t\t\targ = arg->lasti->nexti;\t/* 2nd arg list */\n\t\t\tif (nexp == 2) {\n\t\t\t\tINSTRUCTION *expr;\n\n\t\t\t\texpr = list_create(instruction(Op_push_i));\n\t\t\t\texpr->nexti->memory = make_number(0.0);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(expr, instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push_i) {\n\t\t\t\tif (do_lint)\n\t\t\t\t\tlintwarn(_(\"%s: string literal as last arg of substitute has no effect\"),\n\t\t\t\t\t\toperator);\n\t\t\t\tr->sub_flags |=\tLITERAL;\n\t\t\t} else {\n\t\t\t\tif (make_assignable(ip) == NULL)\n\t\t\t\t\tyyerror(_(\"%s third parameter is not a changeable object\"),\n\t\t\t\t\t\toperator);\n\t\t\t\telse\n\t\t\t\t\tip->do_reference = true;\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\tip = subn->lasti;\n\n\t\t\t(void) list_append(subn, r);\n\n\t\t\t/* add after_assign code */\n\t\t\tif (ip->opcode == Op_push_lhs && ip->memory->type == Node_var && ip->memory->var_assign) {\n\t\t\t\t(void) list_append(subn, instruction(Op_var_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->assign_var = ip->memory->var_assign;\n\t\t\t} else if (ip->opcode == Op_field_spec_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_field_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t\tsubn->lasti->field_assign = (Func_ptr) 0;\n\t\t\t\tip->target_assign = subn->lasti;\n\t\t\t} else if (ip->opcode == Op_subscript_lhs) {\n\t\t\t\t(void) list_append(subn, instruction(Op_subscript_assign));\n\t\t\t\tsubn->lasti->assign_ctxt = Op_sub_builtin;\n\t\t\t}\n\n\t\t\treturn subn;\n\n\t\t} else {\n\t\t\t/* gensub */\n\n\t\t\tr->sub_flags |= GENSUB;\n\t\t\tif (nexp == 3) {\n\t\t\t\tip = instruction(Op_push_i);\n\t\t\t\tip->memory = make_number(0.0);\n\t\t\t\t(void) mk_expression_list(subn,\n\t\t\t\t\t\tlist_append(list_create(ip), instruction(Op_field_spec)));\n\t\t\t}\n\n\t\t\tr->expr_count = count_expressions(&subn, false);\n\t\t\treturn list_append(subn, r);\n\t\t}\n\t}\n\n#ifdef HAVE_MPFR\n\t/* N.B.: There isn't any special processing for an alternate function below */\n\tif (do_mpfr && tokentab[idx].ptr2)\n\t\tr->builtin =  tokentab[idx].ptr2;\n\telse\n#endif\n\t\tr->builtin = tokentab[idx].ptr;\n\n\t/* special case processing for a few builtins */\n\n\tif (r->builtin == do_length) {\n\t\tif (nexp == 0) {\n\t\t    /* no args. Use $0 */\n\n\t\t\tINSTRUCTION *list;\n\t\t\tr->expr_count = 1;\n\t\t\tlist = list_create(r);\n\t\t\t(void) list_prepend(list, instruction(Op_field_spec));\n\t\t\t(void) list_prepend(list, instruction(Op_push_i));\n\t\t\tlist->nexti->memory = make_number(0.0);\n\t\t\treturn list;\n\t\t} else {\n\t\t\targ = subn->nexti;\n\t\t\tif (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)\n\t\t\t\targ->nexti->opcode = Op_push_arg;\t/* argument may be array */\n \t\t}\n\t} else if (r->builtin == do_isarray) {\n\t\targ = subn->nexti;\n\t\tif (arg->nexti == arg->lasti && arg->nexti->opcode == Op_push)\n\t\t\targ->nexti->opcode = Op_push_arg;\t/* argument may be array */\n\t} else if (r->builtin == do_match) {\n\t\tstatic bool warned = false;\n\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\t(void) mk_rexp(arg);\n\n\t\tif (nexp == 3) {\t/* 3rd argument there */\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"match: third argument is a gawk extension\"));\n\t\t\t}\n\t\t\tif (do_traditional) {\n\t\t\t\tyyerror(_(\"match: third argument is a gawk extension\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\targ = arg->lasti->nexti; \t/* third arg list */\n\t\t\tip = arg->lasti;\n\t\t\tif (/*ip == arg->nexti  && */ ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_split) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp == 2) {\n\t\t\tINSTRUCTION *expr;\n\t\t\texpr = list_create(instruction(Op_push));\n\t\t\texpr->nexti->memory = FS_node;\n\t\t\t(void) mk_expression_list(subn, expr);\n\t\t}\n\t\targ = arg->lasti->nexti;\n\t\tn = mk_rexp(arg);\n\t\tif (nexp == 2)\n\t\t\tn->re_flags |= FS_DFLT;\n\t\tif (nexp == 4) {\n\t\t\targ = arg->lasti->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_patsplit) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp == 2) {\n\t\t\tINSTRUCTION *expr;\n\t\t\texpr = list_create(instruction(Op_push));\n\t\t\texpr->nexti->memory = FPAT_node;\n\t\t\t(void) mk_expression_list(subn, expr);\n\t\t}\n\t\targ = arg->lasti->nexti;\n\t\tn = mk_rexp(arg);\n\t\tif (nexp == 4) {\n\t\t\targ = arg->lasti->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t} else if (r->builtin == do_close) {\n\t\tstatic bool warned = false;\n\t\tif (nexp == 2) {\n\t\t\tif (do_lint && ! warned) {\n\t\t\t\twarned = true;\n\t\t\t\tlintwarn(_(\"close: second argument is a gawk extension\"));\n\t\t\t}\n\t\t\tif (do_traditional) {\n\t\t\t\tyyerror(_(\"close: second argument is a gawk extension\"));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else if (do_intl\t\t\t\t\t/* --gen-po */\n\t\t\t&& r->builtin == do_dcgettext\t\t/* dcgettext(...) */\n\t\t\t&& subn->nexti->lasti->opcode == Op_push_i\t/* 1st arg is constant */\n\t\t\t&& (subn->nexti->lasti->memory->flags & STRCUR) != 0) {\t/* it's a string constant */\n\t\t/* ala xgettext, dcgettext(\"some string\" ...) dumps the string */\n\t\tNODE *str = subn->nexti->lasti->memory;\n\n\t\tif ((str->flags & INTLSTR) != 0)\n\t\t\twarning(_(\"use of dcgettext(_\\\"...\\\") is incorrect: remove leading underscore\"));\n\t\t\t/* don't dump it, the lexer already did */\n\t\telse\n\t\t\tdumpintlstr(str->stptr, str->stlen);\n\t} else if (do_intl\t\t\t\t\t/* --gen-po */\n\t\t\t&& r->builtin == do_dcngettext\t\t/* dcngettext(...) */\n\t\t\t&& subn->nexti->lasti->opcode == Op_push_i\t/* 1st arg is constant */\n\t\t\t&& (subn->nexti->lasti->memory->flags & STRCUR) != 0\t/* it's a string constant */\n\t\t\t&& subn->nexti->lasti->nexti->lasti->opcode == Op_push_i\t/* 2nd arg is constant too */\n\t\t\t&& (subn->nexti->lasti->nexti->lasti->memory->flags & STRCUR) != 0) {\t/* it's a string constant */\n\t\t/* ala xgettext, dcngettext(\"some string\", \"some plural\" ...) dumps the string */\n\t\tNODE *str1 = subn->nexti->lasti->memory;\n\t\tNODE *str2 = subn->nexti->lasti->nexti->lasti->memory;\n\n\t\tif (((str1->flags | str2->flags) & INTLSTR) != 0)\n\t\t\twarning(_(\"use of dcngettext(_\\\"...\\\") is incorrect: remove leading underscore\"));\n\t\telse\n\t\t\tdumpintlstr2(str1->stptr, str1->stlen, str2->stptr, str2->stlen);\n\t} else if (r->builtin == do_asort || r->builtin == do_asorti) {\n\t\targ = subn->nexti;\t/* 1st arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t\tif (nexp >= 2) {\n\t\t\targ = ip->nexti;\n\t\t\tip = arg->lasti;\n\t\t\tif (ip->opcode == Op_push)\n\t\t\t\tip->opcode = Op_push_array;\n\t\t}\n\t}\n\telse if (r->builtin == do_index) {\n\t\targ = subn->nexti->lasti->nexti;\t/* 2nd arg list */\n\t\tip = arg->lasti;\n\t\tif (ip->opcode == Op_match_rec)\n\t\t\tfatal(_(\"index: regexp constant as second argument is not allowed\"));\n\t}\n#ifdef ARRAYDEBUG\n\telse if (r->builtin == do_adump) {\n\t\tip = subn->nexti->lasti;\n\t\tif (ip->opcode == Op_push)\n\t\t\tip->opcode = Op_push_array;\n\t}\n#endif\n\n\tif (subn != NULL) {\n\t\tr->expr_count = count_expressions(&subn, false);\n\t\treturn list_append(subn, r);\n\t}\n\n\tr->expr_count = 0;\n\treturn list_create(r);\n}"
}