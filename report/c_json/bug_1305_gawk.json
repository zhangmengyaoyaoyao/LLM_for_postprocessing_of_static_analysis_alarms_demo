{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "debug.c",
    "message": "Offset: [4, 7] Size: [5, 8] by call to `genflags2str`.",
    "warning_function_name": "print_instruction",
    "warning_line": "genflags2str(pc->sub_flags, values));",
    "warning_context": "\t\t                pc->expr_count, redir2str(pc->redir_type));\n\t\tbreak;\n\n\tcase Op_indirect_func_call:\n\tcase Op_func_call:\n\t\tprint_func(fp, \"[func_name = %s] [arg_count = %ld]\\n\",\n\t\t                pc->func_name, (pc + 1)->expr_count);\n\t\tbreak;\n\n\tcase Op_K_nextfile:\n\t\tprint_func(fp, \"[target_newfile = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_newfile, pc->target_endfile);\n\t\tbreak;\n\n\tcase Op_newfile:\n\t\tprint_func(fp, \"[target_jmp = %p] [target_endfile = %p]\\n\",\n\t\t                pc->target_jmp, pc->target_endfile);\n\t\tprint_func(fp, \"%*s[target_get_record = %p]\\n\",\n\t\t                noffset, \"\", (pc + 1)->target_get_record);\n\t\tbreak;\n\n\tcase Op_get_record:\n\t\tprint_func(fp, \"[target_newfile = %p]\\n\", pc->target_newfile);\n\t\tbreak;\n\n\tcase Op_jmp:\n\tcase Op_jmp_false:\n\tcase Op_jmp_true:\n\tcase Op_and:\n\tcase Op_or:\n\tcase Op_K_next:\n\tcase Op_arrayfor_init:\n\tcase Op_K_break:\n\tcase Op_K_continue:\n\t\tprint_func(fp, \"[target_jmp = %p]\\n\", pc->target_jmp);\n\t\tbreak;\n\tcase Op_K_exit:\n\t\tprint_func(fp, \"[target_end = %p] [target_atexit = %p]\\n\",\n\t\t\t\t\t\tpc->target_end, pc->target_atexit);\n\t\tbreak;\n\n\tcase Op_K_case:\n\t\tprint_func(fp, \"[target_jmp = %p] [match_exp = %s]\\n\",\n\t\t\t\t\t\tpc->target_jmp,\t(pc + 1)->match_exp ? \"true\" : \"false\");\n\t\tbreak;\n\n\tcase Op_arrayfor_incr:\n\t\tprint_func(fp, \"[array_var = %s] [target_jmp = %p]\\n\",\n\t\t                pc->array_var->type == Node_param_list ?\n\t\t                   func->fparms[pc->array_var->param_cnt].param : pc->array_var->vname,\n\t\t                pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_line_range:\n\t\tprint_func(fp, \"[triggered = %ld] [target_jmp = %p]\\n\",\n\t\t                pc->triggered, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_cond_pair:\n\t\tprint_func(fp, \"[line_range = %p] [target_jmp = %p]\\n\",\n\t\t                pc->line_range, pc->target_jmp);\n\t\tbreak;\n\n\tcase Op_sub_builtin:\n\t{\n\t\tconst char *fname = \"sub\";\n\t\tstatic const struct flagtab values[] = {\n\t\t\t{ GSUB, \"GSUB\" },\n\t\t\t{ GENSUB, \"GENSUB\" },\n\t\t\t{ LITERAL, \"LITERAL\" },\n\t\t\t{ 0, NULL }\n\t\t};\n\n\t\tif ((pc->sub_flags & GSUB) != 0)\n\t\t\tfname = \"gsub\";\n\t\telse if ((pc->sub_flags & GENSUB) != 0)\n\t\t\tfname = \"gensub\";\n\t\tprint_func(fp, \"%s [arg_count = %ld] [sub_flags = %s]\\n\",\n\t\t\t\tfname, pc->expr_count,\n\t\t\t\tgenflags2str(pc->sub_flags, values));\n\t}\n\t\tbreak;\n\t\n\tcase Op_builtin:\n\t\tprint_func(fp, \"%s [arg_count = %ld]\\n\", getfname(pc->builtin),\n\t\t\t\t\t\tpc->expr_count);\n\t\tbreak;\n\n\tcase Op_ext_builtin:\n\t\tprint_func(fp, \"%s [arg_count = %ld]\\n\", (pc + 1)->func_name,\n\t\t\t\t\t\tpc->expr_count);\n\t\tbreak;\n\n\tcase Op_subscript:\n\tcase Op_sub_array:\n\t\tprint_func(fp, \"[sub_count = %ld]\\n\", pc->sub_count);\n\t\tbreak;\n\n\tcase Op_store_sub:\n\t\tprint_memory(pc->memory, func, print_func, fp);\n\t\tprint_func(fp, \" [sub_count = %ld]\\n\", pc->expr_count);\n"
}