{
    "Project": "sed",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "      vector->v = NULL;",
    "Code_function": "compile_program(vector)\n  struct vector *vector;\n{\n  struct sed_cmd *cur_cmd;\n  struct buffer *b;\n  int ch;\n\n  if (!vector)\n    {\n      vector = MALLOC(1, struct vector);\n      vector->v = NULL;\n      vector->v_allocated = 0;\n      vector->v_length = 0;\n\n      obstack_init (&obs);\n    }\n  if (pending_text)\n    read_text(NULL, '\\n');\n\n  for (;;)\n    {\n      struct addr a;\n\n      while ((ch=inchar()) == ';' || ISSPACE(ch))\n\t;\n      if (ch == EOF)\n\tbreak;\n\n      cur_cmd = next_cmd_entry(&vector);\n      if (compile_address(&a, ch))\n\t{\n\t  if (a.addr_type == ADDR_IS_STEP\n\t      || a.addr_type == ADDR_IS_STEP_MOD)\n\t    bad_prog(_(BAD_STEP));\n\n\t  cur_cmd->a1 = MEMDUP(&a, 1, struct addr);\n\t  ch = in_nonblank();\n\t  if (ch == ',')\n\t    {\n\t      if (!compile_address(&a, in_nonblank()))\n\t\tbad_prog(_(BAD_COMMA));\n\n\t      cur_cmd->a2 = MEMDUP(&a, 1, struct addr);\n\t      ch = in_nonblank();\n\t    }\n\n\t  if ((cur_cmd->a1->addr_type == ADDR_IS_NUM\n\t       && cur_cmd->a1->addr_number == 0)\n\t      && ((!cur_cmd->a2 || cur_cmd->a2->addr_type != ADDR_IS_REGEX)\n\t\t  || posixicity == POSIXLY_BASIC))\n\t    bad_prog(_(INVALID_LINE_0));\n\t}\n      if (ch == '!')\n\t{\n\t  cur_cmd->addr_bang = true;\n\t  ch = in_nonblank();\n\t  if (ch == '!')\n\t    bad_prog(_(BAD_BANG));\n\t}\n\n      /* Do not accept extended commands in --posix mode.  Also,\n\t a few commands only accept one address in that mode.  */\n      if (posixicity == POSIXLY_BASIC)\n\tswitch (ch)\n\t  {\n\t    case 'e': case 'v': case 'z': case 'L':\n\t    case 'Q': case 'T': case 'R': case 'W':\n\t      bad_command(ch);\n\n\t    case 'a': case 'i': case 'l':\n\t    case '=': case 'r':\n\t      if (cur_cmd->a2)\n\t        bad_prog(_(ONE_ADDR));\n\t  }\n\n      cur_cmd->cmd = ch;\n      switch (ch)\n\t{\n\tcase '#':\n\t  if (cur_cmd->a1)\n\t    bad_prog(_(NO_SHARP_ADDR));\n\t  ch = inchar();\n\t  if (ch=='n' && first_script && cur_input.line < 2)\n\t    if (   (prog.base && prog.cur==2+prog.base)\n\t\t|| (prog.file && !prog.base && 2==ftell(prog.file)))\n\t      no_default_output = true;\n\t  while (ch != EOF && ch != '\\n')\n\t    ch = inchar();\n\t  continue;\t/* restart the for (;;) loop */\n\n\tcase 'v':\n\t  /* This is an extension.  Programs needing GNU sed might start\n\t   * with a `v' command so that other seds will stop.\n\t   * We compare the version and ignore POSIXLY_CORRECT.\n\t   */\n\t  {\n\t    char *version = read_label ();\n\t    char *compared_version;\n\t    compared_version = (*version == '\\0') ? \"4.0\" : version;\n\t    if (strverscmp (compared_version, SED_FEATURE_VERSION) > 0)\n\t      bad_prog(_(ANCIENT_VERSION));\n\n\t    free (version);\n\t    posixicity = POSIXLY_EXTENDED;\n\t  }\n\t  continue;\n\n\tcase '{':\n\t  blocks = setup_label(blocks, vector->v_length, NULL, &cur_input);\n\t  cur_cmd->addr_bang = !cur_cmd->addr_bang;\n\t  break;\n\n\tcase '}':\n\t  if (!blocks)\n\t    bad_prog(_(EXCESS_CLOSE_BRACE));\n\t  if (cur_cmd->a1)\n\t    bad_prog(_(NO_CLOSE_BRACE_ADDR));\n\t  ch = in_nonblank();\n\t  if (ch == CLOSE_BRACE || ch == '#')\n\t    savchar(ch);\n\t  else if (ch != EOF && ch != '\\n' && ch != ';')\n\t    bad_prog(_(EXCESS_JUNK));\n\n\t  vector->v[blocks->v_index].x.jump_index = vector->v_length;\n\t  blocks = release_label(blocks);\t/* done with this entry */\n\t  break;\n\n\tcase 'e':\n\t  ch = in_nonblank();\n\t  if (ch == EOF || ch == '\\n')\n\t    {\n\t      cur_cmd->x.cmd_txt.text_length = 0;\n\t      break;\n\t    }\n\t  else\n\t    goto read_text_to_slash;\n\n\tcase 'a':\n\tcase 'i':\n\tcase 'c':\n\t  ch = in_nonblank();\n\n\tread_text_to_slash:\n\t  if (ch == EOF)\n\t    bad_prog(_(EXPECTED_SLASH));\n\n\t  if (ch == '\\\\')\n\t    ch = inchar();\n\t  else\n\t    {\n\t      if (posixicity == POSIXLY_BASIC)\n\t\tbad_prog(_(EXPECTED_SLASH));\n\t      savchar(ch);\n\t      ch = '\\n';\n\t    }\n\n\t  read_text(&cur_cmd->x.cmd_txt, ch);\n\t  break;\n\n\tcase ':':\n\t  if (cur_cmd->a1)\n\t    bad_prog(_(NO_COLON_ADDR));\n\t  labels = setup_label(labels, vector->v_length, read_label(), NULL);\n\t  break;\n\n\tcase 'T':\n\tcase 'b':\n\tcase 't':\n\t  jumps = setup_label(jumps, vector->v_length, read_label(), NULL);\n\t  break;\n\n\tcase 'Q':\n\tcase 'q':\n\t  if (cur_cmd->a2)\n\t    bad_prog(_(ONE_ADDR));\n\t  /* Fall through */\n\n\tcase 'L':\n\tcase 'l':\n\t  ch = in_nonblank();\n\t  if (ISDIGIT(ch) && posixicity != POSIXLY_BASIC)\n\t    {\n\t      cur_cmd->x.int_arg = in_integer(ch);\n\t      ch = in_nonblank();\n\t    }\n\t  else\n\t    cur_cmd->x.int_arg = -1;\n\n\t  if (ch == CLOSE_BRACE || ch == '#')\n\t    savchar(ch);\n\t  else if (ch != EOF && ch != '\\n' && ch != ';')\n\t    bad_prog(_(EXCESS_JUNK));\n\n\t  break;\n\n\tcase '=':\n\tcase 'd':\n\tcase 'D':\n\tcase 'g':\n\tcase 'G':\n\tcase 'h':\n\tcase 'H':\n\tcase 'n':\n\tcase 'N':\n\tcase 'p':\n\tcase 'P':\n\tcase 'z':\n\tcase 'x':\n\t  ch = in_nonblank();\n\t  if (ch == CLOSE_BRACE || ch == '#')\n\t    savchar(ch);\n\t  else if (ch != EOF && ch != '\\n' && ch != ';')\n\t    bad_prog(_(EXCESS_JUNK));\n\t  break;\n\n\tcase 'r':\n\t  b = read_filename();\n\t  cur_cmd->x.fname = ck_strdup(get_buffer(b));\n\t  free_buffer(b);\n\t  break;\n\n        case 'R':\n\t  cur_cmd->x.fp = get_openfile(&file_read, read_mode, false)->fp;\n\t  break;\n\n        case 'W':\n\tcase 'w':\n\t  cur_cmd->x.outf = get_openfile(&file_write, \"w\", true);\n\t  break;\n\n\tcase 's':\n\t  {\n\t    struct buffer *b2;\n\t    int flags;\n\t    int slash;\n\n\t    slash = inchar();\n\t    if ( !(b  = match_slash(slash, true)) )\n\t      bad_prog(_(UNTERM_S_CMD));\n\t    if ( !(b2 = match_slash(slash, false)) )\n\t      bad_prog(_(UNTERM_S_CMD));\n\n\t    cur_cmd->x.cmd_subst = OB_MALLOC(&obs, 1, struct subst);\n\t    setup_replacement(cur_cmd->x.cmd_subst,\n\t\t\t      get_buffer(b2), size_buffer(b2));\n\t    free_buffer(b2);\n\n\t    flags = mark_subst_opts(cur_cmd->x.cmd_subst);\n\t    cur_cmd->x.cmd_subst->regx =\n\t      compile_regex(b, flags, cur_cmd->x.cmd_subst->max_id + 1);\n\t    free_buffer(b);\n\t  }\n\t  break;\n\n\tcase 'y':\n\t  {\n\t    size_t len, dest_len;\n\t    int slash;\n\t    struct buffer *b2;\n            char *src_buf, *dest_buf;\n\n\t    slash = inchar();\n\t    if ( !(b = match_slash(slash, false)) )\n\t      bad_prog(_(UNTERM_Y_CMD));\n            src_buf = get_buffer(b);\n\t    len = normalize_text(src_buf, size_buffer (b), TEXT_BUFFER);\n\n            if ( !(b2 = match_slash(slash, false)) )\n \t      bad_prog(_(UNTERM_Y_CMD));\n            dest_buf = get_buffer(b2);\n\t    dest_len = normalize_text(dest_buf, size_buffer (b2), TEXT_BUFFER);\n\n            if (mb_cur_max > 1)\n\t      {\n                int i, j, idx, src_char_num;\n                size_t *src_lens = MALLOC(len, size_t);\n                char **trans_pairs;\n                size_t mbclen;\n                mbstate_t cur_stat;\n\n                /* Enumerate how many character the source buffer has.  */\n                memset(&cur_stat, 0, sizeof(mbstate_t));\n                for (i = 0, j = 0; i < len;)\n                  {\n                    mbclen = MBRLEN (src_buf + i, len - i, &cur_stat);\n                    /* An invalid sequence, or a truncated multibyte character.\n                       We treat it as a singlebyte character.  */\n                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2\n                        || mbclen == 0)\n                      mbclen = 1;\n                    src_lens[j++] = mbclen;\n                    i += mbclen;\n                  }\n                src_char_num = j;\n\n                memset(&cur_stat, 0, sizeof(mbstate_t));\n                idx = 0;\n\n                /* trans_pairs = {src(0), dest(0), src(1), dest(1), ..., NULL}\n                     src(i) : pointer to i-th source character.\n                     dest(i) : pointer to i-th destination character.\n                     NULL : terminator */\n                trans_pairs = MALLOC(2 * src_char_num + 1, char*);\n                cur_cmd->x.translatemb = trans_pairs;\n                for (i = 0; i < src_char_num; i++)\n                  {\n                    if (idx >= dest_len)\n                      bad_prog(_(Y_CMD_LEN));\n\n                    /* Set the i-th source character.  */\n                    trans_pairs[2 * i] = MALLOC(src_lens[i] + 1, char);\n                    strncpy(trans_pairs[2 * i], src_buf, src_lens[i]);\n                    trans_pairs[2 * i][src_lens[i]] = '\\0';\n                    src_buf += src_lens[i]; /* Forward to next character.  */\n\n                    /* Fetch the i-th destination character.  */\n                    mbclen = MBRLEN (dest_buf + idx, dest_len - idx, &cur_stat);\n                    /* An invalid sequence, or a truncated multibyte character.\n                       We treat it as a singlebyte character.  */\n                    if (mbclen == (size_t) -1 || mbclen == (size_t) -2\n                        || mbclen == 0)\n                      mbclen = 1;\n\n                    /* Set the i-th destination character.  */\n                    trans_pairs[2 * i + 1] = MALLOC(mbclen + 1, char);\n                    strncpy(trans_pairs[2 * i + 1], dest_buf + idx, mbclen);\n                    trans_pairs[2 * i + 1][mbclen] = '\\0';\n                    idx += mbclen; /* Forward to next character.  */\n                  }\n                trans_pairs[2 * i] = NULL;\n                if (idx != dest_len)\n                  bad_prog(_(Y_CMD_LEN));\n              }\n            else\n              {\n\t        unsigned char *translate =\n\t\t  OB_MALLOC(&obs, YMAP_LENGTH, unsigned char);\n                unsigned char *ustring = CAST(unsigned char *)src_buf;\n\n\t\tif (len != dest_len)\n                  bad_prog(_(Y_CMD_LEN));\n\n\t        for (len = 0; len < YMAP_LENGTH; len++)\n\t          translate[len] = len;\n\n                while (dest_len--)\n                  translate[*ustring++] = (unsigned char)*dest_buf++;\n\n\t        cur_cmd->x.translate = translate;\n\t      }\n\n            if ((ch = in_nonblank()) != EOF && ch != '\\n' && ch != ';')\n              bad_prog(_(EXCESS_JUNK));\n\n            free_buffer(b);\n            free_buffer(b2);\n\t  }\n\tbreak;\n\n\tcase EOF:\n\t  bad_prog(_(NO_COMMAND));\n\t  /*NOTREACHED*/\n\n\tdefault:\n\t  bad_command (ch);\n\t  /*NOTREACHED*/\n\t}\n\n      /* this is buried down here so that \"continue\" statements will miss it */\n      ++vector->v_length;\n    }\n  return vector;\n}"
}