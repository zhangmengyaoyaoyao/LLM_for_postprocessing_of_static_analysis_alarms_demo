{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "field.c",
    "message": "Offset: 2 Size: [0, 4] by call to `update_PROCINFO_str`.",
    "warning_function_name": "set_FS",
    "warning_line": "update_PROCINFO_str(\"FS\", \"FS\");",
    "warning_context": "\t */ \n\trefree(FS_re_yes_case);\n\trefree(FS_re_no_case);\n\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\n\nchoose_fs_function:\n\tbuf[0] = '\\0';\n\tdefault_FS = false;\n\tfs = force_string(FS_node->var_value);\n\n\tif (! do_traditional && fs->stlen == 0) {\n\t\tstatic bool warned = false;\n\n\t\tparse_field = null_parse_field;\n\n\t\tif (do_lint && ! warned) {\n\t\t\twarned = true;\n\t\t\tlintwarn(_(\"null string for `FS' is a gawk extension\"));\n\t\t}\n\t} else if (fs->stlen > 1) {\n\t\tif (do_lint_old)\n\t\t\twarning(_(\"old awk does not support regexps as value of `FS'\"));\n\t\tparse_field = re_parse_field;\n\t} else if (RS_is_null) {\n\t\t/* we know that fs->stlen <= 1 */\n\t\tparse_field = sc_parse_field;\n\t\tif (fs->stlen == 1) {\n\t\t\tif (fs->stptr[0] == ' ') {\n\t\t\t\tdefault_FS = true;\n\t\t\t\tstrcpy(buf, \"[ \\t\\n]+\");\n\t\t\t} else if (fs->stptr[0] == '\\\\') {\n\t\t\t\t/* yet another special case */\n\t\t\t\tstrcpy(buf, \"[\\\\\\\\\\n]\");\n\t\t\t} else if (fs->stptr[0] != '\\n')\n\t\t\t\tsprintf(buf, \"[%c\\n]\", fs->stptr[0]);\n\t\t}\n\t} else {\n\t\tif (do_posix)\n\t\t\tparse_field = posix_def_parse_field;\n\t\telse\n\t\t\tparse_field = def_parse_field;\n\n\t\tif (fs->stlen == 1) {\n\t\t\tif (fs->stptr[0] == ' ')\n\t\t\t\tdefault_FS = true;\n\t\t\telse if (fs->stptr[0] == '\\\\')\n\t\t\t\t/* same special case */\n\t\t\t\tstrcpy(buf, \"[\\\\\\\\]\");\n\t\t\telse\n\t\t\t\tparse_field = sc_parse_field;\n\t\t}\n\t}\n\tif (remake_re) {\n\t\trefree(FS_re_yes_case);\n\t\trefree(FS_re_no_case);\n\t\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\n\t\tif (buf[0] != '\\0') {\n\t\t\tFS_re_yes_case = make_regexp(buf, strlen(buf), false, true, true);\n\t\t\tFS_re_no_case = make_regexp(buf, strlen(buf), true, true, true);\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\t\t\tparse_field = re_parse_field;\n\t\t} else if (parse_field == re_parse_field) {\n\t\t\tFS_re_yes_case = make_regexp(fs->stptr, fs->stlen, false, true, true);\n\t\t\tFS_re_no_case = make_regexp(fs->stptr, fs->stlen, true, true, true);\n\t\t\tFS_regexp = (IGNORECASE ? FS_re_no_case : FS_re_yes_case);\n\t\t} else\n\t\t\tFS_re_yes_case = FS_re_no_case = FS_regexp = NULL;\n\t}\n\n\t/*\n\t * For FS = \"c\", we don't use IGNORECASE. But we must use\n\t * re_parse_field to get the character and the newline as\n\t * field separators.\n\t */\n\tif (fs->stlen == 1 && parse_field == re_parse_field)\n\t\tFS_regexp = FS_re_yes_case;\n\n\tupdate_PROCINFO_str(\"FS\", \"FS\");\n}\n\n/* current_field_sep --- return what field separator is */\n\nfield_sep_type\ncurrent_field_sep()\n{\n\tif (parse_field == fw_parse_field)\n\t\treturn Using_FIELDWIDTHS;\n\telse if (parse_field == fpat_parse_field)\n\t\treturn Using_FPAT;\n\telse\n\t\treturn Using_FS;\n}\n\n/* update_PROCINFO_str --- update PROCINFO[sub] with string value */\n\nvoid\nupdate_PROCINFO_str(const char *subscript, const char *str)\n{\n\tNODE **aptr;\n"
}