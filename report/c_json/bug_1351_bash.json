{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);",
    "Code_function": "print_formatted_time (fp, format, rs, rsf, us, usf, ss, ssf, cpu)\n     FILE *fp;\n     char *format;\n     time_t rs;\n     int rsf;\n     time_t us;\n     int usf;\n     time_t ss;\n     int ssf, cpu;\n{\n  int prec, lng, len;\n  char *str, *s, ts[INT_STRLEN_BOUND (time_t) + sizeof (\"mSS.FFFF\")];\n  time_t sum;\n  int sum_frac;\n  int sindex, ssize;\n\n  len = strlen (format);\n  ssize = (len + 64) - (len % 64);\n  str = (char *)xmalloc (ssize);\n  sindex = 0;\n\n  for (s = format; *s; s++)\n    {\n      if (*s != '%' || s[1] == '\\0')\n\t{\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, 1, ssize, 64);\n\t  str[sindex++] = *s;\n\t}\n      else if (s[1] == '%')\n\t{\n\t  s++;\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, 1, ssize, 64);\n\t  str[sindex++] = *s;\n\t}\n      else if (s[1] == 'P')\n\t{\n\t  s++;\n#if 0\n\t  /* clamp CPU usage at 100% */\n\t  if (cpu > 10000)\n\t    cpu = 10000;\n#endif\n\t  sum = cpu / 100;\n\t  sum_frac = (cpu % 100) * 10;\n\t  len = mkfmt (ts, 2, 0, sum, sum_frac);\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);\n\t  strcpy (str + sindex, ts);\n\t  sindex += len;\n\t}\n      else\n\t{\n\t  prec = 3;\t/* default is three places past the decimal point. */\n\t  lng = 0;\t/* default is to not use minutes or append `s' */\n\t  s++;\n\t  if (DIGIT (*s))\t\t/* `precision' */\n\t    {\n\t      prec = *s++ - '0';\n\t      if (prec > 3) prec = 3;\n\t    }\n\t  if (*s == 'l')\t\t/* `length extender' */\n\t    {\n\t      lng = 1;\n\t      s++;\n\t    }\n\t  if (*s == 'R' || *s == 'E')\n\t    len = mkfmt (ts, prec, lng, rs, rsf);\n\t  else if (*s == 'U')\n\t    len = mkfmt (ts, prec, lng, us, usf);\n\t  else if (*s == 'S')\n\t    len = mkfmt (ts, prec, lng, ss, ssf);\n\t  else\n\t    {\n\t      internal_error (_(\"TIMEFORMAT: `%c': invalid format character\"), *s);\n\t      free (str);\n\t      return;\n\t    }\n\t  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);\n\t  strcpy (str + sindex, ts);\n\t  sindex += len;\n\t}\n    }\n\n  str[sindex] = '\\0';\n  fprintf (fp, \"%s\\n\", str);\n  fflush (fp);\n\n  free (str);\n}"
}