{
    "Project": "bash",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "subst.c",
    "message": "Offset: 2 Size: 2 by call to `extract_delimited_string`.",
    "warning_function_name": "skip_to_delim",
    "warning_line": "temp = extract_delimited_string (string, &si, open, \"(\", \")\", SX_NOALLOC); /* ) */",
    "warning_context": "\t test whether or not it's a delimiter until after we skip single- or\n\t double-quoted strings. */\n      skipquote = ((flags & SD_NOQUOTEDELIM) && (c == '\\'' || c =='\"'));\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (c == 0)\n\t    CQ_RETURN(i);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq)\n\t{\n\t  if (c == '`')\n\t    backq = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '`')\n\t{\n\t  backq = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (skipquote == 0 && invert == 0 && member (c, delims))\n\tbreak;\n      else if (c == '\\'' || c == '\"')\n\t{\n\t  i = (c == '\\'') ? skip_single_quoted (string, slen, ++i)\n\t\t\t  : skip_double_quoted (string, slen, ++i);\n\t  /* no increment, the skip functions increment past the closing quote. */\n\t}\n      else if (c == '$' && ((skipcmd && string[i+1] == LPAREN) || string[i+1] == LBRACE))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  if (string[i+1] == LPAREN)\n\t    temp = extract_delimited_string (string, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND); /* ) */\n\t  else\n\t    temp = extract_dollar_brace_string (string, &si, 0, SX_NOALLOC);\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#if defined (PROCESS_SUBSTITUTION)\n      else if (skipcmd && (c == '<' || c == '>') && string[i+1] == LPAREN)\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\t  temp = extract_process_subst (string, (c == '<') ? \"<(\" : \">(\", &si);\n\t  free (temp);\t\t/* no SX_ALLOC here */\n\t  i = si;\n\t  if (string[i] == '\\0')\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif /* PROCESS_SUBSTITUTION */\n#if defined (EXTENDED_GLOB)\n      else if ((flags & SD_EXTGLOB) && extended_glob && string[i+1] == LPAREN && member (c, \"?*+!@\"))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  open[0] = c;\n\t  open[1] = LPAREN;\n\t  open[2] = '\\0';\n\t  temp = extract_delimited_string (string, &si, open, \"(\", \")\", SX_NOALLOC); /* ) */\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n#endif\n      else if ((flags & SD_GLOB) && c == LBRACK)\n\t{\n\t  si = i + 1;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  temp = extract_delimited_string (string, &si, \"[\", \"[\", \"]\", SX_NOALLOC); /* ] */\n\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n"
}