{
    "project": "tiff",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "tools/tiff2ps.c",
    "message": "Offset: [7, +oo] (‚áê [0, +oo] + 7) Size: [0, +oo] by call to `TIFFReverseBits`.",
    "warning_function_name": "PS_Lvl2page",
    "warning_line": "TIFFReverseBits(buf_data, byte_count);",
    "warning_context": "\ttsize_t chunk_size, byte_count;\n\n#if defined( EXP_ASCII85ENCODER )\n\ttsize_t\t\t\tascii85_l;\t/* Length, in bytes, of ascii85_p[] data */\n\tuint8\t\t*\tascii85_p = 0;\t/* Holds ASCII85 encoded data */\n#endif\n\n\tPS_Lvl2colorspace(fd, tif);\n\tuse_rawdata = PS_Lvl2ImageDict(fd, tif, w, h);\n\n/* See http://bugzilla.remotesensing.org/show_bug.cgi?id=80 */\n#ifdef ENABLE_BROKEN_BEGINENDDATA\n\tfputs(\"%%BeginData:\\n\", fd);\n#endif\n\tfputs(\"exec\\n\", fd);\n\n\ttiled_image = TIFFIsTiled(tif);\n\tif (tiled_image) {\n\t\tnum_chunks = TIFFNumberOfTiles(tif);\n\t\tTIFFGetField(tif, TIFFTAG_TILEBYTECOUNTS, &bc);\n\t} else {\n\t\tnum_chunks = TIFFNumberOfStrips(tif);\n\t\tTIFFGetField(tif, TIFFTAG_STRIPBYTECOUNTS, &bc);\n\t}\n\n\tif (use_rawdata) {\n\t\tchunk_size = (tsize_t) bc[0];\n\t\tfor (chunk_no = 1; chunk_no < num_chunks; chunk_no++)\n\t\t\tif ((tsize_t) bc[chunk_no] > chunk_size)\n\t\t\t\tchunk_size = (tsize_t) bc[chunk_no];\n\t} else {\n\t\tif (tiled_image)\n\t\t\tchunk_size = TIFFTileSize(tif);\n\t\telse\n\t\t\tchunk_size = TIFFStripSize(tif);\n\t}\n\tbuf_data = (unsigned char *)_TIFFmalloc(chunk_size);\n\tif (!buf_data) {\n\t\tTIFFError(filename, \"Can't alloc %lu bytes for %s.\",\n\t\t\t(unsigned long) chunk_size, tiled_image ? \"tiles\" : \"strips\");\n\t\treturn(FALSE);\n\t}\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*chunk_size/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*chunk_size/4 rather than\n\t     * 5*chunk_size/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (chunk_size+(chunk_size/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( buf_data );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn ( FALSE );\n\t    }\n\t}\n#endif\n\n\tTIFFGetFieldDefaulted(tif, TIFFTAG_FILLORDER, &fillorder);\n\tfor (chunk_no = 0; chunk_no < num_chunks; chunk_no++) {\n\t\tif (ascii85)\n\t\t\tAscii85Init();\n\t\telse\n\t\t\tbreaklen = MAXLINE;\n\t\tif (use_rawdata) {\n\t\t\tif (tiled_image)\n\t\t\t\tbyte_count = TIFFReadRawTile(tif, chunk_no,\n\t\t\t\t\t\t  buf_data, chunk_size);\n\t\t\telse\n\t\t\t\tbyte_count = TIFFReadRawStrip(tif, chunk_no,\n\t\t\t\t\t\t  buf_data, chunk_size);\n\t\t\tif (fillorder == FILLORDER_LSB2MSB)\n\t\t\t    TIFFReverseBits(buf_data, byte_count);\n\t\t} else {\n\t\t\tif (tiled_image)\n\t\t\t\tbyte_count = TIFFReadEncodedTile(tif,\n\t\t\t\t\t\tchunk_no, buf_data,\n\t\t\t\t\t\tchunk_size);\n\t\t\telse\n\t\t\t\tbyte_count = TIFFReadEncodedStrip(tif,\n\t\t\t\t\t\tchunk_no, buf_data,\n\t\t\t\t\t\tchunk_size);\n\t\t}\n\t\tif (byte_count < 0) {\n\t\t\tTIFFError(filename, \"Can't read %s %d.\",\n\t\t\t\ttiled_image ? \"tile\" : \"strip\", chunk_no);\n\t\t\tif (ascii85)\n\t\t\t\tAscii85Put('\\0', fd);\n\t\t}\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !TIFFIsBigEndian(tif)) {\n"
}