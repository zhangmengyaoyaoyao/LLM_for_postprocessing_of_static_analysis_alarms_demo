{
    "project": "combine",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "src/field.c",
    "message": "Offset: max(0, `range_count`) Size: [`range_count`, `range_count` + 1].",
    "warning_function_name": "a_find_input_ranges",
    "warning_line": "(*out_ranges)[i] = dstrdup (field_list[end_range_start - 1]);",
    "warning_context": "\t}\n      field_list\n\t= realloc (field_list, field_list_length * sizeof (*field_list));\n      if (field_list == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      }\n    }\n\n  *out_ranges\n    = malloc ((range_count + (end_range_start == 0 ? 0 : 1))\n\t      * sizeof (STRINGTYPE));\n  if (*out_ranges == NULL)\n    return EXIT_FAILURE;\n\n  for (i = 0; i < range_count; i++) {\n    if (input_delimiter != NULL) {\n      if (ranges[i].lower_bound <= field_list_length) {\n\tif (empty_replacement != NULL\n\t    && field_list[ranges[i].lower_bound - 1]->length == 0)\n\t  (*out_ranges)[i] = dstrdup (empty_replacement);\n\telse\n\t  (*out_ranges)[i] = dstrdup (field_list[ranges[i].lower_bound - 1]);\n\t}\n      else if (empty_replacement != NULL)\n\t(*out_ranges)[i] = dstrdup (empty_replacement);\n      else\n\t(*out_ranges)[i] = dstrdupstr (\"\");\n      if ((*out_ranges)[i] == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      }\n    else {\n      (*out_ranges)[i]\n\t= dstrsubstr (input_record, ranges[i].lower_bound,\n\t\t      ranges[i].upper_bound, 0, make_copy);\n      if ((*out_ranges)[i] == NULL) {\n\tif (ranges[i].lower_bound < 1\n\t    || ranges[i].lower_bound > ranges[i].upper_bound\n\t    || ranges[i].upper_bound > input_record->length)\n\t  FATAL_ERROR3 (_\n\t\t\t(\"bad field substring -- wanted bytes %ld-%ld in %ld-byte string\"),\n\t\t\tranges[i].lower_bound, ranges[i].upper_bound,\n\t\t\tinput_record->length);\n\telse\n\t  FATAL_ERROR (_(\"unable to allocate memory\"));\n\t}\n      }\n#ifdef HAVE_LIBGUILE\n    if (ranges[i].format != NULL) {\t/* We have some processing to do. */\n      SCM return_value;\n      STRINGTYPE *temp_string;\n      size_t return_length;\n\n      create_scheme_string_variable (&df_name_input_field, 0,\n\t\t\t\t     ((*out_ranges)[i]));\n\n      /* Call Guile */\n      temp_string = eval_scheme_string_function (ranges[i].format);\n      dstrfree ((*out_ranges)[i]);\n      (*out_ranges)[i] = temp_string;\n      }\n#  endif /* HAVE_LIBGUILE */\n    }\n\n  if (end_range_start != 0 && input_delimiter == NULL) {\n    (*out_ranges)[i]\n      = dstrsubstr (input_record, end_range_start, input_record->length, 0,\n\t\t    make_copy);\n    if ((*out_ranges)[i] == NULL) {\n      if (end_range_start < 1 || end_range_start > input_record->length)\n\tFATAL_ERROR3 (_\n\t\t      (\"bad field substring -- wanted bytes %ld-%ld in %ld-byte string\"),\n\t\t      end_range_start, input_record->length,\n\t\t      input_record->length);\n      else\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      }\n    }\n  else if (end_range_start != 0 && input_delimiter != NULL) {\n    if (end_range_start <= field_list_length)\n      (*out_ranges)[i] = dstrdup (field_list[end_range_start - 1]);\n    else\n      (*out_ranges)[i] = dstrdupstr (\"\");\n    j = end_range_start;\n    while (j < field_list_length) {\n      /* If there are more fields, tack them on with the output delimiter if appropriate. */\n      if (output_delimiter != NULL)\n\tdstrcat ((*out_ranges)[i], output_delimiter);\n      if (empty_replacement == NULL || field_list[j]->length != 0)\n\tdstrcat ((*out_ranges)[i], field_list[j]);\n      else\n\tdstrcat ((*out_ranges)[i], empty_replacement);\n      j++;\n      }\n    }\n\n  if (input_delimiter != NULL) {\n    int i;\n    for (i = 0; i < field_list_length; i++)\n      dstrfree (field_list[i]);\n    free (field_list);\n    }\n"
}