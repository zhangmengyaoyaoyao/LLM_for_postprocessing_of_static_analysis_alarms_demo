{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/readline/complete.c",
    "message": "The value read from tlen was never initialized.",
    "warning_function_name": "print_filename",
    "warning_line": "if (mlen >= tlen)",
    "warning_context": "  int start, end, delimiter, found_quote, i, nontrivial_lcd;\n  char *text, *saved_line_buffer;\n  char quote_char;\n#if 1\n  int tlen, mlen;\n#endif\n\n  RL_SETSTATE(RL_STATE_COMPLETING);\n\n  set_completion_defaults (what_to_do);\n\n  saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;\n  our_func = rl_completion_entry_function\n\t\t? rl_completion_entry_function\n\t\t: rl_filename_completion_function;\n  /* We now look backwards for the start of a filename/variable word. */\n  end = rl_point;\n  found_quote = delimiter = 0;\n  quote_char = '\\0';\n\n  if (rl_point)\n    /* This (possibly) changes rl_point.  If it returns a non-zero char,\n       we know we have an open quote. */\n    quote_char = _rl_find_completion_word (&found_quote, &delimiter);\n\n  start = rl_point;\n  rl_point = end;\n\n  text = rl_copy_text (start, end);\n  matches = gen_completion_matches (text, start, end, our_func, found_quote, quote_char);\n  /* nontrivial_lcd is set if the common prefix adds something to the word\n     being completed. */\n  nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;\n  if (what_to_do == '!' || what_to_do == '@')\n    tlen = strlen (text);\n  xfree (text);\n\n  if (matches == 0)\n    {\n      rl_ding ();\n      FREE (saved_line_buffer);\n      completion_changed_buffer = 0;\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_reset_completion_state ();\n      return (0);\n    }\n\n  /* If we are matching filenames, the attempted completion function will\n     have set rl_filename_completion_desired to a non-zero value.  The basic\n     rl_filename_completion_function does this. */\n  i = rl_filename_completion_desired;\n\n  if (postprocess_matches (&matches, i) == 0)\n    {\n      rl_ding ();\n      FREE (saved_line_buffer);\n      completion_changed_buffer = 0;\n      RL_UNSETSTATE(RL_STATE_COMPLETING);\n      _rl_reset_completion_state ();\n      return (0);\n    }\n\n  switch (what_to_do)\n    {\n    case TAB:\n    case '!':\n    case '@':\n      /* Insert the first match with proper quoting. */\n      if (what_to_do == TAB)\n        {\n          if (*matches[0])\n\t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n        }\n      else if (*matches[0] && matches[1] == 0)\n\t/* should we perform the check only if there are multiple matches? */\n\tinsert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n      else if (*matches[0])\t/* what_to_do != TAB && multiple matches */\n\t{\n\t  mlen = *matches[0] ? strlen (matches[0]) : 0;\n\t  if (mlen >= tlen)\n\t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n\t}\n\n      /* If there are more matches, ring the bell to indicate.\n\t If we are in vi mode, Posix.2 says to not ring the bell.\n\t If the `show-all-if-ambiguous' variable is set, display\n\t all the matches immediately.  Otherwise, if this was the\n\t only match, and we are hacking files, check the file to\n\t see if it was a directory.  If so, and the `mark-directories'\n\t variable is set, add a '/' to the name.  If not, and we\n\t are at the end of the line, then add a space.  */\n      if (matches[1])\n\t{\n\t  if (what_to_do == '!')\n\t    {\n\t      display_matches (matches);\n\t      break;\n\t    }\n\t  else if (what_to_do == '@')\n\t    {\n\t      if (nontrivial_lcd == 0)\n"
}