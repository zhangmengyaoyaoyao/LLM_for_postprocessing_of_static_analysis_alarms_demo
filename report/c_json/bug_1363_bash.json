{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "      FREE (ret);",
    "Code_function": "gen_compspec_completions (cs, cmd, word, start, end, foundp)\n     COMPSPEC *cs;\n     const char *cmd;\n     const char *word;\n     int start, end;\n     int *foundp;\n{\n  STRINGLIST *ret, *tmatches;\n  char *line;\n  int llen, nw, cw, found, foundf;\n  WORD_LIST *lwords;\n  WORD_DESC *lw;\n  COMPSPEC *tcs;\n\n  found = 1;\n\n#ifdef DEBUG\n  debug_printf (\"gen_compspec_completions (%s, %s, %d, %d)\", cmd, word, start, end);\n  debug_printf (\"gen_compspec_completions: %s -> %p\", cmd, cs);\n#endif\n  ret = gen_action_completions (cs, word);\n#ifdef DEBUG\n  if (ret && progcomp_debug)\n    {\n      debug_printf (\"gen_action_completions (%p, %s) -->\", cs, word);\n      strlist_print (ret, \"\\t\");\n      rl_on_new_line ();\n    }\n#endif\n\n  /* Now we start generating completions based on the other members of CS. */\n  if (cs->globpat)\n    {\n      tmatches = gen_globpat_matches (cs, word);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_globpat_matches (%p, %s) -->\", cs, word);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t  rl_filename_completion_desired = 1;\n\t}\n    }\n\n  if (cs->words)\n    {\n      tmatches = gen_wordlist_matches (cs, word);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_wordlist_matches (%p, %s) -->\", cs, word);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  lwords = (WORD_LIST *)NULL;\n  line = (char *)NULL;\n  if (cs->command || cs->funcname)\n    {\n      /* If we have a command or function to execute, we need to first break\n\t the command line into individual words, find the number of words,\n\t and find the word in the list containing the word to be completed. */\n      line = substring (rl_line_buffer, start, end);\n      llen = end - start;\n\n#ifdef DEBUG\n      debug_printf (\"command_line_to_word_list (%s, %d, %d, %p, %p)\",\n\t\tline, llen, rl_point - start, &nw, &cw);\n#endif\n      lwords = command_line_to_word_list (line, llen, rl_point - start, &nw, &cw);\n      /* If we skipped a NULL word at the beginning of the line, add it back */\n      if (lwords && lwords->word && cmd[0] == 0 && lwords->word->word[0] != 0)\n\t{\n\t  lw = make_bare_word (cmd);\n\t  lwords = make_word_list (lw, lwords);\n\t  nw++;\n\t  cw++;\n\t}\n#ifdef DEBUG\n      if (lwords == 0 && llen > 0)\n\tdebug_printf (\"ERROR: command_line_to_word_list returns NULL\");\n      else if (progcomp_debug)\n\t{\n\t  debug_printf (\"command_line_to_word_list -->\");\n\t  printf (\"\\t\");\n\t  print_word_list (lwords, \"!\");\n\t  printf (\"\\n\");\n\t  fflush(stdout);\n\t  rl_on_new_line ();\n\t}\n#endif\n    }\n\n  if (cs->funcname)\n    {\n      foundf = 0;\n      tmatches = gen_shell_function_matches (cs, cmd, word, line, rl_point - start, lwords, nw, cw, &foundf);\n      if (foundf != 0)\n\tfound = foundf;\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_shell_function_matches (%p, %s, %s, %p, %d, %d) -->\", cs, cmd, word, lwords, nw, cw);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  if (cs->command)\n    {\n      tmatches = gen_command_matches (cs, cmd, word, line, rl_point - start, lwords, nw, cw);\n      if (tmatches)\n\t{\n#ifdef DEBUG\n\t  if (progcomp_debug)\n\t    {\n\t      debug_printf (\"gen_command_matches (%p, %s, %s, %p, %d, %d) -->\", cs, cmd, word, lwords, nw, cw);\n\t      strlist_print (tmatches, \"\\t\");\n\t      rl_on_new_line ();\n\t    }\n#endif\n\t  ret = strlist_append (ret, tmatches);\n\t  strlist_dispose (tmatches);\n\t}\n    }\n\n  if (cs->command || cs->funcname)\n    {\n      if (lwords)\n\tdispose_words (lwords);\n      FREE (line);\n    }\n\n  if (foundp)\n    *foundp = found;\n\n  if (found == 0 || (found & PCOMP_RETRYFAIL))\n    {\n      strlist_dispose (ret);\n      return NULL;\n    }\n\n  if (cs->filterpat)\n    {\n      tmatches = filter_stringlist (ret, cs->filterpat, word);\n#ifdef DEBUG\n      if (progcomp_debug)\n\t{\n\t  debug_printf (\"filter_stringlist (%p, %s, %s) -->\", ret, cs->filterpat, word);\n\t  strlist_print (tmatches, \"\\t\");\n\t  rl_on_new_line ();\n\t}\n#endif\n      if (ret && ret != tmatches)\n\t{\n\t  FREE (ret->list);\n\t  free (ret);\n\t}\n      ret = tmatches;\n    }\n\n  if (cs->prefix || cs->suffix)\n    ret = strlist_prefix_suffix (ret, cs->prefix, cs->suffix);\n\n  /* If no matches have been generated and the user has specified that\n      directory completion should be done as a default, call\n      gen_action_completions again to generate a list of matching directory\n      names. */\n  if ((ret == 0 || ret->list_len == 0) && (cs->options & COPT_DIRNAMES))\n    {\n      tcs = compspec_create ();\n      tcs->actions = CA_DIRECTORY;\n      FREE (ret);\n      ret = gen_action_completions (tcs, word);\n      compspec_dispose (tcs);\n    }\n  else if (cs->options & COPT_PLUSDIRS)\n    {\n      tcs = compspec_create ();\n      tcs->actions = CA_DIRECTORY;\n      tmatches = gen_action_completions (tcs, word);\n      ret = strlist_append (ret, tmatches);\n      strlist_dispose (tmatches);\n      compspec_dispose (tcs);\n    }\n\n  return (ret);\n}"
}