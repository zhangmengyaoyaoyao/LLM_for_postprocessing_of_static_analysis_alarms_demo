{
    "project": "tiff",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "libtiff/tif_dirread.c",
    "message": "pointer `fip` last assigned on line 1644 could be null and is dereferenced at line 1722, column 26.",
    "warning_function_name": "TIFFFetchNormalTag",
    "warning_line": "{ TIFFDataType type = fip->field_type;",
    "warning_context": "\tint ok = 0;\n\tconst TIFFFieldInfo* fip = _TIFFFieldWithTag(tif, dp->tdir_tag);\n\n\tif (dp->tdir_count > 1) {\t\t/* array of values */\n\t\tchar* cp = NULL;\n\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint8), mesg);\n\t\t\tok = cp && TIFFFetchByteArray(tif, dp, (uint8*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint16), mesg);\n\t\t\tok = cp && TIFFFetchShortArray(tif, dp, (uint16*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (uint32), mesg);\n\t\t\tok = cp && TIFFFetchLongArray(tif, dp, (uint32*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchRationalArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_FLOAT:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (float), mesg);\n\t\t\tok = cp && TIFFFetchFloatArray(tif, dp, (float*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_DOUBLE:\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif,\n\t\t\t    dp->tdir_count, sizeof (double), mesg);\n\t\t\tok = cp && TIFFFetchDoubleArray(tif, dp, (double*) cp);\n\t\t\tbreak;\n\t\tcase TIFF_ASCII:\n\t\tcase TIFF_UNDEFINED:\t\t/* bit of a cheat... */\n\t\t\t/*\n\t\t\t * Some vendors write strings w/o the trailing\n\t\t\t * NULL byte, so always append one just in case.\n\t\t\t */\n\t\t\tcp = (char *)_TIFFCheckMalloc(tif, dp->tdir_count + 1,\n\t\t\t\t\t\t      1, mesg);\n\t\t\tif( (ok = (cp && TIFFFetchString(tif, dp, cp))) != 0 )\n\t\t\t\tcp[dp->tdir_count] = '\\0';\t/* XXX */\n\t\t\tbreak;\n\t\t}\n\t\tif (ok) {\n\t\t\tok = (fip->field_passcount ?\n\t\t\t    TIFFSetField(tif, dp->tdir_tag, dp->tdir_count, cp)\n\t\t\t  : TIFFSetField(tif, dp->tdir_tag, cp));\n\t\t}\n\t\tif (cp != NULL)\n\t\t\t_TIFFfree(cp);\n\t} else if (CheckDirCount(tif, dp, 1, TRUE)) {\t/* singleton value */\n\t\tswitch (dp->tdir_type) {\n\t\tcase TIFF_BYTE:\n\t\tcase TIFF_SBYTE:\n\t\tcase TIFF_SHORT:\n\t\tcase TIFF_SSHORT:\n\t\t\t/*\n\t\t\t * If the tag is also acceptable as a LONG or SLONG\n\t\t\t * then TIFFSetField will expect an uint32 parameter\n\t\t\t * passed to it (through varargs).  Thus, for machines\n\t\t\t * where sizeof (int) != sizeof (uint32) we must do\n\t\t\t * a careful check here.  It's hard to say if this\n\t\t\t * is worth optimizing.\n\t\t\t *\n\t\t\t * NB: We use TIFFFieldWithTag here knowing that\n\t\t\t *     it returns us the first entry in the table\n\t\t\t *     for the tag and that that entry is for the\n\t\t\t *     widest potential data type the tag may have.\n\t\t\t */\n\t\t\t{ TIFFDataType type = fip->field_type;\n\t\t\t  if (type != TIFF_LONG && type != TIFF_SLONG) {\n\t\t\t\tuint16 v = (uint16)\n\t\t\t   TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t\tok = (fip->field_passcount ?\n\t\t\t\t    TIFFSetField(tif, dp->tdir_tag, 1, &v)\n\t\t\t\t  : TIFFSetField(tif, dp->tdir_tag, v));\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t/* fall thru... */\n\t\tcase TIFF_LONG:\n\t\tcase TIFF_SLONG:\n\t\t\t{ uint32 v32 =\n\t\t    TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset);\n\t\t\t  ok = (fip->field_passcount ? \n\t\t\t      TIFFSetField(tif, dp->tdir_tag, 1, &v32)\n\t\t\t    : TIFFSetField(tif, dp->tdir_tag, v32));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFF_RATIONAL:\n\t\tcase TIFF_SRATIONAL:\n"
}