{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "binutils/readelf.c",
    "message": "Offset: [-oo, 126] Size: 2.",
    "warning_function_name": "display_arm_attribute",
    "warning_line": "printf (\"%s\\n\", attr->table[val]);",
    "warning_context": "\t\tcase 0: printf (_(\"None\\n\")); break;\n\t\tcase 1: printf (_(\"8-byte, except leaf SP\\n\")); break;\n\t\tcase 2: printf (_(\"8-byte\\n\")); break;\n\t\tcase 3: printf (\"??? 3\\n\"); break;\n\t\tdefault:\n\t\t  if (val <= 12)\n\t\t    printf (_(\"8-byte and up to %d-byte extended\\n\"),\n\t\t\t    1 << val);\n\t\t  else\n\t\t    printf (\"??? (%d)\\n\", val);\n\t\t  break;\n\t\t}\n\t      break;\n\n\t    case 32: /* Tag_compatibility.  */\n\t      {\n\t\tval = read_uleb128 (p, &len, end);\n\t\tp += len;\n\t\tprintf (_(\"flag = %d, vendor = \"), val);\n\t\tif (p < end - 1)\n\t\t  {\n\t\t    size_t maxlen = (end - p) - 1;\n\n\t\t    print_symbol ((int) maxlen, (const char *) p);\n\t\t    p += strnlen ((char *) p, maxlen) + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    printf (_(\"<corrupt>\"));\n\t\t    p = (unsigned char *) end;\n\t\t  }\n\t\tputchar ('\\n');\n\t      }\n\t      break;\n\n\t    case 64: /* Tag_nodefaults.  */\n\t      /* PR 17531: file: 001-505008-0.01.  */\n\t      if (p < end)\n\t\tp++;\n\t      printf (_(\"True\\n\"));\n\t      break;\n\n\t    case 65: /* Tag_also_compatible_with.  */\n\t      val = read_uleb128 (p, &len, end);\n\t      p += len;\n\t      if (val == 6 /* Tag_CPU_arch.  */)\n\t\t{\n\t\t  val = read_uleb128 (p, &len, end);\n\t\t  p += len;\n\t\t  if ((unsigned int) val >= ARRAY_SIZE (arm_attr_tag_CPU_arch))\n\t\t    printf (\"??? (%d)\\n\", val);\n\t\t  else\n\t\t    printf (\"%s\\n\", arm_attr_tag_CPU_arch[val]);\n\t\t}\n\t      else\n\t\tprintf (\"???\\n\");\n\t      while (p < end && *(p++) != '\\0' /* NUL terminator.  */)\n\t\t;\n\t      break;\n\n\t    default:\n\t      printf (_(\"<unknown: %d>\\n\"), tag);\n\t      break;\n\t    }\n\t  return p;\n\n\tcase 1:\n\t  return display_tag_value (-1, p, end);\n\tcase 2:\n\t  return display_tag_value (0, p, end);\n\n\tdefault:\n\t  assert (attr->type & 0x80);\n\t  val = read_uleb128 (p, &len, end);\n\t  p += len;\n\t  type = attr->type & 0x7f;\n\t  if (val >= type)\n\t    printf (\"??? (%d)\\n\", val);\n\t  else\n\t    printf (\"%s\\n\", attr->table[val]);\n\t  return p;\n\t}\n    }\n\n  return display_tag_value (tag, p, end);\n}\n\nstatic unsigned char *\ndisplay_gnu_attribute (unsigned char * p,\n\t\t       unsigned char * (* display_proc_gnu_attribute) (unsigned char *, int, const unsigned char * const),\n\t\t       const unsigned char * const end)\n{\n  int tag;\n  unsigned int len;\n  int val;\n\n  tag = read_uleb128 (p, &len, end);\n  p += len;\n\n  /* Tag_compatibility is the only generic GNU attribute defined at\n     present.  */\n"
}