{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "ld/ldctor.c",
    "message": "Offset: [1, 2] (⇐ [0, 1] + 1) Size: 2 by call to `exp_nameop`.",
    "warning_function_name": "ldctor_build_sets",
    "warning_line": "exp_nameop (NAME, \".\"),",
    "warning_context": "\n  lang_list_init (&constructor_list);\n  push_stat_ptr (&constructor_list);\n\n  header_printed = FALSE;\n  for (p = sets; p != NULL; p = p->next)\n    {\n      struct set_element *e;\n      reloc_howto_type *howto;\n      int reloc_size, size;\n\n      /* If the symbol is defined, we may have been invoked from\n\t collect, and the sets may already have been built, so we do\n\t not do anything.  */\n      if (p->h->type == bfd_link_hash_defined\n\t  || p->h->type == bfd_link_hash_defweak)\n\tcontinue;\n\n      /* For each set we build:\n\t   set:\n\t     .long number_of_elements\n\t     .long element0\n\t     ...\n\t     .long elementN\n\t     .long 0\n\t except that we use the right size instead of .long.  When\n\t generating relocatable output, we generate relocs instead of\n\t addresses.  */\n      howto = bfd_reloc_type_lookup (link_info.output_bfd, p->reloc);\n      if (howto == NULL)\n\t{\n\t  if (link_info.relocatable)\n\t    {\n\t      einfo (_(\"%P%X: %s does not support reloc %s for set %s\\n\"),\n\t\t     bfd_get_target (link_info.output_bfd),\n\t\t     bfd_get_reloc_code_name (p->reloc),\n\t\t     p->h->root.string);\n\t      continue;\n\t    }\n\n\t  /* If this is not a relocatable link, all we need is the\n\t     size, which we can get from the input BFD.  */\n\t  if (p->elements->section->owner != NULL)\n\t    howto = bfd_reloc_type_lookup (p->elements->section->owner,\n\t\t\t\t\t   p->reloc);\n\t  if (howto == NULL)\n\t    {\n\t      einfo (_(\"%P%X: %s does not support reloc %s for set %s\\n\"),\n\t\t     bfd_get_target (p->elements->section->owner),\n\t\t     bfd_get_reloc_code_name (p->reloc),\n\t\t     p->h->root.string);\n\t      continue;\n\t    }\n\t}\n\n      reloc_size = bfd_get_reloc_size (howto);\n      switch (reloc_size)\n\t{\n\tcase 1: size = BYTE; break;\n\tcase 2: size = SHORT; break;\n\tcase 4: size = LONG; break;\n\tcase 8:\n\t  if (howto->complain_on_overflow == complain_overflow_signed)\n\t    size = SQUAD;\n\t  else\n\t    size = QUAD;\n\t  break;\n\tdefault:\n\t  einfo (_(\"%P%X: Unsupported size %d for set %s\\n\"),\n\t\t bfd_get_reloc_size (howto), p->h->root.string);\n\t  size = LONG;\n\t  break;\n\t}\n\n      lang_add_assignment (exp_assign (\".\",\n\t\t\t\t       exp_unop (ALIGN_K,\n\t\t\t\t\t\t exp_intop (reloc_size)),\n\t\t\t\t       FALSE));\n      lang_add_assignment (exp_assign (p->h->root.string,\n\t\t\t\t       exp_nameop (NAME, \".\"),\n\t\t\t\t       FALSE));\n      lang_add_data (size, exp_intop (p->count));\n\n      for (e = p->elements; e != NULL; e = e->next)\n\t{\n\t  if (config.map_file != NULL)\n\t    {\n\t      int len;\n\n\t      if (! header_printed)\n\t\t{\n\t\t  minfo (_(\"\\nSet                 Symbol\\n\\n\"));\n\t\t  header_printed = TRUE;\n\t\t}\n\n\t      minfo (\"%s\", p->h->root.string);\n\t      len = strlen (p->h->root.string);\n\n\t      if (len >= 19)\n\t\t{\n\t\t  print_nl ();\n"
}