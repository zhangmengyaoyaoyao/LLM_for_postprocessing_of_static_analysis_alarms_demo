{
    "Project": "grep",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset: [1, +oo] (‚áê [0, +oo] + [1, +oo]) Size: [0, +oo].",
    "Code_line": "          size_t count = table[j];",
    "Code_function": "knuth_morris_pratt_multibyte (const char *haystack, const char *needle,\n                              const char **resultp)\n{\n  size_t m = mbslen (needle);\n  mbchar_t *needle_mbchars;\n  size_t *table;\n\n  /* Allocate room for needle_mbchars and the table.  */\n  void *memory = nmalloca (m, sizeof (mbchar_t) + sizeof (size_t));\n  void *table_memory;\n  if (memory == NULL)\n    return false;\n  needle_mbchars = memory;\n  table_memory = needle_mbchars + m;\n  table = table_memory;\n\n  /* Fill needle_mbchars.  */\n  {\n    mbui_iterator_t iter;\n    size_t j;\n\n    j = 0;\n    for (mbui_init (iter, needle); mbui_avail (iter); mbui_advance (iter), j++)\n      mb_copy (&needle_mbchars[j], &mbui_cur (iter));\n  }\n\n  /* Fill the table.\n     For 0 < i < m:\n       0 < table[i] <= i is defined such that\n       forall 0 < x < table[i]: needle[x..i-1] != needle[0..i-1-x],\n       and table[i] is as large as possible with this property.\n     This implies:\n     1) For 0 < i < m:\n          If table[i] < i,\n          needle[table[i]..i-1] = needle[0..i-1-table[i]].\n     2) For 0 < i < m:\n          rhaystack[0..i-1] == needle[0..i-1]\n          and exists h, i <= h < m: rhaystack[h] != needle[h]\n          implies\n          forall 0 <= x < table[i]: rhaystack[x..x+m-1] != needle[0..m-1].\n     table[0] remains uninitialized.  */\n  {\n    size_t i, j;\n\n    /* i = 1: Nothing to verify for x = 0.  */\n    table[1] = 1;\n    j = 0;\n\n    for (i = 2; i < m; i++)\n      {\n        /* Here: j = i-1 - table[i-1].\n           The inequality needle[x..i-1] != needle[0..i-1-x] is known to hold\n           for x < table[i-1], by induction.\n           Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n        mbchar_t *b = &needle_mbchars[i - 1];\n\n        for (;;)\n          {\n            /* Invariants: The inequality needle[x..i-1] != needle[0..i-1-x]\n               is known to hold for x < i-1-j.\n               Furthermore, if j>0: needle[i-1-j..i-2] = needle[0..j-1].  */\n            if (mb_equal (*b, needle_mbchars[j]))\n              {\n                /* Set table[i] := i-1-j.  */\n                table[i] = i - ++j;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for x = i-1-j, because\n                 needle[i-1] != needle[j] = needle[i-1-x].  */\n            if (j == 0)\n              {\n                /* The inequality holds for all possible x.  */\n                table[i] = i;\n                break;\n              }\n            /* The inequality needle[x..i-1] != needle[0..i-1-x] also holds\n               for i-1-j < x < i-1-j+table[j], because for these x:\n                 needle[x..i-2]\n                 = needle[x-(i-1-j)..j-1]\n                 != needle[0..j-1-(x-(i-1-j))]  (by definition of table[j])\n                    = needle[0..i-2-x],\n               hence needle[x..i-1] != needle[0..i-1-x].\n               Furthermore\n                 needle[i-1-j+table[j]..i-2]\n                 = needle[table[j]..j-1]\n                 = needle[0..j-1-table[j]]  (by definition of table[j]).  */\n            j = j - table[j];\n          }\n        /* Here: j = i - table[i].  */\n      }\n  }\n\n  /* Search, using the table to accelerate the processing.  */\n  {\n    size_t j;\n    mbui_iterator_t rhaystack;\n    mbui_iterator_t phaystack;\n\n    *resultp = NULL;\n    j = 0;\n    mbui_init (rhaystack, haystack);\n    mbui_init (phaystack, haystack);\n    /* Invariant: phaystack = rhaystack + j.  */\n    while (mbui_avail (phaystack))\n      if (mb_equal (needle_mbchars[j], mbui_cur (phaystack)))\n        {\n          j++;\n          mbui_advance (phaystack);\n          if (j == m)\n            {\n              /* The entire needle has been found.  */\n              *resultp = mbui_cur_ptr (rhaystack);\n              break;\n            }\n        }\n      else if (j > 0)\n        {\n          /* Found a match of needle[0..j-1], mismatch at needle[j].  */\n          size_t count = table[j];\n          j -= count;\n          for (; count > 0; count--)\n            {\n              if (!mbui_avail (rhaystack))\n                abort ();\n              mbui_advance (rhaystack);\n            }\n        }\n      else\n        {\n          /* Found a mismatch at needle[0] already.  */\n          if (!mbui_avail (rhaystack))\n            abort ();\n          mbui_advance (rhaystack);\n          mbui_advance (phaystack);\n        }\n  }\n\n  freea (memory);\n  return true;\n}"
}