{
    "project": "tiff",
    "tool": "Infer",
    "category": "NULL_DEREFERENCE",
    "file": "tools/tiff2ps.c",
    "message": "pointer `tf_buf` last assigned on line 2599 could be null and is dereferenced by call to `memset()` at line 2600, column 9.",
    "warning_function_name": "PSDataBW",
    "warning_line": "memset(tf_buf, 0, stripsize);",
    "warning_context": "void\nPSDataBW(FILE* fd, TIFF* tif, uint32 w, uint32 h)\n{\n\tint breaklen = MAXLINE;\n\tunsigned char* tf_buf;\n\tunsigned char* cp;\n\ttsize_t stripsize = TIFFStripSize(tif);\n\ttstrip_t s;\n\n#if defined( EXP_ASCII85ENCODER )\n\ttsize_t\tascii85_l;\t\t/* Length, in bytes, of ascii85_p[] data */\n\tuint8\t*ascii85_p = 0;\t\t/* Holds ASCII85 encoded data */\n#endif\n\n\t(void) w; (void) h;\n\ttf_buf = (unsigned char *) _TIFFmalloc(stripsize);\n        memset(tf_buf, 0, stripsize);\n\tif (tf_buf == NULL) {\n\t\tTIFFError(filename, \"No space for scanline buffer\");\n\t\treturn;\n\t}\n\n#if defined( EXP_ASCII85ENCODER )\n\tif ( ascii85 ) {\n\t    /*\n\t     * Allocate a buffer to hold the ASCII85 encoded data.  Note\n\t     * that it is allocated with sufficient room to hold the\n\t     * encoded data (5*stripsize/4) plus the EOD marker (+8)\n\t     * and formatting line breaks.  The line breaks are more\n\t     * than taken care of by using 6*stripsize/4 rather than\n\t     * 5*stripsize/4.\n\t     */\n\n\t    ascii85_p = _TIFFmalloc( (stripsize+(stripsize/2)) + 8 );\n\n\t    if ( !ascii85_p ) {\n\t\t_TIFFfree( tf_buf );\n\n\t\tTIFFError( filename, \"Cannot allocate ASCII85 encoding buffer.\" );\n\t\treturn;\n\t    }\n\t}\n#endif\n\n\tif (ascii85)\n\t\tAscii85Init();\n\n\tfor (s = 0; s < TIFFNumberOfStrips(tif); s++) {\n\t\ttsize_t cc = TIFFReadEncodedStrip(tif, s, tf_buf, stripsize);\n\t\tif (cc < 0) {\n\t\t\tTIFFError(filename, \"Can't read strip\");\n\t\t\tbreak;\n\t\t}\n\t\tcp = tf_buf;\n\t\tif (photometric == PHOTOMETRIC_MINISWHITE) {\n\t\t\tfor (cp += cc; --cp >= tf_buf;)\n\t\t\t\t*cp = ~*cp;\n\t\t\tcp++;\n\t\t}\n\t\t/*\n\t\t * for 16 bits, the two bytes must be most significant\n\t\t * byte first\n\t\t */\n\t\tif (bitspersample == 16 && !HOST_BIGENDIAN) {\n\t\t\tPS_FlipBytes(cp, cc);\n\t\t}\n\t\tif (ascii85) {\n#if defined( EXP_ASCII85ENCODER )\n\t\t\tif (alpha) {\n\t\t\t\tint adjust, i;\n\t\t\t\tfor (i = 0; i < cc; i+=2) {\n\t\t\t\t\tadjust = 255 - cp[i + 1];\n\t\t\t\t    cp[i / 2] = cp[i] + adjust;\n\t\t\t\t}\n\t\t\t\tcc /= 2;\n\t\t\t}\n\n\t\t\tascii85_l = Ascii85EncodeBlock( ascii85_p, 1, cp, cc );\n\n\t\t\tif ( ascii85_l > 0 )\n\t\t\t    fwrite( ascii85_p, ascii85_l, 1, fd );\n#else\n\t\t\twhile (cc-- > 0)\n\t\t\t\tAscii85Put(*cp++, fd);\n#endif /* EXP_ASCII85_ENCODER */\n\t\t} else {\n\t\t\tunsigned char c;\n\n\t\t\tif (alpha) {\n\t\t\t\tint adjust;\n\t\t\t\twhile (cc-- > 0) {\n\t\t\t\t\tDOBREAK(breaklen, 1, fd);\n\t\t\t\t\t/*\n\t\t\t\t\t * For images with alpha, matte against\n\t\t\t\t\t * a white background; i.e.\n\t\t\t\t\t *    Cback * (1 - Aimage)\n\t\t\t\t\t * where Cback = 1.\n\t\t\t\t\t */\n\t\t\t\t\tadjust = 255 - cp[1];\n\t\t\t\t\tc = *cp++ + adjust; PUTHEX(c,fd);\n\t\t\t\t\tcp++, cc--;\n"
}