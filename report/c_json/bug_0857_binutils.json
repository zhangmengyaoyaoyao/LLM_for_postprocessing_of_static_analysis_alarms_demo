{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);",
    "Code_function": "scan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;\n  int nesting_level = 1;\n  struct funcinfo **nested_funcs;\n  int nested_funcs_size;\n\n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct funcinfo **)\n    bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));\n  if (nested_funcs == NULL)\n    return FALSE;\n  nested_funcs[nesting_level] = 0;\n\n  while (nesting_level)\n    {\n      unsigned int abbrev_number, bytes_read, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bfd_boolean high_pc_relative = FALSE;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      abbrev_number = safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, info_ptr_end);\n      info_ptr += bytes_read;\n\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number,unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t     abbrev_number);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  bfd_size_type amt = sizeof (struct funcinfo);\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  unit->function_table = func;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level - 1; i >= 1; i--)\n\t      if (nested_funcs[i])\n\t\t{\n\t\t  func->caller_func = nested_funcs[i];\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level] = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable)\n\t    {\n\t      bfd_size_type amt = sizeof (struct varinfo);\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = 1;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      BFD_ASSERT (!unit->cached);\n\t    }\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level] = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  func->name = find_abstract_instance_name (unit, &attr,\n\t\t\t\t\t\t\t    &func->is_linkage);\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (non_mangled (unit->lang))\n\t\t\tfunc->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  high_pc = attr.u.val;\n\t\t  high_pc_relative = attr.form != DW_FORM_addr;\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (!read_rangelist (unit, &func->arange, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\tattr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  var->file = concat_filename (unit->line_table,\n\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (attr.u.val != 0)\n\t\t    var->stack = 0;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (*attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = 0;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, low_pc, high_pc))\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct funcinfo **tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct funcinfo **)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (struct funcinfo *));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level] = 0;\n\t}\n    }\n\n  free (nested_funcs);\n  return TRUE;\n\n fail:\n  free (nested_funcs);\n  return FALSE;\n}"
}