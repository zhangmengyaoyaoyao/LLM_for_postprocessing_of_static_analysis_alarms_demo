{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/dwarf2.c",
    "message": "Offset added: [-20, 411] (⇐ [-204, 227] + 184) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "parse_comp_unit",
    "warning_line": "unit = (struct comp_unit *) bfd_zalloc (abfd, amt);",
    "warning_context": "  bfd_uint64_t abbrev_offset = 0;\n  unsigned int addr_size;\n  struct abbrev_info** abbrevs;\n  unsigned int abbrev_number, bytes_read, i;\n  struct abbrev_info *abbrev;\n  struct attribute attr;\n  bfd_byte *info_ptr = stash->info_ptr;\n  bfd_byte *end_ptr = info_ptr + unit_length;\n  bfd_size_type amt;\n  bfd_vma low_pc = 0;\n  bfd_vma high_pc = 0;\n  bfd *abfd = stash->bfd_ptr;\n  bfd_boolean high_pc_relative = FALSE;\n\n  version = read_2_bytes (abfd, info_ptr, end_ptr);\n  info_ptr += 2;\n  BFD_ASSERT (offset_size == 4 || offset_size == 8);\n  if (offset_size == 4)\n    abbrev_offset = read_4_bytes (abfd, info_ptr, end_ptr);\n  else\n    abbrev_offset = read_8_bytes (abfd, info_ptr, end_ptr);\n  info_ptr += offset_size;\n  addr_size = read_1_byte (abfd, info_ptr, end_ptr);\n  info_ptr += 1;\n\n  if (version != 2 && version != 3 && version != 4)\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: found dwarf version '%u', this reader\"\n\t   \" only handles version 2, 3 and 4 information.\"), version);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  if (addr_size > sizeof (bfd_vma))\n    {\n      (*_bfd_error_handler)\n\t(_(\"Dwarf Error: found address size '%u', this reader\"\n\t   \" can not handle sizes greater than '%u'.\"),\n\t addr_size,\n\t (unsigned int) sizeof (bfd_vma));\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  if (addr_size != 2 && addr_size != 4 && addr_size != 8)\n    {\n      (*_bfd_error_handler)\n\t(\"Dwarf Error: found address size '%u', this reader\"\n\t \" can only handle address sizes '2', '4' and '8'.\", addr_size);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  /* Read the abbrevs for this compilation unit into a table.  */\n  abbrevs = read_abbrevs (abfd, abbrev_offset, stash);\n  if (! abbrevs)\n    return 0;\n\n  abbrev_number = safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, end_ptr);\n  info_ptr += bytes_read;\n  if (! abbrev_number)\n    {\n      (*_bfd_error_handler) (_(\"Dwarf Error: Bad abbrev number: %u.\"),\n\t\t\t     abbrev_number);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  abbrev = lookup_abbrev (abbrev_number, abbrevs);\n  if (! abbrev)\n    {\n      (*_bfd_error_handler) (_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t\t\t     abbrev_number);\n      bfd_set_error (bfd_error_bad_value);\n      return 0;\n    }\n\n  amt = sizeof (struct comp_unit);\n  unit = (struct comp_unit *) bfd_zalloc (abfd, amt);\n  if (unit == NULL)\n    return NULL;\n  unit->abfd = abfd;\n  unit->version = version;\n  unit->addr_size = addr_size;\n  unit->offset_size = offset_size;\n  unit->abbrevs = abbrevs;\n  unit->end_ptr = end_ptr;\n  unit->stash = stash;\n  unit->info_ptr_unit = info_ptr_unit;\n  unit->sec_info_ptr = stash->sec_info_ptr;\n\n  for (i = 0; i < abbrev->num_attrs; ++i)\n    {\n      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, end_ptr);\n      if (info_ptr == NULL)\n\treturn NULL;\n\n      /* Store the data if it is of an attribute we want to keep in a\n\t partial symbol table.  */\n      switch (attr.name)\n"
}