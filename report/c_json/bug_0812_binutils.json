{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-25, 61] (‚áê [-29, 52] + [4, 9]) Size: 4064 by call to `bfd_zalloc`.",
    "Code_line": "\t      newstring = (char *) bfd_zalloc (abfd, (bfd_size_type) (i + 1));",
    "Code_function": "coff_get_normalized_symtab (bfd *abfd)\n{\n  combined_entry_type *internal;\n  combined_entry_type *internal_ptr;\n  combined_entry_type *symbol_ptr;\n  combined_entry_type *internal_end;\n  size_t symesz;\n  char *raw_src;\n  char *raw_end;\n  const char *string_table = NULL;\n  asection * debug_sec = NULL;\n  char *debug_sec_data = NULL;\n  bfd_size_type size;\n\n  if (obj_raw_syments (abfd) != NULL)\n    return obj_raw_syments (abfd);\n\n  if (! _bfd_coff_get_external_symbols (abfd))\n    return NULL;\n\n  size = obj_raw_syment_count (abfd) * sizeof (combined_entry_type);\n  internal = (combined_entry_type *) bfd_zalloc (abfd, size);\n  if (internal == NULL && size != 0)\n    return NULL;\n  internal_end = internal + obj_raw_syment_count (abfd);\n\n  raw_src = (char *) obj_coff_external_syms (abfd);\n\n  /* Mark the end of the symbols.  */\n  symesz = bfd_coff_symesz (abfd);\n  raw_end = (char *) raw_src + obj_raw_syment_count (abfd) * symesz;\n\n  /* FIXME SOMEDAY.  A string table size of zero is very weird, but\n     probably possible.  If one shows up, it will probably kill us.  */\n\n  /* Swap all the raw entries.  */\n  for (internal_ptr = internal;\n       raw_src < raw_end;\n       raw_src += symesz, internal_ptr++)\n    {\n      unsigned int i;\n\n      bfd_coff_swap_sym_in (abfd, (void *) raw_src,\n\t\t\t    (void *) & internal_ptr->u.syment);\n      symbol_ptr = internal_ptr;\n      internal_ptr->is_sym = TRUE;\n\n      /* PR 17512: file: 1353-1166-0.004.  */\n      if (symbol_ptr->u.syment.n_sclass == C_FILE\n\t  && symbol_ptr->u.syment.n_numaux > 0\n\t  && raw_src + symesz + symbol_ptr->u.syment.n_numaux\n\t  * symesz > raw_end)\n\t{\n\t  bfd_release (abfd, internal);\n\t  return NULL;\n\t}\n\n      for (i = 0;\n\t   i < symbol_ptr->u.syment.n_numaux;\n\t   i++)\n\t{\n\t  internal_ptr++;\n\t  /* PR 17512: Prevent buffer overrun.  */\n\t  if (internal_ptr >= internal_end)\n\t    {\n\t      bfd_release (abfd, internal);\n\t      return NULL;\n\t    }\n\n\t  raw_src += symesz;\n\t  bfd_coff_swap_aux_in (abfd, (void *) raw_src,\n\t\t\t\tsymbol_ptr->u.syment.n_type,\n\t\t\t\tsymbol_ptr->u.syment.n_sclass,\n\t\t\t\t(int) i, symbol_ptr->u.syment.n_numaux,\n\t\t\t\t&(internal_ptr->u.auxent));\n\n\t  internal_ptr->is_sym = FALSE;\n\t  coff_pointerize_aux (abfd, internal, symbol_ptr, i,\n\t\t\t       internal_ptr);\n\t}\n    }\n\n  /* Free the raw symbols, but not the strings (if we have them).  */\n  obj_coff_keep_strings (abfd) = TRUE;\n  if (! _bfd_coff_free_symbols (abfd))\n    return NULL;\n\n  for (internal_ptr = internal; internal_ptr < internal_end;\n       internal_ptr++)\n    {\n      BFD_ASSERT (internal_ptr->is_sym);\n\n      if (internal_ptr->u.syment.n_sclass == C_FILE\n\t  && internal_ptr->u.syment.n_numaux > 0)\n\t{\n\t  combined_entry_type * aux = internal_ptr + 1;\n\n\t  /* Make a file symbol point to the name in the auxent, since\n\t     the text \".file\" is redundant.  */\n\t  BFD_ASSERT (! aux->is_sym);\n\n\t  if (aux->u.auxent.x_file.x_n.x_zeroes == 0)\n\t    {\n\t      /* The filename is a long one, point into the string table.  */\n\t      if (string_table == NULL)\n\t\t{\n\t\t  string_table = _bfd_coff_read_string_table (abfd);\n\t\t  if (string_table == NULL)\n\t\t    return NULL;\n\t\t}\n\n\t      if ((bfd_size_type)(aux->u.auxent.x_file.x_n.x_offset)\n\t\t  >= obj_coff_strings_len (abfd))\n\t\tinternal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _(\"<corrupt>\");\n\t      else\n\t\tinternal_ptr->u.syment._n._n_n._n_offset =\n\t\t  (bfd_hostptr_t) (string_table + (aux->u.auxent.x_file.x_n.x_offset));\n\t    }\n\t  else\n\t    {\n\t      /* Ordinary short filename, put into memory anyway.  The\n                 Microsoft PE tools sometimes store a filename in\n                 multiple AUX entries.  */\n\t      if (internal_ptr->u.syment.n_numaux > 1\n\t\t  && coff_data (abfd)->pe)\n\t\tinternal_ptr->u.syment._n._n_n._n_offset =\n\t\t  (bfd_hostptr_t)\n\t\t  copy_name (abfd,\n\t\t\t     aux->u.auxent.x_file.x_fname,\n\t\t\t     internal_ptr->u.syment.n_numaux * symesz);\n\t      else\n\t\tinternal_ptr->u.syment._n._n_n._n_offset =\n\t\t  ((bfd_hostptr_t)\n\t\t   copy_name (abfd,\n\t\t\t      aux->u.auxent.x_file.x_fname,\n\t\t\t      (size_t) bfd_coff_filnmlen (abfd)));\n\t    }\n\t}\n      else\n\t{\n\t  if (internal_ptr->u.syment._n._n_n._n_zeroes != 0)\n\t    {\n\t      /* This is a \"short\" name.  Make it long.  */\n\t      size_t i;\n\t      char *newstring;\n\n\t      /* Find the length of this string without walking into memory\n\t         that isn't ours.  */\n\t      for (i = 0; i < 8; ++i)\n\t\tif (internal_ptr->u.syment._n._n_name[i] == '\\0')\n\t\t  break;\n\n\t      newstring = (char *) bfd_zalloc (abfd, (bfd_size_type) (i + 1));\n\t      if (newstring == NULL)\n\t\treturn NULL;\n\t      strncpy (newstring, internal_ptr->u.syment._n._n_name, i);\n\t      internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) newstring;\n\t      internal_ptr->u.syment._n._n_n._n_zeroes = 0;\n\t    }\n\t  else if (internal_ptr->u.syment._n._n_n._n_offset == 0)\n\t    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) \"\";\n\t  else if (!bfd_coff_symname_in_debug (abfd, &internal_ptr->u.syment))\n\t    {\n\t      /* Long name already.  Point symbol at the string in the\n                 table.  */\n\t      if (string_table == NULL)\n\t\t{\n\t\t  string_table = _bfd_coff_read_string_table (abfd);\n\t\t  if (string_table == NULL)\n\t\t    return NULL;\n\t\t}\n\t      if (internal_ptr->u.syment._n._n_n._n_offset >= obj_coff_strings_len (abfd)\n\t\t  || string_table + internal_ptr->u.syment._n._n_n._n_offset < string_table)\n\t\tinternal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _(\"<corrupt>\");\n\t      else\n\t\tinternal_ptr->u.syment._n._n_n._n_offset =\n\t\t  ((bfd_hostptr_t)\n\t\t   (string_table\n\t\t    + internal_ptr->u.syment._n._n_n._n_offset));\n\t    }\n\t  else\n\t    {\n\t      /* Long name in debug section.  Very similar.  */\n\t      if (debug_sec_data == NULL)\n\t\tdebug_sec_data = build_debug_section (abfd, & debug_sec);\n\t      if (debug_sec_data != NULL)\n\t\t{\n\t\t  BFD_ASSERT (debug_sec != NULL);\n\t\t  /* PR binutils/17512: Catch out of range offsets into the debug data.  */\n\t\t  if (internal_ptr->u.syment._n._n_n._n_offset > debug_sec->size\n\t\t      || debug_sec_data + internal_ptr->u.syment._n._n_n._n_offset < debug_sec_data)\n\t\t    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _(\"<corrupt>\");\n\t\t  else\n\t\t    internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t)\n\t\t      (debug_sec_data + internal_ptr->u.syment._n._n_n._n_offset);\n\t\t}\n\t      else\n\t\tinternal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) \"\";\n\t    }\n\t}\n      internal_ptr += internal_ptr->u.syment.n_numaux;\n    }\n\n  obj_raw_syments (abfd) = internal;\n  BFD_ASSERT (obj_raw_syment_count (abfd)\n\t      == (unsigned int) (internal_ptr - internal));\n\n  return internal;\n}"
}