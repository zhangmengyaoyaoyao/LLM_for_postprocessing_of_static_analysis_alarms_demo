{
    "Project": "apr",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "        if (*p != '\\0')                         /* Argument inline */",
    "Code_function": "APR_DECLARE(apr_status_t) apr_getopt_long(apr_getopt_t *os,\n                                          const apr_getopt_option_t *opts,\n                                          int *optch, const char **optarg)\n{\n    const char *p;\n    int i;\n\n    /* Let the calling program reset option processing. */\n    if (os->reset) {\n        os->place = EMSG;\n        os->ind = 1;\n        os->reset = 0;\n    }\n\n    /*\n     * We can be in one of two states: in the middle of processing a\n     * run of short options, or about to process a new argument.\n     * Since the second case can lead to the first one, handle that\n     * one first.  */\n    p = os->place;\n    if (*p == '\\0') {\n        /* If we are interleaving, skip non-option arguments. */\n        if (os->interleave) {\n            while (os->ind < os->argc && *os->argv[os->ind] != '-')\n                os->ind++;\n            os->skip_end = os->ind;\n        }\n        if (os->ind >= os->argc || *os->argv[os->ind] != '-') {\n            os->ind = os->skip_start;\n            return APR_EOF;\n        }\n\n        p = os->argv[os->ind++] + 1;\n        if (*p == '-' && p[1] != '\\0') {        /* Long option */\n            /* Search for the long option name in the caller's table. */\n            apr_size_t len = 0;\n\n            p++;\n            for (i = 0; ; i++) {\n                if (opts[i].optch == 0)             /* No match */\n                    return serr(os, \"invalid option\", p - 2, APR_BADCH);\n\n                if (opts[i].name) {\n                    len = strlen(opts[i].name);\n                    if (strncmp(p, opts[i].name, len) == 0\n                        && (p[len] == '\\0' || p[len] == '='))\n                        break;\n                }\n            }\n            *optch = opts[i].optch;\n\n            if (opts[i].has_arg) {\n                if (p[len] == '=')             /* Argument inline */\n                    *optarg = p + len + 1;\n                else {\n                    if (os->ind >= os->argc)   /* Argument missing */\n                        return serr(os, \"missing argument\", p - 2, APR_BADARG);\n                    else                       /* Argument in next arg */\n                        *optarg = os->argv[os->ind++];\n                }\n            } else {\n                *optarg = NULL;\n                if (p[len] == '=')\n                    return serr(os, \"erroneous argument\", p - 2, APR_BADARG);\n            }\n            permute(os);\n            return APR_SUCCESS;\n        } else {\n            if (*p == '-') {                 /* Bare \"--\"; we're done */\n                permute(os);\n                os->ind = os->skip_start;\n                return APR_EOF;\n            }\n            else\n                if (*p == '\\0')                    /* Bare \"-\" is illegal */\n                    return serr(os, \"invalid option\", p, APR_BADCH);\n        }\n    }\n\n    /*\n     * Now we're in a run of short options, and *p is the next one.\n     * Look for it in the caller's table.\n     */\n    for (i = 0; ; i++) {\n        if (opts[i].optch == 0)                     /* No match */\n            return cerr(os, \"invalid option character\", *p, APR_BADCH);\n\n        if (*p == opts[i].optch)\n            break;\n    }\n    *optch = *p++;\n\n    if (opts[i].has_arg) {\n        if (*p != '\\0')                         /* Argument inline */\n            *optarg = p;\n        else {\n            if (os->ind >= os->argc)           /* Argument missing */\n                return cerr(os, \"missing argument\", *optch, APR_BADARG);\n            else                               /* Argument in next arg */\n                *optarg = os->argv[os->ind++];\n        }\n        os->place = EMSG;\n    } else {\n        *optarg = NULL;\n        os->place = p;\n    }\n\n    permute(os);\n    return APR_SUCCESS;\n}"
}