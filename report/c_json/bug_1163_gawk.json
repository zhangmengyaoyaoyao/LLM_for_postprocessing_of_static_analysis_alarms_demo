{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "io.c",
    "message": "Offset: `redir_exp->sub.val.slen` Size: [0, `redir_exp->sub.val.slen` + 1].",
    "warning_function_name": "redirect",
    "warning_line": "str[redir_exp->stlen] = '\\0';",
    "warning_context": "\tdefault:\n\t\tcant_happen();\n\t}\n\tif (do_lint && (redir_exp->flags & STRCUR) == 0)\n\t\tlintwarn(_(\"expression in `%s' redirection only has numeric value\"),\n\t\t\twhat);\n\tredir_exp = force_string(redir_exp);\n\tstr = redir_exp->stptr;\n\n\tif (str == NULL || *str == '\\0')\n\t\tfatal(_(\"expression for `%s' redirection has null string value\"),\n\t\t\twhat);\n\n\tif (do_lint && (strncmp(str, \"0\", redir_exp->stlen) == 0\n\t\t\t|| strncmp(str, \"1\", redir_exp->stlen) == 0))\n\t\tlintwarn(_(\"filename `%s' for `%s' redirection may be result of logical expression\"),\n\t\t\t\tstr, what);\n\n#ifdef HAVE_SOCKETS\n\t/*\n\t * Use /inet4 to force IPv4, /inet6 to force IPv6, and plain\n\t * /inet will be whatever we get back from the system.\n\t */\n\tif (inetfile(str, & isi)) {\n\t\ttflag |= RED_SOCKET;\n\t\tif (isi.protocol == SOCK_STREAM)\n\t\t\ttflag |= RED_TCP;\t/* use shutdown when closing */\n\t}\n#endif /* HAVE_SOCKETS */\n\n\tfor (rp = red_head; rp != NULL; rp = rp->next) {\n#ifndef PIPES_SIMULATED\n\t\t/*\n\t\t * This is an efficiency hack.  We want to\n\t\t * recover the process slot for dead children,\n\t\t * if at all possible.  Messing with signal() for\n\t\t * SIGCLD leads to lots of headaches.  However, if\n\t\t * we've gotten EOF from a child input pipeline, it's\n\t\t * a good bet that the child has died. So recover it.\n\t\t */\n\t\tif ((rp->flag & RED_EOF) != 0 && redirtype == redirect_pipein) {\n\t\t\tif (rp->pid != -1)\n#ifdef __MINGW32__\n\t\t\t\t/* MinGW cannot wait for any process.  */\n\t\t\t\twait_any(rp->pid);\n#else\n\t\t\t\twait_any(0);\n#endif\n\t\t}\n#endif /* PIPES_SIMULATED */\n\n\t\t/* now check for a match */\n\t\tif (strlen(rp->value) == redir_exp->stlen\n\t\t    && memcmp(rp->value, str, redir_exp->stlen) == 0\n\t\t    && ((rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY)) == tflag\n\t\t\t|| (outflag != 0\n\t\t\t    && (rp->flag & (RED_FILE|RED_WRITE)) == outflag))) {\n\n\t\t\tint rpflag = (rp->flag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\t\t\tint newflag = (tflag & ~(RED_NOBUF|RED_EOF|RED_PTY));\n\n\t\t\tif (do_lint && rpflag != newflag)\n\t\t\t\tlintwarn(\n\t\t_(\"unnecessary mixing of `>' and `>>' for file `%.*s'\"),\n\t\t\t\t\t(int) redir_exp->stlen, rp->value);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rp == NULL) {\n\t\tnew_rp = true;\n\t\tif (save_rp != NULL) {\n\t\t\trp = save_rp;\n\t\t\tefree(rp->value);\n\t\t} else\n\t\t\temalloc(rp, struct redirect *, sizeof(struct redirect), \"redirect\");\n\t\temalloc(str, char *, redir_exp->stlen + 1, \"redirect\");\n\t\tmemcpy(str, redir_exp->stptr, redir_exp->stlen);\n\t\tstr[redir_exp->stlen] = '\\0';\n\t\trp->value = str;\n\t\trp->flag = tflag;\n\t\tinit_output_wrapper(& rp->output);\n\t\trp->output.name = str;\n\t\trp->iop = NULL;\n\t\trp->pid = -1;\n\t\trp->status = 0;\n\t} else\n\t\tstr = rp->value;\t/* get \\0 terminated string */\n\tsave_rp = rp;\n\n\twhile (rp->output.fp == NULL && rp->iop == NULL) {\n\t\tif (! new_rp && (rp->flag & RED_EOF) != 0) {\n\t\t\t/*\n\t\t\t * Encountered EOF on file or pipe -- must be cleared\n\t\t\t * by explicit close() before reading more\n\t\t\t */\n\t\t\tsave_rp = NULL;\n\t\t\treturn rp;\n\t\t}\n\t\tmode = NULL;\n"
}