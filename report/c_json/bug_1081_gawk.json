{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "main.c",
    "message": "Offset: [1, +oo] Size: [0, +oo] by call to `make_str_node`.",
    "warning_function_name": "main",
    "warning_line": "Nnull_string = make_string(\"\", 0);",
    "warning_context": "int\nmain(int argc, char **argv)\n{\n\tint i;\n\tchar *extra_stack;\n\tint have_srcfile = 0;\n\tSRCFILE *s;\n\n\t/* do these checks early */\n\tif (getenv(\"TIDYMEM\") != NULL)\n\t\tdo_flags |= DO_TIDY_MEM;\n\n#ifdef HAVE_MCHECK_H\n#ifdef HAVE_MTRACE\n\tif (do_tidy_mem)\n\t\tmtrace();\n#endif /* HAVE_MTRACE */\n#endif /* HAVE_MCHECK_H */\n\n\tmyname = gawk_name(argv[0]);\n\tos_arg_fixup(&argc, &argv); /* emulate redirection, expand wildcards */\n\n\tif (argc < 2)\n\t\tusage(EXIT_FAILURE, stderr);\n\n\t(void) bindtextdomain(PACKAGE, LOCALEDIR);\n\t(void) textdomain(PACKAGE);\n\n\t(void) signal(SIGFPE, catchsig);\n#ifdef SIGBUS\n\t(void) signal(SIGBUS, catchsig);\n#endif\n#ifdef SIGPIPE\n\t/*\n\t * Ignore SIGPIPE so that writes to pipes that fail don't\n\t * kill the process but instead return -1 and set errno.\n\t * That lets us print a fatal message instead of dieing suddenly.\n\t *\n\t * Note that this requires ignoring EPIPE when writing and\n\t * flushing stdout/stderr in other parts of the program. E.g.,\n\t *\n\t * \tgawk 'BEGIN { print \"hi\" }' | exit\n\t *\n\t * should not give us \"broken pipe\" messages --- mainly because\n\t * it did not do so in the past and people would complain.\n\t */\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\n\t(void) sigsegv_install_handler(catchsegv);\n#define STACK_SIZE (16*1024)\n\temalloc(extra_stack, char *, STACK_SIZE, \"main\");\n\t(void) stackoverflow_install_handler(catchstackoverflow, extra_stack, STACK_SIZE);\n#undef STACK_SIZE\n\n\t/* initialize the null string */\n\tNnull_string = make_string(\"\", 0);\n\n\t/* Robustness: check that file descriptors 0, 1, 2 are open */\n\tinit_fds();\n\n\t/* init array handling. */\n\tarray_init();\n\n\t/* init the symbol tables */\n\tinit_symbol_table();\n\n\toutput_fp = stdout;\n\n\t/* initialize global (main) execution context */\n\tpush_context(new_context());\n\n\tparse_args(argc, argv);\n\n\tset_locale_stuff();\n\n\t/*\n\t * In glibc, MB_CUR_MAX is actually a function.  This value is\n\t * tested *a lot* in many speed-critical places in gawk. Caching\n\t * this value once makes a speed difference.\n\t */\n\tgawk_mb_cur_max = MB_CUR_MAX;\n#ifdef LIBC_IS_BORKED\n{\n\tconst char *env_lc;\n\n\tenv_lc = getenv(\"LC_ALL\");\n\tif (env_lc == NULL)\n\t\tenv_lc = getenv(\"LANG\");\n\tif (env_lc != NULL && env_lc[1] == '\\0' && tolower(env_lc[0]) == 'c')\n\t\tgawk_mb_cur_max = 1;\n}\n#endif\n\n\t/* init the cache for checking bytes if they're characters */\n\tinit_btowc_cache();\n\n\n\tif (do_nostalgia)\n\t\tnostalgia();\n\n"
}