{
    "Project": "combine",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/process_files.c",
    "message": "The value read from hash_index was never initialized.",
    "warning_function_name": "process_data_reference_matches",
    "warning_line": "hash_index",
    "warning_context": "      for (ifield = 0;\n\t   ifield < gi_data_out_range_count + (gi_data_out_end_start != 0 ? 1\n\t\t\t\t\t       : 0); ifield++) {\n\tcreate_scheme_string_variable (&df_name_data_field, ifield + 1,\n\t\t\t\t       data_output_fields[ifield]);\n\t}\n\n      for (ifield = 0;\n\t   ifield\n\t   < REFINFO[reference_file_number].out_range_count\n\t   + (REFINFO[reference_file_number].out_end_start != 0 ? 1 : 0);\n\t   ifield++) {\n\tcreate_scheme_string_variable (&df_name_reference_field, ifield + 1,\n\t\t\t\t       REFINFO[reference_file_number]\n\t\t\t\t       .hash_table[hash_index]\n\t\t\t\t       .output_fields[ifield]);\n\t}\n\n\n      command_string\n\t= strdupdstr (REFINFO[reference_file_number].ext_match_command);\n      if (command_string == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      still_keep_match = eval_scheme_boolean_function (command_string);\n      free (command_string);\n      if (!still_keep_match)\n\tkeep_match = 0;\n      }\n#  endif /* HAVE_LIBGUILE */\n\n    if ((hash_index == -1 || keep_match != 1) && gi_reference_file_count != 0) {\n      /* If necessary, invalidate writing. */\n      if (gi_reference_file_count != 0\n\t  && REFINFO[reference_file_number].optional_ind == 0)\n\t*write_record = 0;\n      }\n    else if (gi_reference_file_count != 0 && keep_match == 1) {\n      /* We need to traverse the hierarchy if requested.  Otherwise, treat this match. */\n      if (REFINFO[reference_file_number].hrchy_key_range_count != 0\n\t  || REFINFO[reference_file_number].hrchy_key_end_start != 0) {\n\ttraverse_hierarchy (data_output_fields, reference_file_number,\n\t\t\t    write_record, input_record_desc, hash_index, 0);\n\t}\n      /* Update flags, counters, and sums. */\n      else\n\tupdate_counters (reference_file_number, hash_index, data_output_fields,\n\t\t\t input_record_desc);\n      }\n\n    if (keep_match != 1 || gi_reference_file_count == 0\n\t|| (REFINFO[reference_file_number].hrchy_key_range_count == 0\n\t    && REFINFO[reference_file_number].hrchy_key_end_start == 0)) {\n      /* Either continue with next reference file or write. */\n      if (keep_match == 1 && gi_reference_file_count != 0)\n\tREFINFO[reference_file_number].current_hash_selection = hash_index;\n      else if (gi_reference_file_count != 0)\n\tREFINFO[reference_file_number].current_hash_selection = -1;\n      if (*write_record == 0 && gi_checkallref_ind == 0) {\n\tdstrfree (key_value);\n\treturn EXIT_SUCCESS;\n\t}\n      if (reference_file_number < gi_reference_file_count - 1) {\n\tprocess_data_reference_matches (data_output_fields,\n\t\t\t\t\treference_file_number + 1, write_record,\n\t\t\t\t\tinput_record_desc);\n\t}\n      else {\t\t\t/* We're at the end of the line, so write the record */\n\tif (*write_record != 0 && gi_data_write_ind == 1) {\n\t  int return_code;\n\t  write_match_record (data_output_fields);\n\t  }\n\t}\n      }\n\n    /* Find the next hash key if any TEST */\n    if (gi_reference_file_count > 0 && hash_index != -1\n\t&& REFINFO[reference_file_number].hash_table[hash_index].another_for_key\n\t!= 0) {\n      do {\n\thash_index\n\t  = (hash_index + 1) % REFINFO[reference_file_number].hash_size;\n\t}\n      while (dstrcmp\n\t     (REFINFO[reference_file_number].hash_table[hash_index].value,\n\t      key_value) != 0);\n      }\n    else\n      hash_index = REFINFO[reference_file_number].hash_size + 1;\n  } while (gi_reference_file_count > 0\n\t     && hash_index != REFINFO[reference_file_number].hash_size + 1);\n/*\n  dstrfree (key_value);\n */\n  return EXIT_SUCCESS;\n  }\n\n\n/********\n * For each reference file we are to write output from, write a record for each record\n *   stored in our hash table adding on flags, counters, and sums as appropriate.\n */\n"
}