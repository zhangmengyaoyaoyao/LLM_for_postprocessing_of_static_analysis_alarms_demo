{
    "project": "bash",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "execute_cmd.c",
    "message": "Access to field 'flags' results in a dereference of a null pointer (loaded from variable 'cond')",
    "warning_function_name": "execute_cond_node",
    "warning_line": "invert = (cond->flags & CMD_INVERT_RETURN);",
    "warning_context": "static int\nexecute_cond_node (cond)\n     COND_COM *cond;\n{\n  int result, invert, patmatch, rmatch, mflags, ignore;\n  char *arg1, *arg2;\n#if 0\n  char *t1, *t2;\n#endif\n\n  invert = (cond->flags & CMD_INVERT_RETURN);\n  ignore = (cond->flags & CMD_IGNORE_RETURN);\n  if (ignore)\n    {\n      if (cond->left)\n\tcond->left->flags |= CMD_IGNORE_RETURN;\n      if (cond->right)\n\tcond->right->flags |= CMD_IGNORE_RETURN;\n    }\n      \n  if (cond->type == COND_EXPR)\n    result = execute_cond_node (cond->left);\n  else if (cond->type == COND_OR)\n    {\n      result = execute_cond_node (cond->left);\n      if (result != EXECUTION_SUCCESS)\n\tresult = execute_cond_node (cond->right);\n    }\n  else if (cond->type == COND_AND)\n    {\n      result = execute_cond_node (cond->left);\n      if (result == EXECUTION_SUCCESS)\n\tresult = execute_cond_node (cond->right);\n    }\n  else if (cond->type == COND_UNARY)\n    {\n      if (ignore)\n\tcomsub_ignore_return++;\n      arg1 = cond_expand_word (cond->left->op, 0);\n      if (ignore)\n\tcomsub_ignore_return--;\n      if (arg1 == 0)\n\targ1 = nullstr;\n      if (echo_command_at_execute)\n\txtrace_print_cond_term (cond->type, invert, cond->op, arg1, (char *)NULL);\n      result = unary_test (cond->op->word, arg1) ? EXECUTION_SUCCESS : EXECUTION_FAILURE;\n      if (arg1 != nullstr)\n\tfree (arg1);\n    }\n  else if (cond->type == COND_BINARY)\n    {\n      rmatch = 0;\n      patmatch = (((cond->op->word[1] == '=') && (cond->op->word[2] == '\\0') &&\n\t\t   (cond->op->word[0] == '!' || cond->op->word[0] == '=')) ||\n\t\t  (cond->op->word[0] == '=' && cond->op->word[1] == '\\0'));\n#if defined (COND_REGEXP)\n      rmatch = (cond->op->word[0] == '=' && cond->op->word[1] == '~' &&\n\t\tcond->op->word[2] == '\\0');\n#endif\n\n      if (ignore)\n\tcomsub_ignore_return++;\n      arg1 = cond_expand_word (cond->left->op, 0);\n      if (ignore)\n\tcomsub_ignore_return--;\n      if (arg1 == 0)\n\targ1 = nullstr;\n      if (ignore)\n\tcomsub_ignore_return++;\n      arg2 = cond_expand_word (cond->right->op,\n\t\t\t       (rmatch && shell_compatibility_level > 31) ? 2 : (patmatch ? 1 : 0));\n      if (ignore)\n\tcomsub_ignore_return--;\n      if (arg2 == 0)\n\targ2 = nullstr;\n\n      if (echo_command_at_execute)\n\txtrace_print_cond_term (cond->type, invert, cond->op, arg1, arg2);\n\n#if defined (COND_REGEXP)\n      if (rmatch)\n\t{\n\t  mflags = SHMAT_PWARN;\n#if defined (ARRAY_VARS)\n\t  mflags |= SHMAT_SUBEXP;\n#endif\n\n#if 0\n\t  t1 = strescape(arg1);\n\t  t2 = strescape(arg2);\n\t  itrace(\"execute_cond_node: sh_regmatch on `%s' and `%s'\", t1, t2);\n\t  free(t1);\n\t  free(t2);\n#endif\n\n\t  result = sh_regmatch (arg1, arg2, mflags);\n\t}\n      else\n#endif /* COND_REGEXP */\n\t{\n\t  int oe;\n"
}