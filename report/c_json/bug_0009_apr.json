{
    "Project": "apr",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "file_io/unix/filepath.c",
    "message": "Offset: [1, +oo] (⇐ [0, +oo] + 1) Size: 1.",
    "warning_function_name": "apr_filepath_merge",
    "warning_line": "else if (seglen == 2 && addpath[0] == '.' && addpath[1] == '.') {",
    "warning_context": "         */\n        if (flags & APR_FILEPATH_NOTABSOLUTE) {\n            if (!rootpath)\n                rootpath = \"\";\n            else if (rootpath[0] == '/')\n                return APR_EABSOLUTE;\n        }\n    }\n\n    if (!rootpath) {\n        /* Start with the current working path.  This is bass akwards,\n         * but required since the compiler (at least vc) doesn't like\n         * passing the address of a char const* for a char** arg.\n         */\n        char *getpath;\n        rv = apr_filepath_get(&getpath, flags, p);\n        rootpath = getpath;\n        if (rv != APR_SUCCESS)\n            return errno;\n\n        /* XXX: Any kernel subject to goofy, uncanonical results\n         * must run the rootpath against the user's given flags.\n         * Simplest would be a recursive call to apr_filepath_merge\n         * with an empty (not null) rootpath and addpath of the cwd.\n         */\n    }\n\n    rootlen = strlen(rootpath);\n    maxlen = rootlen + strlen(addpath) + 4; /* 4 for slashes at start, after\n                                             * root, and at end, plus trailing\n                                             * null */\n    if (maxlen > APR_PATH_MAX) {\n        return APR_ENAMETOOLONG;\n    }\n    path = (char *)apr_palloc(p, maxlen);\n\n    if (addpath[0] == '/') {\n        /* Ignore the given root path, strip off leading\n         * '/'s to a single leading '/' from the addpath,\n         * and leave addpath at the first non-'/' character.\n         */\n        keptlen = 0;\n        while (addpath[0] == '/')\n            ++addpath;\n        path[0] = '/';\n        pathlen = 1;\n    }\n    else {\n        /* If both paths are relative, fail early\n         */\n        if (rootpath[0] != '/' && (flags & APR_FILEPATH_NOTRELATIVE))\n            return APR_ERELATIVE;\n\n        /* Base the result path on the rootpath\n         */\n        keptlen = rootlen;\n        memcpy(path, rootpath, rootlen);\n\n        /* Always '/' terminate the given root path\n         */\n        if (keptlen && path[keptlen - 1] != '/') {\n            path[keptlen++] = '/';\n        }\n        pathlen = keptlen;\n    }\n\n    while (*addpath) {\n        /* Parse each segment, find the closing '/'\n         */\n        const char *next = addpath;\n        while (*next && (*next != '/')) {\n            ++next;\n        }\n        seglen = next - addpath;\n\n        if (seglen == 0 || (seglen == 1 && addpath[0] == '.')) {\n            /* noop segment (/ or ./) so skip it\n             */\n        }\n        else if (seglen == 2 && addpath[0] == '.' && addpath[1] == '.') {\n            /* backpath (../) */\n            if (pathlen == 1 && path[0] == '/') {\n                /* Attempt to move above root.  Always die if the\n                 * APR_FILEPATH_SECUREROOTTEST flag is specified.\n                 */\n                if (flags & APR_FILEPATH_SECUREROOTTEST) {\n                    return APR_EABOVEROOT;\n                }\n\n                /* Otherwise this is simply a noop, above root is root.\n                 * Flag that rootpath was entirely replaced.\n                 */\n                keptlen = 0;\n            }\n            else if (pathlen == 0\n                     || (pathlen == 3\n                         && !memcmp(path + pathlen - 3, \"../\", 3))\n                     || (pathlen  > 3\n                         && !memcmp(path + pathlen - 4, \"/../\", 4))) {\n                /* Path is already backpathed or empty, if the\n                 * APR_FILEPATH_SECUREROOTTEST.was given die now.\n"
}