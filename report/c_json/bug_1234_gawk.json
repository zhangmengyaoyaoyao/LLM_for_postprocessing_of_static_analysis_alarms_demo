{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "command.y",
    "message": "Offset: 1 Size: 1.",
    "warning_function_name": "find_command",
    "warning_line": "else if (toklen == 2 && abrv[1] == token[1])",
    "warning_context": "static int\nfind_command(const char *token, size_t toklen)\n{\n\tchar *name, *abrv;\n\tint i, k;\n\tbool try_exact = true;\n\tint abrv_match = -1;\n\tint partial_match = -1;\n\n#if 'a' == 0x81 /* it's EBCDIC */\n\t/* make sure all lower case characters in token (sorting\n\t * isn't the solution in this case)\n\t */\n\tfor (i = 0; i < toklen; i++) {\n\t\tif (token[i] != tolower(token[i]))\n\t\t\treturn -1;\n\t}\n#endif\n\n\tk = sizeof(cmdtab)/sizeof(cmdtab[0]) - 1;\n\tfor (i = 0; i < k; i++) {\n\t\tname = (char *) cmdtab[i].name;\n\t\tif (try_exact && *token == *name\n\t\t\t\t&& toklen == strlen(name)\n\t\t\t\t&& strncmp(name, token, toklen) == 0\n\t\t)\n\t\t\treturn i;\n\n\t\tif (*name > *token || i == (k - 1))\n\t\t\ttry_exact = false;\n\n\t\tif (abrv_match < 0) {\n\t\t\tabrv = cmdtab[i].abbrvn;\n\t\t\tif (abrv[0] == token[0]) {\n\t\t\t\tif (toklen == 1 && ! abrv[1])\n\t\t\t\t\tabrv_match = i;\n\t\t\t\telse if (toklen == 2 && abrv[1] == token[1])\n\t\t\t\t\tabrv_match = i;\n\t\t\t}\n\t\t}\n\t\tif (! try_exact && abrv_match >= 0)\n\t\t\treturn abrv_match;\n\t\tif (partial_match < 0) {\n\t\t\tif (*token == *name\n\t\t\t\t\t&& toklen < strlen(name)\n\t\t\t\t\t&& strncmp(name, token, toklen) == 0\n\t\t\t) {\n\t\t\t\tif ((i == k - 1 || strncmp(cmdtab[i + 1].name, token, toklen) != 0)\n\t\t\t\t\t&& (i == 0 || strncmp(cmdtab[i - 1].name, token, toklen) != 0)\n\t\t\t\t)\n\t\t\t\t\tpartial_match = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn partial_match;\n}\n"
}