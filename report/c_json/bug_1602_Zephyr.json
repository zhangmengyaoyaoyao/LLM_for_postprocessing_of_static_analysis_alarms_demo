{
    "Project": "Zephyr",
    "Tool": "Cppcheck",
    "category": "Uninitialized Variable",
    "file": "arch/arc/core/thread.c",
    "message": "Uninitialized variable: stackAdjSize",
    "warning_function_name": "arch_new_thread",
    "warning_line": "stackEnd = pStackMem + stackAdjSize;",
    "warning_context": "void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,\n\t\t     size_t stackSize, k_thread_entry_t pEntry,\n\t\t     void *parameter1, void *parameter2, void *parameter3,\n\t\t     int priority, unsigned int options)\n{\n\tchar *pStackMem = Z_THREAD_STACK_BUFFER(stack);\n\tZ_ASSERT_VALID_PRIO(priority, pEntry);\n\n\tchar *stackEnd;\n\tchar *stackAdjEnd;\n\tstruct init_stack_frame *pInitCtx;\n\n#ifdef CONFIG_USERSPACE\n\n\tsize_t stackAdjSize;\n\tsize_t offset = 0;\n\n/* adjust stack and stack size */\n#if CONFIG_ARC_MPU_VER == 2\n\tstackAdjSize = Z_ARC_MPUV2_SIZE_ALIGN(stackSize);\n#elif CONFIG_ARC_MPU_VER == 3\n\tstackAdjSize = STACK_SIZE_ALIGN(stackSize);\n#endif\n\tstackEnd = pStackMem + stackAdjSize;\n\n#ifdef CONFIG_STACK_POINTER_RANDOM\n\toffset = stackAdjSize - stackSize;\n#endif\n\n\tif (options & K_USER) {\n\t\tthread->arch.priv_stack_start =\n\t\t\t(u32_t)(stackEnd + STACK_GUARD_SIZE);\n\n\t\tstackAdjEnd = (char *)STACK_ROUND_DOWN(stackEnd +\n\t\t\t\tARCH_THREAD_STACK_RESERVED);\n\n\t\t/* reserve 4 bytes for the start of user sp */\n\t\tstackAdjEnd -= 4;\n\t\t(*(u32_t *)stackAdjEnd) = STACK_ROUND_DOWN(\n\t\t\t(u32_t)stackEnd - offset);\n\n#ifdef CONFIG_THREAD_USERSPACE_LOCAL_DATA\n\t\t/* reserve stack space for the userspace local data struct */\n\t\tthread->userspace_local_data =\n\t\t\t(struct _thread_userspace_local_data *)\n\t\t\tSTACK_ROUND_DOWN(stackEnd -\n\t\t\tsizeof(*thread->userspace_local_data) - offset);\n\t\t/* update the start of user sp */\n\t\t(*(u32_t *)stackAdjEnd) = (u32_t) thread->userspace_local_data;\n#endif\n\n\t} else {\n\t/* for kernel thread, the privilege stack is merged into thread stack */\n\t/* if MPU_STACK_GUARD is enabled, reserve the the stack area\n\t * |---------------------|    |----------------|\n\t * |  user stack         |    | stack guard    |\n\t * |---------------------| to |----------------|\n\t * |  stack guard        |    | kernel thread  |\n\t * |---------------------|    | stack          |\n\t * |  privilege stack    |    |                |\n\t * ---------------------------------------------\n\t */\n\t\tpStackMem += STACK_GUARD_SIZE;\n\t\tstackAdjSize = stackAdjSize + CONFIG_PRIVILEGED_STACK_SIZE;\n\t\tstackEnd += ARCH_THREAD_STACK_RESERVED;\n\n\t\tthread->arch.priv_stack_start = 0;\n\n#ifdef CONFIG_THREAD_USERSPACE_LOCAL_DATA\n\t\t/* reserve stack space for the userspace local data struct */\n\t\tstackAdjEnd = (char *)STACK_ROUND_DOWN(stackEnd\n\t\t\t- sizeof(*thread->userspace_local_data) - offset);\n\t\tthread->userspace_local_data =\n\t\t\t(struct _thread_userspace_local_data *)stackAdjEnd;\n#else\n\t\tstackAdjEnd = (char *)STACK_ROUND_DOWN(stackEnd - offset);\n#endif\n\t}\n\n\tz_new_thread_init(thread, pStackMem, stackAdjSize, priority, options);\n\n\t/* carve the thread entry struct from the \"base\" of\n\t\tthe privileged stack */\n\tpInitCtx = (struct init_stack_frame *)(\n\t\tstackAdjEnd - sizeof(struct init_stack_frame));\n\n\t/* fill init context */\n\tpInitCtx->status32 = 0U;\n\tif (options & K_USER) {\n\t\tpInitCtx->pc = ((u32_t)z_user_thread_entry_wrapper);\n\t} else {\n\t\tpInitCtx->pc = ((u32_t)z_thread_entry_wrapper);\n\t}\n\n\t/*\n\t * enable US bit, US is read as zero in user mode. This will allow use\n\t * mode sleep instructions, and it enables a form of denial-of-service\n\t * attack by putting the processor in sleep mode, but since interrupt\n\t * level/mask can't be set from user space that's not worse than\n\t * executing a loop without yielding.\n\t */\n"
}