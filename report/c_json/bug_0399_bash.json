{
    "project": "bash",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "execute_cmd.c",
    "message": "Access to field 'word' results in a dereference of a null pointer (loaded from field 'word')",
    "warning_function_name": "fix_assignment_words",
    "warning_line": "b = builtin_address_internal (wcmd->word->word, 0);",
    "warning_context": "static void\nfix_assignment_words (words)\n     WORD_LIST *words;\n{\n  WORD_LIST *w, *wcmd;\n  struct builtin *b;\n  int assoc, global, array, integer;\n\n  if (words == 0)\n    return;\n\n  b = 0;\n  assoc = global = array = integer = 0;\n\n  /* Skip over assignment statements preceding a command name */\n  wcmd = words;\n  for (wcmd = words; wcmd; wcmd = wcmd->next)\n    if ((wcmd->word->flags & W_ASSIGNMENT) == 0)\n      break;\n\n  for (w = wcmd; w; w = w->next)\n    if (w->word->flags & W_ASSIGNMENT)\n      {\n\tif (b == 0)\n\t  {\n\t    /* Posix (post-2008) says that `command' doesn't change whether\n\t       or not the builtin it shadows is a `declaration command', even\n\t       though it removes other special builtin properties.  In Posix\n\t       mode, we skip over one or more instances of `command' and\n\t       deal with the next word as the assignment builtin. */\n\t    while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, \"command\"))\n\t      wcmd = wcmd->next;\n\t    b = builtin_address_internal (wcmd->word->word, 0);\n\t    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)\n\t      return;\n\t    else if (b && (b->flags & ASSIGNMENT_BUILTIN))\n\t      wcmd->word->flags |= W_ASSNBLTIN;\n\t  }\n\tw->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);\n#if defined (ARRAY_VARS)\n\tif (assoc)\n\t  w->word->flags |= W_ASSIGNASSOC;\n\tif (array)\n\t  w->word->flags |= W_ASSIGNARRAY;\n#endif\n\tif (global)\n\t  w->word->flags |= W_ASSNGLOBAL;\n\tif (integer)\n\t  w->word->flags |= W_ASSIGNINT;\n      }\n#if defined (ARRAY_VARS)\n    /* Note that we saw an associative array option to a builtin that takes\n       assignment statements.  This is a bit of a kludge. */\n    else if (w->word->word[0] == '-' && (strchr (w->word->word+1, 'A') || strchr (w->word->word+1, 'a') || strchr (w->word->word+1, 'g')))\n#else\n    else if (w->word->word[0] == '-' && strchr (w->word->word+1, 'g'))\n#endif\n      {\n\tif (b == 0)\n\t  {\n\t    while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, \"command\"))\n\t      wcmd = wcmd->next;\n\t    b = builtin_address_internal (wcmd->word->word, 0);\n\t    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)\n\t      return;\n\t    else if (b && (b->flags & ASSIGNMENT_BUILTIN))\n\t      wcmd->word->flags |= W_ASSNBLTIN;\n\t  }\n\tif ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'A'))\n\t  assoc = 1;\n\telse if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'a'))\n\t  array = 1;\n\tif ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'g'))\n\t  global = 1;\n\tif ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'i'))\n\t  integer = 1;\n      }\n}\n"
}