{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: 116 (⇐ 56 + 60) Size: [0, +oo].",
    "Code_line": "  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));",
    "Code_function": "_bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)\n{\n  struct ar_hdr hdr;\n  char *hdrp = (char *) &hdr;\n  bfd_size_type parsed_size;\n  struct areltdata *ared;\n  char *filename = NULL;\n  bfd_size_type namelen = 0;\n  bfd_size_type allocsize = sizeof (struct areltdata) + sizeof (struct ar_hdr);\n  char *allocptr = 0;\n  file_ptr origin = 0;\n  unsigned int extra_size = 0;\n  char fmag_save;\n  int scan;\n\n  if (bfd_bread (hdrp, sizeof (struct ar_hdr), abfd) != sizeof (struct ar_hdr))\n    {\n      if (bfd_get_error () != bfd_error_system_call)\n\tbfd_set_error (bfd_error_no_more_archived_files);\n      return NULL;\n    }\n  if (strncmp (hdr.ar_fmag, ARFMAG, 2) != 0\n      && (mag == NULL\n\t  || strncmp (hdr.ar_fmag, mag, 2) != 0))\n    {\n      bfd_set_error (bfd_error_malformed_archive);\n      return NULL;\n    }\n\n  errno = 0;\n  fmag_save = hdr.ar_fmag[0];\n  hdr.ar_fmag[0] = 0;\n  scan = sscanf (hdr.ar_size, \"%\" BFD_VMA_FMT \"u\", &parsed_size);\n  hdr.ar_fmag[0] = fmag_save;\n  if (scan != 1)\n    {\n      bfd_set_error (bfd_error_malformed_archive);\n      return NULL;\n    }\n\n  /* Extract the filename from the archive - there are two ways to\n     specify an extended name table, either the first char of the\n     name is a space, or it's a slash.  */\n  if ((hdr.ar_name[0] == '/'\n       || (hdr.ar_name[0] == ' '\n\t   && memchr (hdr.ar_name, '/', ar_maxnamelen (abfd)) == NULL))\n      && bfd_ardata (abfd)->extended_names != NULL)\n    {\n      filename = get_extended_arelt_filename (abfd, hdr.ar_name, &origin);\n      if (filename == NULL)\n\treturn NULL;\n    }\n  /* BSD4.4-style long filename.  */\n  else if (is_bsd44_extended_name (hdr.ar_name))\n    {\n      /* BSD-4.4 extended name */\n      namelen = atoi (&hdr.ar_name[3]);\n      allocsize += namelen + 1;\n      parsed_size -= namelen;\n      extra_size = namelen;\n\n      allocptr = (char *) bfd_zmalloc (allocsize);\n      if (allocptr == NULL)\n\treturn NULL;\n      filename = (allocptr\n\t\t  + sizeof (struct areltdata)\n\t\t  + sizeof (struct ar_hdr));\n      if (bfd_bread (filename, namelen, abfd) != namelen)\n\t{\n\t  free (allocptr);\n\t  if (bfd_get_error () != bfd_error_system_call)\n\t    bfd_set_error (bfd_error_no_more_archived_files);\n\t  return NULL;\n\t}\n      filename[namelen] = '\\0';\n    }\n  else\n    {\n      /* We judge the end of the name by looking for '/' or ' '.\n\t Note:  The SYSV format (terminated by '/') allows embedded\n\t spaces, so only look for ' ' if we don't find '/'.  */\n\n      char *e;\n      e = (char *) memchr (hdr.ar_name, '\\0', ar_maxnamelen (abfd));\n      if (e == NULL)\n\t{\n\t  e = (char *) memchr (hdr.ar_name, '/', ar_maxnamelen (abfd));\n\t  if (e == NULL)\n\t    e = (char *) memchr (hdr.ar_name, ' ', ar_maxnamelen (abfd));\n\t}\n\n      if (e != NULL)\n\tnamelen = e - hdr.ar_name;\n      else\n\t{\n\t  /* If we didn't find a termination character, then the name\n\t     must be the entire field.  */\n\t  namelen = ar_maxnamelen (abfd);\n\t}\n\n      allocsize += namelen + 1;\n    }\n\n  if (!allocptr)\n    {\n      allocptr = (char *) bfd_zmalloc (allocsize);\n      if (allocptr == NULL)\n\treturn NULL;\n    }\n\n  ared = (struct areltdata *) allocptr;\n\n  ared->arch_header = allocptr + sizeof (struct areltdata);\n  memcpy (ared->arch_header, &hdr, sizeof (struct ar_hdr));\n  ared->parsed_size = parsed_size;\n  ared->extra_size = extra_size;\n  ared->origin = origin;\n\n  if (filename != NULL)\n    ared->filename = filename;\n  else\n    {\n      ared->filename = allocptr + (sizeof (struct areltdata) +\n\t\t\t\t   sizeof (struct ar_hdr));\n      if (namelen)\n\tmemcpy (ared->filename, hdr.ar_name, namelen);\n      ared->filename[namelen] = '\\0';\n    }\n\n  return ared;\n}"
}