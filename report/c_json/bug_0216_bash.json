{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "lib/glob/glob.c",
    "message": "The value read from name_vector was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "return (name_vector);",
    "warning_context": "      nextlink = (struct globval *) malloc (sizeof (struct globval));\n      if (nextlink == 0 || nextname == 0)\n\t{\n\t  FREE (nextlink);\n\t  FREE (nextname);\n\t  lose = 1;\n\t}\n      else\n\t{\n\t  nextlink->name = nextname;\n\t  nextlink->next = lastlink;\n\t  lastlink = nextlink;\n\t  if (flags & GX_NULLDIR)\n\t    nextname[0] = '\\0';\n\t  else\n\t    bcopy (dir, nextname, sdlen + 1);\n\t  ++count;\n\t}\n    }\n\n  if (lose == 0)\n    {\n      name_vector = (char **) malloc ((count + 1) * sizeof (char *));\n      lose |= name_vector == NULL;\n    }\n\n  /* Have we run out of memory?\t */\n  if (lose)\n    {\n      tmplink = 0;\n\n      /* Here free the strings we have got.  */\n      while (lastlink)\n\t{\n\t  /* Since we build the list in reverse order, the first N entries\n\t     will be allocated with malloc, if firstmalloc is set, from\n\t     lastlink to firstmalloc. */\n\t  if (firstmalloc)\n\t    {\n\t      if (lastlink == firstmalloc)\n\t\tfirstmalloc = 0;\n\t      tmplink = lastlink;\n\t    }\n\t  else\n\t    tmplink = 0;\n\t  free (lastlink->name);\n\t  lastlink = lastlink->next;\n\t  FREE (tmplink);\n\t}\n\n      /* Don't call QUIT; here; let higher layers deal with it. */\n\n      return ((char **)NULL);\n    }\n\n  /* Copy the name pointers from the linked list into the vector.  */\n  for (tmplink = lastlink, i = 0; i < count; ++i)\n    {\n      name_vector[i] = tmplink->name;\n      tmplink = tmplink->next;\n    }\n\n  name_vector[count] = NULL;\n\n  /* If we allocated some of the struct globvals, free them now. */\n  if (firstmalloc)\n    {\n      tmplink = 0;\n      while (lastlink)\n\t{\n\t  tmplink = lastlink;\n\t  if (lastlink == firstmalloc)\n\t    lastlink = firstmalloc = 0;\n\t  else\n\t    lastlink = lastlink->next;\n\t  free (tmplink);\n\t}\n    }\n\n  return (name_vector);\n}\n\n/* Return a new array which is the concatenation of each string in ARRAY\n   to DIR.  This function expects you to pass in an allocated ARRAY, and\n   it takes care of free()ing that array.  Thus, you might think of this\n   function as side-effecting ARRAY.  This should handle GX_MARKDIRS. */\nstatic char **\nglob_dir_to_array (dir, array, flags)\n     char *dir, **array;\n     int flags;\n{\n  register unsigned int i, l;\n  int add_slash;\n  char **result, *new;\n  struct stat sb;\n\n  l = strlen (dir);\n  if (l == 0)\n    {\n      if (flags & GX_MARKDIRS)\n\tfor (i = 0; array[i]; i++)\n"
}