{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Message": "pointer `reldata` last assigned on line 10259 could be null and is dereferenced at line 10264, column 18.",
    "Code_line": "  rel_hash_ptr = reldata->hashes + reldata->count;",
    "Code_function": "elf_reloc_link_order (bfd *output_bfd,\n\t\t      struct bfd_link_info *info,\n\t\t      asection *output_section,\n\t\t      struct bfd_link_order *link_order)\n{\n  reloc_howto_type *howto;\n  long indx;\n  bfd_vma offset;\n  bfd_vma addend;\n  struct bfd_elf_section_reloc_data *reldata;\n  struct elf_link_hash_entry **rel_hash_ptr;\n  Elf_Internal_Shdr *rel_hdr;\n  const struct elf_backend_data *bed = get_elf_backend_data (output_bfd);\n  Elf_Internal_Rela irel[MAX_INT_RELS_PER_EXT_REL];\n  bfd_byte *erel;\n  unsigned int i;\n  struct bfd_elf_section_data *esdo = elf_section_data (output_section);\n\n  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);\n  if (howto == NULL)\n    {\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  addend = link_order->u.reloc.p->addend;\n\n  if (esdo->rel.hdr)\n    reldata = &esdo->rel;\n  else if (esdo->rela.hdr)\n    reldata = &esdo->rela;\n  else\n    {\n      reldata = NULL;\n      BFD_ASSERT (0);\n    }\n\n  /* Figure out the symbol index.  */\n  rel_hash_ptr = reldata->hashes + reldata->count;\n  if (link_order->type == bfd_section_reloc_link_order)\n    {\n      indx = link_order->u.reloc.p->u.section->target_index;\n      BFD_ASSERT (indx != 0);\n      *rel_hash_ptr = NULL;\n    }\n  else\n    {\n      struct elf_link_hash_entry *h;\n\n      /* Treat a reloc against a defined symbol as though it were\n\t actually against the section.  */\n      h = ((struct elf_link_hash_entry *)\n\t   bfd_wrapped_link_hash_lookup (output_bfd, info,\n\t\t\t\t\t link_order->u.reloc.p->u.name,\n\t\t\t\t\t FALSE, FALSE, TRUE));\n      if (h != NULL\n\t  && (h->root.type == bfd_link_hash_defined\n\t      || h->root.type == bfd_link_hash_defweak))\n\t{\n\t  asection *section;\n\n\t  section = h->root.u.def.section;\n\t  indx = section->output_section->target_index;\n\t  *rel_hash_ptr = NULL;\n\t  /* It seems that we ought to add the symbol value to the\n\t     addend here, but in practice it has already been added\n\t     because it was passed to constructor_callback.  */\n\t  addend += section->output_section->vma + section->output_offset;\n\t}\n      else if (h != NULL)\n\t{\n\t  /* Setting the index to -2 tells elf_link_output_extsym that\n\t     this symbol is used by a reloc.  */\n\t  h->indx = -2;\n\t  *rel_hash_ptr = h;\n\t  indx = 0;\n\t}\n      else\n\t{\n\t  if (! ((*info->callbacks->unattached_reloc)\n\t\t (info, link_order->u.reloc.p->u.name, NULL, NULL, 0)))\n\t    return FALSE;\n\t  indx = 0;\n\t}\n    }\n\n  /* If this is an inplace reloc, we must write the addend into the\n     object file.  */\n  if (howto->partial_inplace && addend != 0)\n    {\n      bfd_size_type size;\n      bfd_reloc_status_type rstat;\n      bfd_byte *buf;\n      bfd_boolean ok;\n      const char *sym_name;\n\n      size = (bfd_size_type) bfd_get_reloc_size (howto);\n      buf = (bfd_byte *) bfd_zmalloc (size);\n      if (buf == NULL && size != 0)\n\treturn FALSE;\n      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);\n      switch (rstat)\n\t{\n\tcase bfd_reloc_ok:\n\t  break;\n\n\tdefault:\n\tcase bfd_reloc_outofrange:\n\t  abort ();\n\n\tcase bfd_reloc_overflow:\n\t  if (link_order->type == bfd_section_reloc_link_order)\n\t    sym_name = bfd_section_name (output_bfd,\n\t\t\t\t\t link_order->u.reloc.p->u.section);\n\t  else\n\t    sym_name = link_order->u.reloc.p->u.name;\n\t  if (! ((*info->callbacks->reloc_overflow)\n\t\t (info, NULL, sym_name, howto->name, addend, NULL,\n\t\t  NULL, (bfd_vma) 0)))\n\t    {\n\t      free (buf);\n\t      return FALSE;\n\t    }\n\t  break;\n\t}\n      ok = bfd_set_section_contents (output_bfd, output_section, buf,\n\t\t\t\t     link_order->offset, size);\n      free (buf);\n      if (! ok)\n\treturn FALSE;\n    }\n\n  /* The address of a reloc is relative to the section in a\n     relocatable file, and is a virtual address in an executable\n     file.  */\n  offset = link_order->offset;\n  if (! info->relocatable)\n    offset += output_section->vma;\n\n  for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)\n    {\n      irel[i].r_offset = offset;\n      irel[i].r_info = 0;\n      irel[i].r_addend = 0;\n    }\n  if (bed->s->arch_size == 32)\n    irel[0].r_info = ELF32_R_INFO (indx, howto->type);\n  else\n    irel[0].r_info = ELF64_R_INFO (indx, howto->type);\n\n  rel_hdr = reldata->hdr;\n  erel = rel_hdr->contents;\n  if (rel_hdr->sh_type == SHT_REL)\n    {\n      erel += reldata->count * bed->s->sizeof_rel;\n      (*bed->s->swap_reloc_out) (output_bfd, irel, erel);\n    }\n  else\n    {\n      irel[0].r_addend = addend;\n      erel += reldata->count * bed->s->sizeof_rela;\n      (*bed->s->swap_reloca_out) (output_bfd, irel, erel);\n    }\n\n  ++reldata->count;\n\n  return TRUE;\n}"
}