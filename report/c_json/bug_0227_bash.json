{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "redir.c",
    "message": "The value read from oflags was never initialized.",
    "warning_function_name": "do_redirection_internal",
    "warning_line": "redirectee->flags = oflags;",
    "warning_context": "\t  else\n\t    rd.dest = -1;\t/* XXX */\n\t  switch (ri)\n\t    {\n\t    case r_duplicating_input_word:\n\t      new_redirect = make_redirection (sd, r_duplicating_input, rd, 0);\n\t      break;\n\t    case r_duplicating_output_word:\n\t      new_redirect = make_redirection (sd, r_duplicating_output, rd, 0);\n\t      break;\n\t    case r_move_input_word:\n\t      new_redirect = make_redirection (sd, r_move_input, rd, 0);\n\t      break;\n\t    case r_move_output_word:\n\t      new_redirect = make_redirection (sd, r_move_output, rd, 0);\n\t      break;\n\t    }\n\t}\n      else if (ri == r_duplicating_output_word && (redirect->rflags & REDIR_VARASSIGN) == 0 && redirector == 1)\n\t{\n\t  sd = redirect->redirector;\n\t  rd.filename = make_bare_word (redirectee_word);\n\t  new_redirect = make_redirection (sd, r_err_and_out, rd, 0);\n\t}\n      else\n\t{\n\t  free (redirectee_word);\n\t  return (AMBIGUOUS_REDIRECT);\n\t}\n\n      free (redirectee_word);\n\n      /* Set up the variables needed by the rest of the function from the\n\t new redirection. */\n      if (new_redirect->instruction == r_err_and_out)\n\t{\n\t  char *alloca_hack;\n\n\t  /* Copy the word without allocating any memory that must be\n\t     explicitly freed. */\n\t  redirectee = (WORD_DESC *)alloca (sizeof (WORD_DESC));\n\t  xbcopy ((char *)new_redirect->redirectee.filename,\n\t\t (char *)redirectee, sizeof (WORD_DESC));\n\n\t  alloca_hack = (char *)\n\t    alloca (1 + strlen (new_redirect->redirectee.filename->word));\n\t  redirectee->word = alloca_hack;\n\t  strcpy (redirectee->word, new_redirect->redirectee.filename->word);\n\t}\n      else\n\t/* It's guaranteed to be an integer, and shouldn't be freed. */\n\tredirectee = new_redirect->redirectee.filename;\n\n      redir_fd = new_redirect->redirectee.dest;\n      redirector = new_redirect->redirector.dest;\n      ri = new_redirect->instruction;\n\n      /* Overwrite the flags element of the old redirect with the new value. */\n      redirect->flags = new_redirect->flags;\n      dispose_redirects (new_redirect);\n    }\n\n  switch (ri)\n    {\n    case r_output_direction:\n    case r_appending_to:\n    case r_input_direction:\n    case r_inputa_direction:\n    case r_err_and_out:\t\t/* command &>filename */\n    case r_append_err_and_out:\t/* command &>> filename */\n    case r_input_output:\n    case r_output_force:\n      if (posixly_correct && interactive_shell == 0)\n\t{\n\t  oflags = redirectee->flags;\n\t  redirectee->flags |= W_NOGLOB;\n\t}\n      redirectee_word = redirection_expand (redirectee);\n      if (posixly_correct && interactive_shell == 0)\n\tredirectee->flags = oflags;\n\n      if (redirectee_word == 0)\n\treturn (AMBIGUOUS_REDIRECT);\n\n#if defined (RESTRICTED_SHELL)\n      if (restricted && (WRITE_REDIRECT (ri)))\n\t{\n\t  free (redirectee_word);\n\t  return (RESTRICTED_REDIRECT);\n\t}\n#endif /* RESTRICTED_SHELL */\n\n      fd = redir_open (redirectee_word, redirect->flags, 0666, ri);\n      free (redirectee_word);\n\n      if (fd == NOCLOBBER_REDIRECT)\n\treturn (fd);\n\n      if (fd < 0)\n\treturn (errno);\n\n"
}