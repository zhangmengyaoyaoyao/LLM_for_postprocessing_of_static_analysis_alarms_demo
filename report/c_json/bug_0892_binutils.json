{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t      && strlen (it->name) == classlen)",
    "Code_function": "ieee_read_reference (struct ieee_info *info, const bfd_byte **pp)\n{\n  const bfd_byte *start;\n  bfd_vma flags;\n  const char *cxx_class, *name;\n  unsigned long classlen, namlen;\n  debug_type *pslot;\n  debug_type target;\n\n  start = *pp;\n\n  if (! ieee_require_asn (info, pp, &flags))\n    return FALSE;\n\n  /* Giving the class name before the member name is in an addendum to\n     the spec.  */\n  if (flags == 3)\n    {\n      if (! ieee_require_atn65 (info, pp, &cxx_class, &classlen))\n\treturn FALSE;\n    }\n\n  if (! ieee_require_atn65 (info, pp, &name, &namlen))\n    return FALSE;\n\n  pslot = NULL;\n  if (flags != 3)\n    {\n      int pass;\n\n      /* We search from the last variable indices to the first in\n\t hopes of finding local variables correctly.  We search the\n\t local variables on the first pass, and the global variables\n\t on the second.  FIXME: This probably won't work in all cases.\n\t On the other hand, I don't know what will.  */\n      for (pass = 0; pass < 2; pass++)\n\t{\n\t  struct ieee_vars *vars;\n\t  int i;\n\t  struct ieee_var *pv = NULL;\n\n\t  if (pass == 0)\n\t    vars = &info->vars;\n\t  else\n\t    {\n\t      vars = info->global_vars;\n\t      if (vars == NULL)\n\t\tbreak;\n\t    }\n\n\t  for (i = (int) vars->alloc - 1; i >= 0; i--)\n\t    {\n\t      bfd_boolean found;\n\n\t      pv = vars->vars + i;\n\n\t      if (pv->pslot == NULL\n\t\t  || pv->namlen != namlen\n\t\t  || strncmp (pv->name, name, namlen) != 0)\n\t\tcontinue;\n\n\t      found = FALSE;\n\t      switch (flags)\n\t\t{\n\t\tdefault:\n\t\t  ieee_error (info, start,\n\t\t\t      _(\"unrecognized C++ reference type\"));\n\t\t  return FALSE;\n\n\t\tcase 0:\n\t\t  /* Global variable or function.  */\n\t\t  if (pv->kind == IEEE_GLOBAL\n\t\t      || pv->kind == IEEE_EXTERNAL\n\t\t      || pv->kind == IEEE_FUNCTION)\n\t\t    found = TRUE;\n\t\t  break;\n\n\t\tcase 1:\n\t\t  /* Global static variable or function.  */\n\t\t  if (pv->kind == IEEE_STATIC\n\t\t      || pv->kind == IEEE_FUNCTION)\n\t\t    found = TRUE;\n\t\t  break;\n\n\t\tcase 2:\n\t\t  /* Local variable.  */\n\t\t  if (pv->kind == IEEE_LOCAL)\n\t\t    found = TRUE;\n\t\t  break;\n\t\t}\n\n\t      if (found)\n\t\tbreak;\n\t    }\n\n\t  if (i >= 0)\n\t    {\n\t      pslot = pv->pslot;\n\t      break;\n\t    }\n\t}\n    }\n  else\n    {\n      struct ieee_tag *it;\n\n      for (it = info->tags; it != NULL; it = it->next)\n\t{\n\t  if (it->name[0] == cxx_class[0]\n\t      && strncmp (it->name, cxx_class, classlen) == 0\n\t      && strlen (it->name) == classlen)\n\t    {\n\t      if (it->fslots != NULL)\n\t\t{\n\t\t  const debug_field *pf;\n\t\t  unsigned int findx;\n\n\t\t  pf = debug_get_fields (info->dhandle, it->type);\n\t\t  if (pf == NULL)\n\t\t    {\n\t\t      ieee_error (info, start,\n\t\t\t\t  \"C++ reference in class with no fields\");\n\t\t      return FALSE;\n\t\t    }\n\n\t\t  for (findx = 0; *pf != DEBUG_FIELD_NULL; pf++, findx++)\n\t\t    {\n\t\t      const char *fname;\n\n\t\t      fname = debug_get_field_name (info->dhandle, *pf);\n\t\t      if (fname == NULL)\n\t\t\treturn FALSE;\n\t\t      if (strncmp (fname, name, namlen) == 0\n\t\t\t  && strlen (fname) == namlen)\n\t\t\t{\n\t\t\t  pslot = it->fslots + findx;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t      break;\n\t    }\n\t}\n    }\n\n  if (pslot == NULL)\n    {\n      ieee_error (info, start, _(\"C++ reference not found\"));\n      return FALSE;\n    }\n\n  /* We allocated the type of the object as an indirect type pointing\n     to *pslot, which we can now update to be a reference type.  */\n  if (debug_get_type_kind (info->dhandle, *pslot) != DEBUG_KIND_POINTER)\n    {\n      ieee_error (info, start, _(\"C++ reference is not pointer\"));\n      return FALSE;\n    }\n\n  target = debug_get_target_type (info->dhandle, *pslot);\n  *pslot = debug_make_reference_type (info->dhandle, target);\n  if (*pslot == DEBUG_TYPE_NULL)\n    return FALSE;\n\n  return TRUE;\n}"
}