{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      if (nestdelim && string[i] == delimopen)",
    "Code_function": "history_tokenize_word (string, ind)\n     const char *string;\n     int ind;\n{\n  register int i;\n  int delimiter, nestdelim, delimopen;\n\n  i = ind;\n  delimiter = nestdelim = 0;\n\n  if (member (string[i], \"()\\n\"))\n    {\n      i++;\n      return i;\n    }\n\n  if (member (string[i], \"<>;&|$\"))\n    {\n      int peek = string[i + 1];\n\n      if (peek == string[i] && peek != '$')\n\t{\n\t  if (peek == '<' && string[i + 2] == '-')\n\t    i++;\n\t  else if (peek == '<' && string[i + 2] == '<')\n\t    i++;\n\t  i += 2;\n\t  return i;\n\t}\n      else if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||\n\t\t(peek == '>' && string[i] == '&'))\n\t{\n\t  i += 2;\n\t  return i;\n\t}\n      /* XXX - separated out for later -- bash-4.2 */\n      else if ((peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */\n\t       (peek == '(' && string[i] == '$')) /*)*/\n\t{\n\t  i += 2;\n\t  delimopen = '(';\n\t  delimiter = ')';\n\t  nestdelim = 1;\n\t  goto get_word;\n\t}\n#if 0\n      else if (peek == '\\'' && string[i] == '$')\n        {\n\t  i += 2;\t/* XXX */\n\t  return i;\n        }\n#endif\n\n      if (string[i] != '$')\n\t{\n\t  i++;\n\t  return i;\n\t}\n    }\n\n  /* same code also used for $(...)/<(...)/>(...) above */\n  if (member (string[i], \"!@?+*\"))\n    {\n      int peek = string[i + 1];\n\n      if (peek == '(')\t\t/*)*/\n\t{\n\t  /* Shell extended globbing patterns */\n\t  i += 2;\n\t  delimopen = '(';\n\t  delimiter = ')';\t/* XXX - not perfect */\n\t  nestdelim = 1;\n\t}\n    }\n\nget_word:\n  /* Get word from string + i; */\n\n  if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))\n    delimiter = string[i++];\n\n  for (; string[i]; i++)\n    {\n      if (string[i] == '\\\\' && string[i + 1] == '\\n')\n\t{\n\t  i++;\n\t  continue;\n\t}\n\n      if (string[i] == '\\\\' && delimiter != '\\'' &&\n\t  (delimiter != '\"' || member (string[i], slashify_in_quotes)))\n\t{\n\t  i++;\n\t  continue;\n\t}\n\n      /* delimiter must be set and set to something other than a quote if\n\t nestdelim is set, so these tests are safe. */\n      if (nestdelim && string[i] == delimopen)\n\t{\n\t  nestdelim++;\n\t  continue;\n\t}\n      if (nestdelim && string[i] == delimiter)\n\t{\n\t  nestdelim--;\n\t  if (nestdelim == 0)\n\t    delimiter = 0;\n\t  continue;\n\t}\n\n      if (delimiter && string[i] == delimiter)\n\t{\n\t  delimiter = 0;\n\t  continue;\n\t}\n\n      if (delimiter == 0 && (member (string[i], history_word_delimiters)))\n\tbreak;\n\n      if (delimiter == 0 && member (string[i], HISTORY_QUOTE_CHARACTERS))\n\tdelimiter = string[i];\n    }\n\n  return i;\n}"
}