{
    "Project": "diffutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "lib/vasnprintf.c",
    "message": "Offset added: [1, +oo] Size: [0, 18446744073709551614].",
    "warning_function_name": NaN,
    "warning_line": "ENSURE_ALLOCATION (augmented_length);",
    "warning_context": "    TCHAR_T *buf;\n    TCHAR_T *buf_malloced;\n    const FCHAR_T *cp;\n    size_t i;\n    DIRECTIVE *dp;\n    /* Output string accumulator.  */\n    DCHAR_T *result;\n    size_t allocated;\n    size_t length;\n\n    /* Allocate a small buffer that will hold a directive passed to\n       sprintf or snprintf.  */\n    buf_neededlength =\n      xsum4 (7, d.max_width_length, d.max_precision_length, 6);\n#if HAVE_ALLOCA\n    if (buf_neededlength < 4000 / sizeof (TCHAR_T))\n      {\n        buf = (TCHAR_T *) alloca (buf_neededlength * sizeof (TCHAR_T));\n        buf_malloced = NULL;\n      }\n    else\n#endif\n      {\n        size_t buf_memsize = xtimes (buf_neededlength, sizeof (TCHAR_T));\n        if (size_overflow_p (buf_memsize))\n          goto out_of_memory_1;\n        buf = (TCHAR_T *) malloc (buf_memsize);\n        if (buf == NULL)\n          goto out_of_memory_1;\n        buf_malloced = buf;\n      }\n\n    if (resultbuf != NULL)\n      {\n        result = resultbuf;\n        allocated = *lengthp;\n      }\n    else\n      {\n        result = NULL;\n        allocated = 0;\n      }\n    length = 0;\n    /* Invariants:\n       result is either == resultbuf or == NULL or malloc-allocated.\n       If length > 0, then result != NULL.  */\n\n    /* Ensures that allocated >= needed.  Aborts through a jump to\n       out_of_memory if needed is SIZE_MAX or otherwise too big.  */\n#define ENSURE_ALLOCATION(needed) \\\n    if ((needed) > allocated)                                                \\\n      {                                                                      \\\n        size_t memory_size;                                                  \\\n        DCHAR_T *memory;                                                     \\\n                                                                             \\\n        allocated = (allocated > 0 ? xtimes (allocated, 2) : 12);            \\\n        if ((needed) > allocated)                                            \\\n          allocated = (needed);                                              \\\n        memory_size = xtimes (allocated, sizeof (DCHAR_T));                  \\\n        if (size_overflow_p (memory_size))                                   \\\n          goto out_of_memory;                                                \\\n        if (result == resultbuf || result == NULL)                           \\\n          memory = (DCHAR_T *) malloc (memory_size);                         \\\n        else                                                                 \\\n          memory = (DCHAR_T *) realloc (result, memory_size);                \\\n        if (memory == NULL)                                                  \\\n          goto out_of_memory;                                                \\\n        if (result == resultbuf && length > 0)                               \\\n          DCHAR_CPY (memory, result, length);                                \\\n        result = memory;                                                     \\\n      }\n\n    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)\n      {\n        if (cp != dp->dir_start)\n          {\n            size_t n = dp->dir_start - cp;\n            size_t augmented_length = xsum (length, n);\n\n            ENSURE_ALLOCATION (augmented_length);\n            /* This copies a piece of FCHAR_T[] into a DCHAR_T[].  Here we\n               need that the format string contains only ASCII characters\n               if FCHAR_T and DCHAR_T are not the same type.  */\n            if (sizeof (FCHAR_T) == sizeof (DCHAR_T))\n              {\n                DCHAR_CPY (result + length, (const DCHAR_T *) cp, n);\n                length = augmented_length;\n              }\n            else\n              {\n                do\n                  result[length++] = (unsigned char) *cp++;\n                while (--n > 0);\n              }\n          }\n        if (i == d.count)\n          break;\n\n        /* Execute a single directive.  */\n        if (dp->conversion == '%')\n          {\n"
}