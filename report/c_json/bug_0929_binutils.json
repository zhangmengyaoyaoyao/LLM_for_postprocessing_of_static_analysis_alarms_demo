{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "\t  dpi->templates = dpt.next;",
    "Code_function": "d_print_comp_inner (struct d_print_info *dpi, int options,\n\t\t  const struct demangle_component *dc)\n{\n  /* Magic variable to let reference smashing skip over the next modifier\n     without needing to modify *dc.  */\n  const struct demangle_component *mod_inner = NULL;\n\n  /* Variable used to store the current templates while a previously\n     captured scope is used.  */\n  struct d_print_template *saved_templates;\n\n  /* Nonzero if templates have been stored in the above variable.  */\n  int need_template_restore = 0;\n\n  if (dc == NULL)\n    {\n      d_print_error (dpi);\n      return;\n    }\n  if (d_print_saw_error (dpi))\n    return;\n\n  switch (dc->type)\n    {\n    case DEMANGLE_COMPONENT_NAME:\n      if ((options & DMGL_JAVA) == 0)\n\td_append_buffer (dpi, dc->u.s_name.s, dc->u.s_name.len);\n      else\n\td_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);\n      return;\n\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \"[abi:\");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_char (dpi, ']');\n      return;\n\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      if ((options & DMGL_JAVA) == 0)\n\td_append_string (dpi, \"::\");\n      else\n\td_append_char (dpi, '.');\n      {\n\tstruct demangle_component *local_name = d_right (dc);\n\tif (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t  {\n\t    d_append_string (dpi, \"{default arg#\");\n\t    d_append_num (dpi, local_name->u.s_unary_num.num + 1);\n\t    d_append_string (dpi, \"}::\");\n\t    local_name = local_name->u.s_unary_num.sub;\n\t  }\n\td_print_comp (dpi, options, local_name);\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct demangle_component *typed_name;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_template dpt;\n\n\t/* Pass the name down to the type so that it can be printed in\n\t   the right place for the type.  We also have to pass down\n\t   any CV-qualifiers, which apply to the this parameter.  */\n\thold_modifiers = dpi->modifiers;\n\tdpi->modifiers = 0;\n\ti = 0;\n\ttyped_name = d_left (dc);\n\twhile (typed_name != NULL)\n\t  {\n\t    if (i >= sizeof adpm / sizeof adpm[0])\n\t      {\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    adpm[i].next = dpi->modifiers;\n\t    dpi->modifiers = &adpm[i];\n\t    adpm[i].mod = typed_name;\n\t    adpm[i].printed = 0;\n\t    adpm[i].templates = dpi->templates;\n\t    ++i;\n\n\t    if (typed_name->type != DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_CONST_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t\t&& typed_name->type != DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t      break;\n\n\t    typed_name = d_left (typed_name);\n\t  }\n\n\tif (typed_name == NULL)\n\t  {\n\t    d_print_error (dpi);\n\t    return;\n\t  }\n\n\t/* If typed_name is a template, then it applies to the\n\t   function type as well.  */\n\tif (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)\n\t  {\n\t    dpt.next = dpi->templates;\n\t    dpi->templates = &dpt;\n\t    dpt.template_decl = typed_name;\n\t  }\n\n\t/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n\t   there may be CV-qualifiers on its right argument which\n\t   really apply here; this happens when parsing a class which\n\t   is local to a function.  */\n\tif (typed_name->type == DEMANGLE_COMPONENT_LOCAL_NAME)\n\t  {\n\t    struct demangle_component *local_name;\n\n\t    local_name = d_right (typed_name);\n\t    if (local_name->type == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t      local_name = local_name->u.s_unary_num.sub;\n\t    while (local_name->type == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t   || local_name->type == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t   || local_name->type == DEMANGLE_COMPONENT_CONST_THIS\n\t\t   || local_name->type == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t\t   || (local_name->type\n\t\t       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))\n\t      {\n\t\tif (i >= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = adpm[i - 1];\n\t\tadpm[i].next = &adpm[i - 1];\n\t\tdpi->modifiers = &adpm[i];\n\n\t\tadpm[i - 1].mod = local_name;\n\t\tadpm[i - 1].printed = 0;\n\t\tadpm[i - 1].templates = dpi->templates;\n\t\t++i;\n\n\t\tlocal_name = d_left (local_name);\n\t      }\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tif (typed_name->type == DEMANGLE_COMPONENT_TEMPLATE)\n\t  dpi->templates = dpt.next;\n\n\t/* If the modifiers didn't get printed by the type, print them\n\t   now.  */\n\twhile (i > 0)\n\t  {\n\t    --i;\n\t    if (! adpm[i].printed)\n\t      {\n\t\td_append_char (dpi, ' ');\n\t\td_print_mod (dpi, options, adpm[i].mod);\n\t      }\n\t  }\n\n\tdpi->modifiers = hold_modifiers;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_TEMPLATE:\n      {\n\tstruct d_print_mod *hold_dpm;\n\tstruct demangle_component *dcl;\n\tconst struct demangle_component *hold_current;\n\n\t/* This template may need to be referenced by a cast operator\n\t   contained in its subtree.  */\n\thold_current = dpi->current_template;\n\tdpi->current_template = dc;\n\n\t/* Don't push modifiers into a template definition.  Doing so\n\t   could give the wrong definition for a template argument.\n\t   Instead, treat the template essentially as a name.  */\n\n\thold_dpm = dpi->modifiers;\n\tdpi->modifiers = NULL;\n\n        dcl = d_left (dc);\n\n        if ((options & DMGL_JAVA) != 0\n            && dcl->type == DEMANGLE_COMPONENT_NAME\n            && dcl->u.s_name.len == 6\n            && strncmp (dcl->u.s_name.s, \"JArray\", 6) == 0)\n          {\n            /* Special-case Java arrays, so that JArray<TYPE> appears\n               instead as TYPE[].  */\n\n            d_print_comp (dpi, options, d_right (dc));\n            d_append_string (dpi, \"[]\");\n          }\n        else\n          {\n\t    d_print_comp (dpi, options, dcl);\n\t    if (d_last_char (dpi) == '<')\n\t      d_append_char (dpi, ' ');\n\t    d_append_char (dpi, '<');\n\t    d_print_comp (dpi, options, d_right (dc));\n\t    /* Avoid generating two consecutive '>' characters, to avoid\n\t       the C++ syntactic ambiguity.  */\n\t    if (d_last_char (dpi) == '>')\n\t      d_append_char (dpi, ' ');\n\t    d_append_char (dpi, '>');\n          }\n\n\tdpi->modifiers = hold_dpm;\n\tdpi->current_template = hold_current;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n      {\n\tstruct d_print_template *hold_dpt;\n\tstruct demangle_component *a = d_lookup_template_argument (dpi, dc);\n\n\tif (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t  a = d_index_template_argument (a, dpi->pack_index);\n\n\tif (a == NULL)\n\t  {\n\t    d_print_error (dpi);\n\t    return;\n\t  }\n\n\t/* While processing this parameter, we need to pop the list of\n\t   templates.  This is because the template parameter may\n\t   itself be a reference to a parameter of an outer\n\t   template.  */\n\n\thold_dpt = dpi->templates;\n\tdpi->templates = hold_dpt->next;\n\n\td_print_comp (dpi, options, a);\n\n\tdpi->templates = hold_dpt;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_CTOR:\n      d_print_comp (dpi, options, dc->u.s_ctor.name);\n      return;\n\n    case DEMANGLE_COMPONENT_DTOR:\n      d_append_char (dpi, '~');\n      d_print_comp (dpi, options, dc->u.s_dtor.name);\n      return;\n\n    case DEMANGLE_COMPONENT_VTABLE:\n      d_append_string (dpi, \"vtable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_VTT:\n      d_append_string (dpi, \"VTT for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n      d_append_string (dpi, \"construction vtable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \"-in-\");\n      d_print_comp (dpi, options, d_right (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO:\n      d_append_string (dpi, \"typeinfo for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n      d_append_string (dpi, \"typeinfo name for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n      d_append_string (dpi, \"typeinfo fn for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_THUNK:\n      d_append_string (dpi, \"non-virtual thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n      d_append_string (dpi, \"virtual thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n      d_append_string (dpi, \"covariant return thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n      d_append_string (dpi, \"java Class for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_GUARD:\n      d_append_string (dpi, \"guard variable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TLS_INIT:\n      d_append_string (dpi, \"TLS init function for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n      d_append_string (dpi, \"TLS wrapper function for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_REFTEMP:\n      d_append_string (dpi, \"reference temporary #\");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_string (dpi, \" for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n      d_append_string (dpi, \"hidden alias for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n      d_append_string (dpi, \"transaction clone for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n      d_append_string (dpi, \"non-transaction clone for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_SUB_STD:\n      d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);\n      return;\n\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n      {\n\tstruct d_print_mod *pdpm;\n\n\t/* When printing arrays, it's possible to have cases where the\n\t   same CV-qualifier gets pushed on the stack multiple times.\n\t   We only need to print it once.  */\n\n\tfor (pdpm = dpi->modifiers; pdpm != NULL; pdpm = pdpm->next)\n\t  {\n\t    if (! pdpm->printed)\n\t      {\n\t\tif (pdpm->mod->type != DEMANGLE_COMPONENT_RESTRICT\n\t\t    && pdpm->mod->type != DEMANGLE_COMPONENT_VOLATILE\n\t\t    && pdpm->mod->type != DEMANGLE_COMPONENT_CONST)\n\t\t  break;\n\t\tif (pdpm->mod->type == dc->type)\n\t\t  {\n\t\t    d_print_comp (dpi, options, d_left (dc));\n\t\t    return;\n\t\t  }\n\t      }\n\t  }\n      }\n      goto modifier;\n\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      {\n\t/* Handle reference smashing: & + && = &.  */\n\tconst struct demangle_component *sub = d_left (dc);\n\tif (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n\t  {\n\t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n\t    struct demangle_component *a;\n\n\t    if (scope == NULL)\n\t      {\n\t\t/* This is the first time SUB has been traversed.\n\t\t   We need to capture the current templates so\n\t\t   they can be restored if SUB is reentered as a\n\t\t   substitution.  */\n\t\td_save_scope (dpi, sub);\n\t\tif (d_print_saw_error (dpi))\n\t\t  return;\n\t      }\n\t    else\n\t      {\n\t\tconst struct d_component_stack *dcse;\n\t\tint found_self_or_parent = 0;\n\n\t\t/* This traversal is reentering SUB as a substition.\n\t\t   If we are not beneath SUB or DC in the tree then we\n\t\t   need to restore SUB's template stack temporarily.  */\n\t\tfor (dcse = dpi->component_stack; dcse != NULL;\n\t\t     dcse = dcse->parent)\n\t\t  {\n\t\t    if (dcse->dc == sub\n\t\t\t|| (dcse->dc == dc\n\t\t\t    && dcse != dpi->component_stack))\n\t\t      {\n\t\t\tfound_self_or_parent = 1;\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\n\t\tif (!found_self_or_parent)\n\t\t  {\n\t\t    saved_templates = dpi->templates;\n\t\t    dpi->templates = scope->templates;\n\t\t    need_template_restore = 1;\n\t\t  }\n\t      }\n\n\t    a = d_lookup_template_argument (dpi, sub);\n\t    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t      a = d_index_template_argument (a, dpi->pack_index);\n\n\t    if (a == NULL)\n\t      {\n\t\tif (need_template_restore)\n\t\t  dpi->templates = saved_templates;\n\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    sub = a;\n\t  }\n\n\tif (sub->type == DEMANGLE_COMPONENT_REFERENCE\n\t    || sub->type == dc->type)\n\t  dc = sub;\n\telse if (sub->type == DEMANGLE_COMPONENT_RVALUE_REFERENCE)\n\t  mod_inner = d_left (sub);\n      }\n      /* Fall through.  */\n\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    modifier:\n      {\n\t/* We keep a list of modifiers on the stack.  */\n\tstruct d_print_mod dpm;\n\n\tdpm.next = dpi->modifiers;\n\tdpi->modifiers = &dpm;\n\tdpm.mod = dc;\n\tdpm.printed = 0;\n\tdpm.templates = dpi->templates;\n\n\tif (!mod_inner)\n\t  mod_inner = d_left (dc);\n\n\td_print_comp (dpi, options, mod_inner);\n\n\t/* If the modifier didn't get printed by the type, print it\n\t   now.  */\n\tif (! dpm.printed)\n\t  d_print_mod (dpi, options, dc);\n\n\tdpi->modifiers = dpm.next;\n\n\tif (need_template_restore)\n\t  dpi->templates = saved_templates;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n      if ((options & DMGL_JAVA) == 0)\n\td_append_buffer (dpi, dc->u.s_builtin.type->name,\n\t\t\t dc->u.s_builtin.type->len);\n      else\n\td_append_buffer (dpi, dc->u.s_builtin.type->java_name,\n\t\t\t dc->u.s_builtin.type->java_len);\n      return;\n\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n      {\n\tif ((options & DMGL_RET_POSTFIX) != 0)\n\t  d_print_function_type (dpi,\n\t\t\t\t options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t\t dc, dpi->modifiers);\n\n\t/* Print return type if present */\n\tif (d_left (dc) != NULL && (options & DMGL_RET_POSTFIX) != 0)\n\t  d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\td_left (dc));\n\telse if (d_left (dc) != NULL && (options & DMGL_RET_DROP) == 0)\n\t  {\n\t    struct d_print_mod dpm;\n\n\t    /* We must pass this type down as a modifier in order to\n\t       print it in the right location.  */\n\t    dpm.next = dpi->modifiers;\n\t    dpi->modifiers = &dpm;\n\t    dpm.mod = dc;\n\t    dpm.printed = 0;\n\t    dpm.templates = dpi->templates;\n\n\t    d_print_comp (dpi, options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t  d_left (dc));\n\n\t    dpi->modifiers = dpm.next;\n\n\t    if (dpm.printed)\n\t      return;\n\n\t    /* In standard prefix notation, there is a space between the\n\t       return type and the function signature.  */\n\t    if ((options & DMGL_RET_POSTFIX) == 0)\n\t      d_append_char (dpi, ' ');\n\t  }\n\n\tif ((options & DMGL_RET_POSTFIX) == 0)\n\t  d_print_function_type (dpi,\n\t\t\t\t options & ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t\t dc, dpi->modifiers);\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_mod *pdpm;\n\n\t/* We must pass this type down as a modifier in order to print\n\t   multi-dimensional arrays correctly.  If the array itself is\n\t   CV-qualified, we act as though the element type were\n\t   CV-qualified.  We do this by copying the modifiers down\n\t   rather than fiddling pointers, so that we don't wind up\n\t   with a d_print_mod higher on the stack pointing into our\n\t   stack frame after we return.  */\n\n\thold_modifiers = dpi->modifiers;\n\n\tadpm[0].next = hold_modifiers;\n\tdpi->modifiers = &adpm[0];\n\tadpm[0].mod = dc;\n\tadpm[0].printed = 0;\n\tadpm[0].templates = dpi->templates;\n\n\ti = 1;\n\tpdpm = hold_modifiers;\n\twhile (pdpm != NULL\n\t       && (pdpm->mod->type == DEMANGLE_COMPONENT_RESTRICT\n\t\t   || pdpm->mod->type == DEMANGLE_COMPONENT_VOLATILE\n\t\t   || pdpm->mod->type == DEMANGLE_COMPONENT_CONST))\n\t  {\n\t    if (! pdpm->printed)\n\t      {\n\t\tif (i >= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = *pdpm;\n\t\tadpm[i].next = dpi->modifiers;\n\t\tdpi->modifiers = &adpm[i];\n\t\tpdpm->printed = 1;\n\t\t++i;\n\t      }\n\n\t    pdpm = pdpm->next;\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tdpi->modifiers = hold_modifiers;\n\n\tif (adpm[0].printed)\n\t  return;\n\n\twhile (i > 1)\n\t  {\n\t    --i;\n\t    d_print_mod (dpi, options, adpm[i].mod);\n\t  }\n\n\td_print_array_type (dpi, options, dc, dpi->modifiers);\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n      {\n\tstruct d_print_mod dpm;\n\n\tdpm.next = dpi->modifiers;\n\tdpi->modifiers = &dpm;\n\tdpm.mod = dc;\n\tdpm.printed = 0;\n\tdpm.templates = dpi->templates;\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\t/* If the modifier didn't get printed by the type, print it\n\t   now.  */\n\tif (! dpm.printed)\n\t  d_print_mod (dpi, options, dc);\n\n\tdpi->modifiers = dpm.next;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n      if (dc->u.s_fixed.sat)\n\td_append_string (dpi, \"_Sat \");\n      /* Don't print \"int _Accum\".  */\n      if (dc->u.s_fixed.length->u.s_builtin.type\n\t  != &cplus_demangle_builtin_types['i'-'a'])\n\t{\n\t  d_print_comp (dpi, options, dc->u.s_fixed.length);\n\t  d_append_char (dpi, ' ');\n\t}\n      if (dc->u.s_fixed.accum)\n\td_append_string (dpi, \"_Accum\");\n      else\n\td_append_string (dpi, \"_Fract\");\n      return;\n\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n      if (d_left (dc) != NULL)\n\td_print_comp (dpi, options, d_left (dc));\n      if (d_right (dc) != NULL)\n\t{\n\t  size_t len;\n\t  unsigned long int flush_count;\n\t  /* Make sure \", \" isn't flushed by d_append_string, otherwise\n\t     dpi->len -= 2 wouldn't work.  */\n\t  if (dpi->len >= sizeof (dpi->buf) - 2)\n\t    d_print_flush (dpi);\n\t  d_append_string (dpi, \", \");\n\t  len = dpi->len;\n\t  flush_count = dpi->flush_count;\n\t  d_print_comp (dpi, options, d_right (dc));\n\t  /* If that didn't print anything (which can happen with empty\n\t     template argument packs), remove the comma and space.  */\n\t  if (dpi->flush_count == flush_count && dpi->len == len)\n\t    dpi->len -= 2;\n\t}\n      return;\n\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      {\n\tstruct demangle_component *type = d_left (dc);\n\tstruct demangle_component *list = d_right (dc);\n\n\tif (type)\n\t  d_print_comp (dpi, options, type);\n\td_append_char (dpi, '{');\n\td_print_comp (dpi, options, list);\n\td_append_char (dpi, '}');\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_OPERATOR:\n      {\n\tconst struct demangle_operator_info *op = dc->u.s_operator.op;\n\tint len = op->len;\n\n\td_append_string (dpi, \"operator\");\n\t/* Add a space before new/delete.  */\n\tif (IS_LOWER (op->name[0]))\n\t  d_append_char (dpi, ' ');\n\t/* Omit a trailing space.  */\n\tif (op->name[len-1] == ' ')\n\t  --len;\n\td_append_buffer (dpi, op->name, len);\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      d_append_string (dpi, \"operator \");\n      d_print_comp (dpi, options, dc->u.s_extended_operator.name);\n      return;\n\n    case DEMANGLE_COMPONENT_CAST:\n      d_append_string (dpi, \"operator \");\n      d_print_cast (dpi, options, dc);\n      return;\n\n    case DEMANGLE_COMPONENT_NULLARY:\n      d_print_expr_op (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_UNARY:\n      {\n\tstruct demangle_component *op = d_left (dc);\n\tstruct demangle_component *operand = d_right (dc);\n\tconst char *code = NULL;\n\n\tif (op->type == DEMANGLE_COMPONENT_OPERATOR)\n\t  {\n\t    code = op->u.s_operator.op->code;\n\t    if (!strcmp (code, \"ad\"))\n\t      {\n\t\t/* Don't print the argument list for the address of a\n\t\t   function.  */\n\t\tif (operand->type == DEMANGLE_COMPONENT_TYPED_NAME\n\t\t    && d_left (operand)->type == DEMANGLE_COMPONENT_QUAL_NAME\n\t\t    && d_right (operand)->type == DEMANGLE_COMPONENT_FUNCTION_TYPE)\n\t\t  operand = d_left (operand);\n\t      }\n\t    if (operand->type == DEMANGLE_COMPONENT_BINARY_ARGS)\n\t      {\n\t\t/* This indicates a suffix operator.  */\n\t\toperand = d_left (operand);\n\t\td_print_subexpr (dpi, options, operand);\n\t\td_print_expr_op (dpi, options, op);\n\t\treturn;\n\t      }\n\t  }\n\n\tif (op->type != DEMANGLE_COMPONENT_CAST)\n\t  d_print_expr_op (dpi, options, op);\n\telse\n\t  {\n\t    d_append_char (dpi, '(');\n\t    d_print_cast (dpi, options, op);\n\t    d_append_char (dpi, ')');\n\t  }\n\tif (code && !strcmp (code, \"gs\"))\n\t  /* Avoid parens after '::'.  */\n\t  d_print_comp (dpi, options, operand);\n\telse if (code && !strcmp (code, \"st\"))\n\t  /* Always print parens for sizeof (type).  */\n\t  {\n\t    d_append_char (dpi, '(');\n\t    d_print_comp (dpi, options, operand);\n\t    d_append_char (dpi, ')');\n\t  }\n\telse\n\t  d_print_subexpr (dpi, options, operand);\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_BINARY:\n      if (d_right (dc)->type != DEMANGLE_COMPONENT_BINARY_ARGS)\n\t{\n\t  d_print_error (dpi);\n\t  return;\n\t}\n\n      if (op_is_new_cast (d_left (dc)))\n\t{\n\t  d_print_expr_op (dpi, options, d_left (dc));\n\t  d_append_char (dpi, '<');\n\t  d_print_comp (dpi, options, d_left (d_right (dc)));\n\t  d_append_string (dpi, \">(\");\n\t  d_print_comp (dpi, options, d_right (d_right (dc)));\n\t  d_append_char (dpi, ')');\n\t  return;\n\t}\n\n      /* We wrap an expression which uses the greater-than operator in\n\t an extra layer of parens so that it does not get confused\n\t with the '>' which ends the template parameters.  */\n      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR\n\t  && d_left (dc)->u.s_operator.op->len == 1\n\t  && d_left (dc)->u.s_operator.op->name[0] == '>')\n\td_append_char (dpi, '(');\n\n      if (strcmp (d_left (dc)->u.s_operator.op->code, \"cl\") == 0\n          && d_left (d_right (dc))->type == DEMANGLE_COMPONENT_TYPED_NAME)\n\t{\n\t  /* Function call used in an expression should not have printed types\n\t     of the function arguments.  Values of the function arguments still\n\t     get printed below.  */\n\n\t  const struct demangle_component *func = d_left (d_right (dc));\n\n\t  if (d_right (func)->type != DEMANGLE_COMPONENT_FUNCTION_TYPE)\n\t    d_print_error (dpi);\n\t  d_print_subexpr (dpi, options, d_left (func));\n\t}\n      else\n\td_print_subexpr (dpi, options, d_left (d_right (dc)));\n      if (strcmp (d_left (dc)->u.s_operator.op->code, \"ix\") == 0)\n\t{\n\t  d_append_char (dpi, '[');\n\t  d_print_comp (dpi, options, d_right (d_right (dc)));\n\t  d_append_char (dpi, ']');\n\t}\n      else\n\t{\n\t  if (strcmp (d_left (dc)->u.s_operator.op->code, \"cl\") != 0)\n\t    d_print_expr_op (dpi, options, d_left (dc));\n\t  d_print_subexpr (dpi, options, d_right (d_right (dc)));\n\t}\n\n      if (d_left (dc)->type == DEMANGLE_COMPONENT_OPERATOR\n\t  && d_left (dc)->u.s_operator.op->len == 1\n\t  && d_left (dc)->u.s_operator.op->name[0] == '>')\n\td_append_char (dpi, ')');\n\n      return;\n\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n      /* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */\n      d_print_error (dpi);\n      return;\n\n    case DEMANGLE_COMPONENT_TRINARY:\n      if (d_right (dc)->type != DEMANGLE_COMPONENT_TRINARY_ARG1\n\t  || d_right (d_right (dc))->type != DEMANGLE_COMPONENT_TRINARY_ARG2)\n\t{\n\t  d_print_error (dpi);\n\t  return;\n\t}\n      {\n\tstruct demangle_component *op = d_left (dc);\n\tstruct demangle_component *first = d_left (d_right (dc));\n\tstruct demangle_component *second = d_left (d_right (d_right (dc)));\n\tstruct demangle_component *third = d_right (d_right (d_right (dc)));\n\n\tif (!strcmp (op->u.s_operator.op->code, \"qu\"))\n\t  {\n\t    d_print_subexpr (dpi, options, first);\n\t    d_print_expr_op (dpi, options, op);\n\t    d_print_subexpr (dpi, options, second);\n\t    d_append_string (dpi, \" : \");\n\t    d_print_subexpr (dpi, options, third);\n\t  }\n\telse\n\t  {\n\t    d_append_string (dpi, \"new \");\n\t    if (d_left (first) != NULL)\n\t      {\n\t\td_print_subexpr (dpi, options, first);\n\t\td_append_char (dpi, ' ');\n\t      }\n\t    d_print_comp (dpi, options, second);\n\t    if (third)\n\t      d_print_subexpr (dpi, options, third);\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      /* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */\n      d_print_error (dpi);\n      return;\n\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n      {\n\tenum d_builtin_type_print tp;\n\n\t/* For some builtin types, produce simpler output.  */\n\ttp = D_PRINT_DEFAULT;\n\tif (d_left (dc)->type == DEMANGLE_COMPONENT_BUILTIN_TYPE)\n\t  {\n\t    tp = d_left (dc)->u.s_builtin.type->print;\n\t    switch (tp)\n\t      {\n\t      case D_PRINT_INT:\n\t      case D_PRINT_UNSIGNED:\n\t      case D_PRINT_LONG:\n\t      case D_PRINT_UNSIGNED_LONG:\n\t      case D_PRINT_LONG_LONG:\n\t      case D_PRINT_UNSIGNED_LONG_LONG:\n\t\tif (d_right (dc)->type == DEMANGLE_COMPONENT_NAME)\n\t\t  {\n\t\t    if (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)\n\t\t      d_append_char (dpi, '-');\n\t\t    d_print_comp (dpi, options, d_right (dc));\n\t\t    switch (tp)\n\t\t      {\n\t\t      default:\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED:\n\t\t\td_append_char (dpi, 'u');\n\t\t\tbreak;\n\t\t      case D_PRINT_LONG:\n\t\t\td_append_char (dpi, 'l');\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED_LONG:\n\t\t\td_append_string (dpi, \"ul\");\n\t\t\tbreak;\n\t\t      case D_PRINT_LONG_LONG:\n\t\t\td_append_string (dpi, \"ll\");\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED_LONG_LONG:\n\t\t\td_append_string (dpi, \"ull\");\n\t\t\tbreak;\n\t\t      }\n\t\t    return;\n\t\t  }\n\t\tbreak;\n\n\t      case D_PRINT_BOOL:\n\t\tif (d_right (dc)->type == DEMANGLE_COMPONENT_NAME\n\t\t    && d_right (dc)->u.s_name.len == 1\n\t\t    && dc->type == DEMANGLE_COMPONENT_LITERAL)\n\t\t  {\n\t\t    switch (d_right (dc)->u.s_name.s[0])\n\t\t      {\n\t\t      case '0':\n\t\t\td_append_string (dpi, \"false\");\n\t\t\treturn;\n\t\t      case '1':\n\t\t\td_append_string (dpi, \"true\");\n\t\t\treturn;\n\t\t      default:\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\n\td_append_char (dpi, '(');\n\td_print_comp (dpi, options, d_left (dc));\n\td_append_char (dpi, ')');\n\tif (dc->type == DEMANGLE_COMPONENT_LITERAL_NEG)\n\t  d_append_char (dpi, '-');\n\tif (tp == D_PRINT_FLOAT)\n\t  d_append_char (dpi, '[');\n\td_print_comp (dpi, options, d_right (dc));\n\tif (tp == D_PRINT_FLOAT)\n\t  d_append_char (dpi, ']');\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_NUMBER:\n      d_append_num (dpi, dc->u.s_number.number);\n      return;\n\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n      d_append_string (dpi, \"java resource \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      d_print_comp (dpi, options, d_right (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_CHARACTER:\n      d_append_char (dpi, dc->u.s_character.character);\n      return;\n\n    case DEMANGLE_COMPONENT_DECLTYPE:\n      d_append_string (dpi, \"decltype (\");\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_char (dpi, ')');\n      return;\n\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n      {\n\tint len;\n\tint i;\n\tstruct demangle_component *a = d_find_pack (dpi, d_left (dc));\n\tif (a == NULL)\n\t  {\n\t    /* d_find_pack won't find anything if the only packs involved\n\t       in this expansion are function parameter packs; in that\n\t       case, just print the pattern and \"...\".  */\n\t    d_print_subexpr (dpi, options, d_left (dc));\n\t    d_append_string (dpi, \"...\");\n\t    return;\n\t  }\n\n\tlen = d_pack_length (a);\n\tdc = d_left (dc);\n\tfor (i = 0; i < len; ++i)\n\t  {\n\t    dpi->pack_index = i;\n\t    d_print_comp (dpi, options, dc);\n\t    if (i < len-1)\n\t      d_append_string (dpi, \", \");\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n      {\n\tlong num = dc->u.s_number.number;\n\tif (num == 0)\n\t  d_append_string (dpi, \"this\");\n\telse\n\t  {\n\t    d_append_string (dpi, \"{parm#\");\n\t    d_append_num (dpi, num);\n\t    d_append_char (dpi, '}');\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n      d_append_string (dpi, \"global constructors keyed to \");\n      d_print_comp (dpi, options, dc->u.s_binary.left);\n      return;\n\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n      d_append_string (dpi, \"global destructors keyed to \");\n      d_print_comp (dpi, options, dc->u.s_binary.left);\n      return;\n\n    case DEMANGLE_COMPONENT_LAMBDA:\n      d_append_string (dpi, \"{lambda(\");\n      d_print_comp (dpi, options, dc->u.s_unary_num.sub);\n      d_append_string (dpi, \")#\");\n      d_append_num (dpi, dc->u.s_unary_num.num + 1);\n      d_append_char (dpi, '}');\n      return;\n\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n      d_append_string (dpi, \"{unnamed type#\");\n      d_append_num (dpi, dc->u.s_number.number + 1);\n      d_append_char (dpi, '}');\n      return;\n\n    case DEMANGLE_COMPONENT_CLONE:\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \" [clone \");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_char (dpi, ']');\n      return;\n\n    default:\n      d_print_error (dpi);\n      return;\n    }\n}"
}