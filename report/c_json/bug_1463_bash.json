{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from state_bak.__count was never initialized.",
    "Code_line": "\t  SADD_MBCHAR (temp, string, sindex, string_size);",
    "Code_function": "expand_word_internal (word, quoted, isexp, contains_dollar_at, expanded_something)\n     WORD_DESC *word;\n     int quoted, isexp;\n     int *contains_dollar_at;\n     int *expanded_something;\n{\n  WORD_LIST *list;\n  WORD_DESC *tword;\n\n  /* The intermediate string that we build while expanding. */\n  char *istring;\n\n  /* The current size of the above object. */\n  int istring_size;\n\n  /* Index into ISTRING. */\n  int istring_index;\n\n  /* Temporary string storage. */\n  char *temp, *temp1;\n\n  /* The text of WORD. */\n  register char *string;\n\n  /* The size of STRING. */\n  size_t string_size;\n\n  /* The index into STRING. */\n  int sindex;\n\n  /* This gets 1 if we see a $@ while quoted. */\n  int quoted_dollar_at;\n\n  /* One of UNQUOTED, PARTIALLY_QUOTED, or WHOLLY_QUOTED, depending on\n     whether WORD contains no quoting characters, a partially quoted\n     string (e.g., \"xx\"ab), or is fully quoted (e.g., \"xxab\"). */\n  int quoted_state;\n\n  /* State flags */\n  int had_quoted_null;\n  int has_dollar_at, temp_has_dollar_at;\n  int split_on_spaces;\n  int tflag;\n  int pflags;\t\t\t/* flags passed to param_expand */\n\n  int assignoff;\t\t/* If assignment, offset of `=' */\n\n  register unsigned char c;\t/* Current character. */\n  int t_index;\t\t\t/* For calls to string_extract_xxx. */\n\n  char twochars[2];\n\n  DECLARE_MBSTATE;\n\n  istring = (char *)xmalloc (istring_size = DEFAULT_INITIAL_ARRAY_SIZE);\n  istring[istring_index = 0] = '\\0';\n  quoted_dollar_at = had_quoted_null = has_dollar_at = 0;\n  split_on_spaces = 0;\n  quoted_state = UNQUOTED;\n\n  string = word->word;\n  if (string == 0)\n    goto finished_with_string;\n  /* Don't need the string length for the SADD... and COPY_ macros unless\n     multibyte characters are possible. */\n  string_size = (MB_CUR_MAX > 1) ? strlen (string) : 1;\n\n  if (contains_dollar_at)\n    *contains_dollar_at = 0;\n\n  assignoff = -1;\n\n  /* Begin the expansion. */\n\n  for (sindex = 0; ;)\n    {\n      c = string[sindex];\n\n      /* Case on top-level character. */\n      switch (c)\n\t{\n\tcase '\\0':\n\t  goto finished_with_string;\n\n\tcase CTLESC:\n\t  sindex++;\n#if HANDLE_MULTIBYTE\n\t  if (MB_CUR_MAX > 1 && string[sindex])\n\t    {\n\t      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);\n\t    }\n\t  else\n#endif\n\t    {\n\t      temp = (char *)xmalloc (3);\n\t      temp[0] = CTLESC;\n\t      temp[1] = c = string[sindex];\n\t      temp[2] = '\\0';\n\t    }\n\ndollar_add_string:\n\t  if (string[sindex])\n\t    sindex++;\n\nadd_string:\n\t  if (temp)\n\t    {\n\t      istring = sub_append_string (temp, istring, &istring_index, &istring_size);\n\t      temp = (char *)0;\n\t    }\n\n\t  break;\n\n#if defined (PROCESS_SUBSTITUTION)\n\t  /* Process substitution. */\n\tcase '<':\n\tcase '>':\n\t  {\n\t    if (string[++sindex] != LPAREN || (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (word->flags & (W_DQUOTE|W_NOPROCSUB)) || posixly_correct)\n\t      {\n\t\tsindex--;\t/* add_character: label increments sindex */\n\t\tgoto add_character;\n\t      }\n\t    else\n\t      t_index = sindex + 1; /* skip past both '<' and LPAREN */\n\n\t    temp1 = extract_process_subst (string, (c == '<') ? \"<(\" : \">(\", &t_index); /*))*/\n\t    sindex = t_index;\n\n\t    /* If the process substitution specification is `<()', we want to\n\t       open the pipe for writing in the child and produce output; if\n\t       it is `>()', we want to open the pipe for reading in the child\n\t       and consume input. */\n\t    temp = temp1 ? process_substitute (temp1, (c == '>')) : (char *)0;\n\n\t    FREE (temp1);\n\n\t    goto dollar_add_string;\n\t  }\n#endif /* PROCESS_SUBSTITUTION */\n\n\tcase '=':\n\t  /* Posix.2 section 3.6.1 says that tildes following `=' in words\n\t     which are not assignment statements are not expanded.  If the\n\t     shell isn't in posix mode, though, we perform tilde expansion\n\t     on `likely candidate' unquoted assignment statements (flags\n\t     include W_ASSIGNMENT but not W_QUOTED).  A likely candidate\n\t     contains an unquoted :~ or =~.  Something to think about: we\n\t     now have a flag that says  to perform tilde expansion on arguments\n\t     to `assignment builtins' like declare and export that look like\n\t     assignment statements.  We now do tilde expansion on such words\n\t     even in POSIX mode. */\n\t  if (word->flags & (W_ASSIGNRHS|W_NOTILDE))\n\t    {\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\t  /* If we're not in posix mode or forcing assignment-statement tilde\n\t     expansion, note where the `=' appears in the word and prepare to\n\t     do tilde expansion following the first `='. */\n\t  if ((word->flags & W_ASSIGNMENT) &&\n\t      (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&\n\t      assignoff == -1 && sindex > 0)\n\t    assignoff = sindex;\n\t  if (sindex == assignoff && string[sindex+1] == '~')\t/* XXX */\n\t    word->flags |= W_ITILDE;\n#if 0\n\t  else if ((word->flags & W_ASSIGNMENT) &&\n\t\t   (posixly_correct == 0 || (word->flags & W_TILDEEXP)) &&\n\t\t   string[sindex+1] == '~')\n\t    word->flags |= W_ITILDE;\n#endif\n\t  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t    goto add_ifs_character;\n\t  else\n\t    goto add_character;\n\n\tcase ':':\n\t  if (word->flags & W_NOTILDE)\n\t    {\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\n\t  if ((word->flags & (W_ASSIGNMENT|W_ASSIGNRHS|W_TILDEEXP)) &&\n\t      string[sindex+1] == '~')\n\t    word->flags |= W_ITILDE;\n\n\t  if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c))\n\t    goto add_ifs_character;\n\t  else\n\t    goto add_character;\n\n\tcase '~':\n\t  /* If the word isn't supposed to be tilde expanded, or we're not\n\t     at the start of a word or after an unquoted : or = in an\n\t     assignment statement, we don't do tilde expansion. */\n\t  if ((word->flags & (W_NOTILDE|W_DQUOTE)) ||\n\t      (sindex > 0 && ((word->flags & W_ITILDE) == 0)) ||\n\t      (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    {\n\t      word->flags &= ~W_ITILDE;\n\t      if (isexp == 0 && (word->flags & (W_NOSPLIT|W_NOSPLIT2)) == 0 && isifs (c) && (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) == 0)\n\t\tgoto add_ifs_character;\n\t      else\n\t\tgoto add_character;\n\t    }\n\n\t  if (word->flags & W_ASSIGNRHS)\n\t    tflag = 2;\n\t  else if (word->flags & (W_ASSIGNMENT|W_TILDEEXP))\n\t    tflag = 1;\n\t  else\n\t    tflag = 0;\n\n\t  temp = bash_tilde_find_word (string + sindex, tflag, &t_index);\n\n\t  word->flags &= ~W_ITILDE;\n\n\t  if (temp && *temp && t_index > 0)\n\t    {\n\t      temp1 = bash_tilde_expand (temp, tflag);\n\t      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))\n\t\t{\n\t\t  FREE (temp);\n\t\t  FREE (temp1);\n\t\t  goto add_character;\t\t/* tilde expansion failed */\n\t\t}\n\t      free (temp);\n\t      temp = temp1;\n\t      sindex += t_index;\n\t      goto add_quoted_string;\t\t/* XXX was add_string */\n\t    }\n\t  else\n\t    {\n\t      FREE (temp);\n\t      goto add_character;\n\t    }\n\n\tcase '$':\n\t  if (expanded_something)\n\t    *expanded_something = 1;\n\n\t  temp_has_dollar_at = 0;\n\t  pflags = (word->flags & W_NOCOMSUB) ? PF_NOCOMSUB : 0;\n\t  if (word->flags & W_NOSPLIT2)\n\t    pflags |= PF_NOSPLIT2;\n\t  if (word->flags & W_ASSIGNRHS)\n\t    pflags |= PF_ASSIGNRHS;\n\t  tword = param_expand (string, &sindex, quoted, expanded_something,\n\t\t\t       &temp_has_dollar_at, &quoted_dollar_at,\n\t\t\t       &had_quoted_null, pflags);\n\t  has_dollar_at += temp_has_dollar_at;\n\t  split_on_spaces += (tword->flags & W_SPLITSPACE);\n\n\t  if (tword == &expand_wdesc_error || tword == &expand_wdesc_fatal)\n\t    {\n\t      free (string);\n\t      free (istring);\n\t      return ((tword == &expand_wdesc_error) ? &expand_word_error\n\t\t\t\t\t\t     : &expand_word_fatal);\n\t    }\n\t  if (contains_dollar_at && has_dollar_at)\n\t    *contains_dollar_at = 1;\n\n\t  if (tword && (tword->flags & W_HASQUOTEDNULL))\n\t    had_quoted_null = 1;\n\n\t  temp = tword ? tword->word : (char *)NULL;\n\t  dispose_word_desc (tword);\n\n\t  /* Kill quoted nulls; we will add them back at the end of\n\t     expand_word_internal if nothing else in the string */\n\t  if (had_quoted_null && temp && QUOTED_NULL (temp))\n\t    {\n\t      FREE (temp);\n\t      temp = (char *)NULL;\n\t    }\n\n\t  goto add_string;\n\t  break;\n\n\tcase '`':\t\t/* Backquoted command substitution. */\n\t  {\n\t    t_index = sindex++;\n\n\t    temp = string_extract (string, &sindex, \"`\", SX_REQMATCH);\n\t    /* The test of sindex against t_index is to allow bare instances of\n\t       ` to pass through, for backwards compatibility. */\n\t    if (temp == &extract_string_error || temp == &extract_string_fatal)\n\t      {\n\t\tif (sindex - 1 == t_index)\n\t\t  {\n\t\t    sindex = t_index;\n\t\t    goto add_character;\n\t\t  }\n\t\tlast_command_exit_value = EXECUTION_FAILURE;\n\t\treport_error (_(\"bad substitution: no closing \\\"`\\\" in %s\") , string+t_index);\n\t\tfree (string);\n\t\tfree (istring);\n\t\treturn ((temp == &extract_string_error) ? &expand_word_error\n\t\t\t\t\t\t\t: &expand_word_fatal);\n\t      }\n\n\t    if (expanded_something)\n\t      *expanded_something = 1;\n\n\t    if (word->flags & W_NOCOMSUB)\n\t      /* sindex + 1 because string[sindex] == '`' */\n\t      temp1 = substring (string, t_index, sindex + 1);\n\t    else\n\t      {\n\t\tde_backslash (temp);\n\t\ttword = command_substitute (temp, quoted);\n\t\ttemp1 = tword ? tword->word : (char *)NULL;\n\t\tif (tword)\n\t\t  dispose_word_desc (tword);\n\t      }\n\t    FREE (temp);\n\t    temp = temp1;\n\t    goto dollar_add_string;\n\t  }\n\n\tcase '\\\\':\n\t  if (string[sindex + 1] == '\\n')\n\t    {\n\t      sindex += 2;\n\t      continue;\n\t    }\n\n\t  c = string[++sindex];\n\n\t  if (quoted & Q_HERE_DOCUMENT)\n\t    tflag = CBSHDOC;\n\t  else if (quoted & Q_DOUBLE_QUOTES)\n\t    tflag = CBSDQUOTE;\n\t  else\n\t    tflag = 0;\n\n\t  /* From Posix discussion on austin-group list:  Backslash escaping\n\t     a } in ${...} is removed.  Issue 0000221 */\n\t  if ((quoted & Q_DOLBRACE) && c == RBRACE)\n\t    {\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\t  /* This is the fix for \" $@\\ \" */\n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0) && isexp == 0 && isifs (c))\n\t    {\n\t      RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t      DEFAULT_ARRAY_SIZE);\n\t      istring[istring_index++] = CTLESC;\n\t      istring[istring_index++] = '\\\\';\n\t      istring[istring_index] = '\\0';\n\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\t  else if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) && ((sh_syntaxtab[c] & tflag) == 0))\n\t    {\n\t      SCOPY_CHAR_I (twochars, '\\\\', c, string, sindex, string_size);\n\t    }\n\t  else if (c == 0)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\t\t/* add_character: label increments sindex */\n\t      goto add_character;\n\t    }\n\t  else\n\t    {\n\t      SCOPY_CHAR_I (twochars, CTLESC, c, string, sindex, string_size);\n\t    }\n\n\t  sindex++;\nadd_twochars:\n\t  /* BEFORE jumping here, we need to increment sindex if appropriate */\n\t  RESIZE_MALLOCED_BUFFER (istring, istring_index, 2, istring_size,\n\t\t\t\t  DEFAULT_ARRAY_SIZE);\n\t  istring[istring_index++] = twochars[0];\n\t  istring[istring_index++] = twochars[1];\n\t  istring[istring_index] = '\\0';\n\n\t  break;\n\n\tcase '\"':\n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    goto add_character;\n\n\t  t_index = ++sindex;\n\t  temp = string_extract_double_quoted (string, &sindex, 0);\n\n\t  /* If the quotes surrounded the entire string, then the\n\t     whole word was quoted. */\n\t  quoted_state = (t_index == 1 && string[sindex] == '\\0')\n\t\t\t    ? WHOLLY_QUOTED\n\t\t\t    : PARTIALLY_QUOTED;\n\n\t  if (temp && *temp)\n\t    {\n\t      tword = alloc_word_desc ();\n\t      tword->word = temp;\n\n\t      temp = (char *)NULL;\n\n\t      temp_has_dollar_at = 0;\t/* XXX */\n\t      /* Need to get W_HASQUOTEDNULL flag through this function. */\n\t      list = expand_word_internal (tword, Q_DOUBLE_QUOTES, 0, &temp_has_dollar_at, (int *)NULL);\n\t      has_dollar_at += temp_has_dollar_at;\n\n\t      if (list == &expand_word_error || list == &expand_word_fatal)\n\t\t{\n\t\t  free (istring);\n\t\t  free (string);\n\t\t  /* expand_word_internal has already freed temp_word->word\n\t\t     for us because of the way it prints error messages. */\n\t\t  tword->word = (char *)NULL;\n\t\t  dispose_word (tword);\n\t\t  return list;\n\t\t}\n\n\t      dispose_word (tword);\n\n\t      /* \"$@\" (a double-quoted dollar-at) expands into nothing,\n\t\t not even a NULL word, when there are no positional\n\t\t parameters. */\n\t      if (list == 0 && has_dollar_at)\n\t\t{\n\t\t  quoted_dollar_at++;\n\t\t  break;\n\t\t}\n\n\t      /* If we get \"$@\", we know we have expanded something, so we\n\t\t need to remember it for the final split on $IFS.  This is\n\t\t a special case; it's the only case where a quoted string\n\t\t can expand into more than one word.  It's going to come back\n\t\t from the above call to expand_word_internal as a list with\n\t\t a single word, in which all characters are quoted and\n\t\t separated by blanks.  What we want to do is to turn it back\n\t\t into a list for the next piece of code. */\n\t      if (list)\n\t\tdequote_list (list);\n\n\t      if (list && list->word && (list->word->flags & W_HASQUOTEDNULL))\n\t\thad_quoted_null = 1;\t\t/* XXX */\n\n\t      if (has_dollar_at)\n\t\t{\n\t\t  quoted_dollar_at++;\n\t\t  if (contains_dollar_at)\n\t\t    *contains_dollar_at = 1;\n\t\t  if (expanded_something)\n\t\t    *expanded_something = 1;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* What we have is \"\".  This is a minor optimization. */\n\t      FREE (temp);\n\t      list = (WORD_LIST *)NULL;\n\t    }\n\n\t  /* The code above *might* return a list (consider the case of \"$@\",\n\t     where it returns \"$1\", \"$2\", etc.).  We can't throw away the\n\t     rest of the list, and we have to make sure each word gets added\n\t     as quoted.  We test on tresult->next:  if it is non-NULL, we\n\t     quote the whole list, save it to a string with string_list, and\n\t     add that string. We don't need to quote the results of this\n\t     (and it would be wrong, since that would quote the separators\n\t     as well), so we go directly to add_string. */\n\t  if (list)\n\t    {\n\t      if (list->next)\n\t\t{\n\t\t  /* Testing quoted_dollar_at makes sure that \"$@\" is\n\t\t     split correctly when $IFS does not contain a space. */\n\t\t  temp = quoted_dollar_at\n\t\t\t\t? string_list_dollar_at (list, Q_DOUBLE_QUOTES)\n\t\t\t\t: string_list (quote_list (list));\n\t\t  dispose_words (list);\n\t\t  goto add_string;\n\t\t}\n\t      else\n\t\t{\n\t\t  temp = savestring (list->word->word);\n\t\t  tflag = list->word->flags;\n\t\t  dispose_words (list);\n\n\t\t  /* If the string is not a quoted null string, we want\n\t\t     to remove any embedded unquoted CTLNUL characters.\n\t\t     We do not want to turn quoted null strings back into\n\t\t     the empty string, though.  We do this because we\n\t\t     want to remove any quoted nulls from expansions that\n\t\t     contain other characters.  For example, if we have\n\t\t     x\"$*\"y or \"x$*y\" and there are no positional parameters,\n\t\t     the $* should expand into nothing. */\n\t\t  /* We use the W_HASQUOTEDNULL flag to differentiate the\n\t\t     cases:  a quoted null character as above and when\n\t\t     CTLNUL is contained in the (non-null) expansion\n\t\t     of some variable.  We use the had_quoted_null flag to\n\t\t     pass the value through this function to its caller. */\n\t\t  if ((tflag & W_HASQUOTEDNULL) && QUOTED_NULL (temp) == 0)\n\t\t    remove_quoted_nulls (temp);\t/* XXX */\n\t\t}\n\t    }\n\t  else\n\t    temp = (char *)NULL;\n\n\t  /* We do not want to add quoted nulls to strings that are only\n\t     partially quoted; we can throw them away.  The exception to\n\t     this is when we are going to be performing word splitting,\n\t     since we have to preserve a null argument if the next character\n\t     will cause word splitting. */\n\t  if (temp == 0 && quoted_state == PARTIALLY_QUOTED && (word->flags & (W_NOSPLIT|W_NOSPLIT2)))\n\t    continue;\n\n\tadd_quoted_string:\n\n\t  if (temp)\n\t    {\n\t      temp1 = temp;\n\t      temp = quote_string (temp);\n\t      free (temp1);\n\t      goto add_string;\n\t    }\n\t  else\n\t    {\n\t      /* Add NULL arg. */\n\t      c = CTLNUL;\n\t      sindex--;\t\t/* add_character: label increments sindex */\n\t      goto add_character;\n\t    }\n\n\t  /* break; */\n\n\tcase '\\'':\n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)))\n\t    goto add_character;\n\n\t  t_index = ++sindex;\n\t  temp = string_extract_single_quoted (string, &sindex);\n\n\t  /* If the entire STRING was surrounded by single quotes,\n\t     then the string is wholly quoted. */\n\t  quoted_state = (t_index == 1 && string[sindex] == '\\0')\n\t\t\t    ? WHOLLY_QUOTED\n\t\t\t    : PARTIALLY_QUOTED;\n\n\t  /* If all we had was '', it is a null expansion. */\n\t  if (*temp == '\\0')\n\t    {\n\t      free (temp);\n\t      temp = (char *)NULL;\n\t    }\n\t  else\n\t    remove_quoted_escapes (temp);\t/* ??? */\n\n\t  /* We do not want to add quoted nulls to strings that are only\n\t     partially quoted; such nulls are discarded. */\n\t  if (temp == 0 && (quoted_state == PARTIALLY_QUOTED))\n\t    continue;\n\n\t  /* If we have a quoted null expansion, add a quoted NULL to istring. */\n\t  if (temp == 0)\n\t    {\n\t      c = CTLNUL;\n\t      sindex--;\t\t/* add_character: label increments sindex */\n\t      goto add_character;\n\t    }\n\t  else\n\t    goto add_quoted_string;\n\n\t  /* break; */\n\n\tdefault:\n\t  /* This is the fix for \" $@ \" */\n\tadd_ifs_character:\n\t  if ((quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES)) || (isexp == 0 && isifs (c)))\n\t    {\n\t      if (string[sindex])\t/* from old goto dollar_add_string */\n\t\tsindex++;\n\t      if (c == 0)\n\t\t{\n\t\t  c = CTLNUL;\n\t\t  goto add_character;\n\t\t}\n\t      else\n\t\t{\n#if HANDLE_MULTIBYTE\n\t\t  if (MB_CUR_MAX > 1)\n\t\t    sindex--;\n\n\t\t  if (MB_CUR_MAX > 1)\n\t\t    {\n\t\t      SADD_MBQCHAR_BODY(temp, string, sindex, string_size);\n\t\t    }\n\t\t  else\n#endif\n\t\t    {\n\t\t      twochars[0] = CTLESC;\n\t\t      twochars[1] = c;\n\t\t      goto add_twochars;\n\t\t    }\n\t\t}\n\t    }\n\n\t  SADD_MBCHAR (temp, string, sindex, string_size);\n\n\tadd_character:\n\t  RESIZE_MALLOCED_BUFFER (istring, istring_index, 1, istring_size,\n\t\t\t\t  DEFAULT_ARRAY_SIZE);\n\t  istring[istring_index++] = c;\n\t  istring[istring_index] = '\\0';\n\n\t  /* Next character. */\n\t  sindex++;\n\t}\n    }\n\nfinished_with_string:\n  /* OK, we're ready to return.  If we have a quoted string, and\n     quoted_dollar_at is not set, we do no splitting at all; otherwise\n     we split on ' '.  The routines that call this will handle what to\n     do if nothing has been expanded. */\n\n  /* Partially and wholly quoted strings which expand to the empty\n     string are retained as an empty arguments.  Unquoted strings\n     which expand to the empty string are discarded.  The single\n     exception is the case of expanding \"$@\" when there are no\n     positional parameters.  In that case, we discard the expansion. */\n\n  /* Because of how the code that handles \"\" and '' in partially\n     quoted strings works, we need to make ISTRING into a QUOTED_NULL\n     if we saw quoting characters, but the expansion was empty.\n     \"\" and '' are tossed away before we get to this point when\n     processing partially quoted strings.  This makes \"\" and $xxx\"\"\n     equivalent when xxx is unset.  We also look to see whether we\n     saw a quoted null from a ${} expansion and add one back if we\n     need to. */\n\n  /* If we expand to nothing and there were no single or double quotes\n     in the word, we throw it away.  Otherwise, we return a NULL word.\n     The single exception is for $@ surrounded by double quotes when\n     there are no positional parameters.  In that case, we also throw\n     the word away. */\n\n  if (*istring == '\\0')\n    {\n      if (quoted_dollar_at == 0 && (had_quoted_null || quoted_state == PARTIALLY_QUOTED))\n\t{\n\t  istring[0] = CTLNUL;\n\t  istring[1] = '\\0';\n\t  tword = make_bare_word (istring);\n\t  tword->flags |= W_HASQUOTEDNULL;\t\t/* XXX */\n\t  list = make_word_list (tword, (WORD_LIST *)NULL);\n\t  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t    tword->flags |= W_QUOTED;\n\t}\n      /* According to sh, ksh, and Posix.2, if a word expands into nothing\n\t and a double-quoted \"$@\" appears anywhere in it, then the entire\n\t word is removed. */\n      else  if (quoted_state == UNQUOTED || quoted_dollar_at)\n\tlist = (WORD_LIST *)NULL;\n#if 0\n      else\n\t{\n\t  tword = make_bare_word (istring);\n\t  if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\t    tword->flags |= W_QUOTED;\n\t  list = make_word_list (tword, (WORD_LIST *)NULL);\n\t}\n#else\n      else\n\tlist = (WORD_LIST *)NULL;\n#endif\n    }\n  else if (word->flags & W_NOSPLIT)\n    {\n      tword = make_bare_word (istring);\n      if (word->flags & W_ASSIGNMENT)\n\ttword->flags |= W_ASSIGNMENT;\t/* XXX */\n      if (word->flags & W_COMPASSIGN)\n\ttword->flags |= W_COMPASSIGN;\t/* XXX */\n      if (word->flags & W_NOGLOB)\n\ttword->flags |= W_NOGLOB;\t/* XXX */\n      if (word->flags & W_NOBRACE)\n\ttword->flags |= W_NOBRACE;\t/* XXX */\n      if (word->flags & W_NOEXPAND)\n\ttword->flags |= W_NOEXPAND;\t/* XXX */\n      if (quoted & (Q_HERE_DOCUMENT|Q_DOUBLE_QUOTES))\n\ttword->flags |= W_QUOTED;\n      if (had_quoted_null && QUOTED_NULL (istring))\n\ttword->flags |= W_HASQUOTEDNULL;\n      list = make_word_list (tword, (WORD_LIST *)NULL);\n    }\n  else\n    {\n      char *ifs_chars;\n\n      ifs_chars = (quoted_dollar_at || has_dollar_at) ? ifs_value : (char *)NULL;\n\n      /* If we have $@, we need to split the results no matter what.  If\n\t IFS is unset or NULL, string_list_dollar_at has separated the\n\t positional parameters with a space, so we split on space (we have\n\t set ifs_chars to \" \\t\\n\" above if ifs is unset).  If IFS is set,\n\t string_list_dollar_at has separated the positional parameters\n\t with the first character of $IFS, so we split on $IFS.  If\n\t SPLIT_ON_SPACES is set, we expanded $* (unquoted) with IFS either\n\t unset or null, and we want to make sure that we split on spaces\n\t regardless of what else has happened to IFS since the expansion. */\n      if (split_on_spaces)\n\tlist = list_string (istring, \" \", 1);\t/* XXX quoted == 1? */\n      else if (has_dollar_at && ifs_chars)\n\tlist = list_string (istring, *ifs_chars ? ifs_chars : \" \", 1);\n      else\n\t{\n\t  tword = make_bare_word (istring);\n\t  if ((quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT)) || (quoted_state == WHOLLY_QUOTED))\n\t    tword->flags |= W_QUOTED;\n\t  if (word->flags & W_ASSIGNMENT)\n\t    tword->flags |= W_ASSIGNMENT;\n\t  if (word->flags & W_COMPASSIGN)\n\t    tword->flags |= W_COMPASSIGN;\n\t  if (word->flags & W_NOGLOB)\n\t    tword->flags |= W_NOGLOB;\n\t  if (word->flags & W_NOBRACE)\n\t    tword->flags |= W_NOBRACE;\n\t  if (word->flags & W_NOEXPAND)\n\t    tword->flags |= W_NOEXPAND;\n\t  if (had_quoted_null && QUOTED_NULL (istring))\n\t    tword->flags |= W_HASQUOTEDNULL;\t/* XXX */\n\t  list = make_word_list (tword, (WORD_LIST *)NULL);\n\t}\n    }\n\n  free (istring);\n  return (list);\n}"
}