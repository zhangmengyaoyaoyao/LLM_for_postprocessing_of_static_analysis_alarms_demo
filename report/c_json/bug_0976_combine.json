{
    "project": "combine",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "src/process_files.c",
    "message": "Offset: [-1, +oo] Size: [1, +oo] by call to `process_data_reference_matches`.",
    "warning_function_name": "process_data_file",
    "warning_line": "process_data_reference_matches (output_fields, 0, &write_record,",
    "warning_context": "      fprintf (stderr, _(\"\\rReading from data file %s: %12d records\"),\n\t       (input_file == stdin ? \"stdin\" : input_filename),\n\t       gi_file_records_read);\n\n    /* If we need to do anything to the entire record, do it */\n#ifdef HAVE_LIBGUILE\n    if (gs_data_ext_record_read_command != NULL) {\n      char *command_string;\n      STRINGTYPE *result_string;\n      SCM return_val;\n      size_t return_length;\n\n      command_string\n\t= malloc (gs_data_ext_record_read_command->length\n\t\t  + input_record_desc->length + 1);\n      if (command_string == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      sprintf (command_string, gs_data_ext_record_read_command->string,\n\t       input_record_desc->length, input_record_desc->string);\n      result_string = eval_scheme_string_function (command_string);\n      if (input_record_desc->own_string == DStr_own)\n\tfree (input_record_desc->string);\n      input_record_desc->string = result_string->string;\n      input_record_desc->length = result_string->length;\n      input_record_desc->own_string = DStr_not_own;\n      result_string->own_string = DStr_not_own;\n      dstrfree (result_string);\n      free (command_string);\n      }\n#  endif /* HAVE_LIBGUILE */\n\n\n    /* Assemble data file output fields. */\n    return_code\n      = a_find_input_ranges (&output_fields, input_record_desc,\n\t\t\t     gra_data_out_ranges, gi_data_out_range_count,\n\t\t\t     gi_data_out_end_start,\n\t\t\t     gs_data_input_field_delimiter,\n\t\t\t     gi_data_input_field_delimiter_repeat, DStr_not_own,\n\t\t\t     gs_output_field_delimiter, gs_data_empty_string);\n    if (return_code != EXIT_SUCCESS)\n      FATAL_ERROR (_(\"unable to allocate memory\"));\n    if (gs_data_empty_string != NULL) {\n      return_code\n\t= fill_empty_fields (output_fields, gi_data_out_range_count,\n\t\t\t     gs_data_empty_string);\n      if (return_code != EXIT_SUCCESS)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      }\n\n#ifdef HAVE_LIBGUILE\n    /* Before we do anything for the record, check for filtering request */\n    if (gs_data_ext_filter_command != NULL) {\n      char *command_string;\n      SCM return_val;\n      int still_keep_record;\n      int ifield;\n\n      /* Make the output fields available to Guile */\n      for (ifield = 0;\n\t   ifield < gi_data_out_range_count + (gi_data_out_end_start != 0 ? 1\n\t\t\t\t\t       : 0); ifield++) {\n\tcreate_scheme_string_variable (&df_name_data_field, ifield + 1,\n\t\t\t\t       output_fields[ifield]);\n\t}\n\n      command_string = strdupdstr (gs_data_ext_filter_command);\n      if (command_string == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      still_keep_record = eval_scheme_boolean_function (command_string);\n      free (command_string);\n      if (!still_keep_record)\n\tkeep_record = 0;\n      }\n#  endif /* HAVE_LIBGUILE */\n\n\n    if (keep_record) {\n      /* Now loop through reference files to find matches. */\n      process_data_reference_matches (output_fields, 0, &write_record,\n\t\t\t\t      input_record_desc);\n      if (write_record != 0) {\n\tgi_data_records_matched++;\n\tgi_file_records_matched++;\n\t}\n      }\n    else {\n      gi_file_records_dropped_filter++;\n      gi_data_records_dropped_filter++;\n      }\n\n    for (i = 0; i < gi_data_out_range_count; i++)\n      dstrfree (output_fields[i]);\n    free (output_fields);\n\n    dstrfree (input_record_desc);\n    input_record_desc\n      = df_get_next_record (input_file, &(gs_data_input_buffer),\n\t\t\t    &(gi_data_input_buffer_pos),\n\t\t\t    &(gi_data_input_buffer_size),\n\t\t\t    gs_data_input_record_delimiter,\n"
}