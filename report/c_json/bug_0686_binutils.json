{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "NULL_DEREFERENCE",
    "Code_line": "  os = s->output_section;",
    "Code_function": "linux_finish_dynamic_link (bfd *output_bfd,\n\t\t\t   struct bfd_link_info *info)\n{\n  asection *s, *os, *is;\n  bfd_byte *fixup_table;\n  struct linux_link_hash_entry *h;\n  struct fixup *f;\n  unsigned int new_addr;\n  int section_offset;\n  unsigned int fixups_written;\n\n  if (linux_hash_table (info)->dynobj == NULL)\n    return TRUE;\n\n  s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,\n\t\t\t       \".linux-dynamic\");\n  BFD_ASSERT (s != NULL);\n  os = s->output_section;\n  fixups_written = 0;\n\n#ifdef LINUX_LINK_DEBUG\n  printf (\"Fixup table file offset: %x  VMA: %x\\n\",\n\t  os->filepos + s->output_offset,\n\t  os->vma + s->output_offset);\n#endif\n\n  fixup_table = s->contents;\n  bfd_put_32 (output_bfd,\n\t      (bfd_vma) linux_hash_table (info)->fixup_count, fixup_table);\n  fixup_table += 4;\n\n  /* Fill in fixup table.  */\n  for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)\n    {\n      if (f->builtin)\n\tcontinue;\n\n      if (f->h->root.root.type != bfd_link_hash_defined\n\t  && f->h->root.root.type != bfd_link_hash_defweak)\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"Symbol %s not defined for fixups\\n\"),\n\t     f->h->root.root.root.string);\n\t  continue;\n\t}\n\n      is = f->h->root.root.u.def.section;\n      section_offset = is->output_section->vma + is->output_offset;\n      new_addr = f->h->root.root.u.def.value + section_offset;\n\n#ifdef LINUX_LINK_DEBUG\n      printf (\"Fixup(%d) %s: %x %x\\n\",f->jump, f->h->root.root.string,\n\t      new_addr, f->value);\n#endif\n\n      if (f->jump)\n\t{\n\t  /* Relative address */\n\t  new_addr = new_addr - (f->value + 5);\n\t  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);\n\t  fixup_table += 4;\n\t  bfd_put_32 (output_bfd, f->value + 1, fixup_table);\n\t  fixup_table += 4;\n\t}\n      else\n\t{\n\t  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);\n\t  fixup_table += 4;\n\t  bfd_put_32 (output_bfd, f->value, fixup_table);\n\t  fixup_table += 4;\n\t}\n      ++fixups_written;\n    }\n\n  if (linux_hash_table (info)->local_builtins != 0)\n    {\n      /* Special marker so we know to switch to the other type of fixup */\n      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n      fixup_table += 4;\n      bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n      fixup_table += 4;\n      ++fixups_written;\n      for (f = linux_hash_table (info)->fixup_list; f != NULL; f = f->next)\n\t{\n\t  if (! f->builtin)\n\t    continue;\n\n\t  if (f->h->root.root.type != bfd_link_hash_defined\n\t      && f->h->root.root.type != bfd_link_hash_defweak)\n\t    {\n\t      (*_bfd_error_handler)\n\t\t(_(\"Symbol %s not defined for fixups\\n\"),\n\t\t f->h->root.root.root.string);\n\t      continue;\n\t    }\n\n\t  is = f->h->root.root.u.def.section;\n\t  section_offset = is->output_section->vma + is->output_offset;\n\t  new_addr = f->h->root.root.u.def.value + section_offset;\n\n#ifdef LINUX_LINK_DEBUG\n\t  printf (\"Fixup(B) %s: %x %x\\n\", f->h->root.root.string,\n\t\t  new_addr, f->value);\n#endif\n\n\t  bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);\n\t  fixup_table += 4;\n\t  bfd_put_32 (output_bfd, f->value, fixup_table);\n\t  fixup_table += 4;\n\t  ++fixups_written;\n\t}\n  }\n\n  if (linux_hash_table (info)->fixup_count != fixups_written)\n    {\n      (*_bfd_error_handler) (_(\"Warning: fixup count mismatch\\n\"));\n      while (linux_hash_table (info)->fixup_count > fixups_written)\n\t{\n\t  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n\t  fixup_table += 4;\n\t  bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n\t  fixup_table += 4;\n\t  ++fixups_written;\n\t}\n    }\n\n  h = linux_link_hash_lookup (linux_hash_table (info),\n\t\t\t      \"__BUILTIN_FIXUPS__\",\n\t\t\t      FALSE, FALSE, FALSE);\n\n  if (h != NULL\n      && (h->root.root.type == bfd_link_hash_defined\n\t  || h->root.root.type == bfd_link_hash_defweak))\n    {\n      is = h->root.root.u.def.section;\n      section_offset = is->output_section->vma + is->output_offset;\n      new_addr = h->root.root.u.def.value + section_offset;\n\n#ifdef LINUX_LINK_DEBUG\n      printf (\"Builtin fixup table at %x\\n\", new_addr);\n#endif\n\n      bfd_put_32 (output_bfd, (bfd_vma) new_addr, fixup_table);\n    }\n  else\n    bfd_put_32 (output_bfd, (bfd_vma) 0, fixup_table);\n\n  if (bfd_seek (output_bfd, (file_ptr) (os->filepos + s->output_offset),\n\t\tSEEK_SET) != 0)\n    return FALSE;\n\n  if (bfd_bwrite (s->contents, s->size, output_bfd) != s->size)\n    return FALSE;\n\n  return TRUE;\n}"
}