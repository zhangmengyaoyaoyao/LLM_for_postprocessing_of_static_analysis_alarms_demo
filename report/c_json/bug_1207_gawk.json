{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "array.c",
    "message": "Offset added: 65 (‚áê 1 + 64) Size: [0, +oo] by call to `bcalloc`.",
    "warning_function_name": "assoc_list",
    "warning_line": "code = bcalloc(Op_func_call, 2, 0);",
    "warning_context": "{\n\ttypedef int (*qsort_compfunc)(const void *, const void *);\n\n\tstatic const struct qsort_funcs {\n\t\tconst char *name;\n\t\tqsort_compfunc comp_func;\n\t\tassoc_kind_t kind;\n\t} sort_funcs[] = {\n{ \"@ind_str_asc\",\tsort_up_index_string,\tAINDEX|AISTR|AASC },\n{ \"@ind_num_asc\",\tsort_up_index_number,\tAINDEX|AINUM|AASC },\n{ \"@val_str_asc\",\tsort_up_value_string,\tAVALUE|AVSTR|AASC },\n{ \"@val_num_asc\",\tsort_up_value_number,\tAVALUE|AVNUM|AASC },\n{ \"@ind_str_desc\",\tsort_down_index_string,\tAINDEX|AISTR|ADESC },\n{ \"@ind_num_desc\",\tsort_down_index_number,\tAINDEX|AINUM|ADESC },\n{ \"@val_str_desc\",\tsort_down_value_string,\tAVALUE|AVSTR|ADESC },\n{ \"@val_num_desc\",\tsort_down_value_number,\tAVALUE|AVNUM|ADESC },\n{ \"@val_type_asc\",\tsort_up_value_type,\tAVALUE|AASC },\n{ \"@val_type_desc\",\tsort_down_value_type,\tAVALUE|ADESC },\n{ \"@unsorted\",\t\t0,\t\t\tAINDEX },\n};\n\n\t/*\n\t * N.B.: AASC and ADESC are hints to the specific array types.\n\t *\tSee cint_list() in cint_array.c.\n\t */\n\n\tNODE **list;\n\tNODE akind;\n\tunsigned long num_elems, j;\n\tint elem_size, qi;\n\tqsort_compfunc cmp_func = 0;\n\tINSTRUCTION *code = NULL;\n\textern int currule;\n\tint save_rule = 0;\n\tassoc_kind_t assoc_kind = ANONE;\n\t\n\telem_size = 1;\n\n\tfor (qi = 0, j = sizeof(sort_funcs)/sizeof(sort_funcs[0]); qi < j; qi++) {\n\t\tif (strcmp(sort_funcs[qi].name, sort_str) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (qi < j) {\n\t\tcmp_func = sort_funcs[qi].comp_func;\n\t\tassoc_kind = sort_funcs[qi].kind;\n\n\t\tif (symbol->array_funcs != cint_array_func)\n\t\t\tassoc_kind &= ~(AASC|ADESC);\n\n\t\tif (sort_ctxt != SORTED_IN || (assoc_kind & AVALUE) != 0) {\n\t\t\t/* need index and value pair in the list */\n\n\t\t\tassoc_kind |= (AINDEX|AVALUE);\n\t\t\telem_size = 2;\n\t\t}\n\n\t} else {\t/* unrecognized */\n\t\tNODE *f;\n\t\tconst char *sp;\t\n\n\t\tfor (sp = sort_str; *sp != '\\0' && ! isspace((unsigned char) *sp); sp++)\n\t\t\tcontinue;\n\n\t\t/* empty string or string with space(s) not valid as function name */\n\t\tif (sp == sort_str || *sp != '\\0')\n\t\t\tfatal(_(\"`%s' is invalid as a function name\"), sort_str);\n\n\t\tf = lookup(sort_str);\n\t\tif (f == NULL || f->type != Node_func)\n\t\t\tfatal(_(\"sort comparison function `%s' is not defined\"), sort_str);\n\n\t\tcmp_func = sort_user_func;\n\n\t\t/* need index and value pair in the list */\n\t\tassoc_kind |= (AVALUE|AINDEX);\n\t\telem_size = 2;\n\n\t\t/* make function call instructions */\n\t\tcode = bcalloc(Op_func_call, 2, 0);\n\t\tcode->func_body = f;\n\t\tcode->func_name = NULL;\t\t/* not needed, func_body already assigned */\n\t\t(code + 1)->expr_count = 4;\t/* function takes 4 arguments */\n\t\tcode->nexti = bcalloc(Op_stop, 1, 0);\t\n\n\t\t/*\n\t\t * make non-redirected getline, exit, `next' and `nextfile' fatal in\n\t\t * callback function by setting currule in interpret()\n\t\t * to undefined (0).\n\t\t */\n\n\t\tsave_rule = currule;\t/* save current rule */\n\t\tcurrule = 0;\n\n\t\tPUSH_CODE(code);\n\t}\n\n\takind.flags = (unsigned int) assoc_kind;\t/* kludge */\n\tlist = symbol->alist(symbol, & akind);\n\tassoc_kind = (assoc_kind_t) akind.flags;\t/* symbol->alist can modify it */\n\n"
}