{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "libiberty/cplus-dem.c",
    "message": "Offset added: [0, 10] Size: [8, 88] by call to `string_append`.",
    "warning_function_name": "demangle_function_name",
    "warning_line": "string_append (declp, optable[i].out);",
    "warning_context": "static int \ndemangle_function_name (struct work_stuff *work, const char **mangled,\n                        string *declp, const char *scan)\n{\n  size_t i;\n  string type;\n  const char *tem;\n\n  string_appendn (declp, (*mangled), scan - (*mangled));\n  string_need (declp, 1);\n  *(declp -> p) = '\\0';\n\n  /* Consume the function name, including the \"__\" separating the name\n     from the signature.  We are guaranteed that SCAN points to the\n     separator.  */\n\n  (*mangled) = scan + 2;\n  /* We may be looking at an instantiation of a template function:\n     foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a\n     following _F marks the start of the function arguments.  Handle\n     the template arguments first. */\n\n  if (HP_DEMANGLING && (**mangled == 'X'))\n    {\n      demangle_arm_hp_template (work, mangled, 0, declp);\n      /* This leaves MANGLED pointing to the 'F' marking func args */\n    }\n\n  if (LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING)\n    {\n\n      /* See if we have an ARM style constructor or destructor operator.\n\t If so, then just record it, clear the decl, and return.\n\t We can't build the actual constructor/destructor decl until later,\n\t when we recover the class name from the signature.  */\n\n      if (strcmp (declp -> b, \"__ct\") == 0)\n\t{\n\t  work -> constructor += 1;\n\t  string_clear (declp);\n\t  return 1;\n\t}\n      else if (strcmp (declp -> b, \"__dt\") == 0)\n\t{\n\t  work -> destructor += 1;\n\t  string_clear (declp);\n\t  return 1;\n\t}\n    }\n\n  if (declp->p - declp->b >= 3\n      && declp->b[0] == 'o'\n      && declp->b[1] == 'p'\n      && strchr (cplus_markers, declp->b[2]) != NULL)\n    {\n      /* see if it's an assignment expression */\n      if (declp->p - declp->b >= 10 /* op$assign_ */\n\t  && memcmp (declp->b + 3, \"assign_\", 7) == 0)\n\t{\n\t  for (i = 0; i < ARRAY_SIZE (optable); i++)\n\t    {\n\t      int len = declp->p - declp->b - 10;\n\t      if ((int) strlen (optable[i].in) == len\n\t\t  && memcmp (optable[i].in, declp->b + 10, len) == 0)\n\t\t{\n\t\t  string_clear (declp);\n\t\t  string_append (declp, \"operator\");\n\t\t  string_append (declp, optable[i].out);\n\t\t  string_append (declp, \"=\");\n\t\t  break;\n\t\t}\n\t    }\n\t}\n      else\n\t{\n\t  for (i = 0; i < ARRAY_SIZE (optable); i++)\n\t    {\n\t      int len = declp->p - declp->b - 3;\n\t      if ((int) strlen (optable[i].in) == len\n\t\t  && memcmp (optable[i].in, declp->b + 3, len) == 0)\n\t\t{\n\t\t  string_clear (declp);\n\t\t  string_append (declp, \"operator\");\n\t\t  string_append (declp, optable[i].out);\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  else if (declp->p - declp->b >= 5 && memcmp (declp->b, \"type\", 4) == 0\n\t   && strchr (cplus_markers, declp->b[4]) != NULL)\n    {\n      /* type conversion operator */\n      tem = declp->b + 5;\n      if (do_type (work, &tem, &type))\n\t{\n\t  string_clear (declp);\n\t  string_append (declp, \"operator \");\n\t  string_appends (declp, &type);\n\t  string_delete (&type);\n\t}\n"
}