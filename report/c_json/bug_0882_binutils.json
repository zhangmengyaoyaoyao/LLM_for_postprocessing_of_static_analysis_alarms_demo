{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Message": "Offset: [max(1, `abfd->tdata.elf_obj_data->strtab_hdr.sh_name`), `abfd->tdata.elf_obj_data->strtab_hdr.sh_name`] Size: [0, +oo] by call to `_bfd_elf_strtab_addref`.",
    "Code_line": "      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);",
    "Code_function": "assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)\n{\n  struct elf_obj_tdata *t = elf_tdata (abfd);\n  asection *sec;\n  unsigned int section_number, secn;\n  Elf_Internal_Shdr **i_shdrp;\n  struct bfd_elf_section_data *d;\n  bfd_boolean need_symtab;\n\n  section_number = 1;\n\n  _bfd_elf_strtab_clear_all_refs (elf_shstrtab (abfd));\n\n  /* SHT_GROUP sections are in relocatable files only.  */\n  if (link_info == NULL || link_info->relocatable)\n    {\n      /* Put SHT_GROUP sections first.  */\n      for (sec = abfd->sections; sec != NULL; sec = sec->next)\n\t{\n\t  d = elf_section_data (sec);\n\n\t  if (d->this_hdr.sh_type == SHT_GROUP)\n\t    {\n\t      if (sec->flags & SEC_LINKER_CREATED)\n\t\t{\n\t\t  /* Remove the linker created SHT_GROUP sections.  */\n\t\t  bfd_section_list_remove (abfd, sec);\n\t\t  abfd->section_count--;\n\t\t}\n\t      else\n\t\td->this_idx = section_number++;\n\t    }\n\t}\n    }\n\n  for (sec = abfd->sections; sec; sec = sec->next)\n    {\n      d = elf_section_data (sec);\n\n      if (d->this_hdr.sh_type != SHT_GROUP)\n\td->this_idx = section_number++;\n      _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->this_hdr.sh_name);\n      if (d->rel.hdr)\n\t{\n\t  d->rel.idx = section_number++;\n\t  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rel.hdr->sh_name);\n\t}\n      else\n\td->rel.idx = 0;\n\n      if (d->rela.hdr)\n\t{\n\t  d->rela.idx = section_number++;\n\t  _bfd_elf_strtab_addref (elf_shstrtab (abfd), d->rela.hdr->sh_name);\n\t}\n      else\n\td->rela.idx = 0;\n    }\n\n  elf_shstrtab_sec (abfd) = section_number++;\n  _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->shstrtab_hdr.sh_name);\n  elf_elfheader (abfd)->e_shstrndx = elf_shstrtab_sec (abfd);\n\n  need_symtab = (bfd_get_symcount (abfd) > 0\n\t\t|| (link_info == NULL\n\t\t    && ((abfd->flags & (EXEC_P | DYNAMIC | HAS_RELOC))\n\t\t\t== HAS_RELOC)));\n  if (need_symtab)\n    {\n      elf_onesymtab (abfd) = section_number++;\n      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->symtab_hdr.sh_name);\n      if (section_number > ((SHN_LORESERVE - 2) & 0xFFFF))\n\t{\n\t  elf_symtab_shndx (abfd) = section_number++;\n\t  t->symtab_shndx_hdr.sh_name\n\t    = (unsigned int) _bfd_elf_strtab_add (elf_shstrtab (abfd),\n\t\t\t\t\t\t  \".symtab_shndx\", FALSE);\n\t  if (t->symtab_shndx_hdr.sh_name == (unsigned int) -1)\n\t    return FALSE;\n\t}\n      elf_strtab_sec (abfd) = section_number++;\n      _bfd_elf_strtab_addref (elf_shstrtab (abfd), t->strtab_hdr.sh_name);\n    }\n\n  if (section_number >= SHN_LORESERVE)\n    {\n      _bfd_error_handler (_(\"%B: too many sections: %u\"),\n\t\t\t  abfd, section_number);\n      return FALSE;\n    }\n\n  _bfd_elf_strtab_finalize (elf_shstrtab (abfd));\n  t->shstrtab_hdr.sh_size = _bfd_elf_strtab_size (elf_shstrtab (abfd));\n\n  elf_numsections (abfd) = section_number;\n  elf_elfheader (abfd)->e_shnum = section_number;\n\n  /* Set up the list of section header pointers, in agreement with the\n     indices.  */\n  i_shdrp = (Elf_Internal_Shdr **) bfd_zalloc2 (abfd, section_number,\n                                                sizeof (Elf_Internal_Shdr *));\n  if (i_shdrp == NULL)\n    return FALSE;\n\n  i_shdrp[0] = (Elf_Internal_Shdr *) bfd_zalloc (abfd,\n                                                 sizeof (Elf_Internal_Shdr));\n  if (i_shdrp[0] == NULL)\n    {\n      bfd_release (abfd, i_shdrp);\n      return FALSE;\n    }\n\n  elf_elfsections (abfd) = i_shdrp;\n\n  i_shdrp[elf_shstrtab_sec (abfd)] = &t->shstrtab_hdr;\n  if (need_symtab)\n    {\n      i_shdrp[elf_onesymtab (abfd)] = &t->symtab_hdr;\n      if (elf_numsections (abfd) > (SHN_LORESERVE & 0xFFFF))\n\t{\n\t  i_shdrp[elf_symtab_shndx (abfd)] = &t->symtab_shndx_hdr;\n\t  t->symtab_shndx_hdr.sh_link = elf_onesymtab (abfd);\n\t}\n      i_shdrp[elf_strtab_sec (abfd)] = &t->strtab_hdr;\n      t->symtab_hdr.sh_link = elf_strtab_sec (abfd);\n    }\n\n  for (sec = abfd->sections; sec; sec = sec->next)\n    {\n      asection *s;\n      const char *name;\n\n      d = elf_section_data (sec);\n\n      i_shdrp[d->this_idx] = &d->this_hdr;\n      if (d->rel.idx != 0)\n\ti_shdrp[d->rel.idx] = d->rel.hdr;\n      if (d->rela.idx != 0)\n\ti_shdrp[d->rela.idx] = d->rela.hdr;\n\n      /* Fill in the sh_link and sh_info fields while we're at it.  */\n\n      /* sh_link of a reloc section is the section index of the symbol\n\t table.  sh_info is the section index of the section to which\n\t the relocation entries apply.  */\n      if (d->rel.idx != 0)\n\t{\n\t  d->rel.hdr->sh_link = elf_onesymtab (abfd);\n\t  d->rel.hdr->sh_info = d->this_idx;\n\t  d->rel.hdr->sh_flags |= SHF_INFO_LINK;\n\t}\n      if (d->rela.idx != 0)\n\t{\n\t  d->rela.hdr->sh_link = elf_onesymtab (abfd);\n\t  d->rela.hdr->sh_info = d->this_idx;\n\t  d->rela.hdr->sh_flags |= SHF_INFO_LINK;\n\t}\n\n      /* We need to set up sh_link for SHF_LINK_ORDER.  */\n      if ((d->this_hdr.sh_flags & SHF_LINK_ORDER) != 0)\n\t{\n\t  s = elf_linked_to_section (sec);\n\t  if (s)\n\t    {\n\t      /* elf_linked_to_section points to the input section.  */\n\t      if (link_info != NULL)\n\t\t{\n\t\t  /* Check discarded linkonce section.  */\n\t\t  if (discarded_section (s))\n\t\t    {\n\t\t      asection *kept;\n\t\t      (*_bfd_error_handler)\n\t\t\t(_(\"%B: sh_link of section `%A' points to discarded section `%A' of `%B'\"),\n\t\t\t abfd, d->this_hdr.bfd_section,\n\t\t\t s, s->owner);\n\t\t      /* Point to the kept section if it has the same\n\t\t\t size as the discarded one.  */\n\t\t      kept = _bfd_elf_check_kept_section (s, link_info);\n\t\t      if (kept == NULL)\n\t\t\t{\n\t\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t\t  return FALSE;\n\t\t\t}\n\t\t      s = kept;\n\t\t    }\n\n\t\t  s = s->output_section;\n\t\t  BFD_ASSERT (s != NULL);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Handle objcopy. */\n\t\t  if (s->output_section == NULL)\n\t\t    {\n\t\t      (*_bfd_error_handler)\n\t\t\t(_(\"%B: sh_link of section `%A' points to removed section `%A' of `%B'\"),\n\t\t\t abfd, d->this_hdr.bfd_section, s, s->owner);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      return FALSE;\n\t\t    }\n\t\t  s = s->output_section;\n\t\t}\n\t      d->this_hdr.sh_link = elf_section_data (s)->this_idx;\n\t    }\n\t  else\n\t    {\n\t      /* PR 290:\n\t\t The Intel C compiler generates SHT_IA_64_UNWIND with\n\t\t SHF_LINK_ORDER.  But it doesn't set the sh_link or\n\t\t sh_info fields.  Hence we could get the situation\n\t\t where s is NULL.  */\n\t      const struct elf_backend_data *bed\n\t\t= get_elf_backend_data (abfd);\n\t      if (bed->link_order_error_handler)\n\t\tbed->link_order_error_handler\n\t\t  (_(\"%B: warning: sh_link not set for section `%A'\"),\n\t\t   abfd, sec);\n\t    }\n\t}\n\n      switch (d->this_hdr.sh_type)\n\t{\n\tcase SHT_REL:\n\tcase SHT_RELA:\n\t  /* A reloc section which we are treating as a normal BFD\n\t     section.  sh_link is the section index of the symbol\n\t     table.  sh_info is the section index of the section to\n\t     which the relocation entries apply.  We assume that an\n\t     allocated reloc section uses the dynamic symbol table.\n\t     FIXME: How can we be sure?  */\n\t  s = bfd_get_section_by_name (abfd, \".dynsym\");\n\t  if (s != NULL)\n\t    d->this_hdr.sh_link = elf_section_data (s)->this_idx;\n\n\t  /* We look up the section the relocs apply to by name.  */\n\t  name = sec->name;\n\t  if (d->this_hdr.sh_type == SHT_REL)\n\t    name += 4;\n\t  else\n\t    name += 5;\n\t  s = bfd_get_section_by_name (abfd, name);\n\t  if (s != NULL)\n\t    {\n\t      d->this_hdr.sh_info = elf_section_data (s)->this_idx;\n\t      d->this_hdr.sh_flags |= SHF_INFO_LINK;\n\t    }\n\t  break;\n\n\tcase SHT_STRTAB:\n\t  /* We assume that a section named .stab*str is a stabs\n\t     string section.  We look for a section with the same name\n\t     but without the trailing ``str'', and set its sh_link\n\t     field to point to this section.  */\n\t  if (CONST_STRNEQ (sec->name, \".stab\")\n\t      && strcmp (sec->name + strlen (sec->name) - 3, \"str\") == 0)\n\t    {\n\t      size_t len;\n\t      char *alc;\n\n\t      len = strlen (sec->name);\n\t      alc = (char *) bfd_malloc (len - 2);\n\t      if (alc == NULL)\n\t\treturn FALSE;\n\t      memcpy (alc, sec->name, len - 3);\n\t      alc[len - 3] = '\\0';\n\t      s = bfd_get_section_by_name (abfd, alc);\n\t      free (alc);\n\t      if (s != NULL)\n\t\t{\n\t\t  elf_section_data (s)->this_hdr.sh_link = d->this_idx;\n\n\t\t  /* This is a .stab section.  */\n\t\t  if (elf_section_data (s)->this_hdr.sh_entsize == 0)\n\t\t    elf_section_data (s)->this_hdr.sh_entsize\n\t\t      = 4 + 2 * bfd_get_arch_size (abfd) / 8;\n\t\t}\n\t    }\n\t  break;\n\n\tcase SHT_DYNAMIC:\n\tcase SHT_DYNSYM:\n\tcase SHT_GNU_verneed:\n\tcase SHT_GNU_verdef:\n\t  /* sh_link is the section header index of the string table\n\t     used for the dynamic entries, or the symbol table, or the\n\t     version strings.  */\n\t  s = bfd_get_section_by_name (abfd, \".dynstr\");\n\t  if (s != NULL)\n\t    d->this_hdr.sh_link = elf_section_data (s)->this_idx;\n\t  break;\n\n\tcase SHT_GNU_LIBLIST:\n\t  /* sh_link is the section header index of the prelink library\n\t     list used for the dynamic entries, or the symbol table, or\n\t     the version strings.  */\n\t  s = bfd_get_section_by_name (abfd, (sec->flags & SEC_ALLOC)\n\t\t\t\t\t     ? \".dynstr\" : \".gnu.libstr\");\n\t  if (s != NULL)\n\t    d->this_hdr.sh_link = elf_section_data (s)->this_idx;\n\t  break;\n\n\tcase SHT_HASH:\n\tcase SHT_GNU_HASH:\n\tcase SHT_GNU_versym:\n\t  /* sh_link is the section header index of the symbol table\n\t     this hash table or version table is for.  */\n\t  s = bfd_get_section_by_name (abfd, \".dynsym\");\n\t  if (s != NULL)\n\t    d->this_hdr.sh_link = elf_section_data (s)->this_idx;\n\t  break;\n\n\tcase SHT_GROUP:\n\t  d->this_hdr.sh_link = elf_onesymtab (abfd);\n\t}\n    }\n\n  for (secn = 1; secn < section_number; ++secn)\n    if (i_shdrp[secn] == NULL)\n      i_shdrp[secn] = i_shdrp[0];\n    else\n      i_shdrp[secn]->sh_name = _bfd_elf_strtab_offset (elf_shstrtab (abfd),\n\t\t\t\t\t\t       i_shdrp[secn]->sh_name);\n  return TRUE;\n}"
}