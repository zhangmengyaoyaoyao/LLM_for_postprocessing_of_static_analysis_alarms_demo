{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Message": "The value read from name_vector was never initialized.",
    "Code_line": "  return (name_vector);",
    "Code_function": "glob_vector (pat, dir, flags)\n     char *pat;\n     char *dir;\n     int flags;\n{\n  DIR *d;\n  register struct dirent *dp;\n  struct globval *lastlink, *e, *dirlist;\n  register struct globval *nextlink;\n  register char *nextname, *npat, *subdir;\n  unsigned int count;\n  int lose, skip, ndirs, isdir, sdlen, add_current, patlen;\n  register char **name_vector;\n  register unsigned int i;\n  int mflags;\t\t/* Flags passed to strmatch (). */\n  int pflags;\t\t/* flags passed to sh_makepath () */\n  int nalloca;\n  struct globval *firstmalloc, *tmplink;\n  char *convfn;\n\n  lastlink = 0;\n  count = lose = skip = add_current = 0;\n\n  firstmalloc = 0;\n  nalloca = 0;\n\n/*itrace(\"glob_vector: pat = `%s' dir = `%s' flags = 0x%x\", pat, dir, flags);*/\n  /* If PAT is empty, skip the loop, but return one (empty) filename. */\n  if (pat == 0 || *pat == '\\0')\n    {\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n\n      nextlink = (struct globval *)alloca (sizeof (struct globval));\n      if (nextlink == NULL)\n\treturn ((char **) NULL);\n\n      nextlink->next = (struct globval *)0;\n      nextname = (char *) malloc (1);\n      if (nextname == 0)\n\tlose = 1;\n      else\n\t{\n\t  lastlink = nextlink;\n\t  nextlink->name = nextname;\n\t  nextname[0] = '\\0';\n\t  count = 1;\n\t}\n\n      skip = 1;\n    }\n\n  patlen = (pat && *pat) ? strlen (pat) : 0;\n\n  /* If the filename pattern (PAT) does not contain any globbing characters,\n     we can dispense with reading the directory, and just see if there is\n     a filename `DIR/PAT'.  If there is, and we can access it, just make the\n     vector to return and bail immediately. */\n  if (skip == 0 && glob_pattern_p (pat) == 0)\n    {\n      int dirlen;\n      struct stat finfo;\n\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n\n      dirlen = strlen (dir);\n      nextname = (char *)malloc (dirlen + patlen + 2);\n      npat = (char *)malloc (patlen + 1);\n      if (nextname == 0 || npat == 0)\n\t{\n\t  FREE (nextname);\n\t  FREE (npat);\n\t  lose = 1;\n\t}\n      else\n\t{\n\t  strcpy (npat, pat);\n\t  dequote_pathname (npat);\n\n\t  strcpy (nextname, dir);\n\t  nextname[dirlen++] = '/';\n\t  strcpy (nextname + dirlen, npat);\n\n\t  if (GLOB_TESTNAME (nextname) >= 0)\n\t    {\n\t      free (nextname);\n\t      nextlink = (struct globval *)alloca (sizeof (struct globval));\n\t      if (nextlink)\n\t\t{\n\t\t  nextlink->next = (struct globval *)0;\n\t\t  lastlink = nextlink;\n\t\t  nextlink->name = npat;\n\t\t  count = 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  free (npat);\n\t\t  lose = 1;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      free (nextname);\n\t      free (npat);\n\t    }\n\t}\n\n      skip = 1;\n    }\n\n  if (skip == 0)\n    {\n      /* Open the directory, punting immediately if we cannot.  If opendir\n\t is not robust (i.e., it opens non-directories successfully), test\n\t that DIR is a directory and punt if it's not. */\n#if defined (OPENDIR_NOT_ROBUST)\n      if (glob_testdir (dir, 0) < 0)\n\treturn ((char **) &glob_error_return);\n#endif\n\n      d = opendir (dir);\n      if (d == NULL)\n\treturn ((char **) &glob_error_return);\n\n      /* Compute the flags that will be passed to strmatch().  We don't\n\t need to do this every time through the loop. */\n      mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME;\n\n#ifdef FNM_CASEFOLD\n      if (glob_ignore_case)\n\tmflags |= FNM_CASEFOLD;\n#endif\n\n      if (extended_glob)\n\tmflags |= FNM_EXTMATCH;\n\n      add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR));\n\n      /* Scan the directory, finding all names that match.\n\t For each name that matches, allocate a struct globval\n\t on the stack and store the name in it.\n\t Chain those structs together; lastlink is the front of the chain.  */\n      while (1)\n\t{\n\t  /* Make globbing interruptible in the shell. */\n\t  if (interrupt_state || terminating_signal)\n\t    {\n\t      lose = 1;\n\t      break;\n\t    }\n\t  else if (signal_is_pending (SIGINT))\t/* XXX - make SIGINT traps responsive */\n\t    {\n\t      lose = 1;\n\t      break;\n\t    }\n\n\t  dp = readdir (d);\n\t  if (dp == NULL)\n\t    break;\n\n\t  /* If this directory entry is not to be used, try again. */\n\t  if (REAL_DIR_ENTRY (dp) == 0)\n\t    continue;\n\n#if 0\n\t  if (dp->d_name == 0 || *dp->d_name == 0)\n\t    continue;\n#endif\n\n#if HANDLE_MULTIBYTE\n\t  if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags))\n\t    continue;\n\t  else\n#endif\n\t  if (skipname (pat, dp->d_name, flags))\n\t    continue;\n\n\t  /* If we're only interested in directories, don't bother with files */\n\t  if (flags & (GX_MATCHDIRS|GX_ALLDIRS))\n\t    {\n\t      pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0;\n\t      if (flags & GX_NULLDIR)\n\t\tpflags |= MP_IGNDOT;\n\t      subdir = sh_makepath (dir, dp->d_name, pflags);\n\t      isdir = glob_testdir (subdir, flags);\n\t      if (isdir < 0 && (flags & GX_MATCHDIRS))\n\t\t{\n\t\t  free (subdir);\n\t\t  continue;\n\t\t}\n\t    }\n\n\t  if (flags & GX_ALLDIRS)\n\t    {\n\t      if (isdir == 0)\n\t\t{\n\t\t  dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs);\n\t\t  if (dirlist == &finddirs_error_return)\n\t\t    {\n\t\t      free (subdir);\n\t\t      lose = 1;\n\t\t      break;\n\t\t    }\n\t\t  if (ndirs)\t\t/* add recursive directories to list */\n\t\t    {\n\t\t      if (firstmalloc == 0)\n\t\t        firstmalloc = e;\n\t\t      e->next = lastlink;\n\t\t      lastlink = dirlist;\n\t\t      count += ndirs;\n\t\t    }\n\t\t}\n\n\t      nextlink = (struct globval *) malloc (sizeof (struct globval));\n\t      if (firstmalloc == 0)\n\t\tfirstmalloc = nextlink;\n\t      sdlen = strlen (subdir);\n\t      nextname = (char *) malloc (sdlen + 1);\n\t      if (nextlink == 0 || nextname == 0)\n\t\t{\n\t\t  FREE (nextlink);\n\t\t  FREE (nextname);\n\t\t  free (subdir);\n\t\t  lose = 1;\n\t\t  break;\n\t\t}\n\t      nextlink->next = lastlink;\n\t      lastlink = nextlink;\n\t      nextlink->name = nextname;\n\t      bcopy (subdir, nextname, sdlen + 1);\n\t      free (subdir);\n\t      ++count;\n\t      continue;\n\t    }\n\t  else if (flags & GX_MATCHDIRS)\n\t    free (subdir);\n\n\t  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));\n\t  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)\n\t    {\n\t      if (nalloca < ALLOCA_MAX)\n\t\t{\n\t\t  nextlink = (struct globval *) alloca (sizeof (struct globval));\n\t\t  nalloca += sizeof (struct globval);\n\t\t}\n\t      else\n\t\t{\n\t\t  nextlink = (struct globval *) malloc (sizeof (struct globval));\n\t\t  if (firstmalloc == 0)\n\t\t    firstmalloc = nextlink;\n\t\t}\n\n\t      nextname = (char *) malloc (D_NAMLEN (dp) + 1);\n\t      if (nextlink == 0 || nextname == 0)\n\t\t{\n\t\t  FREE (nextlink);\n\t\t  FREE (nextname);\n\t\t  lose = 1;\n\t\t  break;\n\t\t}\n\t      nextlink->next = lastlink;\n\t      lastlink = nextlink;\n\t      nextlink->name = nextname;\n\t      bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1);\n\t      ++count;\n\t    }\n\t}\n\n      (void) closedir (d);\n    }\n\n  /* compat: if GX_ADDCURDIR, add the passed directory also.  Add an empty\n     directory name as a placeholder if GX_NULLDIR (in which case the passed\n     directory name is \".\"). */\n  if (add_current)\n    {\n      sdlen = strlen (dir);\n      nextname = (char *)malloc (sdlen + 1);\n      nextlink = (struct globval *) malloc (sizeof (struct globval));\n      if (nextlink == 0 || nextname == 0)\n\t{\n\t  FREE (nextlink);\n\t  FREE (nextname);\n\t  lose = 1;\n\t}\n      else\n\t{\n\t  nextlink->name = nextname;\n\t  nextlink->next = lastlink;\n\t  lastlink = nextlink;\n\t  if (flags & GX_NULLDIR)\n\t    nextname[0] = '\\0';\n\t  else\n\t    bcopy (dir, nextname, sdlen + 1);\n\t  ++count;\n\t}\n    }\n\n  if (lose == 0)\n    {\n      name_vector = (char **) malloc ((count + 1) * sizeof (char *));\n      lose |= name_vector == NULL;\n    }\n\n  /* Have we run out of memory?\t */\n  if (lose)\n    {\n      tmplink = 0;\n\n      /* Here free the strings we have got.  */\n      while (lastlink)\n\t{\n\t  /* Since we build the list in reverse order, the first N entries\n\t     will be allocated with malloc, if firstmalloc is set, from\n\t     lastlink to firstmalloc. */\n\t  if (firstmalloc)\n\t    {\n\t      if (lastlink == firstmalloc)\n\t\tfirstmalloc = 0;\n\t      tmplink = lastlink;\n\t    }\n\t  else\n\t    tmplink = 0;\n\t  free (lastlink->name);\n\t  lastlink = lastlink->next;\n\t  FREE (tmplink);\n\t}\n\n      /* Don't call QUIT; here; let higher layers deal with it. */\n\n      return ((char **)NULL);\n    }\n\n  /* Copy the name pointers from the linked list into the vector.  */\n  for (tmplink = lastlink, i = 0; i < count; ++i)\n    {\n      name_vector[i] = tmplink->name;\n      tmplink = tmplink->next;\n    }\n\n  name_vector[count] = NULL;\n\n  /* If we allocated some of the struct globvals, free them now. */\n  if (firstmalloc)\n    {\n      tmplink = 0;\n      while (lastlink)\n\t{\n\t  tmplink = lastlink;\n\t  if (lastlink == firstmalloc)\n\t    lastlink = firstmalloc = 0;\n\t  else\n\t    lastlink = lastlink->next;\n\t  free (tmplink);\n\t}\n    }\n\n  return (name_vector);\n}"
}