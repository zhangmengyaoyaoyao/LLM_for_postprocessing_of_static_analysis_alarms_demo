{
    "Project": "binutils",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/dwarf2.c",
    "message": "Offset added: [-20, 155] (⇐ [-76, 99] + 56) Size: 4064 by call to `bfd_zalloc`.",
    "warning_function_name": "scan_unit_for_symbols",
    "warning_line": "var = (struct varinfo *) bfd_zalloc (abfd, amt);",
    "warning_context": "  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;\n  int nesting_level = 1;\n  struct funcinfo **nested_funcs;\n  int nested_funcs_size;\n\n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct funcinfo **)\n    bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));\n  if (nested_funcs == NULL)\n    return FALSE;\n  nested_funcs[nesting_level] = 0;\n\n  while (nesting_level)\n    {\n      unsigned int abbrev_number, bytes_read, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bfd_boolean high_pc_relative = FALSE;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      abbrev_number = safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, info_ptr_end);\n      info_ptr += bytes_read;\n\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number,unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  (*_bfd_error_handler)\n\t    (_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t     abbrev_number);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  bfd_size_type amt = sizeof (struct funcinfo);\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  unit->function_table = func;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level - 1; i >= 1; i--)\n\t      if (nested_funcs[i])\n\t\t{\n\t\t  func->caller_func = nested_funcs[i];\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level] = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable)\n\t    {\n\t      bfd_size_type amt = sizeof (struct varinfo);\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = 1;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      BFD_ASSERT (!unit->cached);\n\t    }\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level] = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n"
}