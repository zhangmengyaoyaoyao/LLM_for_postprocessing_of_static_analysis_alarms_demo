{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "      if (! elf_i386_tls_transition (info, abfd, sec, NULL,",
    "Code_function": "elf_i386_check_relocs (bfd *abfd,\n\t\t       struct bfd_link_info *info,\n\t\t       asection *sec,\n\t\t       const Elf_Internal_Rela *relocs)\n{\n  struct elf_i386_link_hash_table *htab;\n  Elf_Internal_Shdr *symtab_hdr;\n  struct elf_link_hash_entry **sym_hashes;\n  const Elf_Internal_Rela *rel;\n  const Elf_Internal_Rela *rel_end;\n  asection *sreloc;\n\n  if (info->relocatable)\n    return TRUE;\n\n  BFD_ASSERT (is_i386_elf (abfd));\n\n  htab = elf_i386_hash_table (info);\n  if (htab == NULL)\n    return FALSE;\n\n  symtab_hdr = &elf_symtab_hdr (abfd);\n  sym_hashes = elf_sym_hashes (abfd);\n\n  sreloc = NULL;\n\n  rel_end = relocs + sec->reloc_count;\n  for (rel = relocs; rel < rel_end; rel++)\n    {\n      unsigned int r_type;\n      unsigned long r_symndx;\n      struct elf_link_hash_entry *h;\n      Elf_Internal_Sym *isym;\n      const char *name;\n      bfd_boolean size_reloc;\n\n      r_symndx = ELF32_R_SYM (rel->r_info);\n      r_type = ELF32_R_TYPE (rel->r_info);\n\n      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))\n\t{\n\t  (*_bfd_error_handler) (_(\"%B: bad symbol index: %d\"),\n\t\t\t\t abfd,\n\t\t\t\t r_symndx);\n\t  return FALSE;\n\t}\n\n      if (r_symndx < symtab_hdr->sh_info)\n\t{\n\t  /* A local symbol.  */\n\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n\t\t\t\t\tabfd, r_symndx);\n\t  if (isym == NULL)\n\t    return FALSE;\n\n\t  /* Check relocation against local STT_GNU_IFUNC symbol.  */\n\t  if (ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)\n\t    {\n\t      h = elf_i386_get_local_sym_hash (htab, abfd, rel, TRUE);\n\t      if (h == NULL)\n\t\treturn FALSE;\n\n\t      /* Fake a STT_GNU_IFUNC symbol.  */\n\t      h->type = STT_GNU_IFUNC;\n\t      h->def_regular = 1;\n\t      h->ref_regular = 1;\n\t      h->forced_local = 1;\n\t      h->root.type = bfd_link_hash_defined;\n\t    }\n\t  else\n\t    h = NULL;\n\t}\n      else\n\t{\n\t  isym = NULL;\n\t  h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n\t  while (h->root.type == bfd_link_hash_indirect\n\t\t || h->root.type == bfd_link_hash_warning)\n\t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\t}\n\n      if (h != NULL)\n\t{\n\t  /* Create the ifunc sections for static executables.  If we\n\t     never see an indirect function symbol nor we are building\n\t     a static executable, those sections will be empty and\n\t     won't appear in output.  */\n\t  switch (r_type)\n\t    {\n\t    default:\n\t      break;\n\n\t    case R_386_32:\n\t    case R_386_PC32:\n\t    case R_386_PLT32:\n\t    case R_386_GOT32:\n\t    case R_386_GOTOFF:\n\t      if (htab->elf.dynobj == NULL)\n\t\thtab->elf.dynobj = abfd;\n\t      if (!_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))\n\t\treturn FALSE;\n\t      break;\n\t    }\n\n\t  /* It is referenced by a non-shared object. */\n\t  h->ref_regular = 1;\n\t  h->root.non_ir_ref = 1;\n\t}\n\n      if (! elf_i386_tls_transition (info, abfd, sec, NULL,\n\t\t\t\t     symtab_hdr, sym_hashes,\n\t\t\t\t     &r_type, GOT_UNKNOWN,\n\t\t\t\t     rel, rel_end, h, r_symndx))\n\treturn FALSE;\n\n      switch (r_type)\n\t{\n\tcase R_386_TLS_LDM:\n\t  htab->tls_ldm_got.refcount += 1;\n\t  goto create_got;\n\n\tcase R_386_PLT32:\n\t  /* This symbol requires a procedure linkage table entry.  We\n\t     actually build the entry in adjust_dynamic_symbol,\n\t     because this might be a case of linking PIC code which is\n\t     never referenced by a dynamic object, in which case we\n\t     don't need to generate a procedure linkage table entry\n\t     after all.  */\n\n\t  /* If this is a local symbol, we resolve it directly without\n\t     creating a procedure linkage table entry.  */\n\t  if (h == NULL)\n\t    continue;\n\n\t  h->needs_plt = 1;\n\t  h->plt.refcount += 1;\n\t  break;\n\n\tcase R_386_SIZE32:\n\t  size_reloc = TRUE;\n\t  goto do_size;\n\n\tcase R_386_TLS_IE_32:\n\tcase R_386_TLS_IE:\n\tcase R_386_TLS_GOTIE:\n\t  if (!info->executable)\n\t    info->flags |= DF_STATIC_TLS;\n\t  /* Fall through */\n\n\tcase R_386_GOT32:\n\tcase R_386_TLS_GD:\n\tcase R_386_TLS_GOTDESC:\n\tcase R_386_TLS_DESC_CALL:\n\t  /* This symbol requires a global offset table entry.  */\n\t  {\n\t    int tls_type, old_tls_type;\n\n\t    switch (r_type)\n\t      {\n\t      default:\n\t      case R_386_GOT32: tls_type = GOT_NORMAL; break;\n\t      case R_386_TLS_GD: tls_type = GOT_TLS_GD; break;\n\t      case R_386_TLS_GOTDESC:\n\t      case R_386_TLS_DESC_CALL:\n\t\ttls_type = GOT_TLS_GDESC; break;\n\t      case R_386_TLS_IE_32:\n\t\tif (ELF32_R_TYPE (rel->r_info) == r_type)\n\t\t  tls_type = GOT_TLS_IE_NEG;\n\t\telse\n\t\t  /* If this is a GD->IE transition, we may use either of\n\t\t     R_386_TLS_TPOFF and R_386_TLS_TPOFF32.  */\n\t\t  tls_type = GOT_TLS_IE;\n\t\tbreak;\n\t      case R_386_TLS_IE:\n\t      case R_386_TLS_GOTIE:\n\t\ttls_type = GOT_TLS_IE_POS; break;\n\t      }\n\n\t    if (h != NULL)\n\t      {\n\t\th->got.refcount += 1;\n\t\told_tls_type = elf_i386_hash_entry(h)->tls_type;\n\t      }\n\t    else\n\t      {\n\t\tbfd_signed_vma *local_got_refcounts;\n\n\t\t/* This is a global offset table entry for a local symbol.  */\n\t\tlocal_got_refcounts = elf_local_got_refcounts (abfd);\n\t\tif (local_got_refcounts == NULL)\n\t\t  {\n\t\t    bfd_size_type size;\n\n\t\t    size = symtab_hdr->sh_info;\n\t\t    size *= (sizeof (bfd_signed_vma)\n\t\t\t     + sizeof (bfd_vma) + sizeof(char));\n\t\t    local_got_refcounts = (bfd_signed_vma *)\n                        bfd_zalloc (abfd, size);\n\t\t    if (local_got_refcounts == NULL)\n\t\t      return FALSE;\n\t\t    elf_local_got_refcounts (abfd) = local_got_refcounts;\n\t\t    elf_i386_local_tlsdesc_gotent (abfd)\n\t\t      = (bfd_vma *) (local_got_refcounts + symtab_hdr->sh_info);\n\t\t    elf_i386_local_got_tls_type (abfd)\n\t\t      = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);\n\t\t  }\n\t\tlocal_got_refcounts[r_symndx] += 1;\n\t\told_tls_type = elf_i386_local_got_tls_type (abfd) [r_symndx];\n\t      }\n\n\t    if ((old_tls_type & GOT_TLS_IE) && (tls_type & GOT_TLS_IE))\n\t      tls_type |= old_tls_type;\n\t    /* If a TLS symbol is accessed using IE at least once,\n\t       there is no point to use dynamic model for it.  */\n\t    else if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN\n\t\t     && (! GOT_TLS_GD_ANY_P (old_tls_type)\n\t\t\t || (tls_type & GOT_TLS_IE) == 0))\n\t      {\n\t\tif ((old_tls_type & GOT_TLS_IE) && GOT_TLS_GD_ANY_P (tls_type))\n\t\t  tls_type = old_tls_type;\n\t\telse if (GOT_TLS_GD_ANY_P (old_tls_type)\n\t\t\t && GOT_TLS_GD_ANY_P (tls_type))\n\t\t  tls_type |= old_tls_type;\n\t\telse\n\t\t  {\n\t\t    if (h)\n\t\t      name = h->root.root.string;\n\t\t    else\n\t\t      name = bfd_elf_sym_name (abfd, symtab_hdr, isym,\n\t\t\t\t\t     NULL);\n\t\t    (*_bfd_error_handler)\n\t\t      (_(\"%B: `%s' accessed both as normal and \"\n\t\t\t \"thread local symbol\"),\n\t\t       abfd, name);\n\t\t    bfd_set_error (bfd_error_bad_value);\n\t\t    return FALSE;\n\t\t  }\n\t      }\n\n\t    if (old_tls_type != tls_type)\n\t      {\n\t\tif (h != NULL)\n\t\t  elf_i386_hash_entry (h)->tls_type = tls_type;\n\t\telse\n\t\t  elf_i386_local_got_tls_type (abfd) [r_symndx] = tls_type;\n\t      }\n\t  }\n\t  /* Fall through */\n\n\tcase R_386_GOTOFF:\n\tcase R_386_GOTPC:\n\tcreate_got:\n\t  if (htab->elf.sgot == NULL)\n\t    {\n\t      if (htab->elf.dynobj == NULL)\n\t\thtab->elf.dynobj = abfd;\n\t      if (!_bfd_elf_create_got_section (htab->elf.dynobj, info))\n\t\treturn FALSE;\n\t    }\n\t  if (r_type != R_386_TLS_IE)\n\t    break;\n\t  /* Fall through */\n\n\tcase R_386_TLS_LE_32:\n\tcase R_386_TLS_LE:\n\t  if (info->executable)\n\t    break;\n\t  info->flags |= DF_STATIC_TLS;\n\t  /* Fall through */\n\n\tcase R_386_32:\n\tcase R_386_PC32:\n\t  if (h != NULL && info->executable)\n\t    {\n\t      /* If this reloc is in a read-only section, we might\n\t\t need a copy reloc.  We can't check reliably at this\n\t\t stage whether the section is read-only, as input\n\t\t sections have not yet been mapped to output sections.\n\t\t Tentatively set the flag for now, and correct in\n\t\t adjust_dynamic_symbol.  */\n\t      h->non_got_ref = 1;\n\n\t      /* We may need a .plt entry if the function this reloc\n\t\t refers to is in a shared lib.  */\n\t      h->plt.refcount += 1;\n\t      if (r_type != R_386_PC32)\n\t\th->pointer_equality_needed = 1;\n\t    }\n\n\t  size_reloc = FALSE;\ndo_size:\n\t  /* If we are creating a shared library, and this is a reloc\n\t     against a global symbol, or a non PC relative reloc\n\t     against a local symbol, then we need to copy the reloc\n\t     into the shared library.  However, if we are linking with\n\t     -Bsymbolic, we do not need to copy a reloc against a\n\t     global symbol which is defined in an object we are\n\t     including in the link (i.e., DEF_REGULAR is set).  At\n\t     this point we have not seen all the input files, so it is\n\t     possible that DEF_REGULAR is not set now but will be set\n\t     later (it is never cleared).  In case of a weak definition,\n\t     DEF_REGULAR may be cleared later by a strong definition in\n\t     a shared library.  We account for that possibility below by\n\t     storing information in the relocs_copied field of the hash\n\t     table entry.  A similar situation occurs when creating\n\t     shared libraries and symbol visibility changes render the\n\t     symbol local.\n\n\t     If on the other hand, we are creating an executable, we\n\t     may need to keep relocations for symbols satisfied by a\n\t     dynamic library if we manage to avoid copy relocs for the\n\t     symbol.  */\n\t  if ((info->shared\n\t       && (sec->flags & SEC_ALLOC) != 0\n\t       && (r_type != R_386_PC32\n\t\t   || (h != NULL\n\t\t       && (! SYMBOLIC_BIND (info, h)\n\t\t\t   || h->root.type == bfd_link_hash_defweak\n\t\t\t   || !h->def_regular))))\n\t      || (ELIMINATE_COPY_RELOCS\n\t\t  && !info->shared\n\t\t  && (sec->flags & SEC_ALLOC) != 0\n\t\t  && h != NULL\n\t\t  && (h->root.type == bfd_link_hash_defweak\n\t\t      || !h->def_regular)))\n\t    {\n\t      struct elf_dyn_relocs *p;\n\t      struct elf_dyn_relocs **head;\n\n\t      /* We must copy these reloc types into the output file.\n\t\t Create a reloc section in dynobj and make room for\n\t\t this reloc.  */\n\t      if (sreloc == NULL)\n\t\t{\n\t\t  if (htab->elf.dynobj == NULL)\n\t\t    htab->elf.dynobj = abfd;\n\n\t\t  sreloc = _bfd_elf_make_dynamic_reloc_section\n\t\t    (sec, htab->elf.dynobj, 2, abfd, /*rela?*/ FALSE);\n\n\t\t  if (sreloc == NULL)\n\t\t    return FALSE;\n\t\t}\n\n\t      /* If this is a global symbol, we count the number of\n\t\t relocations we need for this symbol.  */\n\t      if (h != NULL)\n\t\t{\n\t\t  head = &((struct elf_i386_link_hash_entry *) h)->dyn_relocs;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Track dynamic relocs needed for local syms too.\n\t\t     We really need local syms available to do this\n\t\t     easily.  Oh well.  */\n\t\t  void **vpp;\n\t\t  asection *s;\n\n\t\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n\t\t\t\t\t\tabfd, r_symndx);\n\t\t  if (isym == NULL)\n\t\t    return FALSE;\n\n\t\t  s = bfd_section_from_elf_index (abfd, isym->st_shndx);\n\t\t  if (s == NULL)\n\t\t    s = sec;\n\n\t\t  vpp = &elf_section_data (s)->local_dynrel;\n\t\t  head = (struct elf_dyn_relocs **)vpp;\n\t\t}\n\n\t      p = *head;\n\t      if (p == NULL || p->sec != sec)\n\t\t{\n\t\t  bfd_size_type amt = sizeof *p;\n\t\t  p = (struct elf_dyn_relocs *) bfd_alloc (htab->elf.dynobj,\n                                                           amt);\n\t\t  if (p == NULL)\n\t\t    return FALSE;\n\t\t  p->next = *head;\n\t\t  *head = p;\n\t\t  p->sec = sec;\n\t\t  p->count = 0;\n\t\t  p->pc_count = 0;\n\t\t}\n\n\t      p->count += 1;\n\t      /* Count size relocation as PC-relative relocation.  */\n\t      if (r_type == R_386_PC32 || size_reloc)\n\t\tp->pc_count += 1;\n\t    }\n\t  break;\n\n\t  /* This relocation describes the C++ object vtable hierarchy.\n\t     Reconstruct it for later use during GC.  */\n\tcase R_386_GNU_VTINHERIT:\n\t  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))\n\t    return FALSE;\n\t  break;\n\n\t  /* This relocation describes which C++ vtable entries are actually\n\t     used.  Record for later use during GC.  */\n\tcase R_386_GNU_VTENTRY:\n\t  BFD_ASSERT (h != NULL);\n\t  if (h != NULL\n\t      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_offset))\n\t    return FALSE;\n\t  break;\n\n\tdefault:\n\t  break;\n\t}\n    }\n\n  return TRUE;\n}"
}