{
    "Project": "bash",
    "Tool": "Infer",
    "Bug Type": "UNINITIALIZED_VALUE",
    "Code_line": "      exec_result = job_exit_status (lastpipe_jid);",
    "Code_function": "execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close)\n     COMMAND *command;\n     int asynchronous, pipe_in, pipe_out;\n     struct fd_bitmap *fds_to_close;\n{\n  int prev, fildes[2], new_bitmap_size, dummyfd, ignore_return, exec_result;\n  int lstdin, lastpipe_flag, lastpipe_jid;\n  COMMAND *cmd;\n  struct fd_bitmap *fd_bitmap;\n  pid_t lastpid;\n\n#if defined (JOB_CONTROL)\n  sigset_t set, oset;\n  BLOCK_CHILD (set, oset);\n#endif /* JOB_CONTROL */\n\n  ignore_return = (command->flags & CMD_IGNORE_RETURN) != 0;\n\n  prev = pipe_in;\n  cmd = command;\n\n  while (cmd && cmd->type == cm_connection &&\n\t cmd->value.Connection && cmd->value.Connection->connector == '|')\n    {\n      /* Make a pipeline between the two commands. */\n      if (pipe (fildes) < 0)\n\t{\n\t  sys_error (_(\"pipe error\"));\n#if defined (JOB_CONTROL)\n\t  terminate_current_pipeline ();\n\t  kill_current_pipeline ();\n\t  UNBLOCK_CHILD (oset);\n#endif /* JOB_CONTROL */\n\t  last_command_exit_value = EXECUTION_FAILURE;\n\t  /* The unwind-protects installed below will take care\n\t     of closing all of the open file descriptors. */\n\t  throw_to_top_level ();\n\t  return (EXECUTION_FAILURE);\t/* XXX */\n\t}\n\n      /* Here is a problem: with the new file close-on-exec\n\t code, the read end of the pipe (fildes[0]) stays open\n\t in the first process, so that process will never get a\n\t SIGPIPE.  There is no way to signal the first process\n\t that it should close fildes[0] after forking, so it\n\t remains open.  No SIGPIPE is ever sent because there\n\t is still a file descriptor open for reading connected\n\t to the pipe.  We take care of that here.  This passes\n\t around a bitmap of file descriptors that must be\n\t closed after making a child process in execute_simple_command. */\n\n      /* We need fd_bitmap to be at least as big as fildes[0].\n\t If fildes[0] is less than fds_to_close->size, then\n\t use fds_to_close->size. */\n      new_bitmap_size = (fildes[0] < fds_to_close->size)\n\t\t\t\t? fds_to_close->size\n\t\t\t\t: fildes[0] + 8;\n\n      fd_bitmap = new_fd_bitmap (new_bitmap_size);\n\n      /* Now copy the old information into the new bitmap. */\n      xbcopy ((char *)fds_to_close->bitmap, (char *)fd_bitmap->bitmap, fds_to_close->size);\n\n      /* And mark the pipe file descriptors to be closed. */\n      fd_bitmap->bitmap[fildes[0]] = 1;\n\n      /* In case there are pipe or out-of-processes errors, we\n\t want all these file descriptors to be closed when\n\t unwind-protects are run, and the storage used for the\n\t bitmaps freed up. */\n      begin_unwind_frame (\"pipe-file-descriptors\");\n      add_unwind_protect (dispose_fd_bitmap, fd_bitmap);\n      add_unwind_protect (close_fd_bitmap, fd_bitmap);\n      if (prev >= 0)\n\tadd_unwind_protect (close, prev);\n      dummyfd = fildes[1];\n      add_unwind_protect (close, dummyfd);\n\n#if defined (JOB_CONTROL)\n      add_unwind_protect (restore_signal_mask, &oset);\n#endif /* JOB_CONTROL */\n\n      if (ignore_return && cmd->value.Connection->first)\n\tcmd->value.Connection->first->flags |= CMD_IGNORE_RETURN;\n      execute_command_internal (cmd->value.Connection->first, asynchronous,\n\t\t\t\tprev, fildes[1], fd_bitmap);\n\n      if (prev >= 0)\n\tclose (prev);\n\n      prev = fildes[0];\n      close (fildes[1]);\n\n      dispose_fd_bitmap (fd_bitmap);\n      discard_unwind_frame (\"pipe-file-descriptors\");\n\n      cmd = cmd->value.Connection->second;\n    }\n\n  lastpid = last_made_pid;\n\n  /* Now execute the rightmost command in the pipeline.  */\n  if (ignore_return && cmd)\n    cmd->flags |= CMD_IGNORE_RETURN;\n\n  lastpipe_flag = 0;\n\n  begin_unwind_frame (\"lastpipe-exec\");\n  lstdin = -1;\n  /* If the `lastpipe' option is set with shopt, and job control is not\n     enabled, execute the last element of non-async pipelines in the\n     current shell environment. */\n  if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)\n    {\n      lstdin = move_to_high_fd (0, 1, -1);\n      if (lstdin > 0)\n\t{\n\t  do_piping (prev, pipe_out);\n\t  prev = NO_PIPE;\n\t  add_unwind_protect (restore_stdin, lstdin);\n\t  lastpipe_flag = 1;\n\t  freeze_jobs_list ();\n\t  lastpipe_jid = stop_pipeline (0, (COMMAND *)NULL);\t/* XXX */\n\t  add_unwind_protect (lastpipe_cleanup, lastpipe_jid);\n\t}\n      if (cmd)\n\tcmd->flags |= CMD_LASTPIPE;\n    }\n  if (prev >= 0)\n    add_unwind_protect (close, prev);\n\n  exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);\n\n  if (lstdin > 0)\n    restore_stdin (lstdin);\n\n  if (prev >= 0)\n    close (prev);\n\n#if defined (JOB_CONTROL)\n  UNBLOCK_CHILD (oset);\n#endif\n\n  QUIT;\n\n  if (lastpipe_flag)\n    {\n#if defined (JOB_CONTROL)\n      append_process (savestring (the_printed_command), dollar_dollar_pid, exec_result, lastpipe_jid);\n#endif\n      lstdin = wait_for (lastpid);\n#if defined (JOB_CONTROL)\n      exec_result = job_exit_status (lastpipe_jid);\n#endif\n      unfreeze_jobs_list ();\n    }\n\n  discard_unwind_frame (\"lastpipe-exec\");\n\n  return (exec_result);\n}"
}