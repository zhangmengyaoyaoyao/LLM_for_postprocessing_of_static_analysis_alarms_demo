{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "execute_cmd.c",
    "message": "The value read from ofifo was never initialized.",
    "warning_function_name": NaN,
    "warning_line": "if (nfifo > ofifo)",
    "warning_context": "      if (ignore_return)\n\tcommand->value.Arith->flags |= CMD_IGNORE_RETURN;\n      line_number_for_err_trap = save_line_number = line_number;\n      exec_result = execute_arith_command (command->value.Arith);\n      line_number = save_line_number;\n\n      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  save_line_number = line_number;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n#endif\n\n#if defined (COND_COMMAND)\n    case cm_cond:\n      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;\n      if (ignore_return)\n\tcommand->value.Cond->flags |= CMD_IGNORE_RETURN;\n\n      line_number_for_err_trap = save_line_number = line_number;\n      exec_result = execute_cond_command (command->value.Cond);\n      line_number = save_line_number;\n\n      if (was_error_trap && ignore_return == 0 && invert == 0 && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  save_line_number = line_number;\n\t  line_number = line_number_for_err_trap;\n\t  run_error_trap ();\n\t  line_number = save_line_number;\n\t}\n\n      if (ignore_return == 0 && invert == 0 && exit_immediately_on_error && exec_result != EXECUTION_SUCCESS)\n\t{\n\t  last_command_exit_value = exec_result;\n\t  run_pending_traps ();\n\t  jump_to_top_level (ERREXIT);\n\t}\n\n      break;\n#endif\n    \n    case cm_function_def:\n      exec_result = execute_intern_function (command->value.Function_def->name,\n\t\t\t\t\t     command->value.Function_def);\n      break;\n\n    default:\n      command_error (\"execute_command\", CMDERR_BADTYPE, command->type, 0);\n    }\n\n  if (my_undo_list)\n    {\n      do_redirections (my_undo_list, RX_ACTIVE);\n      dispose_redirects (my_undo_list);\n    }\n\n  if (exec_undo_list)\n    dispose_redirects (exec_undo_list);\n\n  if (my_undo_list || exec_undo_list)\n    discard_unwind_frame (\"loop_redirections\");\n\n#if defined (PROCESS_SUBSTITUTION)\n  if (saved_fifo)\n    {\n      nfifo = num_fifos ();\n      if (nfifo > ofifo)\n\tclose_new_fifos ((char *)ofifo_list, osize);\n      free ((void *)ofifo_list);\n    }\n#endif\n\n  /* Invert the return value if we have to */\n  if (invert)\n    exec_result = (exec_result == EXECUTION_SUCCESS)\n\t\t    ? EXECUTION_FAILURE\n\t\t    : EXECUTION_SUCCESS;\n\n#if defined (DPAREN_ARITHMETIC) || defined (COND_COMMAND)\n  /* This is where we set PIPESTATUS from the exit status of the appropriate\n     compound commands (the ones that look enough like simple commands to\n     cause confusion).  We might be able to optimize by not doing this if\n     subshell_environment != 0. */\n  switch (command->type)\n    {\n#  if defined (DPAREN_ARITHMETIC)\n    case cm_arith:\n#  endif\n"
}