{
    "project": "Zephyr",
    "tool": "Cppcheck",
    "category": "Uninitialized Variable",
    "file": "subsys/net/ip/connection.c",
    "message": "Uninitialized variable: conn->proto",
    "warning_function_name": "net_conn_input",
    "warning_line": "if (conn->proto != proto) {",
    "warning_context": "enum net_verdict net_conn_input(struct net_pkt *pkt,\n\t\t\t\tunion net_ip_header *ip_hdr,\n\t\t\t\tu8_t proto,\n\t\t\t\tunion net_proto_header *proto_hdr)\n{\n\tstruct net_if *pkt_iface = net_pkt_iface(pkt);\n\tstruct net_conn *best_match = NULL;\n\tbool is_mcast_pkt = false, mcast_pkt_delivered = false;\n\ts16_t best_rank = -1;\n\tstruct net_conn *conn;\n\tu16_t src_port;\n\tu16_t dst_port;\n\n\tif (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {\n\t\tsrc_port = proto_hdr->udp->src_port;\n\t\tdst_port = proto_hdr->udp->dst_port;\n\t} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {\n\t\tsrc_port = proto_hdr->tcp->src_port;\n\t\tdst_port = proto_hdr->tcp->dst_port;\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_PACKET)) {\n\t\tif (net_pkt_family(pkt) != AF_PACKET || proto != ETH_P_ALL) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tsrc_port = dst_port = 0U;\n\t} else if (IS_ENABLED(CONFIG_NET_SOCKETS_CAN) &&\n\t\t   net_pkt_family(pkt) == AF_CAN) {\n\t\tif (proto != CAN_RAW) {\n\t\t\treturn NET_DROP;\n\t\t}\n\n\t\tsrc_port = dst_port = 0U;\n\t} else {\n\t\tNET_DBG(\"No suitable protocol handler configured\");\n\t\treturn NET_DROP;\n\t}\n\n\tif (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {\n\t\tNET_DBG(\"Dropping invalid src/dst end-points packet\");\n\t\treturn NET_DROP;\n\t}\n\n\t/* TODO: Make core part of networing subsystem less dependent on\n\t * UDP, TCP, IPv4 or IPv6. So that we can add new features with\n\t * less cross-module changes.\n\t */\n\tNET_DBG(\"Check %s listener for pkt %p src port %u dst port %u\"\n\t\t\" family %d\", net_proto2str(net_pkt_family(pkt), proto), pkt,\n\t\tntohs(src_port), ntohs(dst_port), net_pkt_family(pkt));\n\n\t/* If we receive a packet with multicast destination address, we might\n\t * need to deliver the packet to multiple recipients.\n\t */\n\tif (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {\n\t\tif (net_ipv4_is_addr_mcast(&ip_hdr->ipv4->dst)) {\n\t\t\tis_mcast_pkt = true;\n\t\t}\n\t} else if (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t\t\t\t   net_pkt_family(pkt) == AF_INET6) {\n\t\tif (net_ipv6_is_addr_mcast(&ip_hdr->ipv6->dst)) {\n\t\t\tis_mcast_pkt = true;\n\t\t}\n\t}\n\n\tSYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {\n\t\tif (conn->proto != proto) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (conn->family != AF_UNSPEC &&\n\t\t    conn->family != net_pkt_family(pkt)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_NET_UDP) ||\n\t\t    IS_ENABLED(CONFIG_NET_TCP)) {\n\t\t\tif (net_sin(&conn->remote_addr)->sin_port) {\n\t\t\t\tif (net_sin(&conn->remote_addr)->sin_port !=\n\t\t\t\t    src_port) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (net_sin(&conn->local_addr)->sin_port) {\n\t\t\t\tif (net_sin(&conn->local_addr)->sin_port !=\n\t\t\t\t    dst_port) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (conn->flags & NET_CONN_REMOTE_ADDR_SET) {\n\t\t\t\tif (!conn_addr_cmp(pkt, ip_hdr,\n\t\t\t\t\t\t   &conn->remote_addr,\n\t\t\t\t\t\t   true)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (conn->flags & NET_CONN_LOCAL_ADDR_SET) {\n\t\t\t\tif (!conn_addr_cmp(pkt, ip_hdr,\n\t\t\t\t\t\t   &conn->local_addr,\n"
}