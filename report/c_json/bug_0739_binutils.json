{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_S2",
    "Code_line": "\t    if (! ieee_alloc_type (info, typindx, TRUE))",
    "Code_function": "parse_ieee_bb (struct ieee_info *info, const bfd_byte **pp)\n{\n  const bfd_byte *block_start;\n  bfd_byte b;\n  bfd_vma size;\n  const char *name;\n  unsigned long namlen;\n  char *namcopy = NULL;\n  unsigned int fnindx;\n  bfd_boolean skip;\n\n  block_start = *pp;\n\n  b = **pp;\n  ++*pp;\n\n  if (! ieee_read_number (info, pp, &size)\n      || ! ieee_read_id (info, pp, &name, &namlen))\n    return FALSE;\n\n  fnindx = (unsigned int) -1;\n  skip = FALSE;\n\n  switch (b)\n    {\n    case 1:\n      /* BB1: Type definitions local to a module.  */\n      namcopy = savestring (name, namlen);\n      if (namcopy == NULL)\n\treturn FALSE;\n      if (! debug_set_filename (info->dhandle, namcopy))\n\treturn FALSE;\n      info->saw_filename = TRUE;\n\n      /* Discard any variables or types we may have seen before.  */\n      if (info->vars.vars != NULL)\n\tfree (info->vars.vars);\n      info->vars.vars = NULL;\n      info->vars.alloc = 0;\n      if (info->types.types != NULL)\n\tfree (info->types.types);\n      info->types.types = NULL;\n      info->types.alloc = 0;\n\n      /* Initialize the types to the global types.  */\n      if (info->global_types != NULL)\n\t{\n\t  info->types.alloc = info->global_types->alloc;\n\t  info->types.types = ((struct ieee_type *)\n\t\t\t       xmalloc (info->types.alloc\n\t\t\t\t\t* sizeof (*info->types.types)));\n\t  memcpy (info->types.types, info->global_types->types,\n\t\t  info->types.alloc * sizeof (*info->types.types));\n\t}\n\n      break;\n\n    case 2:\n      /* BB2: Global type definitions.  The name is supposed to be\n\t empty, but we don't check.  */\n      if (! debug_set_filename (info->dhandle, \"*global*\"))\n\treturn FALSE;\n      info->saw_filename = TRUE;\n      break;\n\n    case 3:\n      /* BB3: High level module block begin.  We don't have to do\n\t anything here.  The name is supposed to be the same as for\n\t the BB1, but we don't check.  */\n      break;\n\n    case 4:\n      /* BB4: Global function.  */\n      {\n\tbfd_vma stackspace, typindx, offset;\n\tdebug_type return_type;\n\n\tif (! ieee_read_number (info, pp, &stackspace)\n\t    || ! ieee_read_number (info, pp, &typindx)\n\t    || ! ieee_read_expression (info, pp, &offset))\n\t  return FALSE;\n\n\t/* We have no way to record the stack space.  FIXME.  */\n\n\tif (typindx < 256)\n\t  {\n\t    return_type = ieee_builtin_type (info, block_start, typindx);\n\t    if (return_type == DEBUG_TYPE_NULL)\n\t      return FALSE;\n\t  }\n\telse\n\t  {\n\t    typindx -= 256;\n\t    if (! ieee_alloc_type (info, typindx, TRUE))\n\t      return FALSE;\n\t    fnindx = typindx;\n\t    return_type = info->types.types[typindx].type;\n\t    if (debug_get_type_kind (info->dhandle, return_type)\n\t\t== DEBUG_KIND_FUNCTION)\n\t      return_type = debug_get_return_type (info->dhandle,\n\t\t\t\t\t\t   return_type);\n\t  }\n\n\tnamcopy = savestring (name, namlen);\n\tif (namcopy == NULL)\n\t  return FALSE;\n\tif (! debug_record_function (info->dhandle, namcopy, return_type,\n\t\t\t\t     TRUE, offset))\n\t  return FALSE;\n      }\n      break;\n\n    case 5:\n      /* BB5: File name for source line numbers.  */\n      {\n\tunsigned int i;\n\n\t/* We ignore the date and time.  FIXME.  */\n\tfor (i = 0; i < 6; i++)\n\t  {\n\t    bfd_vma ignore;\n\t    bfd_boolean present;\n\n\t    if (! ieee_read_optional_number (info, pp, &ignore, &present))\n\t      return FALSE;\n\t    if (! present)\n\t      break;\n\t  }\n\n\tif (! info->saw_filename)\n\t  {\n\t    namcopy = savestring (name, namlen);\n\t    if (namcopy == NULL)\n\t      return FALSE;\n\t    if (! debug_set_filename (info->dhandle, namcopy))\n\t      return FALSE;\n\t    info->saw_filename = TRUE;\n\t  }\n\n\tnamcopy = savestring (name, namlen);\n\tif (namcopy == NULL)\n\t  return FALSE;\n\tif (! debug_start_source (info->dhandle, namcopy))\n\t  return FALSE;\n      }\n      break;\n\n    case 6:\n      /* BB6: Local function or block.  */\n      {\n\tbfd_vma stackspace, typindx, offset;\n\n\tif (! ieee_read_number (info, pp, &stackspace)\n\t    || ! ieee_read_number (info, pp, &typindx)\n\t    || ! ieee_read_expression (info, pp, &offset))\n\t  return FALSE;\n\n\t/* We have no way to record the stack space.  FIXME.  */\n\n\tif (namlen == 0)\n\t  {\n\t    if (! debug_start_block (info->dhandle, offset))\n\t      return FALSE;\n\t    /* Change b to indicate that this is a block\n\t       rather than a function.  */\n\t    b = 0x86;\n\t  }\n\telse\n\t  {\n\t    /* The MRI C++ compiler will output a fake function named\n\t       __XRYCPP to hold C++ debugging information.  We skip\n\t       that function.  This is not crucial, but it makes\n\t       converting from IEEE to other debug formats work\n\t       better.  */\n\t    if (strncmp (name, \"__XRYCPP\", namlen) == 0)\n\t      skip = TRUE;\n\t    else\n\t      {\n\t\tdebug_type return_type;\n\n\t\tif (typindx < 256)\n\t\t  {\n\t\t    return_type = ieee_builtin_type (info, block_start,\n\t\t\t\t\t\t     typindx);\n\t\t    if (return_type == NULL)\n\t\t      return FALSE;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    typindx -= 256;\n\t\t    if (! ieee_alloc_type (info, typindx, TRUE))\n\t\t      return FALSE;\n\t\t    fnindx = typindx;\n\t\t    return_type = info->types.types[typindx].type;\n\t\t    if (debug_get_type_kind (info->dhandle, return_type)\n\t\t\t== DEBUG_KIND_FUNCTION)\n\t\t      return_type = debug_get_return_type (info->dhandle,\n\t\t\t\t\t\t\t   return_type);\n\t\t  }\n\n\t\tnamcopy = savestring (name, namlen);\n\t\tif (namcopy == NULL)\n\t\t  return FALSE;\n\t\tif (! debug_record_function (info->dhandle, namcopy,\n\t\t\t\t\t     return_type, FALSE, offset))\n\t\t  return FALSE;\n\t      }\n\t  }\n      }\n      break;\n\n    case 10:\n      /* BB10: Assembler module scope.  In the normal case, we\n\t completely ignore all this information.  FIXME.  */\n      {\n\tconst char *inam, *vstr;\n\tunsigned long inamlen, vstrlen;\n\tbfd_vma tool_type;\n\tbfd_boolean present;\n\tunsigned int i;\n\n\tif (! info->saw_filename)\n\t  {\n\t    namcopy = savestring (name, namlen);\n\t    if (namcopy == NULL)\n\t      return FALSE;\n\t    if (! debug_set_filename (info->dhandle, namcopy))\n\t      return FALSE;\n\t    info->saw_filename = TRUE;\n\t  }\n\n\tif (! ieee_read_id (info, pp, &inam, &inamlen)\n\t    || ! ieee_read_number (info, pp, &tool_type)\n\t    || ! ieee_read_optional_id (info, pp, &vstr, &vstrlen, &present))\n\t  return FALSE;\n\tfor (i = 0; i < 6; i++)\n\t  {\n\t    bfd_vma ignore;\n\n\t    if (! ieee_read_optional_number (info, pp, &ignore, &present))\n\t      return FALSE;\n\t    if (! present)\n\t      break;\n\t  }\n      }\n      break;\n\n    case 11:\n      /* BB11: Module section.  We completely ignore all this\n\t information.  FIXME.  */\n      {\n\tbfd_vma sectype, secindx, offset, map;\n\tbfd_boolean present;\n\n\tif (! ieee_read_number (info, pp, &sectype)\n\t    || ! ieee_read_number (info, pp, &secindx)\n\t    || ! ieee_read_expression (info, pp, &offset)\n\t    || ! ieee_read_optional_number (info, pp, &map, &present))\n\t  return FALSE;\n      }\n      break;\n\n    default:\n      ieee_error (info, block_start, _(\"unknown BB type\"));\n      return FALSE;\n    }\n\n\n  /* Push this block on the block stack.  */\n\n  if (info->blockstack.bsp >= info->blockstack.stack + BLOCKSTACK_SIZE)\n    {\n      ieee_error (info, (const bfd_byte *) NULL, _(\"stack overflow\"));\n      return FALSE;\n    }\n\n  info->blockstack.bsp->kind = b;\n  if (b == 5)\n    info->blockstack.bsp->filename = namcopy;\n  info->blockstack.bsp->fnindx = fnindx;\n  info->blockstack.bsp->skip = skip;\n  ++info->blockstack.bsp;\n\n  return TRUE;\n}"
}