{
    "Project": "diffutils",
    "Tool": "Cppcheck",
    "category": "uninitvar",
    "file": "lib/xstrtol.c",
    "message": "Uninitialized variable: &t_ptr",
    "warning_function_name": "__xstrtol",
    "warning_line": "p = (ptr ? ptr : &t_ptr);",
    "warning_context": "strtol_error\n__xstrtol (const char *s, char **ptr, int strtol_base,\n           __strtol_t *val, const char *valid_suffixes)\n{\n  char *t_ptr;\n  char **p;\n  __strtol_t tmp;\n  strtol_error err = LONGINT_OK;\n\n  assert (0 <= strtol_base && strtol_base <= 36);\n\n  p = (ptr ? ptr : &t_ptr);\n\n  if (! TYPE_SIGNED (__strtol_t))\n    {\n      const char *q = s;\n      unsigned char ch = *q;\n      while (isspace (ch))\n        ch = *++q;\n      if (ch == '-')\n        return LONGINT_INVALID;\n    }\n\n  errno = 0;\n  tmp = __strtol (s, p, strtol_base);\n\n  if (*p == s)\n    {\n      /* If there is no number but there is a valid suffix, assume the\n         number is 1.  The string is invalid otherwise.  */\n      if (valid_suffixes && **p && strchr (valid_suffixes, **p))\n        tmp = 1;\n      else\n        return LONGINT_INVALID;\n    }\n  else if (errno != 0)\n    {\n      if (errno != ERANGE)\n        return LONGINT_INVALID;\n      err = LONGINT_OVERFLOW;\n    }\n\n  /* Let valid_suffixes == NULL mean \"allow any suffix\".  */\n  /* FIXME: update all callers except the ones that allow suffixes\n     after the number, changing last parameter NULL to \"\".  */\n  if (!valid_suffixes)\n    {\n      *val = tmp;\n      return err;\n    }\n\n  if (**p != '\\0')\n    {\n      int base = 1024;\n      int suffixes = 1;\n      strtol_error overflow;\n\n      if (!strchr (valid_suffixes, **p))\n        {\n          *val = tmp;\n          return err | LONGINT_INVALID_SUFFIX_CHAR;\n        }\n\n      if (strchr (valid_suffixes, '0'))\n        {\n          /* The \"valid suffix\" '0' is a special flag meaning that\n             an optional second suffix is allowed, which can change\n             the base.  A suffix \"B\" (e.g. \"100MB\") stands for a power\n             of 1000, whereas a suffix \"iB\" (e.g. \"100MiB\") stands for\n             a power of 1024.  If no suffix (e.g. \"100M\"), assume\n             power-of-1024.  */\n\n          switch (p[0][1])\n            {\n            case 'i':\n              if (p[0][2] == 'B')\n                suffixes += 2;\n              break;\n\n            case 'B':\n            case 'D': /* 'D' is obsolescent */\n              base = 1000;\n              suffixes++;\n              break;\n            }\n        }\n\n      switch (**p)\n        {\n        case 'b':\n          overflow = bkm_scale (&tmp, 512);\n          break;\n\n        case 'B':\n          overflow = bkm_scale (&tmp, 1024);\n          break;\n\n        case 'c':\n          overflow = 0;\n          break;\n\n"
}