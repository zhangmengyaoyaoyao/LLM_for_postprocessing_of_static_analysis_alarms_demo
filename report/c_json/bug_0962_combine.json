{
    "project": "combine",
    "tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "src/field.c",
    "message": "The value read from field_list_length was never initialized.",
    "warning_function_name": "find_input_ranges",
    "warning_line": "if (ranges[i].lower_bound < 0 || ranges[i].lower_bound > field_list_length)",
    "warning_context": "int\nfind_input_ranges (out_string, input_record, ranges, range_count,\n\t\t   end_range_start, input_delimiter, input_delimiter_repeat,\n\t\t   output_delimiter)\n     STRINGTYPE *out_string;\n     STRINGTYPE *input_record;\n     field_range *ranges;\n     int range_count;\n     size_t end_range_start;\n     STRINGTYPE *input_delimiter;\n     int input_delimiter_repeat;\n     STRINGTYPE *output_delimiter;\n{\n  int i;\n  int j;\n  STRINGTYPE **field_list;\n  int field_list_length;\n  int return_code;\n\n  if (input_delimiter != NULL) {\n    return_code\n      = dstrsplit (input_record, input_delimiter, &field_list,\n\t\t   &field_list_length);\n    if (return_code != EXIT_SUCCESS) {\n      if (return_code == DSTR_EMEMORY)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      else\n\tFATAL_ERROR (_(\"internal error: invalid string descriptor\"));\n      }\n    if (input_delimiter_repeat) {\n      i = 0;\n      while (i < field_list_length) {\n\tif (field_list[i]->length == 0) {\n\t  for (j = i + 1; j < field_list_length; j++)\n\t    field_list[j - 1] = field_list[j];\n\t  field_list_length--;\n\t  }\n\telse\n\t  i++;\n\t}\n      field_list\n\t= realloc (field_list, field_list_length * sizeof (*field_list));\n      if (field_list == NULL)\n\tFATAL_ERROR (_(\"unable to allocate memory\"));\n      }\n    }\n\n  for (i = 0; i < range_count; i++) {\n    STRINGTYPE *temp_string;\n    STRINGTYPE *other_string;\n\n    if (out_string->length > 0 && output_delimiter != NULL)\n      dstrcat (out_string, output_delimiter);\n    if (input_delimiter != NULL) {\n      if (ranges[i].lower_bound < 0 || ranges[i].lower_bound > field_list_length)\n\tFATAL_ERROR2 (_\n\t\t      (\"bad field substring -- wanted field %ld from %d fields\"),\n\t\t      ranges[i].lower_bound, field_list_length);\n      temp_string = field_list[ranges[i].lower_bound - 1];\n      }\n    else {\n      temp_string\n\t= dstrsubstr (input_record, ranges[i].lower_bound,\n\t\t      ranges[i].upper_bound, 0, DStr_not_own);\n      if (temp_string == NULL) {\n\tif (ranges[i].lower_bound > 0\n\t    || ranges[i].lower_bound > ranges[i].upper_bound\n\t    || ranges[i].upper_bound > input_record->length)\n\t  FATAL_ERROR3 (_\n\t\t\t(\"bad field substring -- wanted bytes %ld-%ld in %ld-byte string\"),\n\t\t\tranges[i].lower_bound, ranges[i].upper_bound,\n\t\t\tinput_record->length);\n\telse\n\t  FATAL_ERROR (_(\"unable to allocate memory\"));\n\t}\n      }\n#ifdef HAVE_LIBGUILE\n    if (ranges[i].format != NULL) {\t/* We have some processing to do. */\n      SCM return_value;\n      STRINGTYPE *result_string;\n      size_t return_length;\n      /* Assuming scheme for now */\n      /* Assemble scheme code */\n      create_scheme_string_variable (&df_name_input_field, 0, temp_string);\n\n      /* Call Guile */\n      result_string = eval_scheme_string_function (ranges[i].format);\n      if (input_delimiter == NULL)\n\tdstrfree (temp_string);\n      temp_string = result_string;\n      }\n#  endif /* HAVE_LIBGUILE */\n    other_string = dstrcat (out_string, temp_string);\n    if (other_string == NULL)\n      FATAL_ERROR (_(\"unable to allocate memory\"));\n    if (input_delimiter == NULL || ranges[i].format != NULL)\n      dstrfree (temp_string);\n    }\n\n  /* Note: we have not given the possibility of changing a record-ending\n   *  key string with scheme extensibility.\n"
}