{
    "Project": "gawk",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "random.c",
    "message": "Offset: 32 Size: 32.",
    "warning_function_name": "good_rand",
    "warning_line": "static uint32_t *end_ptr = &randtbl[DEG_3 + 1];",
    "warning_context": "static uint32_t *end_ptr = &randtbl[DEG_3 + 1];\n\nstatic inline uint32_t good_rand(int32_t);\n\nstatic inline uint32_t good_rand (x)\n\tint32_t x;\n{\n#ifdef  USE_WEAK_SEEDING\n/*\n * Historic implementation compatibility.\n * The random sequences do not vary much with the seed,\n * even with overflowing.\n */\n\treturn (1103515245 * x + 12345);\n#else   /* !USE_WEAK_SEEDING */\n/*\n * Compute x = (7^5 * x) mod (2^31 - 1)\n * wihout overflowing 31 bits:\n *      (2^31 - 1) = 127773 * (7^5) + 2836\n * From \"Random number generators: good ones are hard to find\",\n * Park and Miller, Communications of the ACM, vol. 31, no. 10,\n * October 1988, p. 1195.\n */\n\tint32_t hi, lo;\n\n\t/* Can't be initialized with 0, so use another value. */\n\tif (x == 0)\n\t\tx = 123459876;\n\thi = x / 127773;\n\tlo = x % 127773;\n\tx = 16807 * lo - 2836 * hi;\n\tif (x < 0)\n\t\tx += 0x7fffffff;\n\treturn (x);\n#endif  /* !USE_WEAK_SEEDING */\n}\n\n/*\n * srandom:\n *\n * Initialize the random number generator based on the given seed.  If the\n * type is the trivial no-state-information type, just remember the seed.\n * Otherwise, initializes state[] based on the given \"seed\" via a linear\n * congruential generator.  Then, the pointers are set to known locations\n * that are exactly rand_sep places apart.  Lastly, it cycles the state\n * information a given number of times to get rid of any initial dependencies\n * introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]\n * for default usage relies on values produced by this routine.\n */\nvoid\nsrandom(x)\n\tunsigned long x;\n{\n\tint i, lim;\n\n\tstate[0] = (uint32_t)x;\n\tif (rand_type == TYPE_0)\n\t\tlim = NSHUFF;\n\telse {\n\t\tfor (i = 1; i < rand_deg; i++)\n\t\t\tstate[i] = good_rand(state[i - 1]);\n\t\tfptr = &state[rand_sep];\n\t\trptr = &state[0];\n\t\tlim = 10 * rand_deg;\n\t}\n\tfor (i = 0; i < lim; i++)\n\t\t(void)random();\n}\n\n#if 0 /* gawk doesn't use this */\n/*\n * srandomdev:\n *\n * Many programs choose the seed value in a totally predictable manner.\n * This often causes problems.  We seed the generator using the much more\n * secure random(4) interface.  Note that this particular seeding\n * procedure can generate states which are impossible to reproduce by\n * calling srandom() with any value, since the succeeding terms in the\n * state buffer are no longer derived from the LC algorithm applied to\n * a fixed seed.\n */\nvoid\nsrandomdev()\n{\n\tint fd, done;\n\tsize_t len;\n\n\tif (rand_type == TYPE_0)\n\t\tlen = sizeof state[0];\n\telse\n\t\tlen = rand_deg * sizeof state[0];\n\n\tdone = 0;\n\tfd = open(\"/dev/random\", O_RDONLY, 0);\n\tif (fd >= 0) {\n\t\tif (read(fd, (void *) state, len) == (ssize_t) len)\n\t\t\tdone = 1;\n\t\tclose(fd);\n\t}\n\n\tif (!done) {\n"
}