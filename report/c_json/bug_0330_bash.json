{
    "Project": "bash",
    "Tool": "Infer",
    "category": "UNINITIALIZED_VALUE",
    "file": "subst.c",
    "message": "The value read from state_bak.__count was never initialized.",
    "warning_function_name": "list_string",
    "warning_line": "ADVANCE_CHAR (string, slen, sindex);",
    "warning_context": "  sh_style_split = separators && separators[0] == ' ' &&\n\t\t\t\t separators[1] == '\\t' &&\n\t\t\t\t separators[2] == '\\n' &&\n\t\t\t\t separators[3] == '\\0';\n  for (xflags = 0, s = ifs_value; s && *s; s++)\n    {\n      if (*s == CTLESC) xflags |= SX_NOCTLESC;\n      else if (*s == CTLNUL) xflags |= SX_NOESCCTLNUL;\n    }\n\n  slen = 0;\n  /* Remove sequences of whitespace at the beginning of STRING, as\n     long as those characters appear in IFS.  Do not do this if\n     STRING is quoted or if there are no separator characters. */\n  if (!quoted || !separators || !*separators)\n    {\n      for (s = string; *s && spctabnl (*s) && issep (*s); s++);\n\n      if (!*s)\n\treturn ((WORD_LIST *)NULL);\n\n      string = s;\n    }\n\n  /* OK, now STRING points to a word that does not begin with white space.\n     The splitting algorithm is:\n\textract a word, stopping at a separator\n\tskip sequences of spc, tab, or nl as long as they are separators\n     This obeys the field splitting rules in Posix.2. */\n  slen = (MB_CUR_MAX > 1) ? strlen (string) : 1;\n  for (result = (WORD_LIST *)NULL, sindex = 0; string[sindex]; )\n    {\n      /* Don't need string length in ADVANCE_CHAR or string_extract_verbatim\n\t unless multibyte chars are possible. */\n      current_word = string_extract_verbatim (string, slen, &sindex, separators, xflags);\n      if (current_word == 0)\n\tbreak;\n\n      /* If we have a quoted empty string, add a quoted null argument.  We\n\t want to preserve the quoted null character iff this is a quoted\n\t empty string; otherwise the quoted null characters are removed\n\t below. */\n      if (QUOTED_NULL (current_word))\n\t{\n\t  t = alloc_word_desc ();\n\t  t->word = make_quoted_char ('\\0');\n\t  t->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  result = make_word_list (t, result);\n\t}\n      else if (current_word[0] != '\\0')\n\t{\n\t  /* If we have something, then add it regardless.  However,\n\t     perform quoted null character removal on the current word. */\n\t  remove_quoted_nulls (current_word);\n\t  result = add_string_to_list (current_word, result);\n\t  result->word->flags &= ~W_HASQUOTEDNULL;\t/* just to be sure */\n\t  if (quoted & (Q_DOUBLE_QUOTES|Q_HERE_DOCUMENT))\n\t    result->word->flags |= W_QUOTED;\n\t}\n\n      /* If we're not doing sequences of separators in the traditional\n\t Bourne shell style, then add a quoted null argument. */\n      else if (!sh_style_split && !spctabnl (string[sindex]))\n\t{\n\t  t = alloc_word_desc ();\n\t  t->word = make_quoted_char ('\\0');\n\t  t->flags |= W_QUOTED|W_HASQUOTEDNULL;\n\t  result = make_word_list (t, result);\n\t}\n\n      free (current_word);\n\n      /* Note whether or not the separator is IFS whitespace, used later. */\n      whitesep = string[sindex] && spctabnl (string[sindex]);\n\n      /* Move past the current separator character. */\n      if (string[sindex])\n\t{\n\t  DECLARE_MBSTATE;\n\t  ADVANCE_CHAR (string, slen, sindex);\n\t}\n\n      /* Now skip sequences of space, tab, or newline characters if they are\n\t in the list of separators. */\n      while (string[sindex] && spctabnl (string[sindex]) && issep (string[sindex]))\n\tsindex++;\n\n      /* If the first separator was IFS whitespace and the current character\n\t is a non-whitespace IFS character, it should be part of the current\n\t field delimiter, not a separate delimiter that would result in an\n\t empty field.  Look at POSIX.2, 3.6.5, (3)(b). */\n      if (string[sindex] && whitesep && issep (string[sindex]) && !spctabnl (string[sindex]))\n\t{\n\t  sindex++;\n\t  /* An IFS character that is not IFS white space, along with any\n\t     adjacent IFS white space, shall delimit a field. (SUSv3) */\n\t  while (string[sindex] && spctabnl (string[sindex]) && isifs (string[sindex]))\n\t    sindex++;\n\t}\n    }\n  return (REVERSE_LIST (result, WORD_LIST *));\n"
}