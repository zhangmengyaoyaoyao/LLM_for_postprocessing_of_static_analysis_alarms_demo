{
    "Project": "gawk",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: 33 (⇐ 1 + 32) Size: [0, +oo] by call to `bcalloc`.",
    "Code_line": "\t\tlist_append(right, instruction(final_opc));",
    "Code_function": "mk_boolean(INSTRUCTION *left, INSTRUCTION *right, INSTRUCTION *op)\n{\n\tINSTRUCTION *tp;\n\tOPCODE opc, final_opc;\n\n\topc = op->opcode;\t\t/* Op_and or Op_or */\n\tfinal_opc = (opc == Op_or) ? Op_or_final : Op_and_final;\n\n\tadd_lint(right, LINT_assign_in_cond);\n\n\ttp = left->lasti;\n\n\tif (tp->opcode != final_opc) {\t/* x || y */\n\t\tlist_append(right, instruction(final_opc));\n\t\tadd_lint(left, LINT_assign_in_cond);\n\t\t(void) list_append(left, op);\n\t\tleft->lasti->target_jmp = right->lasti;\n\n\t\t/* NB: target_stmt points to previous Op_and(Op_or) in a chain;\n\t\t *     target_stmt only used in the parser (see below).\n\t\t */\n\n\t\tleft->lasti->target_stmt = left->lasti;\n\t\tright->lasti->target_stmt = left->lasti;\n\t} else {\t\t/* optimization for x || y || z || ... */\n\t\tINSTRUCTION *ip;\n\n\t\top->opcode = final_opc;\n\t\t(void) list_append(right, op);\n\t\top->target_stmt = tp;\n\t\ttp->opcode = opc;\n\t\ttp->target_jmp = op;\n\n\t\t/* update jump targets */\n\t\tfor (ip = tp->target_stmt; ; ip = ip->target_stmt) {\n\t\t\tassert(ip->opcode == opc);\n\t\t\tassert(ip->target_jmp == tp);\n\t\t\t/* if (ip->opcode == opc &&  ip->target_jmp == tp) */\n\t\t\tip->target_jmp = op;\n\t\t\tif (ip->target_stmt == ip)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn list_merge(left, right);\n}"
}