{
    "project": "bash",
    "tool": "CSA",
    "category": "core.NullDereference",
    "file": "jobs.c",
    "message": "Access to field 'status' results in a dereference of a null pointer (loaded from variable 'child')",
    "warning_function_name": "wait_for",
    "warning_line": ": process_exit_status (child->status);",
    "warning_context": "\t  act.sa_flags = 0;\n#  if defined (SA_RESTART)\n\t  act.sa_flags |= SA_RESTART;\n#  endif\n\t  sigaction (SIGCHLD, &act, &oact);\n#  endif /* MUST_UNBLOCK_CHLD */\n\t  queue_sigchld = 1;\n\t  waiting_for_child++;\n\t  r = waitchld (pid, 1);\t/* XXX */\n\t  waiting_for_child--;\n#if 0\nitrace(\"wait_for: blocking wait for %d returns %d child = %p\", (int)pid, r, child);\n#endif\n#  if defined (MUST_UNBLOCK_CHLD)\n\t  sigaction (SIGCHLD, &oact, (struct sigaction *)NULL);\n\t  sigprocmask (SIG_SETMASK, &chldset, (sigset_t *)NULL);\n#  endif\n\t  queue_sigchld = 0;\n\t  if (r == -1 && errno == ECHILD && this_shell_builtin == wait_builtin)\n\t    {\n\t      termination_state = -1;\n\t      /* XXX - restore sigint handler here? */\n\t      goto wait_for_return;\n\t    }\n\n\t  /* If child is marked as running, but waitpid() returns -1/ECHILD,\n\t     there is something wrong.  Somewhere, wait should have returned\n\t     that child's pid.  Mark the child as not running and the job,\n\t     if it exists, as JDEAD. */\n\t  if (r == -1 && errno == ECHILD)\n\t    {\n\t      if (child)\n\t\t{\n\t\t  child->running = PS_DONE;\n\t\t  WSTATUS (child->status) = 0;\t/* XXX -- can't find true status */\n\t\t}\n\t      js.c_living = 0;\t\t/* no living child processes */\n\t      if (job != NO_JOB)\n\t\t{\n\t\t  jobs[job]->state = JDEAD;\n\t\t  js.c_reaped++;\n\t\t  js.j_ndead++;\n\t\t}\n\t      if (pid == ANY_PID)\n\t\t{\n\t\t  termination_state = -1;\n\t\t  break;\n\t\t}\n\t    }\n#endif /* WAITPID_BROKEN */\n\t}\n\n      /* If the shell is interactive, and job control is disabled, see\n\t if the foreground process has died due to SIGINT and jump out\n\t of the wait loop if it has.  waitchld has already restored the\n\t old SIGINT signal handler. */\n      if (interactive && job_control == 0)\n\tQUIT;\n      /* Check for terminating signals and exit the shell if we receive one */\n      CHECK_TERMSIG;\n\n      /* Check for a trapped signal interrupting the wait builtin and jump out */\n      CHECK_WAIT_INTR;\n\n      if (pid == ANY_PID)\n        /* XXX - could set child but we don't have a handle on what waitchld\n\t   reaps.  Leave termination_state alone. */\n\tgoto wait_for_return;\n    }\n  while (PRUNNING (child) || (job != NO_JOB && RUNNING (job)));\n\n  /* Restore the original SIGINT signal handler before we return. */\n  restore_sigint_handler ();\n\n  /* The exit state of the command is either the termination state of the\n     child, or the termination state of the job.  If a job, the status\n     of the last child in the pipeline is the significant one.  If the command\n     or job was terminated by a signal, note that value also. */\n  termination_state = (job != NO_JOB) ? job_exit_status (job)\n\t\t\t\t      : process_exit_status (child->status);\n  last_command_exit_signal = (job != NO_JOB) ? job_exit_signal (job)\n\t\t\t\t\t     : process_exit_signal (child->status);\n\n  /* XXX */\n  if ((job != NO_JOB && JOBSTATE (job) == JSTOPPED) || WIFSTOPPED (child->status))\n    termination_state = 128 + WSTOPSIG (child->status);\n\n  if (job == NO_JOB || IS_JOBCONTROL (job))\n    {\n      /* XXX - under what circumstances is a job not present in the jobs\n\t table (job == NO_JOB)?\n\t \t1.  command substitution\n\n\t In the case of command substitution, at least, it's probably not\n\t the right thing to give the terminal to the shell's process group,\n\t even though there is code in subst.c:command_substitute to work\n\t around it.\n\n\t Things that don't:\n\t\t$PROMPT_COMMAND execution\n\t\tprocess substitution\n"
}