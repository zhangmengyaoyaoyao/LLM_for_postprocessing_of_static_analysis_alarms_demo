{
    "Project": "Zephyr",
    "Tool": "Cppcheck",
    "category": "Null Pointer Dereference",
    "file": "subsys/bluetooth/controller/ll_sw/ull_conn.c",
    "message": "Either the condition 'rx' is redundant or there is possible null pointer dereference: rx.",
    "warning_function_name": NaN,
    "warning_line": "conn->llcp_rx = rx->hdr.link->mem;",
    "warning_context": "\t\t} else if (conn->llcp_feature.features &\n\t\t\t   BIT(BT_LE_FEAT_BIT_PHY_2M)) {\n\t\t\tu16_t rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(1));\n\t\t\tu16_t tx_time;\n\n\t\t\tif (conn->default_tx_time > rx_time) {\n\t\t\t\ttx_time = rx_time;\n\t\t\t} else {\n\t\t\t\ttx_time = conn->default_tx_time;\n\t\t\t}\n\n\t\t\tlr->max_rx_time = sys_cpu_to_le16(rx_time);\n\t\t\tlr->max_tx_time = sys_cpu_to_le16(tx_time);\n#endif /* CONFIG_BT_CTLR_PHY_2M */\n#endif /* CONFIG_BT_CTLR_PHY */\n\t\t}\n\n\t\tctrl_tx_enqueue(conn, tx);\n\n\t\t/* Start Procedure Timeout (TODO: this shall not replace\n\t\t * terminate procedure).\n\t\t */\n\t\tconn->procedure_expire = conn->procedure_reload;\n\t}\n\tbreak;\n\n\tcase LLCP_LENGTH_STATE_RESIZE:\n\tcase LLCP_LENGTH_STATE_RESIZE_RSP:\n\t{\n\t\tstruct pdu_data_llctrl_length_rsp *lr;\n\t\tstruct pdu_data *pdu_ctrl_rx;\n\t\tstruct node_rx_pdu *rx;\n\t\tstruct lll_conn *lll;\n\t\tu16_t tx_octets;\n\n\t\tlll = &conn->lll;\n\n\t\t/* Use the new rx octets/time in the connection */\n\t\tlll->max_rx_octets = conn->llcp_length.rx_octets;\n\n\t\t/* backup tx_octets */\n\t\ttx_octets = conn->llcp_length.tx_octets;\n\n#if defined(CONFIG_BT_CTLR_PHY)\n\t\t/* Use the new rx time in the connection */\n\t\tlll->max_rx_time = conn->llcp_length.rx_time;\n\n\t\t/* backup tx time */\n\t\tu16_t tx_time = conn->llcp_length.tx_time;\n#endif /* CONFIG_BT_CTLR_PHY */\n\n\t\t/* switch states, to wait for ack, to request cached values or\n\t\t * complete the procedure\n\t\t */\n\t\tif (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {\n\t\t\t/* check cache */\n\t\t\tif (!conn->llcp_length.cache.tx_octets) {\n\t\t\t\t/* Procedure complete */\n\t\t\t\tconn->llcp_length.ack = conn->llcp_length.req;\n\t\t\t\tconn->procedure_expire = 0U;\n\t\t\t} else {\n\t\t\t\t/* Initiate cached procedure */\n\t\t\t\tconn->llcp_length.tx_octets =\n\t\t\t\t\tconn->llcp_length.cache.tx_octets;\n\t\t\t\tconn->llcp_length.cache.tx_octets = 0;\n#if defined(CONFIG_BT_CTLR_PHY)\n\t\t\t\tconn->llcp_length.tx_time =\n\t\t\t\t\tconn->llcp_length.cache.tx_time;\n#endif /* CONFIG_BT_CTLR_PHY */\n\t\t\t\tconn->llcp_length.state = LLCP_LENGTH_STATE_REQ;\n\t\t\t}\n\t\t} else {\n\t\t\tconn->llcp_length.state =\n\t\t\t\tLLCP_LENGTH_STATE_RESIZE_RSP_ACK_WAIT;\n\t\t}\n\n\t\t/* Prepare the rx packet structure */\n\t\trx = conn->llcp_rx;\n\t\tLL_ASSERT(rx && rx->hdr.link);\n\t\tconn->llcp_rx = rx->hdr.link->mem;\n\n\t\trx->hdr.handle = conn->lll.handle;\n\t\trx->hdr.type = NODE_RX_TYPE_DC_PDU;\n\n\t\t/* prepare length rsp structure */\n\t\tpdu_ctrl_rx = (void *)rx->pdu;\n\t\tpdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;\n\t\tpdu_ctrl_rx->len =\n\t\t\toffsetof(struct pdu_data_llctrl, length_rsp) +\n\t\t\tsizeof(struct pdu_data_llctrl_length_rsp);\n\t\tpdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;\n\n\t\tlr = &pdu_ctrl_rx->llctrl.length_rsp;\n\t\tlr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);\n\t\tlr->max_tx_octets = sys_cpu_to_le16(tx_octets);\n#if !defined(CONFIG_BT_CTLR_PHY)\n\t\tlr->max_rx_time =\n\t\t\tsys_cpu_to_le16(PKT_US(lll->max_rx_octets, 0));\n\t\tlr->max_tx_time = sys_cpu_to_le16(PKT_US(tx_octets, 0));\n#else /* CONFIG_BT_CTLR_PHY */\n\t\tlr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);\n"
}