{
    "project": "gawk",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "awkgram.y",
    "message": "Offset added: 33 (⇐ 1 + 32) Size: [0, +oo] by call to `bcalloc`.",
    "warning_function_name": "optimize_assignment",
    "warning_line": "return list_append(exp, instruction(Op_pop));",
    "warning_context": "static INSTRUCTION *\noptimize_assignment(INSTRUCTION *exp)\n{\n\tINSTRUCTION *i1, *i2, *i3;\n\n\t/*\n\t * Optimize assignment statements array[subs] = x; var = x; $n = x;\n\t * string concatenation of the form s = s t.\n\t *\n\t * 1) Array element assignment array[subs] = x:\n\t *   Replaces Op_push_array + Op_subscript_lhs + Op_assign + Op_pop\n\t *   with single instruction Op_store_sub.\n\t *\t Limitation: 1 dimension and sub is simple var/value.\n\t * \n\t * 2) Simple variable assignment var = x:\n\t *   Replaces Op_push_lhs + Op_assign + Op_pop with Op_store_var.\n\t *\n\t * 3) Field assignment $n = x:\n\t *   Replaces Op_field_spec_lhs + Op_assign + Op_field_assign + Op_pop\n\t *   with Op_store_field.\n\t *\n\t * 4) Optimization for string concatenation:\n\t *   For cases like x = x y, uses realloc to include y in x;\n\t *   also eliminates instructions Op_push_lhs and Op_pop.\n\t */\n\n\t/*\n\t * N.B.: do not append Op_pop instruction to the returned\n\t * instruction list if optimized. None of these\n\t * optimized instructions pushes the r-value of assignment\n\t * onto the runtime stack.\n\t */\n\n\ti2 = NULL;\n\ti1 = exp->lasti;\n\n\tif (   i1->opcode != Op_assign\n\t    && i1->opcode != Op_field_assign) \n\t\treturn list_append(exp, instruction(Op_pop));\n\n\tfor (i2 = exp->nexti; i2 != i1; i2 = i2->nexti) {\n\t\tswitch (i2->opcode) {\n\t\tcase Op_concat:\n\t\t\tif (i2->nexti->opcode == Op_push_lhs    /* l.h.s is a simple variable */\n\t\t\t\t&& (i2->concat_flag & CSVAR) != 0   /* 1st exp in r.h.s is a simple variable;\n\t\t\t\t                                     * see Op_concat in the grammer above.\n\t\t\t\t                                     */\n\t\t\t\t&& i2->nexti->memory == exp->nexti->memory\t /* and the same as in l.h.s */\n\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t&& i1->opcode == Op_assign\n\t\t\t) {\n\t\t\t\t/* s = s ... optimization */\n\n\t\t\t\t/* avoid stuff like x = x (x = y) or x = x gsub(/./, \"b\", x);\n\t\t\t\t * check for l-value reference to this variable in the r.h.s.\n\t\t\t\t * Also, avoid function calls in general to guard against\n\t\t\t\t * global variable assignment.\n\t\t\t\t */\n\n\t\t\t\tfor (i3 = exp->nexti->nexti; i3 != i2; i3 = i3->nexti) {\n\t\t\t\t\tif ((i3->opcode == Op_push_lhs && i3->memory == i2->nexti->memory)\n\t\t\t\t\t\t\t|| i3->opcode == Op_func_call)\n\t\t\t\t\t\treturn list_append(exp, instruction(Op_pop)); /* no optimization */\n\t\t\t\t}\n\n\t\t\t\t/* remove the variable from r.h.s */\n\t\t\t\ti3 = exp->nexti;\n\t\t\t\texp->nexti = i3->nexti;\n\t\t\t\tbcfree(i3);\n\n\t\t\t\tif (--i2->expr_count == 1)\t/* one less expression in Op_concat */\n\t\t\t\t\ti2->opcode = Op_no_op;\n\n\t\t\t\ti3 = i2->nexti;\n\t\t\t\tassert(i3->opcode == Op_push_lhs);\n\t\t\t\ti3->opcode = Op_assign_concat;\t/* change Op_push_lhs to Op_assign_concat */\n\t\t\t\ti3->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_assign */\n\t\t\t\texp->lasti = i3;     /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_field_spec_lhs:\n\t\t\tif (i2->nexti->opcode == Op_assign\n\t\t\t\t\t&& i2->nexti->nexti == i1\n\t\t\t\t\t&& i1->opcode == Op_field_assign\n\t\t\t) {\n\t\t\t\t/* $n = .. */\n\t\t\t\ti2->opcode = Op_store_field;\n\t\t\t\tbcfree(i2->nexti);  /* Op_assign */\n\t\t\t\ti2->nexti = NULL;\n\t\t\t\tbcfree(i1);          /* Op_field_assign */\n\t\t\t\texp->lasti = i2;    /* update Op_list */\n\t\t\t\treturn exp;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase Op_push_array:\n\t\t\tif (i2->nexti->nexti->opcode == Op_subscript_lhs) {\n\t\t\t\ti3 = i2->nexti->nexti;\n"
}