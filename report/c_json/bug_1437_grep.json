{
    "Project": "grep",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L2",
    "file": "src/dfa.c",
    "message": "Offset: [0, 255] Size: 8 by call to `setbit`.",
    "warning_function_name": "dfastate",
    "warning_line": "setbit (d->tokens[pos.index], matches);",
    "warning_context": "void\ndfastate (state_num s, struct dfa *d, state_num trans[])\n{\n  leaf_set grps[NOTCHAR];       /* As many as will ever be needed.  */\n  charclass labels[NOTCHAR];    /* Labels corresponding to the groups.  */\n  size_t ngrps = 0;             /* Number of groups actually used.  */\n  position pos;                 /* Current position being considered.  */\n  charclass matches;            /* Set of matching characters.  */\n  charclass_word matchesf;\t/* Nonzero if matches is nonempty.  */\n  charclass intersect;          /* Intersection with some label set.  */\n  charclass_word intersectf;\t/* Nonzero if intersect is nonempty.  */\n  charclass leftovers;          /* Stuff in the label that didn't match.  */\n  charclass_word leftoversf;\t/* Nonzero if leftovers is nonempty.  */\n  position_set follows;         /* Union of the follows of some group.  */\n  position_set tmp;             /* Temporary space for merging sets.  */\n  int possible_contexts;        /* Contexts that this group can match.  */\n  int separate_contexts;        /* Context that new state wants to know.  */\n  state_num state;              /* New state.  */\n  state_num state_newline;      /* New state on a newline transition.  */\n  state_num state_letter;       /* New state on a letter transition.  */\n  bool next_isnt_1st_byte = false; /* We can't add state0.  */\n  size_t i, j, k;\n\n  zeroset (matches);\n\n  for (i = 0; i < d->states[s].elems.nelem; ++i)\n    {\n      pos = d->states[s].elems.elems[i];\n      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)\n        setbit (d->tokens[pos.index], matches);\n      else if (d->tokens[pos.index] >= CSET)\n        copyset (d->charclasses[d->tokens[pos.index] - CSET], matches);\n      else\n        {\n          if (d->tokens[pos.index] == MBCSET\n              || d->tokens[pos.index] == ANYCHAR)\n            {\n              /* MB_CUR_MAX > 1 */\n              if (d->tokens[pos.index] == MBCSET)\n                d->states[s].has_mbcset = true;\n              /* ANYCHAR and MBCSET must match with a single character, so we\n                 must put it to d->states[s].mbps, which contains the positions\n                 which can match with a single character not a byte.  */\n              if (d->states[s].mbps.nelem == 0)\n                alloc_position_set (&d->states[s].mbps, 1);\n              insert (pos, &(d->states[s].mbps));\n            }\n          continue;\n        }\n\n      /* Some characters may need to be eliminated from matches because\n         they fail in the current context.  */\n      if (pos.constraint != NO_CONSTRAINT)\n        {\n          if (!SUCCEEDS_IN_CONTEXT (pos.constraint,\n                                    d->states[s].context, CTX_NEWLINE))\n            for (j = 0; j < CHARCLASS_WORDS; ++j)\n              matches[j] &= ~newline[j];\n          if (!SUCCEEDS_IN_CONTEXT (pos.constraint,\n                                    d->states[s].context, CTX_LETTER))\n            for (j = 0; j < CHARCLASS_WORDS; ++j)\n              matches[j] &= ~letters[j];\n          if (!SUCCEEDS_IN_CONTEXT (pos.constraint,\n                                    d->states[s].context, CTX_NONE))\n            for (j = 0; j < CHARCLASS_WORDS; ++j)\n              matches[j] &= letters[j] | newline[j];\n\n          /* If there are no characters left, there's no point in going on.  */\n          for (j = 0; j < CHARCLASS_WORDS && !matches[j]; ++j)\n            continue;\n          if (j == CHARCLASS_WORDS)\n            continue;\n        }\n\n      for (j = 0; j < ngrps; ++j)\n        {\n          /* If matches contains a single character only, and the current\n             group's label doesn't contain that character, go on to the\n             next group.  */\n          if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR\n              && !tstbit (d->tokens[pos.index], labels[j]))\n            continue;\n\n          /* Check if this group's label has a nonempty intersection with\n             matches.  */\n          intersectf = 0;\n          for (k = 0; k < CHARCLASS_WORDS; ++k)\n            intersectf |= intersect[k] = matches[k] & labels[j][k];\n          if (!intersectf)\n            continue;\n\n          /* It does; now find the set differences both ways.  */\n          leftoversf = matchesf = 0;\n          for (k = 0; k < CHARCLASS_WORDS; ++k)\n            {\n              /* Even an optimizing compiler can't know this for sure.  */\n              charclass_word match = matches[k], label = labels[j][k];\n\n              leftoversf |= leftovers[k] = ~match & label;\n              matchesf |= matches[k] = match & ~label;\n            }\n"
}