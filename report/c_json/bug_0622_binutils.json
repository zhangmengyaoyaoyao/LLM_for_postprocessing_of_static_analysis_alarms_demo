{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Message": "Offset: [29, 30] (⇐ [7, 8] + 22) Size: 23 by call to `_bfd_generic_link_add_one_symbol`.",
    "Code_line": "      if (! (_bfd_generic_link_add_one_symbol",
    "Code_function": "linux_add_one_symbol (struct bfd_link_info *info,\n\t\t      bfd *abfd,\n\t\t      const char *name,\n\t\t      flagword flags,\n\t\t      asection *section,\n\t\t      bfd_vma value,\n\t\t      const char *string,\n\t\t      bfd_boolean copy,\n\t\t      bfd_boolean collect,\n\t\t      struct bfd_link_hash_entry **hashp)\n{\n  struct linux_link_hash_entry *h;\n  bfd_boolean insert;\n\n  /* Look up and see if we already have this symbol in the hash table.\n     If we do, and the defining entry is from a shared library, we\n     need to create the dynamic sections.\n\n     FIXME: What if abfd->xvec != info->output_bfd->xvec?  We may\n     want to be able to link Linux a.out and ELF objects together,\n     but serious confusion is possible.  */\n\n  insert = FALSE;\n\n  if (! info->relocatable\n      && linux_hash_table (info)->dynobj == NULL\n      && strcmp (name, SHARABLE_CONFLICTS) == 0\n      && (flags & BSF_CONSTRUCTOR) != 0\n      && abfd->xvec == info->output_bfd->xvec)\n    {\n      if (! linux_link_create_dynamic_sections (abfd, info))\n\treturn FALSE;\n      linux_hash_table (info)->dynobj = abfd;\n      insert = TRUE;\n    }\n\n  if (bfd_is_abs_section (section)\n      && abfd->xvec == info->output_bfd->xvec)\n    {\n      h = linux_link_hash_lookup (linux_hash_table (info), name, FALSE,\n\t\t\t\t  FALSE, FALSE);\n      if (h != NULL\n\t  && (h->root.root.type == bfd_link_hash_defined\n\t      || h->root.root.type == bfd_link_hash_defweak))\n\t{\n\t  struct fixup *f;\n\n\t  if (hashp != NULL)\n\t    *hashp = (struct bfd_link_hash_entry *) h;\n\n\t  f = new_fixup (info, h, value, ! IS_PLT_SYM (name));\n\t  if (f == NULL)\n\t    return FALSE;\n\t  f->jump = IS_PLT_SYM (name);\n\n\t  return TRUE;\n\t}\n    }\n\n  /* Do the usual procedure for adding a symbol.  */\n  if (! _bfd_generic_link_add_one_symbol (info, abfd, name, flags, section,\n\t\t\t\t\t  value, string, copy, collect,\n\t\t\t\t\t  hashp))\n    return FALSE;\n\n  /* Insert a pointer to our table in the set vector.  The dynamic\n     linker requires this information */\n  if (insert)\n    {\n      asection *s;\n\n      /* Here we do our special thing to add the pointer to the\n\t dynamic section in the SHARABLE_CONFLICTS set vector.  */\n      s = bfd_get_section_by_name (linux_hash_table (info)->dynobj,\n\t\t\t\t   \".linux-dynamic\");\n      BFD_ASSERT (s != NULL);\n\n      if (! (_bfd_generic_link_add_one_symbol\n\t     (info, linux_hash_table (info)->dynobj, SHARABLE_CONFLICTS,\n\t      BSF_GLOBAL | BSF_CONSTRUCTOR, s, (bfd_vma) 0, NULL,\n\t      FALSE, FALSE, NULL)))\n\treturn FALSE;\n    }\n\n  return TRUE;\n}"
}