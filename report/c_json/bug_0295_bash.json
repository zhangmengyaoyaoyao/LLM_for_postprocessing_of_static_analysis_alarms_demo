{
    "project": "bash",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L1",
    "file": "subst.c",
    "message": "Offset: 2 Size: 2 by call to `extract_delimited_string`.",
    "warning_function_name": "skip_matched_pair",
    "warning_line": "temp = extract_delimited_string (ss, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND); /* ) */",
    "warning_context": "static int\nskip_matched_pair (string, start, open, close, flags)\n     const char *string;\n     int start, open, close, flags;\n{\n  int i, pass_next, backq, si, c, count;\n  size_t slen;\n  char *temp, *ss;\n  DECLARE_MBSTATE;\n\n  slen = strlen (string + start) + start;\n  no_longjmp_on_fatal_error = 1;\n\n  i = start + 1;\t\t/* skip over leading bracket */\n  count = 1;\n  pass_next = backq = 0;\n  ss = (char *)string;\n  while (c = string[i])\n    {\n      if (pass_next)\n\t{\n\t  pass_next = 0;\n\t  if (c == 0)\n\t    CQ_RETURN(i);\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if (c == '\\\\')\n\t{\n\t  pass_next = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if (backq)\n\t{\n\t  if (c == '`')\n\t    backq = 0;\n\t  ADVANCE_CHAR (string, slen, i);\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && c == '`')\n\t{\n\t  backq = 1;\n\t  i++;\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && c == open)\n\t{\n\t  count++;\n\t  i++;\n\t  continue;\n\t}\n      else if (c == close)\n\t{\n\t  count--;\n\t  if (count == 0)\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else if ((flags & 1) == 0 && (c == '\\'' || c == '\"'))\n\t{\n\t  i = (c == '\\'') ? skip_single_quoted (ss, slen, ++i)\n\t\t\t  : skip_double_quoted (ss, slen, ++i);\n\t  /* no increment, the skip functions increment past the closing quote. */\n\t}\n      else if ((flags&1) == 0 && c == '$' && (string[i+1] == LPAREN || string[i+1] == LBRACE))\n\t{\n\t  si = i + 2;\n\t  if (string[si] == '\\0')\n\t    CQ_RETURN(si);\n\n\t  if (string[i+1] == LPAREN)\n\t    temp = extract_delimited_string (ss, &si, \"$(\", \"(\", \")\", SX_NOALLOC|SX_COMMAND); /* ) */\n\t  else\n\t    temp = extract_dollar_brace_string (ss, &si, 0, SX_NOALLOC);\n\t  i = si;\n\t  if (string[i] == '\\0')\t/* don't increment i past EOS in loop */\n\t    break;\n\t  i++;\n\t  continue;\n\t}\n      else\n\tADVANCE_CHAR (string, slen, i);\n    }\n\n  CQ_RETURN(i);\n}\n"
}