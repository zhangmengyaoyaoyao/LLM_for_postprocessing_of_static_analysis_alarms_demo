{
    "Project": "apr",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "random/unix/sha2.c",
    "message": "Offset added: 56 Size: [0, +oo].",
    "warning_function_name": "apr__SHA256_Final",
    "warning_line": "MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);",
    "warning_context": "void apr__SHA256_Final(sha2_byte digest[], SHA256_CTX* context) {\n        sha2_word32     *d = (sha2_word32*)digest;\n        unsigned int    usedspace;\n\n        /* Sanity check: */\n        assert(context != (SHA256_CTX*)0);\n\n        /* If no digest buffer is passed, we don't bother doing this: */\n        if (digest != (sha2_byte*)0) {\n                usedspace = (unsigned int)((context->bitcount >> 3) \n                                         % SHA256_BLOCK_LENGTH);\n#if !APR_IS_BIGENDIAN\n                /* Convert FROM host byte order */\n                REVERSE64(context->bitcount,context->bitcount);\n#endif\n                if (usedspace > 0) {\n                        /* Begin padding with a 1 bit: */\n                        context->buffer[usedspace++] = 0x80;\n\n                        if (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {\n                                /* Set-up for the last transform: */\n                                MEMSET_BZERO(&context->buffer[usedspace], SHA256_SHORT_BLOCK_LENGTH - usedspace);\n                        } else {\n                                if (usedspace < SHA256_BLOCK_LENGTH) {\n                                        MEMSET_BZERO(&context->buffer[usedspace], SHA256_BLOCK_LENGTH - usedspace);\n                                }\n                                /* Do second-to-last transform: */\n                                apr__SHA256_Transform(context, (sha2_word32*)context->buffer);\n\n                                /* And set-up for the last transform: */\n                                MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);\n                        }\n                } else {\n                        /* Set-up for the last transform: */\n                        MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);\n\n                        /* Begin padding with a 1 bit: */\n                        *context->buffer = 0x80;\n                }\n                /* Set the bit count: */\n                {\n                        union dummy {\n                                apr_uint64_t bitcount;\n                                apr_byte_t bytes[8];\n                        } bitcount;\n                        bitcount.bitcount = context->bitcount;\n                        MEMCPY_BCOPY(&context->buffer[SHA256_SHORT_BLOCK_LENGTH], bitcount.bytes, 8);\n                }\n\n                /* Final transform: */\n                apr__SHA256_Transform(context, (sha2_word32*)context->buffer);\n\n#if !APR_IS_BIGENDIAN\n                {\n                        /* Convert TO host byte order */\n                        int     j;\n                        for (j = 0; j < 8; j++) {\n                                REVERSE32(context->state[j],context->state[j]);\n                                *d++ = context->state[j];\n                        }\n                }\n#else\n                MEMCPY_BCOPY(d, context->state, SHA256_DIGEST_LENGTH);\n#endif\n        }\n\n        /* Clean up state data: */\n        MEMSET_BZERO(context, sizeof(*context));\n        usedspace = 0;\n}\n"
}