{
    "project": "RIOT",
    "tool": "Cppcheck",
    "category": "Null Pointer Dereference",
    "file": "core/clist.c",
    "message": "Possible null pointer dereference: tail",
    "warning_function_name": "clist_sort(",
    "warning_line": "tail->next = list;",
    "warning_context": "\n    insize = 1;\n\n    while (1) {\n        clist_node_t *tail = NULL;\n        clist_node_t *oldhead = list;\n        p = list;\n        list = NULL;\n\n        int nmerges = 0;  /* count number of merges we do in this pass */\n\n        while (p) {\n            nmerges++;  /* there exists a merge to be done */\n            /* step `insize' places along from p */\n            q = p;\n            psize = 0;\n            for (i = 0; i < insize; i++) {\n                psize++;\n                q = (q->next == oldhead) ? NULL : q->next;\n                /* cppcheck-suppress nullPointer\n                 * (reason: possible bug in cppcheck 1.6x) */\n                if (!q) {\n                    break;\n                }\n            }\n\n            /* if q hasn't fallen off end, we have two lists to merge */\n            qsize = insize;\n\n            /* now we have two lists; merge them */\n            while (psize > 0 || (qsize > 0 && q)) {\n\n                /* decide whether next element of merge comes from p or q */\n                if (psize == 0) {\n                    /* p is empty; e must come from q. */\n                    e = q; q = q->next; qsize--;\n                    if (q == oldhead) {\n                        q = NULL;\n                    }\n                }\n                else if (qsize == 0 || !q) {\n                    /* q is empty; e must come from p. */\n                    e = p; p = p->next; psize--;\n                    if (p == oldhead) {\n                        p = NULL;\n                    }\n                }\n                else if (cmp(p, q) <= 0) {\n                    /* First element of p is lower (or same);\n                     * e must come from p. */\n                    e = p; p = p->next; psize--;\n                    if (p == oldhead) {\n                        p = NULL;\n                    }\n                }\n                else {\n                    /* First element of q is lower; e must come from q. */\n                    e = q; q = q->next; qsize--;\n                    if (q == oldhead) {\n                        q = NULL;\n                    }\n                }\n\n                /* add the next element to the merged list */\n                if (tail) {\n                    tail->next = e;\n                }\n                else {\n                    list = e;\n                }\n                tail = e;\n            }\n\n            /* now p has stepped `insize' places along, and q has too */\n            p = q;\n        }\n\n        /* cppcheck-suppress nullPointer\n         * (reason: tail cannot be NULL at this point, because list != NULL) */\n        tail->next = list;\n\n        /* If we have done only one merge, we're finished. */\n        if (nmerges <= 1) { /* allow for nmerges==0, the empty list case */\n            return tail;\n        }\n\n        /* Otherwise repeat, merging lists twice the size */\n        insize *= 2;\n    }\n}\n"
}