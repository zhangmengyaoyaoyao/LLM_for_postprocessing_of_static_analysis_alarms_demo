{
    "project": "binutils",
    "tool": "Infer",
    "category": "BUFFER_OVERRUN_L3",
    "file": "bfd/elf32-i386.c",
    "message": "Offset: [-218, 33] Size: 34 by call to `elf_i386_tls_transition`.",
    "warning_function_name": "elf_i386_check_relocs",
    "warning_line": "if (! elf_i386_tls_transition (info, abfd, sec, NULL,",
    "warning_context": "      unsigned long r_symndx;\n      struct elf_link_hash_entry *h;\n      Elf_Internal_Sym *isym;\n      const char *name;\n      bfd_boolean size_reloc;\n\n      r_symndx = ELF32_R_SYM (rel->r_info);\n      r_type = ELF32_R_TYPE (rel->r_info);\n\n      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))\n\t{\n\t  (*_bfd_error_handler) (_(\"%B: bad symbol index: %d\"),\n\t\t\t\t abfd,\n\t\t\t\t r_symndx);\n\t  return FALSE;\n\t}\n\n      if (r_symndx < symtab_hdr->sh_info)\n\t{\n\t  /* A local symbol.  */\n\t  isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n\t\t\t\t\tabfd, r_symndx);\n\t  if (isym == NULL)\n\t    return FALSE;\n\n\t  /* Check relocation against local STT_GNU_IFUNC symbol.  */\n\t  if (ELF32_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)\n\t    {\n\t      h = elf_i386_get_local_sym_hash (htab, abfd, rel, TRUE);\n\t      if (h == NULL)\n\t\treturn FALSE;\n\n\t      /* Fake a STT_GNU_IFUNC symbol.  */\n\t      h->type = STT_GNU_IFUNC;\n\t      h->def_regular = 1;\n\t      h->ref_regular = 1;\n\t      h->forced_local = 1;\n\t      h->root.type = bfd_link_hash_defined;\n\t    }\n\t  else\n\t    h = NULL;\n\t}\n      else\n\t{\n\t  isym = NULL;\n\t  h = sym_hashes[r_symndx - symtab_hdr->sh_info];\n\t  while (h->root.type == bfd_link_hash_indirect\n\t\t || h->root.type == bfd_link_hash_warning)\n\t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n\t}\n\n      if (h != NULL)\n\t{\n\t  /* Create the ifunc sections for static executables.  If we\n\t     never see an indirect function symbol nor we are building\n\t     a static executable, those sections will be empty and\n\t     won't appear in output.  */\n\t  switch (r_type)\n\t    {\n\t    default:\n\t      break;\n\n\t    case R_386_32:\n\t    case R_386_PC32:\n\t    case R_386_PLT32:\n\t    case R_386_GOT32:\n\t    case R_386_GOTOFF:\n\t      if (htab->elf.dynobj == NULL)\n\t\thtab->elf.dynobj = abfd;\n\t      if (!_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))\n\t\treturn FALSE;\n\t      break;\n\t    }\n\n\t  /* It is referenced by a non-shared object. */\n\t  h->ref_regular = 1;\n\t  h->root.non_ir_ref = 1;\n\t}\n\n      if (! elf_i386_tls_transition (info, abfd, sec, NULL,\n\t\t\t\t     symtab_hdr, sym_hashes,\n\t\t\t\t     &r_type, GOT_UNKNOWN,\n\t\t\t\t     rel, rel_end, h, r_symndx))\n\treturn FALSE;\n\n      switch (r_type)\n\t{\n\tcase R_386_TLS_LDM:\n\t  htab->tls_ldm_got.refcount += 1;\n\t  goto create_got;\n\n\tcase R_386_PLT32:\n\t  /* This symbol requires a procedure linkage table entry.  We\n\t     actually build the entry in adjust_dynamic_symbol,\n\t     because this might be a case of linking PIC code which is\n\t     never referenced by a dynamic object, in which case we\n\t     don't need to generate a procedure linkage table entry\n\t     after all.  */\n\n\t  /* If this is a local symbol, we resolve it directly without\n\t     creating a procedure linkage table entry.  */\n"
}