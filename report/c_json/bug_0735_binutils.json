{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Message": "Offset added: [-20, 219] (â‡ [-108, 131] + 88) Size: 4064 by call to `bfd_zalloc`.",
    "Code_line": "      info = (struct stab_find_info *) bfd_zalloc (abfd, amt);",
    "Code_function": "_bfd_stab_section_find_nearest_line (bfd *abfd,\n\t\t\t\t     asymbol **symbols,\n\t\t\t\t     asection *section,\n\t\t\t\t     bfd_vma offset,\n\t\t\t\t     bfd_boolean *pfound,\n\t\t\t\t     const char **pfilename,\n\t\t\t\t     const char **pfnname,\n\t\t\t\t     unsigned int *pline,\n\t\t\t\t     void **pinfo)\n{\n  struct stab_find_info *info;\n  bfd_size_type stabsize, strsize;\n  bfd_byte *stab, *str;\n  bfd_byte *nul_fun, *nul_str;\n  bfd_size_type stroff;\n  struct indexentry *indexentry;\n  char *file_name;\n  char *directory_name;\n  bfd_boolean saw_line, saw_func;\n\n  *pfound = FALSE;\n  *pfilename = bfd_get_filename (abfd);\n  *pfnname = NULL;\n  *pline = 0;\n\n  /* Stabs entries use a 12 byte format:\n       4 byte string table index\n       1 byte stab type\n       1 byte stab other field\n       2 byte stab desc field\n       4 byte stab value\n     FIXME: This will have to change for a 64 bit object format.\n\n     The stabs symbols are divided into compilation units.  For the\n     first entry in each unit, the type of 0, the value is the length\n     of the string table for this unit, and the desc field is the\n     number of stabs symbols for this unit.  */\n\n#define STRDXOFF (0)\n#define TYPEOFF (4)\n#define OTHEROFF (5)\n#define DESCOFF (6)\n#define VALOFF (8)\n#define STABSIZE (12)\n\n  info = (struct stab_find_info *) *pinfo;\n  if (info != NULL)\n    {\n      if (info->stabsec == NULL || info->strsec == NULL)\n\t{\n\t  /* No stabs debugging information.  */\n\t  return TRUE;\n\t}\n\n      stabsize = (info->stabsec->rawsize\n\t\t  ? info->stabsec->rawsize\n\t\t  : info->stabsec->size);\n      strsize = (info->strsec->rawsize\n\t\t ? info->strsec->rawsize\n\t\t : info->strsec->size);\n    }\n  else\n    {\n      long reloc_size, reloc_count;\n      arelent **reloc_vector;\n      int i;\n      char *function_name;\n      bfd_size_type amt = sizeof *info;\n\n      info = (struct stab_find_info *) bfd_zalloc (abfd, amt);\n      if (info == NULL)\n\treturn FALSE;\n\n      /* FIXME: When using the linker --split-by-file or\n\t --split-by-reloc options, it is possible for the .stab and\n\t .stabstr sections to be split.  We should handle that.  */\n\n      info->stabsec = bfd_get_section_by_name (abfd, \".stab\");\n      info->strsec = bfd_get_section_by_name (abfd, \".stabstr\");\n\n      if (info->stabsec == NULL || info->strsec == NULL)\n\t{\n\t  /* Try SOM section names.  */\n\t  info->stabsec = bfd_get_section_by_name (abfd, \"$GDB_SYMBOLS$\");\n\t  info->strsec  = bfd_get_section_by_name (abfd, \"$GDB_STRINGS$\");\n\n\t  if (info->stabsec == NULL || info->strsec == NULL)\n\t    {\n\t      /* No stabs debugging information.  Set *pinfo so that we\n\t\t can return quickly in the info != NULL case above.  */\n\t      *pinfo = info;\n\t      return TRUE;\n\t    }\n\t}\n\n      stabsize = (info->stabsec->rawsize\n\t\t  ? info->stabsec->rawsize\n\t\t  : info->stabsec->size);\n      stabsize = (stabsize / STABSIZE) * STABSIZE;\n      strsize = (info->strsec->rawsize\n\t\t ? info->strsec->rawsize\n\t\t : info->strsec->size);\n\n      info->stabs = (bfd_byte *) bfd_alloc (abfd, stabsize);\n      info->strs = (bfd_byte *) bfd_alloc (abfd, strsize);\n      if (info->stabs == NULL || info->strs == NULL)\n\treturn FALSE;\n\n      if (! bfd_get_section_contents (abfd, info->stabsec, info->stabs,\n\t\t\t\t      0, stabsize)\n\t  || ! bfd_get_section_contents (abfd, info->strsec, info->strs,\n\t\t\t\t\t 0, strsize))\n\treturn FALSE;\n\n      /* If this is a relocatable object file, we have to relocate\n\t the entries in .stab.  This should always be simple 32 bit\n\t relocations against symbols defined in this object file, so\n\t this should be no big deal.  */\n      reloc_size = bfd_get_reloc_upper_bound (abfd, info->stabsec);\n      if (reloc_size < 0)\n\treturn FALSE;\n      reloc_vector = (arelent **) bfd_malloc (reloc_size);\n      if (reloc_vector == NULL && reloc_size != 0)\n\treturn FALSE;\n      reloc_count = bfd_canonicalize_reloc (abfd, info->stabsec, reloc_vector,\n\t\t\t\t\t    symbols);\n      if (reloc_count < 0)\n\t{\n\t  if (reloc_vector != NULL)\n\t    free (reloc_vector);\n\t  return FALSE;\n\t}\n      if (reloc_count > 0)\n\t{\n\t  arelent **pr;\n\n\t  for (pr = reloc_vector; *pr != NULL; pr++)\n\t    {\n\t      arelent *r;\n\t      unsigned long val;\n\t      asymbol *sym;\n\n\t      r = *pr;\n\t      /* Ignore R_*_NONE relocs.  */\n\t      if (r->howto->dst_mask == 0)\n\t\tcontinue;\n\n\t      if (r->howto->rightshift != 0\n\t\t  || r->howto->size != 2\n\t\t  || r->howto->bitsize != 32\n\t\t  || r->howto->pc_relative\n\t\t  || r->howto->bitpos != 0\n\t\t  || r->howto->dst_mask != 0xffffffff)\n\t\t{\n\t\t  (*_bfd_error_handler)\n\t\t    (_(\"Unsupported .stab relocation\"));\n\t\t  bfd_set_error (bfd_error_invalid_operation);\n\t\t  if (reloc_vector != NULL)\n\t\t    free (reloc_vector);\n\t\t  return FALSE;\n\t\t}\n\n\t      val = bfd_get_32 (abfd, info->stabs + r->address);\n\t      val &= r->howto->src_mask;\n\t      sym = *r->sym_ptr_ptr;\n\t      val += sym->value + sym->section->vma + r->addend;\n\t      bfd_put_32 (abfd, (bfd_vma) val, info->stabs + r->address);\n\t    }\n\t}\n\n      if (reloc_vector != NULL)\n\tfree (reloc_vector);\n\n      /* First time through this function, build a table matching\n\t function VM addresses to stabs, then sort based on starting\n\t VM address.  Do this in two passes: once to count how many\n\t table entries we'll need, and a second to actually build the\n\t table.  */\n\n      info->indextablesize = 0;\n      nul_fun = NULL;\n      for (stab = info->stabs; stab < info->stabs + stabsize; stab += STABSIZE)\n\t{\n\t  if (stab[TYPEOFF] == (bfd_byte) N_SO)\n\t    {\n\t      /* if we did not see a function def, leave space for one.  */\n\t      if (nul_fun != NULL)\n\t\t++info->indextablesize;\n\n\t      /* N_SO with null name indicates EOF */\n\t      if (bfd_get_32 (abfd, stab + STRDXOFF) == 0)\n\t\tnul_fun = NULL;\n\t      else\n\t\t{\n\t\t  nul_fun = stab;\n\n\t\t  /* two N_SO's in a row is a filename and directory. Skip */\n\t\t  if (stab + STABSIZE + TYPEOFF < info->stabs + stabsize\n\t\t      && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)\n\t\t    stab += STABSIZE;\n\t\t}\n\t    }\n\t  else if (stab[TYPEOFF] == (bfd_byte) N_FUN\n\t\t   && bfd_get_32 (abfd, stab + STRDXOFF) != 0)\n\t    {\n\t      nul_fun = NULL;\n\t      ++info->indextablesize;\n\t    }\n\t}\n\n      if (nul_fun != NULL)\n\t++info->indextablesize;\n\n      if (info->indextablesize == 0)\n\treturn TRUE;\n      ++info->indextablesize;\n\n      amt = info->indextablesize;\n      amt *= sizeof (struct indexentry);\n      info->indextable = (struct indexentry *) bfd_alloc (abfd, amt);\n      if (info->indextable == NULL)\n\treturn FALSE;\n\n      file_name = NULL;\n      directory_name = NULL;\n      nul_fun = NULL;\n      stroff = 0;\n\n      for (i = 0, stab = info->stabs, nul_str = str = info->strs;\n\t   i < info->indextablesize && stab < info->stabs + stabsize;\n\t   stab += STABSIZE)\n\t{\n\t  switch (stab[TYPEOFF])\n\t    {\n\t    case 0:\n\t      /* This is the first entry in a compilation unit.  */\n\t      if ((bfd_size_type) ((info->strs + strsize) - str) < stroff)\n\t\tbreak;\n\t      str += stroff;\n\t      stroff = bfd_get_32 (abfd, stab + VALOFF);\n\t      break;\n\n\t    case N_SO:\n\t      /* The main file name.  */\n\n\t      /* The following code creates a new indextable entry with\n\t         a NULL function name if there were no N_FUNs in a file.\n\t         Note that a N_SO without a file name is an EOF and\n\t         there could be 2 N_SO following it with the new filename\n\t         and directory.  */\n\t      if (nul_fun != NULL)\n\t\t{\n\t\t  info->indextable[i].val = bfd_get_32 (abfd, nul_fun + VALOFF);\n\t\t  info->indextable[i].stab = nul_fun;\n\t\t  info->indextable[i].str = nul_str;\n\t\t  info->indextable[i].directory_name = directory_name;\n\t\t  info->indextable[i].file_name = file_name;\n\t\t  info->indextable[i].function_name = NULL;\n\t\t  ++i;\n\t\t}\n\n\t      directory_name = NULL;\n\t      file_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);\n\t      if (file_name == (char *) str)\n\t\t{\n\t\t  file_name = NULL;\n\t\t  nul_fun = NULL;\n\t\t}\n\t      else\n\t\t{\n\t\t  nul_fun = stab;\n\t\t  nul_str = str;\n\t\t  if (file_name >= (char *) info->strs + strsize || file_name < (char *) str)\n\t\t    file_name = NULL;\n\t\t  if (stab + STABSIZE + TYPEOFF < info->stabs + stabsize\n\t\t      && *(stab + STABSIZE + TYPEOFF) == (bfd_byte) N_SO)\n\t\t    {\n\t\t      /* Two consecutive N_SOs are a directory and a\n\t\t\t file name.  */\n\t\t      stab += STABSIZE;\n\t\t      directory_name = file_name;\n\t\t      file_name = ((char *) str\n\t\t\t\t   + bfd_get_32 (abfd, stab + STRDXOFF));\n\t\t      if (file_name >= (char *) info->strs + strsize || file_name < (char *) str)\n\t\t\tfile_name = NULL;\n\t\t    }\n\t\t}\n\t      break;\n\n\t    case N_SOL:\n\t      /* The name of an include file.  */\n\t      file_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);\n\t      /* PR 17512: file: 0c680a1f.  */\n\t      /* PR 17512: file: 5da8aec4.  */\n\t      if (file_name >= (char *) info->strs + strsize || file_name < (char *) str)\n\t\tfile_name = NULL;\n\t      break;\n\n\t    case N_FUN:\n\t      /* A function name.  */\n\t      function_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);\n\t      if (function_name == (char *) str)\n\t\tcontinue;\n\t      if (function_name >= (char *) info->strs + strsize)\n\t\tfunction_name = NULL;\n\n\t      nul_fun = NULL;\n\t      info->indextable[i].val = bfd_get_32 (abfd, stab + VALOFF);\n\t      info->indextable[i].stab = stab;\n\t      info->indextable[i].str = str;\n\t      info->indextable[i].directory_name = directory_name;\n\t      info->indextable[i].file_name = file_name;\n\t      info->indextable[i].function_name = function_name;\n\t      ++i;\n\t      break;\n\t    }\n\t}\n\n      if (nul_fun != NULL)\n\t{\n\t  info->indextable[i].val = bfd_get_32 (abfd, nul_fun + VALOFF);\n\t  info->indextable[i].stab = nul_fun;\n\t  info->indextable[i].str = nul_str;\n\t  info->indextable[i].directory_name = directory_name;\n\t  info->indextable[i].file_name = file_name;\n\t  info->indextable[i].function_name = NULL;\n\t  ++i;\n\t}\n\n      info->indextable[i].val = (bfd_vma) -1;\n      info->indextable[i].stab = info->stabs + stabsize;\n      info->indextable[i].str = str;\n      info->indextable[i].directory_name = NULL;\n      info->indextable[i].file_name = NULL;\n      info->indextable[i].function_name = NULL;\n      ++i;\n\n      info->indextablesize = i;\n      qsort (info->indextable, (size_t) i, sizeof (struct indexentry),\n\t     cmpindexentry);\n\n      *pinfo = info;\n    }\n\n  /* We are passed a section relative offset.  The offsets in the\n     stabs information are absolute.  */\n  offset += bfd_get_section_vma (abfd, section);\n\n#ifdef ENABLE_CACHING\n  if (info->cached_indexentry != NULL\n      && offset >= info->cached_offset\n      && offset < (info->cached_indexentry + 1)->val)\n    {\n      stab = info->cached_stab;\n      indexentry = info->cached_indexentry;\n      file_name = info->cached_file_name;\n    }\n  else\n#endif\n    {\n      long low, high;\n      long mid = -1;\n\n      /* Cache non-existent or invalid.  Do binary search on\n         indextable.  */\n      indexentry = NULL;\n\n      low = 0;\n      high = info->indextablesize - 1;\n      while (low != high)\n\t{\n\t  mid = (high + low) / 2;\n\t  if (offset >= info->indextable[mid].val\n\t      && offset < info->indextable[mid + 1].val)\n\t    {\n\t      indexentry = &info->indextable[mid];\n\t      break;\n\t    }\n\n\t  if (info->indextable[mid].val > offset)\n\t    high = mid;\n\t  else\n\t    low = mid + 1;\n\t}\n\n      if (indexentry == NULL)\n\treturn TRUE;\n\n      stab = indexentry->stab + STABSIZE;\n      file_name = indexentry->file_name;\n    }\n\n  directory_name = indexentry->directory_name;\n  str = indexentry->str;\n\n  saw_line = FALSE;\n  saw_func = FALSE;\n  for (; stab < (indexentry+1)->stab; stab += STABSIZE)\n    {\n      bfd_boolean done;\n      bfd_vma val;\n\n      done = FALSE;\n\n      switch (stab[TYPEOFF])\n\t{\n\tcase N_SOL:\n\t  /* The name of an include file.  */\n\t  val = bfd_get_32 (abfd, stab + VALOFF);\n\t  if (val <= offset)\n\t    {\n\t      file_name = (char *) str + bfd_get_32 (abfd, stab + STRDXOFF);\n\t      if (file_name >= (char *) info->strs + strsize || file_name < (char *) str)\n\t\tfile_name = NULL;\n\t      *pline = 0;\n\t    }\n\t  break;\n\n\tcase N_SLINE:\n\tcase N_DSLINE:\n\tcase N_BSLINE:\n\t  /* A line number.  If the function was specified, then the value\n\t     is relative to the start of the function.  Otherwise, the\n\t     value is an absolute address.  */\n\t  val = ((indexentry->function_name ? indexentry->val : 0)\n\t\t + bfd_get_32 (abfd, stab + VALOFF));\n\t  /* If this line starts before our desired offset, or if it's\n\t     the first line we've been able to find, use it.  The\n\t     !saw_line check works around a bug in GCC 2.95.3, which emits\n\t     the first N_SLINE late.  */\n\t  if (!saw_line || val <= offset)\n\t    {\n\t      *pline = bfd_get_16 (abfd, stab + DESCOFF);\n\n#ifdef ENABLE_CACHING\n\t      info->cached_stab = stab;\n\t      info->cached_offset = val;\n\t      info->cached_file_name = file_name;\n\t      info->cached_indexentry = indexentry;\n#endif\n\t    }\n\t  if (val > offset)\n\t    done = TRUE;\n\t  saw_line = TRUE;\n\t  break;\n\n\tcase N_FUN:\n\tcase N_SO:\n\t  if (saw_func || saw_line)\n\t    done = TRUE;\n\t  saw_func = TRUE;\n\t  break;\n\t}\n\n      if (done)\n\tbreak;\n    }\n\n  *pfound = TRUE;\n\n  if (file_name == NULL || IS_ABSOLUTE_PATH (file_name)\n      || directory_name == NULL)\n    *pfilename = file_name;\n  else\n    {\n      size_t dirlen;\n\n      dirlen = strlen (directory_name);\n      if (info->filename == NULL\n\t  || filename_ncmp (info->filename, directory_name, dirlen) != 0\n\t  || filename_cmp (info->filename + dirlen, file_name) != 0)\n\t{\n\t  size_t len;\n\n\t  /* Don't free info->filename here.  objdump and other\n\t     apps keep a copy of a previously returned file name\n\t     pointer.  */\n\t  len = strlen (file_name) + 1;\n\t  info->filename = (char *) bfd_alloc (abfd, dirlen + len);\n\t  if (info->filename == NULL)\n\t    return FALSE;\n\t  memcpy (info->filename, directory_name, dirlen);\n\t  memcpy (info->filename + dirlen, file_name, len);\n\t}\n\n      *pfilename = info->filename;\n    }\n\n  if (indexentry->function_name != NULL)\n    {\n      char *s;\n\n      /* This will typically be something like main:F(0,1), so we want\n         to clobber the colon.  It's OK to change the name, since the\n         string is in our own local storage anyhow.  */\n      s = strchr (indexentry->function_name, ':');\n      if (s != NULL)\n\t*s = '\\0';\n\n      *pfnname = indexentry->function_name;\n    }\n\n  return TRUE;\n}"
}