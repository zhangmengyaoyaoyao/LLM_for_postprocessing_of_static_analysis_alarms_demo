{
    "Project": "tiff",
    "Tool": "Infer",
    "category": "BUFFER_OVERRUN_S2",
    "file": "libtiff/tif_write.c",
    "message": "Offset: `tile` Size: [0, +oo].",
    "warning_function_name": "TIFFWriteEncodedTile",
    "warning_line": "if( td->td_stripbytecount[tile] > 0 )",
    "warning_context": "tsize_t\nTIFFWriteEncodedTile(TIFF* tif, ttile_t tile, tdata_t data, tsize_t cc)\n{\n\tstatic const char module[] = \"TIFFWriteEncodedTile\";\n\tTIFFDirectory *td;\n\ttsample_t sample;\n\n\tif (!WRITECHECKTILES(tif, module))\n\t\treturn ((tsize_t) -1);\n\ttd = &tif->tif_dir;\n\tif (tile >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s: Tile %lu out of range, max %lu\",\n\t\t    tif->tif_name, (unsigned long) tile, (unsigned long) td->td_nstrips);\n\t\treturn ((tsize_t) -1);\n\t}\n\t/*\n\t * Handle delayed allocation of data buffer.  This\n\t * permits it to be sized more intelligently (using\n\t * directory information).\n\t */\n\tif (!BUFFERCHECK(tif))\n\t\treturn ((tsize_t) -1);\n\ttif->tif_curtile = tile;\n\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\n        if( td->td_stripbytecount[tile] > 0 )\n        {\n\t    /* Force TIFFAppendToStrip() to consider placing data at end\n               of file. */\n            tif->tif_curoff = 0;\n        }\n        \n\t/* \n\t * Compute tiles per row & per column to compute\n\t * current row and column\n\t */\n\ttif->tif_row = (tile % TIFFhowmany(td->td_imagelength, td->td_tilelength))\n\t\t* td->td_tilelength;\n\ttif->tif_col = (tile % TIFFhowmany(td->td_imagewidth, td->td_tilewidth))\n\t\t* td->td_tilewidth;\n\n\tif ((tif->tif_flags & TIFF_CODERSETUP) == 0) {\n\t\tif (!(*tif->tif_setupencode)(tif))\n\t\t\treturn ((tsize_t) -1);\n\t\ttif->tif_flags |= TIFF_CODERSETUP;\n\t}\n\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\tsample = (tsample_t)(tile/td->td_stripsperimage);\n\tif (!(*tif->tif_preencode)(tif, sample))\n\t\treturn ((tsize_t) -1);\n\t/*\n\t * Clamp write amount to the tile size.  This is mostly\n\t * done so that callers can pass in some large number\n\t * (e.g. -1) and have the tile size used instead.\n\t */\n\tif ( cc < 1 || cc > tif->tif_tilesize)\n\t\tcc = tif->tif_tilesize;\n\n        /* swab if needed - note that source buffer will be altered */\n        tif->tif_postdecode( tif, (tidata_t) data, cc );\n\n\tif (!(*tif->tif_encodetile)(tif, (tidata_t) data, cc, sample))\n\t\treturn ((tsize_t) 0);\n\tif (!(*tif->tif_postencode)(tif))\n\t\treturn ((tsize_t) -1);\n\tif (!isFillOrder(tif, td->td_fillorder) &&\n\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\tTIFFReverseBits((unsigned char *)tif->tif_rawdata, tif->tif_rawcc);\n\tif (tif->tif_rawcc > 0 && !TIFFAppendToStrip(tif, tile,\n\t    tif->tif_rawdata, tif->tif_rawcc))\n\t\treturn ((tsize_t) -1);\n\ttif->tif_rawcc = 0;\n\ttif->tif_rawcp = tif->tif_rawdata;\n\treturn (cc);\n}\n"
}