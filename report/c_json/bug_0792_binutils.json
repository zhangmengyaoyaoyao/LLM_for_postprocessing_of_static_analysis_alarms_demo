{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L3",
    "Code_line": "\t  || ! append_type (info, \" */\"))",
    "Code_function": "pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n\t\t    enum debug_visibility visibility)\n{\n  struct pr_handle *info = (struct pr_handle *) p;\n  char *t;\n  const char *prefix;\n  char ab[20];\n  char *s, *l, *n;\n\n  assert (info->stack != NULL && info->stack->next != NULL);\n\n  if (! substitute_type (info, \"\"))\n    return FALSE;\n\n  t = pop_type (info);\n  if (t == NULL)\n    return FALSE;\n\n  if (CONST_STRNEQ (t, \"class \"))\n    t += sizeof \"class \" - 1;\n\n  /* Push it back on to take advantage of the prepend_type and\n     append_type routines.  */\n  if (! push_type (info, t))\n    return FALSE;\n\n  if (is_virtual)\n    {\n      if (! prepend_type (info, \"virtual \"))\n\treturn FALSE;\n    }\n\n  switch (visibility)\n    {\n    case DEBUG_VISIBILITY_PUBLIC:\n      prefix = \"public \";\n      break;\n    case DEBUG_VISIBILITY_PROTECTED:\n      prefix = \"protected \";\n      break;\n    case DEBUG_VISIBILITY_PRIVATE:\n      prefix = \"private \";\n      break;\n    default:\n      prefix = \"/* unknown visibility */ \";\n      break;\n    }\n\n  if (! prepend_type (info, prefix))\n    return FALSE;\n\n  if (bitpos != 0)\n    {\n      print_vma (bitpos, ab, TRUE, FALSE);\n      if (! append_type (info, \" /* bitpos \")\n\t  || ! append_type (info, ab)\n\t  || ! append_type (info, \" */\"))\n\treturn FALSE;\n    }\n\n  /* Now the top of the stack is something like \"public A / * bitpos\n     10 * /\".  The next element on the stack is something like \"class\n     xx { / * size 8 * /\\n...\".  We want to substitute the top of the\n     stack in before the {.  */\n  s = strchr (info->stack->next->type, '{');\n  assert (s != NULL);\n  --s;\n\n  /* If there is already a ':', then we already have a baseclass, and\n     we must append this one after a comma.  */\n  for (l = info->stack->next->type; l != s; l++)\n    if (*l == ':')\n      break;\n  if (! prepend_type (info, l == s ? \" : \" : \", \"))\n    return FALSE;\n\n  t = pop_type (info);\n  if (t == NULL)\n    return FALSE;\n\n  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);\n  memcpy (n, info->stack->type, s - info->stack->type);\n  strcpy (n + (s - info->stack->type), t);\n  strcat (n, s);\n\n  free (info->stack->type);\n  info->stack->type = n;\n\n  free (t);\n\n  return TRUE;\n}"
}