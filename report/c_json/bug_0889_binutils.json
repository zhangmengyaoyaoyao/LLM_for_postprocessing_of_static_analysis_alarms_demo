{
    "Project": "binutils",
    "Tool": "Infer",
    "Bug Type": "BUFFER_OVERRUN_L1",
    "Code_line": "\t\t  strncpy (newFileName,",
    "Code_function": "display_debug_lines_decoded (struct dwarf_section *section,\n\t\t\t     unsigned char *data,\n\t\t\t     unsigned char *end)\n{\n  static DWARF2_Internal_LineInfo saved_linfo;\n\n  printf (_(\"Decoded dump of debug contents of section %s:\\n\\n\"),\n\t  section->name);\n\n  while (data < end)\n    {\n      /* This loop amounts to one iteration per compilation unit.  */\n      DWARF2_Internal_LineInfo linfo;\n      unsigned char *standard_opcodes;\n      unsigned char *end_of_sequence;\n      int i;\n      File_Entry *file_table = NULL;\n      unsigned int n_files = 0;\n      unsigned char **directory_table = NULL;\n      unsigned int n_directories = 0;\n\n      if (const_strneq (section->name, \".debug_line.\")\n\t  /* Note: the following does not apply to .debug_line.dwo sections.\n\t     These are full debug_line sections.  */\n\t  && strcmp (section->name, \".debug_line.dwo\") != 0)\n\t{\n\t  /* See comment in display_debug_lines_raw().  */\n\t  end_of_sequence = end;\n\t  standard_opcodes = NULL;\n\t  linfo = saved_linfo;\n\t  /* PR 17531: file: 0522b371.  */\n\t  if (linfo.li_line_range == 0)\n\t    {\n\t      warn (_(\"Partial .debug_line. section encountered without a prior full .debug_line section\\n\"));\n\t      return 0;\n\t    }\n\t  reset_state_machine (linfo.li_default_is_stmt);\n\t}\n      else\n\t{\n\t  unsigned char *hdrptr;\n\n\t  if ((hdrptr = read_debug_line_header (section, data, end, & linfo,\n\t\t\t\t\t\t& end_of_sequence)) == NULL)\n\t      return 0;\n\n\t  /* PR 17531: file: 0522b371.  */\n\t  if (linfo.li_line_range == 0)\n\t    {\n\t      warn (_(\"Line range of 0 is invalid, using 1 instead\\n\"));\n\t      linfo.li_line_range = 1;\n\t    }\n\t  reset_state_machine (linfo.li_default_is_stmt);\n\n\t  /* Save a pointer to the contents of the Opcodes table.  */\n\t  standard_opcodes = hdrptr;\n\n\t  /* Traverse the Directory table just to count entries.  */\n\t  data = standard_opcodes + linfo.li_opcode_base - 1;\n\t  if (*data != 0)\n\t    {\n\t      unsigned char *ptr_directory_table = data;\n\n\t      while (*data != 0)\n\t\t{\n\t\t  data += strnlen ((char *) data, end - data) + 1;\n\t\t  n_directories++;\n\t\t}\n\n\t      /* Go through the directory table again to save the directories.  */\n\t      directory_table = (unsigned char **)\n\t\txmalloc (n_directories * sizeof (unsigned char *));\n\n\t      i = 0;\n\t      while (*ptr_directory_table != 0)\n\t\t{\n\t\t  directory_table[i] = ptr_directory_table;\n\t\t  ptr_directory_table += strnlen ((char *) ptr_directory_table,\n\t\t\t\t\t\t  ptr_directory_table - end) + 1;\n\t\t  i++;\n\t\t}\n\t    }\n\t  /* Skip the NUL at the end of the table.  */\n\t  data++;\n\n\t  /* Traverse the File Name table just to count the entries.  */\n\t  if (*data != 0)\n\t    {\n\t      unsigned char *ptr_file_name_table = data;\n\n\t      while (*data != 0)\n\t\t{\n\t\t  unsigned int bytes_read;\n\n\t\t  /* Skip Name, directory index, last modification time and length\n\t\t     of file.  */\n\t\t  data += strnlen ((char *) data, end - data) + 1;\n\t\t  read_uleb128 (data, & bytes_read, end);\n\t\t  data += bytes_read;\n\t\t  read_uleb128 (data, & bytes_read, end);\n\t\t  data += bytes_read;\n\t\t  read_uleb128 (data, & bytes_read, end);\n\t\t  data += bytes_read;\n\n\t\t  n_files++;\n\t\t}\n\n\t      /* Go through the file table again to save the strings.  */\n\t      file_table = (File_Entry *) xmalloc (n_files * sizeof (File_Entry));\n\n\t      i = 0;\n\t      while (*ptr_file_name_table != 0)\n\t\t{\n\t\t  unsigned int bytes_read;\n\n\t\t  file_table[i].name = ptr_file_name_table;\n\t\t  ptr_file_name_table += strnlen ((char *) ptr_file_name_table,\n\t\t\t\t\t\t  end - ptr_file_name_table) + 1;\n\n\t\t  /* We are not interested in directory, time or size.  */\n\t\t  file_table[i].directory_index = read_uleb128 (ptr_file_name_table,\n\t\t\t\t\t\t\t\t& bytes_read, end);\n\t\t  ptr_file_name_table += bytes_read;\n\t\t  file_table[i].modification_date = read_uleb128 (ptr_file_name_table,\n\t\t\t\t\t\t\t\t  & bytes_read, end);\n\t\t  ptr_file_name_table += bytes_read;\n\t\t  file_table[i].length = read_uleb128 (ptr_file_name_table, & bytes_read, end);\n\t\t  ptr_file_name_table += bytes_read;\n\t\t  i++;\n\t\t}\n\t      i = 0;\n\n\t      /* Print the Compilation Unit's name and a header.  */\n\t      if (directory_table == NULL)\n\t\t{\n\t\t  printf (_(\"CU: %s:\\n\"), file_table[0].name);\n\t\t  printf (_(\"File name                            Line number    Starting address\\n\"));\n\t\t}\n\t      else\n\t\t{\n\t\t  unsigned int ix = file_table[0].directory_index;\n\t\t  const char *directory = ix ? (char *)directory_table[ix - 1] : \".\";\n\n\t\t  if (do_wide || strlen (directory) < 76)\n\t\t    printf (_(\"CU: %s/%s:\\n\"), directory, file_table[0].name);\n\t\t  else\n\t\t    printf (\"%s:\\n\", file_table[0].name);\n\n\t\t  printf (_(\"File name                            Line number    Starting address\\n\"));\n\t\t}\n\t    }\n\n\t  /* Skip the NUL at the end of the table.  */\n\t  data++;\n\n\t  saved_linfo = linfo;\n\t}\n\n      /* This loop iterates through the Dwarf Line Number Program.  */\n      while (data < end_of_sequence)\n\t{\n\t  unsigned char op_code;\n\t  int adv;\n\t  unsigned long int uladv;\n\t  unsigned int bytes_read;\n\t  int is_special_opcode = 0;\n\n\t  op_code = *data++;\n\n\t  if (op_code >= linfo.li_opcode_base)\n\t    {\n\t      op_code -= linfo.li_opcode_base;\n\t      uladv = (op_code / linfo.li_line_range);\n\t      if (linfo.li_max_ops_per_insn == 1)\n\t\t{\n\t\t  uladv *= linfo.li_min_insn_length;\n\t\t  state_machine_regs.address += uladv;\n\t\t}\n\t      else\n\t\t{\n\t\t  state_machine_regs.address\n\t\t    += ((state_machine_regs.op_index + uladv)\n\t\t\t/ linfo.li_max_ops_per_insn)\n\t\t    * linfo.li_min_insn_length;\n\t\t  state_machine_regs.op_index\n\t\t    = (state_machine_regs.op_index + uladv)\n\t\t    % linfo.li_max_ops_per_insn;\n\t\t}\n\n\t      adv = (op_code % linfo.li_line_range) + linfo.li_line_base;\n\t      state_machine_regs.line += adv;\n\t      is_special_opcode = 1;\n\t    }\n\t  else switch (op_code)\n\t\t {\n\t\t case DW_LNS_extended_op:\n\t\t   {\n\t\t     unsigned int ext_op_code_len;\n\t\t     unsigned char ext_op_code;\n\t\t     unsigned char *op_code_data = data;\n\n\t\t     ext_op_code_len = read_uleb128 (op_code_data, &bytes_read,\n\t\t\t\t\t\t     end_of_sequence);\n\t\t     op_code_data += bytes_read;\n\n\t\t     if (ext_op_code_len == 0)\n\t\t       {\n\t\t\t warn (_(\"Badly formed extended line op encountered!\\n\"));\n\t\t\t break;\n\t\t       }\n\t\t     ext_op_code_len += bytes_read;\n\t\t     ext_op_code = *op_code_data++;\n\n\t\t     switch (ext_op_code)\n\t\t       {\n\t\t       case DW_LNE_end_sequence:\n\t\t\t reset_state_machine (linfo.li_default_is_stmt);\n\t\t\t break;\n\t\t       case DW_LNE_set_address:\n\t\t\t SAFE_BYTE_GET_AND_INC (state_machine_regs.address,\n\t\t\t\t\t\top_code_data,\n\t\t\t\t\t\text_op_code_len - bytes_read - 1,\n\t\t\t\t\t\tend);\n\t\t\t state_machine_regs.op_index = 0;\n\t\t\t break;\n\t\t       case DW_LNE_define_file:\n\t\t\t {\n\t\t\t   file_table = (File_Entry *) xrealloc\n\t\t\t     (file_table, (n_files + 1) * sizeof (File_Entry));\n\n\t\t\t   ++state_machine_regs.last_file_entry;\n\t\t\t   /* Source file name.  */\n\t\t\t   file_table[n_files].name = op_code_data;\n\t\t\t   op_code_data += strlen ((char *) op_code_data) + 1;\n\t\t\t   /* Directory index.  */\n\t\t\t   file_table[n_files].directory_index =\n\t\t\t     read_uleb128 (op_code_data, & bytes_read,\n\t\t\t\t\t   end_of_sequence);\n\t\t\t   op_code_data += bytes_read;\n\t\t\t   /* Last modification time.  */\n\t\t\t   file_table[n_files].modification_date =\n\t\t\t     read_uleb128 (op_code_data, & bytes_read,\n\t\t\t\t\t   end_of_sequence);\n\t\t\t   op_code_data += bytes_read;\n\t\t\t   /* File length.  */\n\t\t\t   file_table[n_files].length =\n\t\t\t     read_uleb128 (op_code_data, & bytes_read,\n\t\t\t\t\t   end_of_sequence);\n\n\t\t\t   n_files++;\n\t\t\t   break;\n\t\t\t }\n\t\t       case DW_LNE_set_discriminator:\n\t\t       case DW_LNE_HP_set_sequence:\n\t\t\t /* Simply ignored.  */\n\t\t\t break;\n\n\t\t       default:\n\t\t\t printf (_(\"UNKNOWN (%u): length %d\\n\"),\n\t\t\t\t ext_op_code, ext_op_code_len - bytes_read);\n\t\t\t break;\n\t\t       }\n\t\t     data += ext_op_code_len;\n\t\t     break;\n\t\t   }\n\t\t case DW_LNS_copy:\n\t\t   break;\n\n\t\t case DW_LNS_advance_pc:\n\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n\t\t   data += bytes_read;\n\t\t   if (linfo.li_max_ops_per_insn == 1)\n\t\t     {\n\t\t       uladv *= linfo.li_min_insn_length;\n\t\t       state_machine_regs.address += uladv;\n\t\t     }\n\t\t   else\n\t\t     {\n\t\t       state_machine_regs.address\n\t\t\t += ((state_machine_regs.op_index + uladv)\n\t\t\t     / linfo.li_max_ops_per_insn)\n\t\t\t * linfo.li_min_insn_length;\n\t\t       state_machine_regs.op_index\n\t\t\t = (state_machine_regs.op_index + uladv)\n\t\t\t % linfo.li_max_ops_per_insn;\n\t\t     }\n\t\t   break;\n\n\t\t case DW_LNS_advance_line:\n\t\t   adv = read_sleb128 (data, & bytes_read, end);\n\t\t   data += bytes_read;\n\t\t   state_machine_regs.line += adv;\n\t\t   break;\n\n\t\t case DW_LNS_set_file:\n\t\t   adv = read_uleb128 (data, & bytes_read, end);\n\t\t   data += bytes_read;\n\t\t   state_machine_regs.file = adv;\n\n\t\t   if (file_table == NULL)\n\t\t     printf (_(\"\\n [Use file table entry %d]\\n\"), state_machine_regs.file - 1);\n\t\t   else if (file_table[state_machine_regs.file - 1].directory_index == 0)\n\t\t     /* If directory index is 0, that means current directory.  */\n\t\t     printf (\"\\n./%s:[++]\\n\",\n\t\t\t     file_table[state_machine_regs.file - 1].name);\n\t\t   else if (directory_table == NULL)\n\t\t     printf (_(\"\\n [Use directory table entry %d]\\n\"),\n\t\t\t     file_table[state_machine_regs.file - 1].directory_index - 1);\n\t\t   else\n\t\t     /* The directory index starts counting at 1.  */\n\t\t     printf (\"\\n%s/%s:\\n\",\n\t\t\t     directory_table[file_table[state_machine_regs.file - 1].directory_index - 1],\n\t\t\t     file_table[state_machine_regs.file - 1].name);\n\t\t   break;\n\n\t\t case DW_LNS_set_column:\n\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n\t\t   data += bytes_read;\n\t\t   state_machine_regs.column = uladv;\n\t\t   break;\n\n\t\t case DW_LNS_negate_stmt:\n\t\t   adv = state_machine_regs.is_stmt;\n\t\t   adv = ! adv;\n\t\t   state_machine_regs.is_stmt = adv;\n\t\t   break;\n\n\t\t case DW_LNS_set_basic_block:\n\t\t   state_machine_regs.basic_block = 1;\n\t\t   break;\n\n\t\t case DW_LNS_const_add_pc:\n\t\t   uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);\n\t\t   if (linfo.li_max_ops_per_insn == 1)\n\t\t     {\n\t\t       uladv *= linfo.li_min_insn_length;\n\t\t       state_machine_regs.address += uladv;\n\t\t     }\n\t\t   else\n\t\t     {\n\t\t       state_machine_regs.address\n\t\t\t += ((state_machine_regs.op_index + uladv)\n\t\t\t     / linfo.li_max_ops_per_insn)\n\t\t\t * linfo.li_min_insn_length;\n\t\t       state_machine_regs.op_index\n\t\t\t = (state_machine_regs.op_index + uladv)\n\t\t\t % linfo.li_max_ops_per_insn;\n\t\t     }\n\t\t   break;\n\n\t\t case DW_LNS_fixed_advance_pc:\n\t\t   SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);\n\t\t   state_machine_regs.address += uladv;\n\t\t   state_machine_regs.op_index = 0;\n\t\t   break;\n\n\t\t case DW_LNS_set_prologue_end:\n\t\t   break;\n\n\t\t case DW_LNS_set_epilogue_begin:\n\t\t   break;\n\n\t\t case DW_LNS_set_isa:\n\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n\t\t   data += bytes_read;\n\t\t   printf (_(\"  Set ISA to %lu\\n\"), uladv);\n\t\t   break;\n\n\t\t default:\n\t\t   printf (_(\"  Unknown opcode %d with operands: \"), op_code);\n\n\t\t   if (standard_opcodes != NULL)\n\t\t     for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)\n\t\t       {\n\t\t\t printf (\"0x%s%s\", dwarf_vmatoa (\"x\", read_uleb128 (data,\n\t\t\t\t\t\t\t\t\t    &bytes_read, end)),\n\t\t\t\t i == 1 ? \"\" : \", \");\n\t\t\t data += bytes_read;\n\t\t       }\n\t\t   putchar ('\\n');\n\t\t   break;\n\t\t }\n\n\t  /* Only Special opcodes, DW_LNS_copy and DW_LNE_end_sequence adds a row\n\t     to the DWARF address/line matrix.  */\n\t  if ((is_special_opcode) || (op_code == DW_LNE_end_sequence)\n\t      || (op_code == DW_LNS_copy))\n\t    {\n\t      const unsigned int MAX_FILENAME_LENGTH = 35;\n\t      char *fileName;\n\t      char *newFileName = NULL;\n\t      size_t fileNameLength;\n\n\t      if (file_table)\n\t\tfileName = (char *) file_table[state_machine_regs.file - 1].name;\n\t      else\n\t\tfileName = \"<unknown>\";\n\n\t      fileNameLength = strlen (fileName);\n\n\t      if ((fileNameLength > MAX_FILENAME_LENGTH) && (!do_wide))\n\t\t{\n\t\t  newFileName = (char *) xmalloc (MAX_FILENAME_LENGTH + 1);\n\t\t  /* Truncate file name */\n\t\t  strncpy (newFileName,\n\t\t\t   fileName + fileNameLength - MAX_FILENAME_LENGTH,\n\t\t\t   MAX_FILENAME_LENGTH + 1);\n\t\t}\n\t      else\n\t\t{\n\t\t  newFileName = (char *) xmalloc (fileNameLength + 1);\n\t\t  strncpy (newFileName, fileName, fileNameLength + 1);\n\t\t}\n\n\t      if (!do_wide || (fileNameLength <= MAX_FILENAME_LENGTH))\n\t\t{\n\t\t  if (linfo.li_max_ops_per_insn == 1)\n\t\t    printf (\"%-35s  %11d  %#18\" DWARF_VMA_FMT \"x\\n\",\n\t\t\t    newFileName, state_machine_regs.line,\n\t\t\t    state_machine_regs.address);\n\t\t  else\n\t\t    printf (\"%-35s  %11d  %#18\" DWARF_VMA_FMT \"x[%d]\\n\",\n\t\t\t    newFileName, state_machine_regs.line,\n\t\t\t    state_machine_regs.address,\n\t\t\t    state_machine_regs.op_index);\n\t\t}\n\t      else\n\t\t{\n\t\t  if (linfo.li_max_ops_per_insn == 1)\n\t\t    printf (\"%s  %11d  %#18\" DWARF_VMA_FMT \"x\\n\",\n\t\t\t    newFileName, state_machine_regs.line,\n\t\t\t    state_machine_regs.address);\n\t\t  else\n\t\t    printf (\"%s  %11d  %#18\" DWARF_VMA_FMT \"x[%d]\\n\",\n\t\t\t    newFileName, state_machine_regs.line,\n\t\t\t    state_machine_regs.address,\n\t\t\t    state_machine_regs.op_index);\n\t\t}\n\n\t      if (op_code == DW_LNE_end_sequence)\n\t\tprintf (\"\\n\");\n\n\t      free (newFileName);\n\t    }\n\t}\n\n      if (file_table)\n\t{\n\t  free (file_table);\n\t  file_table = NULL;\n\t  n_files = 0;\n\t}\n\n      if (directory_table)\n\t{\n\t  free (directory_table);\n\t  directory_table = NULL;\n\t  n_directories = 0;\n\t}\n\n      putchar ('\\n');\n    }\n\n  return 1;\n}"
}