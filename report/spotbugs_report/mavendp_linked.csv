category,vtype,final_label,priority,rank,project,no,warning_line,warning_method
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,2,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,3,protected MavenProject project;,protected MavenProject project;
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,4,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,5,public boolean silent;,public boolean silent;
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,6,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,7,"location.mkdirs();
","protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,9,protected File outputFile;,protected File outputFile;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,10,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.getLocal() );
","protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,11,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,FP,2,18,mavendp,12,"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,13,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,14,"model = pomReader.read( new FileReader( project.getFile() ) );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,FP,2,20,mavendp,15,"model = pomReader.read( new FileReader( project.getFile() ) );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,16,private MavenProject project;,private MavenProject project;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,17,"model = pomReader.read( new FileReader( project.getFile() ) );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set duplicateDependencies = new HashSet();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set duplicateDependenciesManagement = new HashSet();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = (String) it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,18,private Renderer siteRenderer;,private Renderer siteRenderer;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,19,"analysis = analyzer.analyze( project );
","public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,20,private File outputDirectory;,private File outputDirectory;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,21,private ProjectDependencyAnalyzer analyzer;,private ProjectDependencyAnalyzer analyzer;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,22,"getLog().info( outputDirectory.toString() );
","protected String getOutputDirectory() {
getLog().info(outputDirectory.toString());
return outputDirectory.toString();
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,23,"if ( ""pom"".equals( project.getPackaging() ) )
","public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,24,private MavenProject project;,private MavenProject project;
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,25,"Writer w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,26,"BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,27,"List artList = new ArrayList( artifacts );
","public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
if (StringUtils.isEmpty(fileSeparator)) {
isFileSepSet = false;
} else {
isFileSepSet = true;
}
if (StringUtils.isEmpty(pathSeparator)) {
isPathSepSet = false;
} else {
isPathSepSet = true;
}
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
String separator = File.separator;
if (File.separator.equals(""\\"")) {
separator = ""\\\\"";
}
cpString = cpString.replaceAll(separator, fileSeparator);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,28,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,29,boolean attach;,boolean attach;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,30,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,31,private File cpFile;,private File cpFile;
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,32,"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private File outputFile;
private boolean regenerateFile;
private String fileSeparator;
private String pathSeparator;
private String localRepoProperty;
boolean attach;
boolean outputFilterFile;
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if (cpFile != null)
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
if ( StringUtils.isEmpty( fileSeparator ) )
{
isFileSepSet = false;
}
else
{
isFileSepSet = true;
}
if ( StringUtils.isEmpty( pathSeparator ) )
{
isPathSepSet = false;
}
else
{
isPathSepSet = true;
}
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List artList = new ArrayList( artifacts );
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( (Artifact) i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
String separator = File.separator;
if ( File.separator.equals( ""\\"" ) )
{
separator = ""\\\\"";
}
cpString = cpString.replaceAll( separator, fileSeparator );
}
if (outputFilterFile)
{
cpString = ""classpath=""+ cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
try
{
Writer w = new BufferedWriter( new FileWriter( out ) );
try
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" +
ex.toString(), ex );
}
finally
{
w.close();
}
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while opening/closing classpath file '"" + out + ""': "" +
ex.toString(), ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
try
{
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
r.close();
}
}
public int compare( Object arg1, Object arg2 )
{
if ( arg1 instanceof Artifact && arg2 instanceof Artifact )
{
if ( arg1 == arg2 )
{
return 0;
}
else if ( arg1 == null )
{
return -1;
}
else if ( arg2 == null )
{
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
else
{
return 0;
}
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,33,"else if ( arg2 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,34,private MavenProjectHelper projectHelper;,private MavenProjectHelper projectHelper;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,35,"projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
","protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,36,"else if ( arg1 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,37,boolean outputFilterFile;,boolean outputFilterFile;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,39,"installer.install( artifact.getFile(), artifact, targetRepository );
","private void installArtifact(Artifact artifact, ArtifactRepository targetRepository) {
try {
if (""pom"".equals(artifact.getType())) {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
} else {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
if (isCopyPom()) {
Artifact pomArtifact = getResolvedPomArtifact(artifact);
if (pomArtifact.getFile() != null && pomArtifact.getFile().exists()) {
installer.install(pomArtifact.getFile(), pomArtifact, targetRepository);
installBaseSnapshot(pomArtifact, targetRepository);
}
}
}
} catch (ArtifactInstallationException e) {
getLog().info(e.getMessage());
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,41,protected ArtifactRepositoryFactory repositoryFactory;,protected ArtifactRepositoryFactory repositoryFactory;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,42,protected ArtifactInstaller installer;,protected ArtifactInstaller installer;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,43,"installer.install( artifact.getFile(), baseArtifact, targetRepository );
","private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,44,"ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(
","public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
copyArtifact((Artifact) i.next(), this.stripVersion);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
installArtifact((Artifact) i.next(), targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set skippedArtifacts = dss.getSkippedDependencies();
for (Iterator i = skippedArtifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,45,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,46,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,47,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,2,17,mavendp,48,"TreeTokens treeTokens = toTreeTokens( tokens );
","private String serialiseDependencyTree(DependencyNode rootNode) {
StringWriter writer = new StringWriter();
TreeTokens treeTokens = toTreeTokens(tokens);
DependencyNodeVisitor visitor = getSerializingDependencyNodeVisitor(writer);
// TODO: remove the need for this when the serializer can calculate last nodes from visitor calls only
visitor = new BuildingDependencyNodeVisitor(visitor);
DependencyNodeFilter filter = createDependencyNodeFilter();
if (filter != null) {
CollectingDependencyNodeVisitor collectingVisitor = new CollectingDependencyNodeVisitor();
DependencyNodeVisitor firstPassVisitor = new FilteringDependencyNodeVisitor(collectingVisitor, filter);
rootNode.accept(firstPassVisitor);
DependencyNodeFilter secondPassFilter = new AncestorOrSelfDependencyNodeFilter(collectingVisitor.getNodes());
visitor = new FilteringDependencyNodeVisitor(visitor, secondPassFilter);
}
rootNode.accept(visitor);
return writer.toString();
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,49,private ArtifactRepositoryFactory artifactRepositoryManager;,private ArtifactRepositoryFactory artifactRepositoryManager;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,50,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,3,11,mavendp,51,"this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(
","protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
if (this.localRepositoryDirectory != null) {
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(super.getLocal().getId(), ""file://"" + this.localRepositoryDirectory.getAbsolutePath(), super.getLocal().getLayout(), super.getLocal().getSnapshots(), super.getLocal().getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
return this.overrideLocalRepository;
}
this.overrideLocalRepository = super.getLocal();
return this.overrideLocalRepository;
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,52,protected boolean outputScope;,protected boolean outputScope;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,53,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,54,private List remotePluginRepositories;,private List remotePluginRepositories;
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,55,"outputWriter = new FileWriter( outputFile );
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Iterator i = plugins.iterator(); i.hasNext(); ) {
Artifact plugin = (Artifact) i.next();
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
Set transitiveDependencies = this.resolveArtifactDependencies(plugin);
for (Iterator transIter = transitiveDependencies.iterator(); transIter.hasNext(); ) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName((Artifact) transIter.next(), false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,56,"outputFile.getParentFile().mkdirs();
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Iterator i = plugins.iterator(); i.hasNext(); ) {
Artifact plugin = (Artifact) i.next();
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
Set transitiveDependencies = this.resolveArtifactDependencies(plugin);
for (Iterator transIter = transitiveDependencies.iterator(); transIter.hasNext(); ) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName((Artifact) transIter.next(), false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,57,"file.getParentFile().mkdirs();
","public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,58,"writer = new FileWriter( file );
","public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,59,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,60,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,61,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,62,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,63,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,64,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,93,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,94,"filter.addFilter( new ProjectTransitivityFilter( project.getDependencyArtifacts(), this.excludeTransitive ) );
","protected DependencyStatusSets getDependencySets(boolean stopOnFailure) throws MojoExecutionException {
FilterArtifacts filter = new FilterArtifacts();
filter.addFilter(new ProjectTransitivityFilter(project.getDependencyArtifacts(), this.excludeTransitive));
filter.addFilter(new ScopeFilter(DependencyUtil.cleanToBeTokenizedString(this.includeScope), DependencyUtil.cleanToBeTokenizedString(this.excludeScope)));
filter.addFilter(new TypeFilter(DependencyUtil.cleanToBeTokenizedString(this.includeTypes), DependencyUtil.cleanToBeTokenizedString(this.excludeTypes)));
filter.addFilter(new ClassifierFilter(DependencyUtil.cleanToBeTokenizedString(this.includeClassifiers), DependencyUtil.cleanToBeTokenizedString(this.excludeClassifiers)));
filter.addFilter(new GroupIdFilter(DependencyUtil.cleanToBeTokenizedString(this.includeGroupIds), DependencyUtil.cleanToBeTokenizedString(this.excludeGroupIds)));
filter.addFilter(new ArtifactIdFilter(DependencyUtil.cleanToBeTokenizedString(this.includeArtifactIds), DependencyUtil.cleanToBeTokenizedString(this.excludeArtifactIds)));
Set<Artifact> artifacts = project.getArtifacts();
try {
artifacts = filter.filter(artifacts);
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
DependencyStatusSets status = null;
if (StringUtils.isNotEmpty(classifier)) {
status = getClassifierTranslatedDependencies(artifacts, stopOnFailure);
} else {
status = filterMarkedDependencies(artifacts);
}
return status;
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,95,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,96,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,97,"location.mkdirs();
","protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,98,protected List<MavenProject> reactorProjects;,protected List<MavenProject> reactorProjects;
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,99,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,100,protected MavenProject project;,protected MavenProject project;
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,101,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,103,protected File outputFile;,protected File outputFile;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,105,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,106,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.getLocal() );
","protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,107,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,111,private File cpFile;,private File cpFile;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,112,"File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
","protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}"
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,113,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,115,"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
","public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,116,boolean attach;,boolean attach;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,117,boolean outputFilterFile;,boolean outputFilterFile;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,118,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,119,"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private File outputFile;
private boolean regenerateFile;
private String fileSeparator;
private String pathSeparator;
private String localRepoProperty;
boolean attach;
boolean outputFilterFile;
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': ""
+ ex.toString(), ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
","protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,120,"projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
","protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,121,private MavenProjectHelper projectHelper;,private MavenProjectHelper projectHelper;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,122,"(ArtifactRepositoryLayout) repositoryLayouts.get( ""default"" ),
","public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,123,protected ArtifactRepositoryFactory repositoryFactory;,protected ArtifactRepositoryFactory repositoryFactory;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,124,protected ArtifactInstaller installer;,protected ArtifactInstaller installer;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,125,"installer.install( artifact.getFile(), artifact, targetRepository );
","private void installArtifact(Artifact artifact, ArtifactRepository targetRepository) {
try {
if (""pom"".equals(artifact.getType())) {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
} else {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
if (isCopyPom()) {
Artifact pomArtifact = getResolvedPomArtifact(artifact);
if (pomArtifact.getFile() != null && pomArtifact.getFile().exists()) {
installer.install(pomArtifact.getFile(), pomArtifact, targetRepository);
installBaseSnapshot(pomArtifact, targetRepository);
}
}
}
} catch (ArtifactInstallationException e) {
getLog().info(e.getMessage());
}
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,126,"installer.install( artifact.getFile(), baseArtifact, targetRepository );
","private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,127,"private Map<String, ArtifactRepositoryLayout> repositoryLayouts;","private Map<String, ArtifactRepositoryLayout> repositoryLayouts;"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,128,"ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(
","public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,129,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,130,"project.getProperties().setProperty( artifact.getDependencyConflictId(),
","public void execute() throws MojoExecutionException {
Set<Artifact> artifacts = getProject().getArtifacts();
for (Artifact artifact : artifacts) {
project.getProperties().setProperty(artifact.getDependencyConflictId(), artifact.getFile().getAbsolutePath());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,131,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,132,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,133,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,136,private ArtifactRepositoryFactory artifactRepositoryManager;,private ArtifactRepositoryFactory artifactRepositoryManager;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,138,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,139,"Set<Artifact> artifacts = project.getArtifacts();
","public void execute() throws MojoExecutionException {
Set<Artifact> artifacts = project.getArtifacts();
if (!silent) {
for (Artifact artifact : artifacts) {
this.getLog().info(""Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false));
}
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,141,protected boolean outputScope;,protected boolean outputScope;
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,142,"outputWriter = new FileWriter( outputFile );
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,144,"outputFile.getParentFile().mkdirs();
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,145,private List remotePluginRepositories;,private List remotePluginRepositories;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,146,private boolean excludeTransitive;,private boolean excludeTransitive;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,147,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,148,"writer = new FileWriter( file, append );
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,149,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,150,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,151,"marker.setLastModified( ts );
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,152,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,153,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,154,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,157,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,158,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,159,protected MavenProject project;,protected MavenProject project;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,160,"location.mkdirs();
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,161,"UnArchiver unArchiver;
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,163,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,164,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,166,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,167,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,168,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
","protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,169,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,170,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,171,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,172,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,173,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,174,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,175,private String groupId;,private String groupId;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,176,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,177,private List remotePluginRepositories;,private List remotePluginRepositories;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,178,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,179,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,180,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,181,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,182,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,183,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,298,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,299,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,300,"location.mkdirs();
","protected void unpack(Artifact artifact, File location, String includes, String excludes) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(artifact.getType());
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
unArchiver.setUseJvmChmod(useJvmChmod);
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,302,"private class SnapshotsFilter
implements ArtifactFilter
{
public boolean include( Artifact artifact )
{
return artifact.isSnapshot();
","public boolean include(Artifact artifact) {
if (artifactsGAMatch(artifact, projectArtifact)) {
return true;
}
for (Artifact depArtifact : directDependencyArtifacts) {
if (this.artifactsGAMatch(artifact, depArtifact)) {
return true;
}
}
return false;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,303,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,304,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,305,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,3,11,mavendp,306,"@Parameter
protected boolean ignorePermissions;","@Parameter
protected boolean ignorePermissions;"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,307,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,309,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,310,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,311,"w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,3,11,mavendp,312,"@Parameter
protected boolean ignorePermissions;","@Parameter
protected boolean ignorePermissions;"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,313,"r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,314,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST,
defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.cpFile"" )
private File cpFile;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
protected boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Parameter
protected boolean useJvmChmod = true;
@Parameter
protected boolean ignorePermissions;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
protected void doExecute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
project.getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
else if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( Exception ex )
{
this.getLog().warn(
""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getOutputProperty()
{
return this.outputProperty;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
","protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
// don't allow them to have absolute paths when they attach.
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
// make the string valid for filtering
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,315,"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
","protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,2,8,mavendp,316,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,317,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,2,8,mavendp,318,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,319,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,320,".mkdirs();
","protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,321,"outputWriter = new FileWriter( outputFile );
","protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
CORRECTNESS,NP_NULL_ON_SOME_PATH,FP,2,8,mavendp,322,"return recommendedVersion.compareTo( theVersion ) <= 0;
","public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,323,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,324,"writer = new FileWriter( file, append );
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,325,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,326,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,327,"marker.setLastModified( ts );
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,328,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,329,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,330,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,331,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,332,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,333,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,334,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,335,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,336,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,337,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,338,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,339,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,340,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,341,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,342,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,343,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,344,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,345,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,346,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,347,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,349,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,350,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,351,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,352,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,353,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,354,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,355,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,356,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,357,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,358,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,359,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,360,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,361,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,362,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,363,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,364,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,365,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,366,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,367,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,368,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,369,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,370,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,371,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,372,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,373,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,374,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,375,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,376,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,377,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,378,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return Objects.equals( cpString, oldCp );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out,
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,379,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,380,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,381,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,382,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,383,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,384,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,385,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,386,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,387,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,388,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,389,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,390,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,391,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,392,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,452,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,453,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,454,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,455,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,456,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,457,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,458,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,459,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,460,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,461,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,462,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,463,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,464,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,465,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,466,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,467,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,468,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,469,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,470,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,471,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,472,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,473,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,474,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,475,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,476,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,477,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,478,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,479,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,480,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,481,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,482,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,483,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,484,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,487,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,488,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,489,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,490,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,491,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,492,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,493,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,494,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,495,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,496,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,497,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,498,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,499,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,500,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,501,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,502,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,503,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,504,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,505,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,506,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,507,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,508,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,510,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,511,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,512,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,513,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,514,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,515,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,516,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,517,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,518,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,519,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,520,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,521,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,522,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,523,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,524,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,525,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,526,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,528,"{
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,531,"location.mkdirs();
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,532,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,533,"{
","public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,534,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,535,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
","protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,536,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,FP,2,18,mavendp,537,"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,2,17,mavendp,538,"ArtifactVersion artifactVersion = new DefaultArtifactVersion( dependencyArtifact.getVersion() );
","public Map getMismatch(Map depMgtMap, Set allDependencyArtifacts) {
Map mismatchMap = new HashMap();
Iterator iter = allDependencyArtifacts.iterator();
while (iter.hasNext()) {
Artifact dependencyArtifact = (Artifact) iter.next();
Dependency depFromDepMgt = (Dependency) depMgtMap.get(getArtifactManagementKey(dependencyArtifact));
if (depFromDepMgt != null) {
ArtifactVersion artifactVersion = new DefaultArtifactVersion(dependencyArtifact.getVersion());
dependencyArtifact.isSnapshot();
if (!depFromDepMgt.getVersion().equals(dependencyArtifact.getBaseVersion())) {
mismatchMap.put(dependencyArtifact, depFromDepMgt);
}
}
}
return mismatchMap;
}"
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,FP,2,11,mavendp,540,"logArtifacts( unusedDeclared, false );
","private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,541,"ProjectDependencyAnalysis analysis = analyzer.analyze( project );
","private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,544,private ProjectDependencyAnalyzer analyzer;,private ProjectDependencyAnalyzer analyzer;
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,FP,2,11,mavendp,545,"logArtifacts( usedUndeclared, true );
","private boolean checkDependencies() throws MojoExecutionException {
boolean result = false;
try {
ProjectDependencyAnalysis analysis = analyzer.analyze(project);
if (this.displayUsed) {
getLog().info(""Used declared dependencies:"");
logArtifacts(analysis.getUsedDeclaredArtifacts(), false);
}
getLog().info(""Used undeclared dependencies:"");
Set usedUndeclared = analysis.getUsedUndeclaredArtifacts();
logArtifacts(usedUndeclared, true);
getLog().info(""Unused declared dependencies:"");
Set unusedDeclared = analysis.getUnusedDeclaredArtifacts();
if (ignoreNonCompile) {
Iterator iter = unusedDeclared.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
if (!artifact.getScope().equals(Artifact.SCOPE_COMPILE)) {
iter.remove();
}
}
}
logArtifacts(unusedDeclared, false);
if (outputXML) {
writeDependencyXML(usedUndeclared);
}
if (scriptableOutput) {
writeScriptableOutput(usedUndeclared);
}
if ((usedUndeclared != null && !usedUndeclared.isEmpty()) || unusedDeclared != null && !unusedDeclared.isEmpty()) {
getLog().warn(""Potential problems discovered."");
result = true;
}
} catch (ProjectDependencyAnalyzerException exception) {
throw new MojoExecutionException(""Cannot analyze dependencies"", exception);
}
return result;
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,546,"if ( ""pom"".equals( project.getPackaging() ) )
","public void execute() throws MojoExecutionException, MojoFailureException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
boolean result = checkDependencies();
if (result && this.failBuild) {
throw new MojoExecutionException(""Found Dependency errors."");
}
AnalyzeDepMgt adm = new AnalyzeDepMgt();
adm.setLog(getLog());
adm.setProject(this.project);
adm.setFailBuild(this.failBuild);
adm.setPluginContext(this.getPluginContext());
adm.setIgnoreDirect(this.ignoreDirect);
adm.execute();
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,547,private MavenProject project;,private MavenProject project;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,548,"if ( !cpFile.isFile() )
","private String readClasspathFile() throws IOException {
if (!cpFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(cpFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,549,"List artList = new ArrayList( artifacts );
","public void execute() throws MojoExecutionException {
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(File.pathSeparatorChar);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (cpFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString);
} else {
this.getLog().info(""Skipped writting classpath file '"" + cpFile + ""'.  No changes found."");
}
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,550,"Writer w = new BufferedWriter( new FileWriter( cpFile ) );
","private void storeClasspathFile(String cpString) throws MojoExecutionException {
try {
Writer w = new BufferedWriter(new FileWriter(cpFile));
try {
w.write(cpString);
getLog().info(""Written classpath file '"" + cpFile + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + cpFile + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + cpFile + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,551,private String prefix;,private String prefix;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,552,private File cpFile;,private File cpFile;
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,553,"BufferedReader r = new BufferedReader( new FileReader( cpFile ) );
","private String readClasspathFile() throws IOException {
if (!cpFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(cpFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}"
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,554,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + cpFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,2,19,mavendp,555,"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private boolean regenerateFile;
public void execute()
throws MojoExecutionException
{
Set artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List artList = new ArrayList( artifacts );
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( (Artifact) i.next(), sb );
while ( i.hasNext() )
{
sb.append(File.pathSeparatorChar);
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( cpFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString );
}
else
{
this.getLog().info( ""Skipped writting classpath file '"" + cpFile + ""'.  No changes found."" );
}
}
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
sb.append( art.getFile() );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separatorChar );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + cpFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString )
throws MojoExecutionException
{
try
{
Writer w = new BufferedWriter( new FileWriter( cpFile ) );
try
{
w.write( cpString );
getLog().info( ""Written classpath file '"" + cpFile + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + cpFile + ""': ""
+ ex.toString(), ex );
}
finally
{
w.close();
}
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while opening/closing classpath file '"" + cpFile + ""': ""
+ ex.toString(), ex );
}
}
private String readClasspathFile()
throws IOException
{
if ( !cpFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader( new FileReader( cpFile ) );
try
{
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
r.close();
}
}
public int compare( Object arg1, Object arg2 )
{
if ( arg1 instanceof Artifact && arg2 instanceof Artifact )
{
if ( arg1 == arg2 )
{
return 0;
}
else if ( arg1 == null )
{
return -1;
}
else if ( arg2 == null )
{
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
else
{
return 0;
}
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,556,"else if ( arg2 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,557,"else if ( arg1 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,558,private boolean regenerateFile;,private boolean regenerateFile;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,559,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,560,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,561,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,562,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}"
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,FP,3,20,mavendp,563,"if ( dependencyManagement != null && dependencyManagement.getDependencies() != null )
{
map = new HashMap();
for ( Iterator i = dependencyManagement.getDependencies().iterator(); i.hasNext(); )
{
Dependency d = (Dependency) i.next();
try
{
VersionRange versionRange = VersionRange.createFromVersionSpec( d.getVersion() );
Artifact artifact = artifactFactory.createDependencyArtifact( d.getGroupId(), d.getArtifactId(),
versionRange, d.getType(), d
.getClassifier(), d.getScope(), d
.isOptional() );
map.put( d.getManagementKey(), artifact );
}
catch ( InvalidVersionSpecificationException e )
{
throw new MojoExecutionException( ""Unable to parse version"", e );
}
}
}
else
{
map = Collections.EMPTY_MAP;
}
return map;
","private Map createManagedVersionMap(ArtifactFactory artifactFactory, String projectId, DependencyManagement dependencyManagement) throws MojoExecutionException {
Map map;
if (dependencyManagement != null && dependencyManagement.getDependencies() != null) {
map = new HashMap();
for (Iterator i = dependencyManagement.getDependencies().iterator(); i.hasNext(); ) {
Dependency d = (Dependency) i.next();
try {
VersionRange versionRange = VersionRange.createFromVersionSpec(d.getVersion());
Artifact artifact = artifactFactory.createDependencyArtifact(d.getGroupId(), d.getArtifactId(), versionRange, d.getType(), d.getClassifier(), d.getScope(), d.isOptional());
map.put(d.getManagementKey(), artifact);
} catch (InvalidVersionSpecificationException e) {
throw new MojoExecutionException(""Unable to parse version"", e);
}
}
} else {
map = Collections.EMPTY_MAP;
}
return map;
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,564,protected boolean outputScope;,protected boolean outputScope;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,565,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,566,private List remotePluginRepositories;,private List remotePluginRepositories;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,567,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,568,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,569,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,570,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,571,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,572,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,663,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,664,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,665,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,666,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,667,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,668,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,669,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,670,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,671,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,672,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,673,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,674,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,675,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,676,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,677,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return Objects.equals( cpString, oldCp );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out,
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,678,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,679,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,680,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,681,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,682,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,683,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,684,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","@Override
protected void doExecute() throws MojoExecutionException {
results = this.getDependencySets(false, includeParents);
String output = getOutput(outputAbsoluteArtifactFilename, outputScope, sort);
try {
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
} catch (IOException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,685,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,686,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,687,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,688,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,689,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,690,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,691,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,692,"UnArchiver unArchiver;
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,693,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,694,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,695,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,697,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,698,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,699,"location.mkdirs();
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,700,"location.mkdirs();
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,701,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,702,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,703,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
","protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,704,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,705,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,706,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,707,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,708,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,709,private String groupId;,private String groupId;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,710,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,711,private List remotePluginRepositories;,private List remotePluginRepositories;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,712,private boolean excludeTransitive;,private boolean excludeTransitive;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,713,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,714,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,715,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,716,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,717,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,718,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,719,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,720,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,721,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,722,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,723,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,724,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,725,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,726,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,727,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,728,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,729,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,730,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,731,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,732,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,733,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,734,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,735,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,737,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,738,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,739,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,740,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,741,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,742,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","@Override
protected void doExecute() throws MojoExecutionException {
results = this.getDependencySets(false, includeParents);
String output = getOutput(outputAbsoluteArtifactFilename, outputScope, sort);
try {
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
} catch (IOException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,743,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,744,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,745,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,746,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,747,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,748,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,749,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,750,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,751,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,785,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,786,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,787,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,788,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,789,"location.mkdirs();
","protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,790,protected List<MavenProject> reactorProjects;,protected List<MavenProject> reactorProjects;
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,791,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,792,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,793,"}
","public void setUseSubDirectoryPerScope(boolean theUseSubDirectoryPerScope) {
this.useSubDirectoryPerScope = theUseSubDirectoryPerScope;
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,794,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.getLocal() );
","protected Set<Artifact> resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.getLocal());
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,795,protected boolean appendOutput;,protected boolean appendOutput;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,797,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,798,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,799,private MavenProject project;,private MavenProject project;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,800,"reader = ReaderFactory.newXmlReader( project.getFile() );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
Reader reader = null;
try {
reader = ReaderFactory.newXmlReader(project.getFile());
model = pomReader.read(reader);
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
} finally {
IOUtil.close(reader);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,801,"w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,802,"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
","public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,803,"r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,804,private MavenProjectHelper projectHelper;,private MavenProjectHelper projectHelper;
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,805,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,806,private File cpFile;,private File cpFile;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,807,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,808,"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private File outputFile;
private boolean regenerateFile;
private String fileSeparator;
private String pathSeparator;
private String localRepoProperty;
boolean attach;
boolean outputFilterFile;
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuffer sb = new StringBuffer();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': ""
+ ex.toString(), ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
",boolean outputFilterFile;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,809,boolean outputFilterFile;,boolean outputFilterFile;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,810,boolean attach;,boolean attach;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,811,"projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
","protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,812,"installer.install( artifact.getFile(), baseArtifact, targetRepository );
","private void installBaseSnapshot(Artifact artifact, ArtifactRepository targetRepository) throws ArtifactInstallationException {
if (artifact.isSnapshot() && !artifact.getBaseVersion().equals(artifact.getVersion())) {
Artifact baseArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getBaseVersion(), artifact.getScope(), artifact.getType());
installer.install(artifact.getFile(), baseArtifact, targetRepository);
}
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,813,"(ArtifactRepositoryLayout) repositoryLayouts.get( ""default"" ),
","public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,814,"installer.install( artifact.getFile(), artifact, targetRepository );
","private void installArtifact(Artifact artifact, ArtifactRepository targetRepository) {
try {
if (""pom"".equals(artifact.getType())) {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
} else {
installer.install(artifact.getFile(), artifact, targetRepository);
installBaseSnapshot(artifact, targetRepository);
if (isCopyPom()) {
Artifact pomArtifact = getResolvedPomArtifact(artifact);
if (pomArtifact.getFile() != null && pomArtifact.getFile().exists()) {
installer.install(pomArtifact.getFile(), pomArtifact, targetRepository);
installBaseSnapshot(pomArtifact, targetRepository);
}
}
}
} catch (ArtifactInstallationException e) {
getLog().info(e.getMessage());
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,815,"private Map<String, ArtifactRepositoryLayout> repositoryLayouts;","private Map<String, ArtifactRepositoryLayout> repositoryLayouts;"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,816,protected ArtifactInstaller installer;,protected ArtifactInstaller installer;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,817,protected ArtifactRepositoryFactory repositoryFactory;,protected ArtifactRepositoryFactory repositoryFactory;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,818,"ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(
","public void execute() throws MojoExecutionException {
DependencyStatusSets dss = getDependencySets(this.failOnMissingClassifierArtifact);
Set<Artifact> artifacts = dss.getResolvedDependencies();
if (!useRepositoryLayout) {
for (Artifact artifact : artifacts) {
copyArtifact(artifact, this.stripVersion, this.prependGroupId);
}
} else {
try {
ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(""local"", outputDirectory.toURL().toExternalForm(), (ArtifactRepositoryLayout) repositoryLayouts.get(""default""), false);
for (Artifact artifact : artifacts) {
installArtifact(artifact, targetRepository);
}
} catch (MalformedURLException e) {
throw new MojoExecutionException(""Could not create outputDirectory repository"", e);
}
}
Set<Artifact> skippedArtifacts = dss.getSkippedDependencies();
for (Artifact artifact : skippedArtifacts) {
getLog().info(artifact.getFile().getName() + "" already exists in destination."");
}
if (isCopyPom()) {
copyPoms(getOutputDirectory(), artifacts, this.stripVersion);
copyPoms(getOutputDirectory(), skippedArtifacts, this.stripVersion);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,819,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,14,mavendp,820,"project.getProperties().setProperty( artifact.getDependencyConflictId(),
","public void execute() throws MojoExecutionException {
@SuppressWarnings(""unchecked"")
Set<Artifact> artifacts = getProject().getArtifacts();
for (Artifact artifact : artifacts) {
project.getProperties().setProperty(artifact.getDependencyConflictId(), artifact.getFile().getAbsolutePath());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,821,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,822,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,FP,3,20,mavendp,823,"{
public boolean include( Artifact artifact )
{
return artifact.isSnapshot();
","private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,824,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> deps_it = deps.entrySet().iterator(); deps_it.hasNext(); ) {
Map.Entry<String, Artifact> dependency = deps_it.next();
Artifact artifact = dependency.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
deps_it.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : deps.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
CORRECTNESS,NP_NULL_ON_SOME_PATH,FP,2,8,mavendp,825,"return recommendedVersion.compareTo( theVersion ) <= 0;
","public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,2,8,mavendp,826,protected List<MavenProject> reactorProjects;,protected List<MavenProject> reactorProjects;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,827,protected List<MavenProject> reactorProjects;,protected List<MavenProject> reactorProjects;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,3,11,mavendp,828,"artifactRepositoryManager.createArtifactRepository( local.getId(), url, local.getLayout(),
","protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
ArtifactRepository local = super.getLocal();
if (this.localRepositoryDirectory != null) {
String url = ""file://"" + this.localRepositoryDirectory.getAbsolutePath();
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(local.getId(), url, local.getLayout(), local.getSnapshots(), local.getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
} else {
this.overrideLocalRepository = local;
}
return this.overrideLocalRepository;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,829,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,830,private ArtifactRepositoryFactory artifactRepositoryManager;,private ArtifactRepositoryFactory artifactRepositoryManager;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,831,protected boolean outputScope;,protected boolean outputScope;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,832,private boolean excludeTransitive;,private boolean excludeTransitive;
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,833,"outputWriter = new FileWriter( outputFile );
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,834,private List<ArtifactRepository> remotePluginRepositories;,private List<ArtifactRepository> remotePluginRepositories;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,835,"outputFile.getParentFile().mkdirs();
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,836,"writer = new FileWriter( file, append );
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,837,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,838,"marker.setLastModified( ts );
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,839,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,840,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,841,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,842,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,843,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,844,"Set<Artifact> results = artifacts;
","public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
CORRECTNESS,UR_UNINIT_READ,FP,2,3,mavendp,916,"if (silent)
","public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,917,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,918,protected boolean useSubDirectoryPerArtifact;,protected boolean useSubDirectoryPerArtifact;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,919,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,920,protected File outputDirectory;,protected File outputDirectory;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,921,protected boolean overWriteReleases;,protected boolean overWriteReleases;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,922,protected boolean overWriteSnapshots;,protected boolean overWriteSnapshots;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,923,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,3,11,mavendp,924,"Iterator iter = artifactItems.iterator();
","protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,925,private ArrayList artifactItems;,private ArrayList artifactItems;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,926,private File markersDirectory;,private File markersDirectory;
PERFORMANCE,UUF_UNUSED_FIELD,FP,2,18,mavendp,927,private File markersDirectory;,private File markersDirectory;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,928,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,929,private String groupId;,private String groupId;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,930,private List remotePluginRepositories;,private List remotePluginRepositories;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,931,private boolean excludeTransitive;,private boolean excludeTransitive;
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,FP,3,20,mavendp,932,"if ( !silent )
{
log.info( """" );
log.info( ""The following files have been resolved: "" );
if ( resolvedArtifacts.isEmpty() )
{
log.info( ""   none"" );
}
else
{
for ( Iterator i = resolvedArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
if ( existingArtifacts != null && !existingArtifacts.isEmpty() )
{
log.info( """" );
log.info( ""The following files where skipped: "" );
for ( Iterator i = existingArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
log.info( """" );
log.info( ""The following files have NOT been resolved: "" );
if ( missingArtifacts.isEmpty() )
{
log.info( ""   none"" );
}
else
{
for ( Iterator i = missingArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
log.info( """" );
}
}
","private static void logResults(Set resolvedArtifacts, Set missingArtifacts, HashSet existingArtifacts, boolean silent, Log log) {
if (!silent) {
log.info("""");
log.info(""The following files have been resolved: "");
if (resolvedArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = resolvedArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
if (existingArtifacts != null && !existingArtifacts.isEmpty()) {
log.info("""");
log.info(""The following files where skipped: "");
for (Iterator i = existingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
log.info(""The following files have NOT been resolved: "");
if (missingArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,933,"markerFile.createNewFile();
","public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,934,"markersDirectory.mkdirs();
","public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}"
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,FP,3,20,mavendp,935,"log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext())
{
Artifact artifact = (Artifact) iter.next();
log.debug(""""+artifact);
}
}
","private void log(Set artifacts, Log log) {
log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
log.debug("""" + artifact);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,936,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,937,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,938,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,939,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,940,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,941,private ArtifactFactory factory;,private ArtifactFactory factory;
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,942,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,943,"Artifact newArtifact = factory.createArtifactWithClassifier( artifact.getGroupId(), artifact
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,944,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,945,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,946,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,947,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,948,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,949,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,950,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,951,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,952,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,953,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,954,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,955,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,956,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,957,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,958,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,959,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,960,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,962,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,963,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,964,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,965,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,966,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,967,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,968,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,969,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,970,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,971,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,972,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,973,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,974,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1036,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1037,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1038,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1039,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1040,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1041,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,1042,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1043,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1044,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1045,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1046,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1047,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1048,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1049,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1050,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1051,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1052,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1054,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1055,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1056,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1057,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,1058,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1059,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,1060,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1061,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1062,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,1063,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1064,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1065,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1066,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1067,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1068,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1069,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1070,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1071,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1072,"location.mkdirs();
","protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
getLog().info(""Unpacking "" + file.getPath() + ""to\n "" + location.getPath() + ""\nwith Includes "" + includes + "" and excludes:"" + excludes);
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1073,public boolean silent;,public boolean silent;
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1074,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1075,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,1076,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
","protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1077,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1078,protected File outputFile;,protected File outputFile;
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,FP,2,18,mavendp,1079,"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1080,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1081,private ProjectDependencyAnalyzer analyzer;,private ProjectDependencyAnalyzer analyzer;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,1082,"analysis = analyzer.analyze( project );
","public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,1083,"getLog().info( outputDirectory.toString() );
","protected String getOutputDirectory() {
getLog().info(outputDirectory.toString());
return outputDirectory.toString();
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1084,private Renderer siteRenderer;,private Renderer siteRenderer;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,1085,"if ( ""pom"".equals( project.getPackaging() ) )
","public void executeReport(Locale locale) throws MavenReportException {
if (""pom"".equals(project.getPackaging())) {
getLog().info(""Skipping pom project"");
return;
}
if (outputDirectory == null || !outputDirectory.exists()) {
getLog().info(""Skipping project with no Target directory"");
return;
}
ProjectDependencyAnalysis analysis = null;
try {
analysis = analyzer.analyze(project);
} catch (ProjectDependencyAnalyzerException exception) {
throw new MavenReportException(""Cannot analyze dependencies"", exception);
}
Sink sink = getSink();
ResourceBundle bundle = getBundle(locale);
AnalyzeReportView analyzethis = new AnalyzeReportView();
analyzethis.generateReport(analysis, sink, bundle);
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1086,private File outputDirectory;,private File outputDirectory;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1087,private MavenProject project;,private MavenProject project;
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,1088,"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private File outputFile;
private boolean regenerateFile;
private String fileSeparator;
private String pathSeparator;
private String localRepoProperty;
boolean attach;
boolean outputFilterFile;
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if (cpFile != null)
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
if ( StringUtils.isEmpty( fileSeparator ) )
{
isFileSepSet = false;
}
else
{
isFileSepSet = true;
}
if ( StringUtils.isEmpty( pathSeparator ) )
{
isPathSepSet = false;
}
else
{
isPathSepSet = true;
}
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List artList = new ArrayList( artifacts );
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( (Artifact) i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
String separator = File.separator;
if ( File.separator.equals( ""\\"" ) )
{
separator = ""\\\\"";
}
cpString = cpString.replaceAll( separator, fileSeparator );
}
if (outputFilterFile)
{
cpString = ""classpath=""+ cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, local.getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
try
{
Writer w = new BufferedWriter( new FileWriter( out ) );
try
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" +
ex.toString(), ex );
}
finally
{
w.close();
}
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while opening/closing classpath file '"" + out + ""': "" +
ex.toString(), ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
try
{
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
r.close();
}
}
public int compare( Object arg1, Object arg2 )
{
if ( arg1 instanceof Artifact && arg2 instanceof Artifact )
{
if ( arg1 == arg2 )
{
return 0;
}
else if ( arg1 == null )
{
return -1;
}
else if ( arg2 == null )
{
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
else
{
return 0;
}
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,1089,"else if ( arg1 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1090,"List artList = new ArrayList( artifacts );
","public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
if (StringUtils.isEmpty(fileSeparator)) {
isFileSepSet = false;
} else {
isFileSepSet = true;
}
if (StringUtils.isEmpty(pathSeparator)) {
isPathSepSet = false;
} else {
isPathSepSet = true;
}
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List artList = new ArrayList(artifacts);
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath((Artifact) i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
String separator = File.separator;
if (File.separator.equals(""\\"")) {
separator = ""\\\\"";
}
cpString = cpString.replaceAll(separator, fileSeparator);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,1091,"else if ( arg2 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1092,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1093,private MavenProjectHelper projectHelper;,private MavenProjectHelper projectHelper;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1094,private File cpFile;,private File cpFile;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1095,boolean attach;,boolean attach;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1096,boolean outputFilterFile;,boolean outputFilterFile;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,1097,"projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
","protected void attachFile(String cpString) throws MojoExecutionException {
File attachedFile = new File(project.getBuild().getDirectory(), ""classpath"");
storeClasspathFile(cpString, attachedFile);
projectHelper.attachArtifact(project, attachedFile, ""classpath"");
}"
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,1098,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1099,"BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1100,"Writer w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1101,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,1102,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,1103,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1104,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1105,protected boolean outputScope;,protected boolean outputScope;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1106,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1107,private List remotePluginRepositories;,private List remotePluginRepositories;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1108,"file.getParentFile().mkdirs();
","public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1109,"writer = new FileWriter( file );
","public synchronized static void write(String string, File file, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file);
writer.write(string);
} finally {
if (writer != null) {
try {
writer.close();
} catch (IOException exception) {
log.error(""Cannot close file"", exception);
}
}
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1110,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1111,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1112,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1113,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1114,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,1115,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1145,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1146,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1147,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1148,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location, e);
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1149,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1150,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1151,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1152,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1153,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1154,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1155,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1156,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1157,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1158,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,1159,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return Objects.equals( cpString, oldCp );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out,
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1160,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out, ex);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1161,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1162,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1163,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1164,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1165,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,1166,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1167,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,1168,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1169,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1170,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1171,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1172,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1173,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1252,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1253,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1254,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1255,"location.mkdirs();
","protected void unpack(File file, File location, String includes, String excludes) throws MojoExecutionException {
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setUseJvmChmod(useJvmChmod);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1257,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,1258,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST,
defaultPhase = LifecyclePhase.GENERATE_SOURCES )
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.cpFile"" )
private File cpFile;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
protected boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
public void execute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId, this.useBaseVersion ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn(
""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1259,"r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}"
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,1260,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1261,"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
","public void execute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath((Artifact) i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1262,"w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1263,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC_ANON,FP,3,20,mavendp,1264,"{
public boolean include( Artifact artifact )
{
return artifact.isSnapshot();
","private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,1265,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1266,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List<String> inclusionPatterns, List<String> exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map<String, Artifact> artifactMap = createProjectArtifactMap(project);
if (artifactMap.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
Map<String, Artifact> depsAfterInclusion = new HashMap<String, Artifact>();
if (!inclusionPatterns.isEmpty()) {
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
if (inclusionPatterns.contains(artifact.getGroupId())) {
verbose(""Including groupId: "" + artifact.getGroupId() + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
} else {
String artifactKey = ArtifactUtils.versionlessKey(artifact);
if (inclusionPatterns.contains(artifactKey)) {
verbose(""Including artifact: "" + artifactKey + "" for refresh operation for project: "" + project.getId());
depsAfterInclusion.put(artifactEntry.getKey(), artifactEntry.getValue());
}
}
}
if (depsAfterInclusion.isEmpty()) {
getLog().info(""Nothing to include for project: "" + project.getId() + "". Ending purge."");
return;
}
artifactMap = depsAfterInclusion;
}
if (!exclusionPatterns.isEmpty()) {
for (String excludedKey : exclusionPatterns) {
if (resolutionFuzziness.equals(GROUP_ID_FUZZINESS)) {
verbose(""Excluding groupId: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
for (Iterator<Map.Entry<String, Artifact>> artifactIter = artifactMap.entrySet().iterator(); artifactIter.hasNext(); ) {
Map.Entry<String, Artifact> artifactEntry = artifactIter.next();
Artifact artifact = artifactEntry.getValue();
if (artifact.getGroupId().equals(excludedKey)) {
artifactIter.remove();
}
}
} else {
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
artifactMap.remove(excludedKey);
}
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Map.Entry<String, Artifact> entry : artifactMap.entrySet()) {
Artifact artifact = entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
CORRECTNESS,NP_NULL_ON_SOME_PATH,FP,2,8,mavendp,1267,"return recommendedVersion.compareTo( theVersion ) <= 0;
","public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1268,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,2,8,mavendp,1269,"@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;","@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1270,"outputWriter = new FileWriter( outputFile );
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1271,"outputFile.getParentFile().mkdirs();
","public void execute() throws MojoExecutionException {
Writer outputWriter = null;
try {
Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1272,"writer = new FileWriter( file, append );
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1274,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1275,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1276,"marker.setLastModified( ts );
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1277,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1278,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1279,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,1280,"Set<Artifact> results = artifacts;
","public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1311,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1312,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1313,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1314,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1315,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1316,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,1317,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1318,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1319,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1320,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1321,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1322,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1323,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1324,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1325,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,1326,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1327,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1328,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1329,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1330,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1331,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1332,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,1333,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1334,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1335,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,1336,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1337,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,1338,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1339,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1340,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1341,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1342,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1343,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1347,protected List reactorProjects;,protected List reactorProjects;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1348,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1349,"location.mkdirs();
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1350,protected boolean outputAbsoluteArtifactFilename;,protected boolean outputAbsoluteArtifactFilename;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1351,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1352,public boolean silent;,public boolean silent;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1353,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1354,protected MavenProject project;,protected MavenProject project;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1355,"UnArchiver unArchiver;
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1357,"else
","public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,1358,"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.local );
","protected Set resolveArtifactDependencies(Artifact artifact) throws ArtifactResolutionException, ArtifactNotFoundException, ProjectBuildingException, InvalidDependencyVersionException {
Artifact pomArtifact = this.factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), """", ""pom"");
MavenProject pomProject = mavenProjectBuilder.buildFromRepository(pomArtifact, this.remoteRepos, this.local);
return resolveDependencyArtifacts(pomProject);
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1359,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1360,"deleteTarget.delete();
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,1361,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void refreshDependenciesForProject(MavenProject project, List exclusionPatterns) throws ArtifactResolutionException, MojoFailureException {
Map deps = createArtifactMap(project);
if (deps.isEmpty()) {
getLog().info(""Nothing to do for project: "" + project.getId());
return;
}
if (!exclusionPatterns.isEmpty()) {
for (Iterator it = exclusionPatterns.iterator(); it.hasNext(); ) {
String excludedKey = (String) it.next();
verbose(""Excluding: "" + excludedKey + "" from refresh operation for project: "" + project.getId());
deps.remove(excludedKey);
}
}
verbose(""Processing dependencies for project: "" + project.getId());
List missingArtifacts = new ArrayList();
for (Iterator it = deps.entrySet().iterator(); it.hasNext(); ) {
Map.Entry entry = (Map.Entry) it.next();
Artifact artifact = (Artifact) entry.getValue();
verbose(""Processing artifact: "" + artifact.getId());
File deleteTarget = findDeleteTarget(artifact);
verbose(""Deleting: "" + deleteTarget);
if (deleteTarget.isDirectory()) {
try {
FileUtils.deleteDirectory(deleteTarget);
} catch (IOException e) {
throw new MojoFailureException(this, ""Cannot delete dependency from the local repository: "" + artifact.getId(), ""Failed to delete: "" + deleteTarget);
}
} else {
deleteTarget.delete();
}
if (reResolve) {
verbose(""Re-resolving."");
artifact.setResolved(false);
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
getLog().debug(e.getMessage());
missingArtifacts.add(artifact);
}
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
Artifact missingArtifact = (Artifact) i.next();
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE,FP,2,13,mavendp,1362,"if ( parent.list().length < 2 )
","private File findDeleteTarget(Artifact artifact) {
File deleteTarget = artifact.getFile();
if (GROUP_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
deleteTarget = deleteTarget.getParentFile();
String[] path = localRepository.pathOf(artifact).split(""\\/"");
int groupParts = path.length - 4;
File parent = deleteTarget.getParentFile();
int count = 0;
while (count++ < groupParts) {
if (parent.list().length < 2) {
deleteTarget = parent;
parent = deleteTarget.getParentFile();
} else {
break;
}
}
} else if (ARTIFACT_ID_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile().getParentFile();
} else if (VERSION_FUZZINESS.equals(resolutionFuzziness)) {
deleteTarget = deleteTarget.getParentFile();
}
return deleteTarget;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1363,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getProcessedArtifactItems(boolean removeVersion) throws MojoExecutionException {
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion));
}
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
}
return artifactItems;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1364,private String groupId;,private String groupId;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1365,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1366,private List remotePluginRepositories;,private List remotePluginRepositories;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1367,private boolean excludeTransitive;,private boolean excludeTransitive;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1368,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1369,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1370,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1371,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1372,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,1373,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1475,"unArchiver = archiverManager.getUnArchiver( file );
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1476,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1477,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1478,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1479,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,1480,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1481,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1482,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1483,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1484,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1485,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1486,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1487,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1488,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1489,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1490,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1491,"try ( Writer w = new BufferedWriter( new FileWriter( out ) ) )
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1492,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1493,"try ( BufferedReader r = new BufferedReader( new FileReader( outputFile ) ) )
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
try (BufferedReader r = new BufferedReader(new FileReader(outputFile))) {
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
return sb.toString();
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1495,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1496,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1497,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1498,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1499,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,1500,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder.toString() + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1501,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,1502,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
DependencyUtil.write(output, outputFile, appendOutput, getLog());
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1503,"try ( FileWriter writer = new FileWriter( file, append ) )
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1504,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1505,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1506,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1507,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1508,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1509,"location.mkdirs();
","protected void unpack(Artifact artifact, File location, String includes, String excludes) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(artifact.getType());
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
unArchiver.setUseJvmChmod(useJvmChmod);
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1510,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1511,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,1513,"private class SnapshotsFilter
implements ArtifactFilter
{
public boolean include( Artifact artifact )
{
return artifact.isSnapshot();
","private void reResolveArtifacts(MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException {
for (Artifact artifact : artifacts) {
try {
Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, ""pom"");
resolver.resolveAlways(pomArtifact, remoteRepositories, localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
}
}
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Artifact artifact : artifacts) {
verbose(""Resolving artifact: "" + artifact.getId());
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
PERFORMANCE,SBSC_USE_STRINGBUFFER_CONCATENATION,FP,2,18,mavendp,1514,"message += ""  "" + missingArtifact.getId() + ""\n"";
","private void reResolveArtifacts(MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter) throws ArtifactResolutionException, ArtifactNotFoundException {
for (Artifact artifact : artifacts) {
try {
Artifact pomArtifact = factory.createArtifact(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), null, ""pom"");
resolver.resolveAlways(pomArtifact, remoteRepositories, localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
}
}
List<Artifact> missingArtifacts = new ArrayList<Artifact>();
for (Artifact artifact : artifacts) {
verbose(""Resolving artifact: "" + artifact.getId());
try {
resolver.resolveAlways(artifact, project.getRemoteArtifactRepositories(), localRepository);
} catch (ArtifactResolutionException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
} catch (ArtifactNotFoundException e) {
verbose(e.getMessage());
missingArtifacts.add(artifact);
}
}
if (missingArtifacts.size() > 0) {
String message = ""required artifacts missing:\n"";
for (Artifact missingArtifact : missingArtifacts) {
message += ""  "" + missingArtifact.getId() + ""\n"";
}
message += ""\nfor the artifact:"";
throw new ArtifactResolutionException(message, project.getArtifact(), project.getRemoteArtifactRepositories());
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1515,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1516,"DependencyManagement depMgt = project.getDependencyManagement();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<String, Dependency>();
Map<String, Exclusion> exclusions = new HashMap<String, Exclusion>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
@SuppressWarnings(""unchecked"")
Set<Artifact> allDependencyArtifacts = new HashSet<Artifact>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
@SuppressWarnings(""unchecked"")
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1517,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1518,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,3,11,mavendp,1519,"@Parameter
protected boolean ignorePermissions;","@Parameter
protected boolean ignorePermissions;"
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,FP,2,11,mavendp,1521,"return (cpString.equals(oldCp) || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,1522,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST,
defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.cpFile"" )
private File cpFile;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
protected boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Parameter
protected boolean useJvmChmod = true;
@Parameter
protected boolean ignorePermissions;
boolean isFileSepSet = true;
boolean isPathSepSet = true;
protected void doExecute()
throws MojoExecutionException
{
if ( cpFile != null )
{
getLog().warn( ""The parameter cpFile is deprecated. Use outputFile instead."" );
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<Artifact>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath(i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
project.getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
else if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( project.getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( project, attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
file = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId, this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn(
""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
Writer w = null;
try
{
w = new BufferedWriter( new FileWriter( out ) );
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
finally
{
IOUtil.close( w );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException(
""The outputFile parameter cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try
{
r = new BufferedReader( new FileReader( outputFile ) );
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
IOUtil.close( r );
}
}
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public File getCpFile()
{
return this.outputFile;
}
public void setCpFile( File theCpFile )
{
this.outputFile = theCpFile;
}
public String getOutputProperty()
{
return this.outputProperty;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public String getFileSeparator()
{
return this.fileSeparator;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public String getPathSeparator()
{
return this.pathSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public String getPrefix()
{
return this.prefix;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public boolean isRegenerateFile()
{
return this.regenerateFile;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public String getLocalRepoProperty()
{
return localRepoProperty;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
public boolean isFileSepSet()
{
return isFileSepSet;
}
public void setFileSepSet( boolean isFileSepSet )
{
this.isFileSepSet = isFileSepSet;
}
public boolean isPathSepSet()
{
return isPathSepSet;
}
public void setPathSepSet( boolean isPathSepSet )
{
this.isPathSepSet = isPathSepSet;
}
","@Parameter
protected boolean useJvmChmod = true;"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,2,8,mavendp,1523,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1524,"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
","protected void doExecute() throws MojoExecutionException {
if (cpFile != null) {
getLog().warn(""The parameter cpFile is deprecated. Use outputFile instead."");
this.outputFile = cpFile;
}
isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<Artifact>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
project.getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
} else if (outputFile == null) {
getLog().info(""Dependencies classpath:\n"" + cpString);
} else {
if (regenerateFile || !isUpdToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1525,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1526,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1527,"w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1528,"r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
IOUtil.close(r);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1529,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,3,11,mavendp,1530,"@Parameter
protected boolean ignorePermissions;","@Parameter
protected boolean ignorePermissions;"
CORRECTNESS,MF_CLASS_MASKS_FIELD,FP,2,8,mavendp,1531,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1532,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1533,".mkdirs();
","protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1534,"outputWriter = new FileWriter( outputFile );
","protected void doExecute() throws MojoExecutionException {
Writer outputWriter = null;
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
if (this.outputFile != null) {
outputFile.getParentFile().mkdirs();
outputWriter = new FileWriter(outputFile);
}
for (final Artifact plugin : plugins) {
String logStr = ""Plugin Resolved: "" + DependencyUtil.getFormattedFileName(plugin, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
if (!excludeTransitive) {
for (final Artifact artifact : resolveArtifactDependencies(plugin)) {
logStr = ""    Plugin Dependency Resolved: "" + DependencyUtil.getFormattedFileName(artifact, false);
if (!silent) {
this.getLog().info(logStr);
}
if (outputWriter != null) {
outputWriter.write(logStr);
outputWriter.write(""\n"");
}
}
}
}
} catch (final IOException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactResolutionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactNotFoundException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ProjectBuildingException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final InvalidDependencyVersionException e) {
throw new MojoExecutionException(""Nested:"", e);
} catch (final ArtifactFilterException e) {
throw new MojoExecutionException(""Nested:"", e);
} finally {
IOUtil.close(outputWriter);
}
}"
CORRECTNESS,NP_NULL_ON_SOME_PATH,FP,2,8,mavendp,1535,"return recommendedVersion.compareTo( theVersion ) <= 0;
","public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
@SuppressWarnings(""unchecked"")
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1536,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1537,"writer = new FileWriter( file, append );
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1538,"marker.setLastModified( ts );
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1539,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1540,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1541,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1542,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1543,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1544,protected List reactorProjects;,protected List reactorProjects;
CORRECTNESS,UR_UNINIT_READ,FP,2,3,mavendp,1545,"if (silent)
","public AbstractDependencyMojo() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
}"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1546,protected File outputDirectory;,protected File outputDirectory;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1547,protected MavenProjectBuilder mavenProjectBuilder;,protected MavenProjectBuilder mavenProjectBuilder;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1548,private ArrayList artifactItems;,private ArrayList artifactItems;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1549,protected boolean overWriteReleases;,protected boolean overWriteReleases;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,2,17,mavendp,1550,protected File outputDirectory;,protected File outputDirectory;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1551,protected boolean overWriteSnapshots;,protected boolean overWriteSnapshots;
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,3,11,mavendp,1552,"Iterator iter = artifactItems.iterator();
","protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1553,"artifactItem.getOutputDirectory().mkdirs();
","protected ArrayList getArtifactItems() throws MojoExecutionException {
Iterator iter = artifactItems.iterator();
while (iter.hasNext()) {
ArtifactItem artifactItem = (ArtifactItem) iter.next();
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
artifactItem.setArtifact(this.getArtifact(artifactItem));
String overWrite = artifactItem.getOverWrite();
if (overWrite == null) {
if (artifactItem.getArtifact().isSnapshot()) {
artifactItem.setDoOverWrite(this.overWriteSnapshots);
} else {
artifactItem.setDoOverWrite(this.overWriteReleases);
}
} else {
artifactItem.setDoOverWrite(overWrite.equalsIgnoreCase(""true""));
}
}
return artifactItems;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1554,private File markersDirectory;,private File markersDirectory;
PERFORMANCE,UUF_UNUSED_FIELD,FP,2,18,mavendp,1555,private boolean useMarkers;,private boolean useMarkers;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1556,private String groupId;,private String groupId;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1557,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,3,15,mavendp,1558,private boolean excludeTransitive;,private boolean excludeTransitive;
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1559,private List remotePluginRepositories;,private List remotePluginRepositories;
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,FP,3,20,mavendp,1560,"if ( !silent )
{
log.info( """" );
log.info( ""The following files have been resolved: "" );
if ( resolvedArtifacts.isEmpty() )
{
log.info( ""   none"" );
}
else
{
for ( Iterator i = resolvedArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
if ( existingArtifacts != null && !existingArtifacts.isEmpty() )
{
log.info( """" );
log.info( ""The following files where skipped: "" );
for ( Iterator i = existingArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
log.info( """" );
log.info( ""The following files have NOT been resolved: "" );
if ( missingArtifacts.isEmpty() )
{
log.info( ""   none"" );
}
else
{
for ( Iterator i = missingArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
log.info( """" );
}
}
","private static void logResults(Set resolvedArtifacts, Set missingArtifacts, HashSet existingArtifacts, boolean silent, Log log) {
if (!silent) {
log.info("""");
log.info(""The following files have been resolved: "");
if (resolvedArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = resolvedArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
if (existingArtifacts != null && !existingArtifacts.isEmpty()) {
log.info("""");
log.info(""The following files where skipped: "");
for (Iterator i = existingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
log.info(""The following files have NOT been resolved: "");
if (missingArtifacts.isEmpty()) {
log.info(""   none"");
} else {
for (Iterator i = missingArtifacts.iterator(); i.hasNext(); ) {
log.info(""   "" + ((Artifact) i.next()).getId());
}
}
log.info("""");
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1561,"markerFile.createNewFile();
","public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1562,"markersDirectory.mkdirs();
","public static void unpackFile(Artifact artifact, File unpackDirectory, File markersDirectory, ArchiverManager archiverManager, Log log, boolean overWrite) throws MojoExecutionException {
markersDirectory.mkdirs();
File markerFile = new File(markersDirectory, artifact.getId().replace(':', '-') + "".unpacked"");
if (!markerFile.exists() || overWrite) {
try {
unpackDirectory.mkdirs();
unpack(artifact.getFile(), unpackDirectory, archiverManager, log);
markerFile.getParentFile().mkdirs();
markerFile.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Error creating marker file: "" + markerFile);
}
} else {
log.info(artifact.getFile().getName() + "" already unpacked."");
}
}"
PERFORMANCE,UPM_UNCALLED_PRIVATE_METHOD,FP,3,20,mavendp,1563,"log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext())
{
Artifact artifact = (Artifact) iter.next();
log.debug(""""+artifact);
}
}
","private void log(Set artifacts, Log log) {
log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext()) {
Artifact artifact = (Artifact) iter.next();
log.debug("""" + artifact);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1564,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1565,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1566,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1567,"marker.createNewFile();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1568,"clearMarker.delete();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,1569,"Artifact newArtifact = factory.createArtifactWithClassifier( artifact.getGroupId(), artifact
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1570,private ArtifactFactory factory;,private ArtifactFactory factory;
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,1571,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1657,"location.mkdirs();
","protected void unpack(Artifact artifact, String type, File location, String includes, String excludes, String encoding, FileMapper[] fileMappers, boolean overwrite) throws MojoExecutionException {
File file = artifact.getFile();
try {
logUnpack(file, location, includes, excludes);
location.mkdirs();
if (!location.exists()) {
throw new MojoExecutionException(""Location to write unpacked files to could not be created: "" + location);
}
if (file.isDirectory()) {
// usual case is a future jar packaging, but there are special cases: classifier and other packaging
throw new MojoExecutionException(""Artifact has not been packaged yet. When used on reactor artifact, "" + ""unpack should be executed after packaging: see MDEP-98."");
}
UnArchiver unArchiver;
try {
unArchiver = archiverManager.getUnArchiver(type);
getLog().debug(""Found unArchiver by type: "" + unArchiver);
} catch (NoSuchArchiverException e) {
unArchiver = archiverManager.getUnArchiver(file);
getLog().debug(""Found unArchiver by extension: "" + unArchiver);
}
if (encoding != null && unArchiver instanceof ZipUnArchiver) {
((ZipUnArchiver) unArchiver).setEncoding(encoding);
getLog().info(""Unpacks '"" + type + ""' with encoding '"" + encoding + ""'."");
}
unArchiver.setIgnorePermissions(ignorePermissions);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
unArchiver.setOverwrite(overwrite);
if (StringUtils.isNotEmpty(excludes) || StringUtils.isNotEmpty(includes)) {
IncludeExcludeFileSelector[] selectors = new IncludeExcludeFileSelector[] { new IncludeExcludeFileSelector() };
if (StringUtils.isNotEmpty(excludes)) {
selectors[0].setExcludes(excludes.split("",""));
}
if (StringUtils.isNotEmpty(includes)) {
selectors[0].setIncludes(includes.split("",""));
}
unArchiver.setFileSelectors(selectors);
}
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.setFileMappers(fileMappers);
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (ArchiverException e) {
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + System.lineSeparator() + e.toString(), e);
}
}"
BAD_PRACTICE,DE_MIGHT_IGNORE,FP,3,19,mavendp,1659,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
DODGY_CODE,REC_CATCH_EXCEPTION,FP,3,20,mavendp,1660,"catch ( Exception e )
","private void silenceUnarchiver(UnArchiver unArchiver) {
try {
Field field = ReflectionUtils.getFieldByNameIncludingSuperclasses(""logger"", unArchiver.getClass());
field.setAccessible(true);
field.set(unArchiver, this.getLog());
} catch (Exception e) {
}
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1661,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,2,18,mavendp,1662,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
PERFORMANCE,URF_UNREAD_FIELD,FP,2,18,mavendp,1663,"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";","@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1664,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1665,"Set<Artifact> directDependencies = project.getDependencyArtifacts();
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency/DependencyManagement mismatches:"");
List<Dependency> depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map<String, Dependency> depMgtMap = new HashMap<>();
Map<String, Exclusion> exclusions = new HashMap<>();
for (Dependency depMgtDependency : depMgtDependencies) {
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set<Artifact> allDependencyArtifacts = new LinkedHashSet<>(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set<Artifact> directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List<Artifact> exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
for (Artifact exclusion : exclusionErrors) {
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map<Artifact, Dependency> mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
for (Map.Entry<Artifact, Dependency> entry : mismatch.entrySet()) {
logMismatch(entry.getKey(), entry.getValue());
foundError = true;
}
if (!foundError) {
getLog().info(""\tNone"");
}
} else {
getLog().info(""\tNothing in DepMgt."");
}
return foundError;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1666,"artifactItem.getOutputDirectory().mkdirs();
","protected List<ArtifactItem> getProcessedArtifactItems(ProcessArtifactItemsRequest processArtifactItemsRequest) throws MojoExecutionException {
boolean removeVersion = processArtifactItemsRequest.isRemoveVersion(), prependGroupId = processArtifactItemsRequest.isPrependGroupId(), useBaseVersion = processArtifactItemsRequest.isUseBaseVersion();
boolean removeClassifier = processArtifactItemsRequest.isRemoveClassifier();
if (artifactItems == null || artifactItems.size() < 1) {
throw new MojoExecutionException(""There are no artifactItems configured."");
}
for (ArtifactItem artifactItem : artifactItems) {
this.getLog().info(""Configured Artifact: "" + artifactItem.toString());
if (artifactItem.getOutputDirectory() == null) {
artifactItem.setOutputDirectory(this.outputDirectory);
}
artifactItem.getOutputDirectory().mkdirs();
if (StringUtils.isEmpty(artifactItem.getVersion())) {
fillMissingArtifactVersion(artifactItem);
}
artifactItem.setArtifact(this.getArtifact(artifactItem));
if (StringUtils.isEmpty(artifactItem.getDestFileName())) {
artifactItem.setDestFileName(DependencyUtil.getFormattedFileName(artifactItem.getArtifact(), removeVersion, prependGroupId, useBaseVersion, removeClassifier));
}
try {
artifactItem.setNeedsProcessing(checkIfProcessingNeeded(artifactItem));
} catch (ArtifactFilterException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}
return artifactItems;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1667,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1668,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1669,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1670,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1671,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
CORRECTNESS,NP_NULL_PARAM_DEREF,FP,2,8,mavendp,1672,"List<Artifact> artList = new ArrayList<>( artifacts );
","@Override
protected void doExecute() throws MojoExecutionException {
boolean isFileSepSet = StringUtils.isNotEmpty(fileSeparator);
boolean isPathSepSet = StringUtils.isNotEmpty(pathSeparator);
if (attach && StringUtils.isEmpty(localRepoProperty)) {
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies(true);
if (artifacts == null || artifacts.isEmpty()) {
getLog().info(""No dependencies found."");
}
List<Artifact> artList = new ArrayList<>(artifacts);
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if (i.hasNext()) {
appendArtifactPath(i.next(), sb);
while (i.hasNext()) {
sb.append(isPathSepSet ? this.pathSeparator : File.pathSeparator);
appendArtifactPath(i.next(), sb);
}
}
String cpString = sb.toString();
if (isFileSepSet) {
final String pattern = Pattern.quote(File.separator);
final String replacement = Matcher.quoteReplacement(fileSeparator);
cpString = cpString.replaceAll(pattern, replacement);
}
if (outputFilterFile) {
cpString = ""classpath="" + cpString;
}
if (outputProperty != null) {
getProject().getProperties().setProperty(outputProperty, cpString);
if (getLog().isDebugEnabled()) {
getLog().debug(outputProperty + "" = "" + cpString);
}
}
if (outputFile == null) {
getLog().info(""Dependencies classpath:"" + System.lineSeparator() + cpString);
} else {
if (regenerateFile || !isUpToDate(cpString)) {
storeClasspathFile(cpString, outputFile);
} else {
this.getLog().info(""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."");
}
}
if (attach) {
attachFile(cpString);
}
}"
BAD_PRACTICE,SE_COMPARATOR_SHOULD_BE_SERIALIZABLE,FP,3,20,mavendp,1673,"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1674,"out.getParentFile().mkdirs();
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
try (Writer w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(out), encoding))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1675,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
MALICIOUS_CODE,EI_EXPOSE_REP,FP,2,18,mavendp,1676,"return this.fileMappers;
","public FileMapper[] getFileMappers() {
return this.fileMappers;
}"
MALICIOUS_CODE,EI_EXPOSE_REP2,FP,2,18,mavendp,1677,"this.fileMappers = fileMappers;
","public void setFileMappers(FileMapper[] fileMappers) {
this.fileMappers = fileMappers;
}"
DODGY_CODE,URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD,FP,2,18,mavendp,1678,"@Parameter
protected boolean useJvmChmod = true;","@Parameter
protected boolean useJvmChmod = true;"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1679,"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
","public String getOutput(boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following files have been resolved:"");
sb.append(System.lineSeparator());
if (results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
sb.append(buildArtifactListOutput(results.getResolvedDependencies(), outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getSkippedDependencies() != null && !results.getSkippedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files were skipped:"");
sb.append(System.lineSeparator());
Set<Artifact> skippedDependencies = new LinkedHashSet<>();
skippedDependencies.addAll(results.getSkippedDependencies());
sb.append(buildArtifactListOutput(skippedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
if (results.getUnResolvedDependencies() != null && !results.getUnResolvedDependencies().isEmpty()) {
sb.append(System.lineSeparator());
sb.append(""The following files have NOT been resolved:"");
sb.append(System.lineSeparator());
Set<Artifact> unResolvedDependencies = new LinkedHashSet<>();
unResolvedDependencies.addAll(results.getUnResolvedDependencies());
sb.append(buildArtifactListOutput(unResolvedDependencies, outputAbsoluteArtifactFilename, theOutputScope, theSort));
}
sb.append(System.lineSeparator());
return sb.toString();
}"
PERFORMANCE,SIC_INNER_SHOULD_BE_STATIC,FP,2,18,mavendp,1680,"private class ModuleDescriptor
{
String name;
boolean automatic = true;
","private StringBuilder buildArtifactListOutput(Set<Artifact> artifacts, boolean outputAbsoluteArtifactFilename, boolean theOutputScope, boolean theSort) {
StringBuilder sb = new StringBuilder();
List<String> artifactStringList = new ArrayList<>();
for (Artifact artifact : artifacts) {
MessageBuilder messageBuilder = MessageUtils.buffer();
messageBuilder.a(""   "");
if (theOutputScope) {
messageBuilder.a(artifact.toString());
} else {
messageBuilder.a(artifact.getId());
}
if (outputAbsoluteArtifactFilename) {
try {
String artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
messageBuilder.a(':').a(artifactFilename);
} catch (NullPointerException e) {
}
}
if (theOutputScope && artifact.isOptional()) {
messageBuilder.a("" (optional)"");
}
if (artifact.getFile() != null) {
ModuleDescriptor moduleDescriptor = getModuleDescriptor(artifact.getFile());
if (moduleDescriptor != null) {
messageBuilder.project("" -- module "" + moduleDescriptor.name);
if (moduleDescriptor.automatic) {
if (""MANIFEST"".equals(moduleDescriptor.moduleNameSource)) {
messageBuilder.strong("" [auto]"");
} else {
messageBuilder.warning("" (auto)"");
}
}
}
}
artifactStringList.add(messageBuilder.toString() + System.lineSeparator());
}
if (theSort) {
Collections.sort(artifactStringList);
}
for (String artifactString : artifactStringList) {
sb.append(artifactString);
}
return sb;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1681,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = newResolvePluginProjectBuildingRequest();
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,3,20,mavendp,1682,"if ( plugins == null || plugins.isEmpty() )
","@Override
protected void doExecute() throws MojoExecutionException {
try {
final Set<Artifact> plugins = resolvePluginArtifacts();
StringBuilder sb = new StringBuilder();
sb.append(System.lineSeparator());
sb.append(""The following plugins have been resolved:"");
sb.append(System.lineSeparator());
if (plugins == null || plugins.isEmpty()) {
sb.append(""   none"");
sb.append(System.lineSeparator());
} else {
for (Artifact plugin : plugins) {
String artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = plugin.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
String id = plugin.toString();
sb.append(""   "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
if (!excludeTransitive) {
DefaultDependableCoordinate pluginCoordinate = new DefaultDependableCoordinate();
pluginCoordinate.setGroupId(plugin.getGroupId());
pluginCoordinate.setArtifactId(plugin.getArtifactId());
pluginCoordinate.setVersion(plugin.getVersion());
for (final Artifact artifact : resolveArtifactDependencies(pluginCoordinate)) {
artifactFilename = null;
if (outputAbsoluteArtifactFilename) {
try {
artifactFilename = artifact.getFile().getAbsoluteFile().getPath();
} catch (NullPointerException e) {
artifactFilename = null;
}
}
id = artifact.toString();
sb.append(""      "").append(id).append(outputAbsoluteArtifactFilename ? "":"" + artifactFilename : """").append(System.lineSeparator());
}
}
}
sb.append(System.lineSeparator());
String output = sb.toString();
if (outputFile == null) {
DependencyUtil.log(output, getLog());
} else {
String encoding = Objects.toString(outputEncoding, ""UTF-8"");
DependencyUtil.write(output, outputFile, appendOutput, encoding);
}
}
} catch (IOException | ArtifactFilterException | ArtifactResolverException | DependencyResolverException e) {
throw new MojoExecutionException(e.getMessage(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1683,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<DependencyNode>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,1684,"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
String managerScope = Objects.toString(manager.getScope(), ""compile"");
Dependency dependency = node.getDependency();
String dependencyScope = dependency.getScope();
if (!managerScope.equals(dependencyScope)) {
artifactProperties.put(PRE_MANAGED_SCOPE, dependencyScope);
artifactProperties.put(MANAGED_SCOPE, managerScope);
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
dependency.setArtifact(dependency.getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1685,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, String encoding) throws IOException {
file.getParentFile().mkdirs();
try (Writer writer = new OutputStreamWriter(new FileOutputStream(file, append), encoding)) {
writer.write(string);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1686,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1687,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
if (!marker.setLastModified(ts)) {
throw new MojoExecutionException(""Unable to update last modified timestamp on marker file "" + marker.getAbsolutePath());
}
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1688,"marker.createNewFile();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,3,19,mavendp,1689,"marker.getParentFile().mkdirs();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
if (!clearMarker.delete()) {
clearMarker.deleteOnExit();
}
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,TP,2,16,mavendp,1819,"clearMarker.delete();
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
File clearMarker = getMarkerFile(!this.resolved);
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
if (clearMarker.exists()) {
clearMarker.delete();
}
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,FP,2,11,mavendp,1820,"return (cpString.equals(oldCp) || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,FP,1,16,mavendp,1821,"else if ( arg1 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
I18N,DM_DEFAULT_ENCODING,TP,1,19,mavendp,1822,"try ( FileWriter writer = new FileWriter( file, append ) )
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
try (FileWriter writer = new FileWriter(file, append)) {
writer.write(string);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1823,"Writer w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try {
Writer w = new BufferedWriter(new FileWriter(out));
try {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writting to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
w.close();
}
} catch (IOException ex) {
throw new MojoExecutionException(""Error while opening/closing classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
DODGY_CODE,UC_USELESS_CONDITION,TP,1,14,mavendp,1824,"if ( tokens.length < 3 && tokens.length > 5 )
","public void execute() throws MojoExecutionException, MojoFailureException {
if (artifactId == null && artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifactId == null) {
String[] tokens = StringUtils.split(artifact, "":"");
if (tokens.length < 3 && tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify groupId:artifactId:version[:packaging][:classifier] "" + artifact);
}
groupId = tokens[0];
artifactId = tokens[1];
version = tokens[2];
if (tokens.length >= 4) {
packaging = tokens[3];
}
if (tokens.length == 5) {
classifier = tokens[4];
} else {
classifier = null;
}
}
Artifact toDownload = classifier == null ? artifactFactory.createBuildArtifact(groupId, artifactId, version, packaging) : artifactFactory.createArtifactWithClassifier(groupId, artifactId, version, packaging, classifier);
Artifact dummyOriginatingArtifact = artifactFactory.createBuildArtifact(""org.apache.maven.plugins"", ""maven-downloader-plugin"", ""1.0"", ""jar"");
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
ArtifactRepository remoteRepo = artifactRepositoryFactory.createArtifactRepository(repositoryId, repositoryUrl, repositoryLayout, always, always);
if (pomRemoteRepositories == null) {
pomRemoteRepositories = new ArrayList();
}
List repoList = new ArrayList(pomRemoteRepositories);
if (remoteRepositories != null) {
// TODO: remote repositories as Strings?
repoList.addAll(Arrays.asList(StringUtils.split(remoteRepositories, "","")));
}
repoList.add(remoteRepo);
try {
if (transitive) {
artifactResolver.resolveTransitively(Collections.singleton(toDownload), dummyOriginatingArtifact, repoList, localRepository, source);
} else {
artifactResolver.resolve(toDownload, repoList, localRepository);
}
} catch (AbstractArtifactResolutionException e) {
throw new MojoExecutionException(""Couldn't download artifact: "" + e.getMessage(), e);
}
}"
CORRECTNESS,MF_CLASS_MASKS_FIELD,TP,2,8,mavendp,1825,"@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;","@Parameter(defaultValue = ""${reactorProjects}"", readonly = true, required = true)
protected List<MavenProject> reactorProjects;"
CORRECTNESS,NP_UNWRITTEN_FIELD,TP,2,8,mavendp,1827,"model = pomReader.read( new FileReader( project.getFile() ) );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
I18N,DM_DEFAULT_ENCODING,TP,1,19,mavendp,1828,"try ( BufferedReader r = new BufferedReader( new FileReader( outputFile ) ) )
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
try (BufferedReader r = new BufferedReader(new FileReader(outputFile))) {
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
return sb.toString();
}
}"
EXPERIMENTAL,OBL_UNSATISFIED_OBLIGATION,TP,2,20,mavendp,1830,"model = pomReader.read( new FileReader( project.getFile() ) );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,1833,"node.getDependency().setArtifact( node.getDependency().getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
if (!manager.getScope().equals(node.getDependency().getScope())) {
artifactProperties.put(PRE_MANAGED_SCOPE, node.getDependency().getScope());
artifactProperties.put(MANAGED_SCOPE, manager.getScope());
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
node.getDependency().setArtifact(node.getDependency().getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1834,"if ( silent )
","public Log getLog() {
if (silent) {
log = new SilentLog();
} else {
log = super.getLog();
}
return this.log;
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,TP,3,20,mavendp,1836,"Set<Artifact> results = artifacts;
","public Set<Artifact> translate(Set<Artifact> artifacts, Log log) {
Set<Artifact> results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet<Artifact>();
for (Artifact artifact : artifacts) {
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,1837,"if ( !findDependencyVersion( artifact, project.getDependencies(), false )
","private void fillMissingArtifactVersion(ArtifactItem artifact) throws MojoExecutionException {
if (!findDependencyVersion(artifact, project.getDependencies(), false) && (project.getDependencyManagement() == null || !findDependencyVersion(artifact, project.getDependencyManagement().getDependencies(), false)) && !findDependencyVersion(artifact, project.getDependencies(), true) && (project.getDependencyManagement() == null || !findDependencyVersion(artifact, project.getDependencyManagement().getDependencies(), true))) {
throw new MojoExecutionException(""Unable to find artifact version of "" + artifact.getGroupId() + "":"" + artifact.getArtifactId() + "" in either dependency list or in project's dependency management."");
}
}"
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1839,"+ ( this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName() ) + "" to: ""
","protected void unpack(File file, File location) throws MojoExecutionException {
try {
location.mkdirs();
UnArchiver unArchiver;
unArchiver = archiverManager.getUnArchiver(file);
unArchiver.setSourceFile(file);
unArchiver.setDestDirectory(location);
if (this.silent) {
silenceUnarchiver(unArchiver);
}
unArchiver.extract();
} catch (NoSuchArchiverException e) {
throw new MojoExecutionException(""Unknown archiver type"", e);
} catch (IOException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + (this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName()) + "" to: "" + location + ""\r\n"" + e.toString(), e);
} catch (ArchiverException e) {
e.printStackTrace();
throw new MojoExecutionException(""Error unpacking file: "" + file + "" to: "" + location + ""\r\n"" + e.toString(), e);
}
}"
CORRECTNESS,NP_NULL_ON_SOME_PATH,FP,2,8,mavendp,1841,"return recommendedVersion.compareTo( theVersion ) <= 0;
","public static boolean containsVersion(VersionRange allowedRange, ArtifactVersion theVersion) {
ArtifactVersion recommendedVersion = allowedRange.getRecommendedVersion();
if (recommendedVersion == null) {
List<Restriction> restrictions = allowedRange.getRestrictions();
for (Restriction restriction : restrictions) {
if (restriction.containsVersion(theVersion)) {
return true;
}
}
}
return recommendedVersion.compareTo(theVersion) <= 0;
}"
PERFORMANCE,SS_SHOULD_BE_STATIC,FP,2,18,mavendp,1842,"@Parameter(property = ""mdep.prependGroupId"", defaultValue = ""false"")
private final boolean prependGroupId = false;","@Parameter(property = ""mdep.prependGroupId"", defaultValue = ""false"")
private final boolean prependGroupId = false;"
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1843,protected boolean appendOutput;,protected boolean appendOutput;
PERFORMANCE,WMI_WRONG_MAP_ITERATOR,TP,2,18,mavendp,1845,"Dependency depMgtDependency = (Dependency) mismatch.get( resolvedArtifact );
","private boolean checkDependencyManagement() throws MojoExecutionException {
boolean foundError = false;
getLog().info(""Found Resolved Dependency / DependencyManagement mismatches:"");
List depMgtDependencies = null;
DependencyManagement depMgt = project.getDependencyManagement();
if (depMgt != null) {
depMgtDependencies = depMgt.getDependencies();
}
if (depMgtDependencies != null && !depMgtDependencies.isEmpty()) {
Map depMgtMap = new HashMap();
Map exclusions = new HashMap();
Iterator iter = depMgtDependencies.iterator();
while (iter.hasNext()) {
Dependency depMgtDependency = (Dependency) iter.next();
depMgtMap.put(depMgtDependency.getManagementKey(), depMgtDependency);
exclusions.putAll(addExclusions(depMgtDependency.getExclusions()));
}
Set allDependencyArtifacts = new HashSet(project.getArtifacts());
if (this.ignoreDirect) {
getLog().info(""\tIgnoring Direct Dependencies."");
Set directDependencies = project.getDependencyArtifacts();
allDependencyArtifacts.removeAll(directDependencies);
}
List exclusionErrors = getExclusionErrors(exclusions, allDependencyArtifacts);
Iterator exclusionIter = exclusionErrors.iterator();
while (exclusionIter.hasNext()) {
Artifact exclusion = (Artifact) exclusionIter.next();
getLog().info(StringUtils.stripEnd(getArtifactManagementKey(exclusion), "":"") + "" was excluded in DepMgt, but version "" + exclusion.getVersion() + "" has been found in the dependency tree."");
foundError = true;
}
Map mismatch = getMismatch(depMgtMap, allDependencyArtifacts);
Iterator mismatchIter = mismatch.keySet().iterator();
while (mismatchIter.hasNext()) {
Artifact resolvedArtifact = (Artifact) mismatchIter.next();
Dependency depMgtDependency = (Dependency) mismatch.get(resolvedArtifact);
logMismatch(resolvedArtifact, depMgtDependency);
foundError = true;
}
if (!foundError) {
getLog().info(""   None"");
}
} else {
getLog().info(""   Nothing in DepMgt."");
}
return foundError;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1846,"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
","private DependencyNode buildTree(DependencyNode parent, org.eclipse.aether.graph.DependencyNode child) {
List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
for (org.eclipse.aether.graph.Exclusion exclusion : child.getDependency().getExclusions()) {
exclusions.add(convertAetherExclusionToMavenExclusion(exclusion));
}
DefaultDependencyNode newChild = new DefaultDependencyNode(parent, convertAetherArtifactToMavenArtifact(child), child.getArtifact().getProperties().get(""preManagedVersion""), child.getArtifact().getProperties().get(""preManagedScope""), null, child.getDependency().isOptional());
newChild.setChildren(new ArrayList<>());
for (org.eclipse.aether.graph.DependencyNode grandChild : child.getChildren()) {
newChild.getChildren().add(buildTree(newChild, grandChild));
}
return newChild;
}"
I18N,DM_DEFAULT_ENCODING,TP,1,19,mavendp,1847,"r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter "" + ""cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuilder sb = new StringBuilder();
BufferedReader r = null;
try {
r = new BufferedReader(new FileReader(outputFile));
for (String line = r.readLine(); line != null; line = r.readLine()) {
sb.append(line);
}
r.close();
r = null;
return sb.toString();
} finally {
IOUtil.close(r);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1849,private String includes;,private String includes;
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,1852,"Set plugins = project.getPluginArtifacts();
","protected Set resolvePluginArtifacts() throws ArtifactResolutionException, ArtifactNotFoundException {
Set plugins = project.getPluginArtifacts();
Set reports = project.getReportArtifacts();
Set artifacts = new HashSet();
artifacts.addAll(reports);
artifacts.addAll(plugins);
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
this.resolver.resolve(artifact, this.remotePluginRepositories, this.getLocal());
}
return artifacts;
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1854,"marker.getParentFile().mkdirs();
","public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
marker.getParentFile().mkdirs();
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1858,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getPluginArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,TP,1,16,mavendp,1859,"else if ( arg2 == null )
","public int compare(Object arg1, Object arg2) {
if (arg1 instanceof Artifact && arg2 instanceof Artifact) {
if (arg1 == arg2) {
return 0;
} else if (arg1 == null) {
return -1;
} else if (arg2 == null) {
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo(s2);
} else {
return 0;
}
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,3,11,mavendp,1860,"artifactRepositoryManager.createArtifactRepository( super.getLocal().getId(), ""file://""
","protected ArtifactRepository getLocal() {
if (this.overrideLocalRepository != null) {
return this.overrideLocalRepository;
}
if (this.localRepositoryDirectory != null) {
this.overrideLocalRepository = artifactRepositoryManager.createArtifactRepository(super.getLocal().getId(), ""file://"" + this.localRepositoryDirectory.getAbsolutePath(), super.getLocal().getLayout(), super.getLocal().getSnapshots(), super.getLocal().getReleases());
this.getLog().debug(""Execution local repository is at: "" + this.overrideLocalRepository.getBasedir());
return this.overrideLocalRepository;
}
this.overrideLocalRepository = super.getLocal();
return this.overrideLocalRepository;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,TP,2,12,mavendp,1861,private List remotePluginRepositories;,private List remotePluginRepositories;
DODGY_CODE,RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE,TP,2,18,mavendp,1862,"if ( artifact != null )
","private ProjectBuildingRequest makeBuildingRequest() throws MojoExecutionException, MojoFailureException {
if (artifact == null) {
throw new MojoFailureException(""You must specify an artifact, "" + ""e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0"");
}
if (artifact != null) {
String[] tokens = artifact.split("":"");
if (tokens.length < 3 || tokens.length > 5) {
throw new MojoFailureException(""Invalid artifact, you must specify "" + ""groupId:artifactId:version[:packaging[:classifier]] "" + artifact);
}
coordinate.setGroupId(tokens[0]);
coordinate.setArtifactId(tokens[1]);
coordinate.setVersion(tokens[2]);
if (tokens.length >= 4) {
coordinate.setType(tokens[3]);
}
if (tokens.length == 5) {
coordinate.setClassifier(tokens[4]);
}
}
ArtifactRepositoryPolicy always = new ArtifactRepositoryPolicy(true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS, ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN);
List<ArtifactRepository> repoList = new ArrayList<>();
if (pomRemoteRepositories != null) {
repoList.addAll(pomRemoteRepositories);
}
if (remoteRepositories != null) {
// Use the same format as in the deploy plugin id::layout::url
String[] repos = remoteRepositories.split("","");
for (String repo : repos) {
repoList.add(parseRepository(repo, always));
}
}
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
Settings settings = session.getSettings();
repositorySystem.injectMirror(repoList, settings.getMirrors());
repositorySystem.injectProxy(repoList, settings.getProxies());
repositorySystem.injectAuthentication(repoList, settings.getServers());
buildingRequest.setRemoteRepositories(repoList);
return buildingRequest;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1863,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
PERFORMANCE,SS_SHOULD_BE_STATIC,FP,2,18,mavendp,1865,"@Parameter(property = ""mdep.useBaseVersion"", defaultValue = ""true"")
private final boolean useBaseVersion = true;","@Parameter(property = ""mdep.useBaseVersion"", defaultValue = ""true"")
private final boolean useBaseVersion = true;"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1866,private MavenProject project;,private MavenProject project;
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,TP,2,16,mavendp,1868,"marker.setLastModified( ts );
","@Override
public void setMarker() throws MojoExecutionException {
File marker = getMarkerFile();
try {
marker.getParentFile().mkdirs();
} catch (NullPointerException e) {
}
try {
marker.createNewFile();
} catch (IOException e) {
throw new MojoExecutionException(""Unable to create Marker: "" + marker.getAbsolutePath(), e);
}
try {
long ts;
if (this.artifact != null && this.artifact.getFile() != null) {
ts = this.artifact.getFile().lastModified();
} else {
ts = System.currentTimeMillis();
}
marker.setLastModified(ts);
} catch (Exception e) {
throw new MojoExecutionException(""Unable to update Marker timestamp: "" + marker.getAbsolutePath(), e);
}
}"
DODGY_CODE,DLS_DEAD_LOCAL_STORE,FP,3,20,mavendp,1869,"Set results = artifacts;
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
String useType = null;
if (StringUtils.isNotEmpty(this.type)) {
useType = this.type;
} else {
useType = artifact.getType();
}
String useClassifier = null;
if (StringUtils.isNotEmpty(this.classifier)) {
useClassifier = this.classifier;
} else {
useClassifier = artifact.getClassifier();
}
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), useType, useClassifier);
newArtifact.setScope(artifact.getScope());
results.add(newArtifact);
}
return results;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1870,private File markersDirectory;,private File markersDirectory;
DODGY_CODE,UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR,FP,3,20,mavendp,1873,"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
","protected ProjectDependencyAnalyzer createProjectDependencyAnalyzer() throws MojoExecutionException {
final String role = ProjectDependencyAnalyzer.ROLE;
final String roleHint = analyzer;
try {
final PlexusContainer container = (PlexusContainer) context.get(PlexusConstants.PLEXUS_KEY);
return (ProjectDependencyAnalyzer) container.lookup(role, roleHint);
} catch (Exception exception) {
throw new MojoExecutionException(""Failed to instantiate ProjectDependencyAnalyser with role "" + role + "" / role-hint "" + roleHint, exception);
}
}"
DODGY_CODE,NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,17,mavendp,1874,"project.getArtifacts(), project.getArtifact(), this.getLocal(),
","public void execute() throws MojoExecutionException {
try {
ArtifactResolutionResult result = this.artifactCollector.collect(project.getArtifacts(), project.getArtifact(), this.getLocal(), this.remoteRepos, this.artifactMetadataSource, new ScopeArtifactFilter(Artifact.SCOPE_TEST), new ArrayList());
HashSet repos = new HashSet();
for (Iterator<ResolutionNode> i = result.getArtifactResolutionNodes().iterator(); i.hasNext(); ) {
ResolutionNode node = i.next();
repos.addAll(node.getRemoteRepositories());
}
this.getLog().info(""Repositories Used by this build:"");
for (Iterator i = repos.iterator(); i.hasNext(); ) {
this.getLog().info(i.next().toString());
}
} catch (ArtifactResolutionException e) {
throw new MojoExecutionException(""Unable to resolve artifacts"", e);
}
}"
DODGY_CODE,RV_RETURN_VALUE_IGNORED_INFERRED,FP,2,17,mavendp,1877,"node.getDependency().setArtifact( node.getDependency().getArtifact().setProperties( artifactProperties ) );
","private void applyDependencyManagementDfs(Map<String, org.apache.maven.model.Dependency> dependencyManagementMap, DependencyNode node) {
if (dependencyManagementMap.containsKey(getDependencyManagementCoordinate(node.getArtifact()))) {
org.apache.maven.model.Dependency manager = dependencyManagementMap.get(getDependencyManagementCoordinate(node.getArtifact()));
Map<String, String> artifactProperties = new HashMap<>();
for (Map.Entry<String, String> entry : node.getArtifact().getProperties().entrySet()) {
artifactProperties.put(entry.getKey(), entry.getValue());
}
if (!manager.getVersion().equals(node.getArtifact().getVersion())) {
artifactProperties.put(PRE_MANAGED_VERSION, node.getArtifact().getVersion());
node.setArtifact(node.getArtifact().setVersion(manager.getVersion()));
}
if (!manager.getScope().equals(node.getDependency().getScope())) {
artifactProperties.put(PRE_MANAGED_SCOPE, node.getDependency().getScope());
artifactProperties.put(MANAGED_SCOPE, manager.getScope());
}
node.setArtifact(node.getArtifact().setProperties(artifactProperties));
node.getDependency().setArtifact(node.getDependency().getArtifact().setProperties(artifactProperties));
}
for (DependencyNode child : node.getChildren()) {
applyDependencyManagementDfs(dependencyManagementMap, child);
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1879,"writer = new FileWriter( file, append );
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}"
BAD_PRACTICE,RV_RETURN_VALUE_IGNORED_BAD_PRACTICE,FP,2,16,mavendp,1880,"file.getParentFile().mkdirs();
","public static synchronized void write(String string, File file, boolean append, Log log) throws IOException {
file.getParentFile().mkdirs();
FileWriter writer = null;
try {
writer = new FileWriter(file, append);
writer.write(string);
writer.close();
writer = null;
} finally {
IOUtil.close(writer);
}
}"
I18N,DM_DEFAULT_ENCODING,TP,1,19,mavendp,1881,"try ( Writer w = new BufferedWriter( new FileWriter( out ) ) )
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
try (Writer w = new BufferedWriter(new FileWriter(out))) {
w.write(cpString);
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,TP,2,12,mavendp,1882,private MavenProject project;,private MavenProject project;
CORRECTNESS,RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE,FP,2,11,mavendp,1887,"return ( cpString.equals( oldCp ) || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString.equals(oldCp) || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
PERFORMANCE,SS_SHOULD_BE_STATIC,FP,2,18,mavendp,1890,"@Parameter(property = ""mdep.stripClassifier"", defaultValue = ""false"")
private final boolean stripClassifier = false;","@Parameter(property = ""mdep.stripClassifier"", defaultValue = ""false"")
private final boolean stripClassifier = false;"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1892,"BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
","protected String readClasspathFile() throws IOException {
if (outputFile == null) {
throw new IllegalArgumentException(""The outputFile parameter cannot be null if the file is intended to be read."");
}
if (!outputFile.isFile()) {
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader(new FileReader(outputFile));
try {
String l;
while ((l = r.readLine()) != null) {
sb.append(l);
}
return sb.toString();
} finally {
r.close();
}
}"
CORRECTNESS,NP_UNWRITTEN_FIELD,FP,2,8,mavendp,1893,"Artifact newArtifact = factory.createArtifactWithClassifier( artifact.getGroupId(), artifact
","public Set translate(Set artifacts, Log log) {
Set results = artifacts;
log.debug(""Translating Artifacts using Classifier: "" + this.classifier + "" and Type: "" + this.type);
results = new HashSet();
for (Iterator i = artifacts.iterator(); i.hasNext(); ) {
Artifact artifact = (Artifact) i.next();
Artifact newArtifact = factory.createArtifactWithClassifier(artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(), this.type, this.classifier);
results.add(newArtifact);
}
return results;
}"
DODGY_CODE,UC_USELESS_OBJECT,FP,2,17,mavendp,1894,"Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>( artifacts.size() );
","protected Set<Artifact> resolvePluginArtifacts() throws ArtifactFilterException, ArtifactResolverException {
final Set<Artifact> plugins = getProject().getPluginArtifacts();
final Set<Artifact> reports = getProject().getReportArtifacts();
Set<Artifact> artifacts = new LinkedHashSet<Artifact>();
artifacts.addAll(reports);
artifacts.addAll(plugins);
final FilterArtifacts filter = getArtifactsFilter();
artifacts = filter.filter(artifacts);
Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>(artifacts.size());
for (final Artifact artifact : new LinkedHashSet<Artifact>(artifacts)) {
// String.format( "" Plugin SKIPPED: %s"", DependencyUtil.getFormattedFileName( artifact, false ) );
ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(session.getProjectBuildingRequest());
buildingRequest.setRemoteRepositories(this.remotePluginRepositories);
resolvedArtifacts.add(getArtifactResolver().resolveArtifact(buildingRequest, artifact).getArtifact());
}
return artifacts;
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,FP,2,12,mavendp,1895,private ArtifactFactory factory;,private ArtifactFactory factory;
I18N,DM_DEFAULT_ENCODING,TP,1,19,mavendp,1896,"model = pomReader.read( new FileReader( project.getFile() ) );
","public void execute() throws MojoExecutionException, MojoFailureException {
MavenXpp3Reader pomReader = new MavenXpp3Reader();
Model model = null;
try {
model = pomReader.read(new FileReader(project.getFile()));
} catch (Exception e) {
throw new MojoExecutionException(""IOException: "" + e.getMessage(), e);
}
Set<String> duplicateDependencies = new HashSet<String>();
if (model.getDependencies() != null) {
duplicateDependencies = findDuplicateDependencies(model.getDependencies());
}
Set<String> duplicateDependenciesManagement = new HashSet<String>();
if (model.getDependencyManagement() != null && model.getDependencyManagement().getDependencies() != null) {
duplicateDependenciesManagement = findDuplicateDependencies(model.getDependencyManagement().getDependencies());
}
if (getLog().isInfoEnabled()) {
StringBuffer sb = new StringBuffer();
if (!duplicateDependencies.isEmpty()) {
sb.append(""List of duplicate dependencies defined in <dependencies/> in your pom.xml:\n"");
for (Iterator<String> it = duplicateDependencies.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (!duplicateDependenciesManagement.isEmpty()) {
if (sb.length() > 0) {
sb.append(""\n"");
}
sb.append(""List of duplicate dependencies defined in <dependencyManagement/> in "" + ""your pom.xml:\n"");
for (Iterator<String> it = duplicateDependenciesManagement.iterator(); it.hasNext(); ) {
String dup = it.next();
sb.append(""\to "" + dup);
if (it.hasNext()) {
sb.append(""\n"");
}
}
}
if (sb.length() > 0) {
getLog().info(sb.toString());
} else {
getLog().info(""No duplicate dependencies found in <dependencies/> or in <dependencyManagement/>"");
}
}
}"
I18N,DM_DEFAULT_ENCODING,FP,1,19,mavendp,1897,"w = new BufferedWriter( new FileWriter( out ) );
","private void storeClasspathFile(String cpString, File out) throws MojoExecutionException {
out.getParentFile().mkdirs();
Writer w = null;
try {
w = new BufferedWriter(new FileWriter(out));
w.write(cpString);
w.close();
w = null;
getLog().info(""Wrote classpath file '"" + out + ""'."");
} catch (IOException ex) {
throw new MojoExecutionException(""Error while writing to classpath file '"" + out + ""': "" + ex.toString(), ex);
} finally {
IOUtil.close(w);
}
}"
CORRECTNESS,UWF_UNWRITTEN_FIELD,TP,3,15,mavendp,1898,private boolean excludeTransitive;,private boolean excludeTransitive;
DODGY_CODE,UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD,FP,3,20,mavendp,1899,protected boolean useSubDirectoryPerType;,protected boolean useSubDirectoryPerType;
BAD_PRACTICE,ES_COMPARING_PARAMETER_STRING_WITH_EQ,FP,3,19,mavendp,1900,"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
","private boolean isUpdToDate(String cpString) {
try {
String oldCp = readClasspathFile();
return (cpString == oldCp || (cpString != null && cpString.equals(oldCp)));
} catch (Exception ex) {
this.getLog().warn(""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: "" + ex);
return false;
}
}"
