{
    "category": "DODGY_CODE",
    "vtype": "SF_SWITCH_NO_DEFAULT",
    "priority": "2",
    "rank": "19",
    "project": "codec",
    "warning_line": "switch (modulus) { \ncase 1 : \nbuffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; \nbuffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; \nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\ncase 2 : \nbuffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n",
    "warning_method": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\nif (inAvail < 0) {\neof = true;\nif (0 == modulus && lineLength == 0) {\nreturn;\n}\nensureBufferSize(encodeSize);\nint savedPos = pos;\nswitch(modulus) {\ncase 1:\nbuffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\ncase 2:\nbuffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\ncurrentLinePos += pos - savedPos;\nif (lineLength > 0 && currentLinePos > 0) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nensureBufferSize(encodeSize);\nmodulus = (modulus + 1) % BYTES_PER_UNENCODED_BLOCK;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nbitWorkArea = (bitWorkArea << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];\ncurrentLinePos += BYTES_PER_ENCODED_BLOCK;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}"
}