{
    "category": "DODGY_CODE",
    "vtype": "SF_SWITCH_NO_DEFAULT",
    "priority": "2",
    "rank": "19",
    "project": "codec",
    "warning_line": "switch(symb) {\ncase 'A' : case 'E' : case 'I' : case 'O' : case 'U' :\nif (n == 0) {\ncode.append(symb);\n}\nbreak ; \ncase 'B' :\nif ( isPreviousChar(local, n, 'M') &&\nisLastChar(wdsz, n) ) { \nbreak;\n}\ncode.append(symb);\nbreak;\ncase 'C' : \nif ( isPreviousChar(local, n, 'S') &&\n!isLastChar(wdsz, n) &&\nFRONTV.indexOf(local.charAt(n + 1)) >= 0 ) {\nbreak;\n}\nif (regionMatch(local, n, \"CIA\")) { \ncode.append('X');\nbreak;\n}\nif (!isLastChar(wdsz, n) &&\nFRONTV.indexOf(local.charAt(n + 1)) >= 0) {\ncode.append('S');\nbreak; \n}\nif (isPreviousChar(local, n, 'S') &&\nisNextChar(local, n, 'H') ) { \ncode.append('K') ;\nbreak ;\n}\nif (isNextChar(local, n, 'H')) { \nif (n == 0 &&\nwdsz >= 3 &&\nisVowel(local,2) ) { \ncode.append('K');\n} else {\ncode.append('X'); \n}\n} else {\ncode.append('K');\n}\nbreak ;\ncase 'D' :\nif (!isLastChar(wdsz, n + 1) &&\nisNextChar(local, n, 'G') &&\nFRONTV.indexOf(local.charAt(n + 2)) >= 0) { \ncode.append('J'); n += 2 ;\n} else {\ncode.append('T');\n}\nbreak ;\ncase 'G' : \nif (isLastChar(wdsz, n + 1) &&\nisNextChar(local, n, 'H')) {\nbreak;\n}\nif (!isLastChar(wdsz, n + 1) &&\nisNextChar(local,n,'H') &&\n!isVowel(local,n+2)) {\nbreak;\n}\nif (n > 0 &&\n( regionMatch(local, n, \"GN\") ||\nregionMatch(local, n, \"GNED\") ) ) {\nbreak; \n}\nif (isPreviousChar(local, n, 'G')) {\n// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\nhard = true ;\n} else {\nhard = false ;\n}\nif (!isLastChar(wdsz, n) &&\nFRONTV.indexOf(local.charAt(n + 1)) >= 0 &&\n!hard) {\ncode.append('J');\n} else {\ncode.append('K');\n}\nbreak ;\ncase 'H':\nif (isLastChar(wdsz, n)) {\nbreak ; \n}\nif (n > 0 &&\nVARSON.indexOf(local.charAt(n - 1)) >= 0) {\nbreak;\n}\nif (isVowel(local,n+1)) {\ncode.append('H'); \n}\nbreak;\ncase 'F':\ncase 'J' :\ncase 'L' :\ncase 'M':\ncase 'N' :\ncase 'R' :\ncode.append(symb);\nbreak;\ncase 'K' :\nif (n > 0) { \nif (!isPreviousChar(local, n, 'C')) {\ncode.append(symb);\n}\n} else {\ncode.append(symb); \n}\nbreak ;\ncase 'P' :\nif (isNextChar(local,n,'H')) {\ncode.append('F');\n} else {\ncode.append(symb);\n}\nbreak ;\ncase 'Q' :\ncode.append('K');\nbreak;\ncase 'S' :\nif (regionMatch(local,n,\"SH\") ||\nregionMatch(local,n,\"SIO\") ||\nregionMatch(local,n,\"SIA\")) {\ncode.append('X');\n} else {\ncode.append('S');\n}\nbreak;\ncase 'T' :\nif (regionMatch(local,n,\"TIA\") ||\nregionMatch(local,n,\"TIO\")) {\ncode.append('X');\nbreak;\n}\nif (regionMatch(local,n,\"TCH\")) {\nbreak;\n}\nif (regionMatch(local,n,\"TH\")) {\ncode.append('0');\n} else {\ncode.append('T');\n}\nbreak ;\ncase 'V' :\ncode.append('F'); break ;\ncase 'W' : case 'Y' : \nif (!isLastChar(wdsz,n) &&\nisVowel(local,n+1)) {\ncode.append(symb);\n}\nbreak ;\ncase 'X' :\ncode.append('K'); code.append('S');\nbreak ;\ncase 'Z' :\ncode.append('S'); break ;\n",
    "warning_method": "public String metaphone(String txt) {\nboolean hard = false;\nif (txt == null || txt.length() == 0) {\nreturn \"\";\n}\nif (txt.length() == 1) {\nreturn txt.toUpperCase(java.util.Locale.ENGLISH);\n}\nchar[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray();\nStringBuilder local = new StringBuilder(40);\nStringBuilder code = new StringBuilder(10);\nswitch(inwd[0]) {\ncase 'K':\ncase 'G':\ncase 'P':\nif (inwd[1] == 'N') {\nlocal.append(inwd, 1, inwd.length - 1);\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'A':\nif (inwd[1] == 'E') {\nlocal.append(inwd, 1, inwd.length - 1);\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'W':\nif (inwd[1] == 'R') {\nlocal.append(inwd, 1, inwd.length - 1);\nbreak;\n}\nif (inwd[1] == 'H') {\nlocal.append(inwd, 1, inwd.length - 1);\nlocal.setCharAt(0, 'W');\n} else {\nlocal.append(inwd);\n}\nbreak;\ncase 'X':\ninwd[0] = 'S';\nlocal.append(inwd);\nbreak;\ndefault:\nlocal.append(inwd);\n}\nint wdsz = local.length();\nint n = 0;\nwhile (code.length() < this.getMaxCodeLen() && n < wdsz) {\nchar symb = local.charAt(n);\nif (symb != 'C' && isPreviousChar(local, n, symb)) {\nn++;\n} else {\nswitch(symb) {\ncase 'A':\ncase 'E':\ncase 'I':\ncase 'O':\ncase 'U':\nif (n == 0) {\ncode.append(symb);\n}\nbreak;\ncase 'B':\nif (isPreviousChar(local, n, 'M') && isLastChar(wdsz, n)) {\nbreak;\n}\ncode.append(symb);\nbreak;\ncase 'C':\nif (isPreviousChar(local, n, 'S') && !isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\nbreak;\n}\nif (regionMatch(local, n, \"CIA\")) {\ncode.append('X');\nbreak;\n}\nif (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0) {\ncode.append('S');\nbreak;\n}\nif (isPreviousChar(local, n, 'S') && isNextChar(local, n, 'H')) {\ncode.append('K');\nbreak;\n}\nif (isNextChar(local, n, 'H')) {\nif (n == 0 && wdsz >= 3 && isVowel(local, 2)) {\ncode.append('K');\n} else {\ncode.append('X');\n}\n} else {\ncode.append('K');\n}\nbreak;\ncase 'D':\nif (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'G') && FRONTV.indexOf(local.charAt(n + 2)) >= 0) {\ncode.append('J');\nn += 2;\n} else {\ncode.append('T');\n}\nbreak;\ncase 'G':\nif (isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H')) {\nbreak;\n}\nif (!isLastChar(wdsz, n + 1) && isNextChar(local, n, 'H') && !isVowel(local, n + 2)) {\nbreak;\n}\nif (n > 0 && (regionMatch(local, n, \"GN\") || regionMatch(local, n, \"GNED\"))) {\nbreak;\n}\nif (isPreviousChar(local, n, 'G')) {\n// NOTE: Given that duplicated chars are removed, I don't see how this can ever be true\nhard = true;\n} else {\nhard = false;\n}\nif (!isLastChar(wdsz, n) && FRONTV.indexOf(local.charAt(n + 1)) >= 0 && !hard) {\ncode.append('J');\n} else {\ncode.append('K');\n}\nbreak;\ncase 'H':\nif (isLastChar(wdsz, n)) {\nbreak;\n}\nif (n > 0 && VARSON.indexOf(local.charAt(n - 1)) >= 0) {\nbreak;\n}\nif (isVowel(local, n + 1)) {\ncode.append('H');\n}\nbreak;\ncase 'F':\ncase 'J':\ncase 'L':\ncase 'M':\ncase 'N':\ncase 'R':\ncode.append(symb);\nbreak;\ncase 'K':\nif (n > 0) {\nif (!isPreviousChar(local, n, 'C')) {\ncode.append(symb);\n}\n} else {\ncode.append(symb);\n}\nbreak;\ncase 'P':\nif (isNextChar(local, n, 'H')) {\ncode.append('F');\n} else {\ncode.append(symb);\n}\nbreak;\ncase 'Q':\ncode.append('K');\nbreak;\ncase 'S':\nif (regionMatch(local, n, \"SH\") || regionMatch(local, n, \"SIO\") || regionMatch(local, n, \"SIA\")) {\ncode.append('X');\n} else {\ncode.append('S');\n}\nbreak;\ncase 'T':\nif (regionMatch(local, n, \"TIA\") || regionMatch(local, n, \"TIO\")) {\ncode.append('X');\nbreak;\n}\nif (regionMatch(local, n, \"TCH\")) {\nbreak;\n}\nif (regionMatch(local, n, \"TH\")) {\ncode.append('0');\n} else {\ncode.append('T');\n}\nbreak;\ncase 'V':\ncode.append('F');\nbreak;\ncase 'W':\ncase 'Y':\nif (!isLastChar(wdsz, n) && isVowel(local, n + 1)) {\ncode.append(symb);\n}\nbreak;\ncase 'X':\ncode.append('K');\ncode.append('S');\nbreak;\ncase 'Z':\ncode.append('S');\nbreak;\n}\nn++;\n}\nif (code.length() > this.getMaxCodeLen()) {\ncode.setLength(this.getMaxCodeLen());\n}\n}\nreturn code.toString();\n}"
}