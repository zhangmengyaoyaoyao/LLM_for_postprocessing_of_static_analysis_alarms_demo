{
    "category": "DODGY_CODE",
    "vtype": "SF_SWITCH_NO_DEFAULT",
    "priority": "2",
    "rank": "19",
    "project": "codec",
    "warning_line": "switch (modulus) {\ncase 2 : \nx = x >> 4;\nbuffer[pos++] = (byte) ((x) & MASK_8BITS);\nbreak;\ncase 3 : \nx = x >> 2;\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x) & MASK_8BITS);\n",
    "warning_method": "void decode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\nif (inAvail < 0) {\neof = true;\n}\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\n}\nbyte b = in[inPos++];\nif (b == PAD) {\neof = true;\nbreak;\n} else {\nif (b >= 0 && b < DECODE_TABLE.length) {\nint result = DECODE_TABLE[b];\nif (result >= 0) {\nmodulus = (++modulus) % 4;\nx = (x << 6) + result;\nif (modulus == 0) {\nbuffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) (x & MASK_8BITS);\n}\n}\n}\n}\n}\n// Two forms of EOF as far as base64 decoder is concerned: actual\nif (eof && modulus != 0) {\nif (buffer == null || buffer.length - pos < decodeSize) {\nresizeBuffer();\n}\nswitch(modulus) {\ncase 2:\nx = x >> 4;\nbuffer[pos++] = (byte) ((x) & MASK_8BITS);\nbreak;\ncase 3:\nx = x >> 2;\nbuffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\nbuffer[pos++] = (byte) ((x) & MASK_8BITS);\nbreak;\n}\n}\n}"
}