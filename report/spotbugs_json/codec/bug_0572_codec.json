{
    "category": "DODGY_CODE",
    "vtype": "SF_SWITCH_NO_DEFAULT",
    "priority": "2",
    "rank": "19",
    "project": "codec",
    "warning_line": "switch (context.modulus) {\ncase 2 : \ncontext.ibitWorkArea = context.ibitWorkArea >> 4; \nbuffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\nbreak;\ncase 3 : \ncontext.ibitWorkArea = context.ibitWorkArea >> 2; \nbuffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\n",
    "warning_method": "@Override\nvoid decode(byte[] in, int inPos, int inAvail, Context context) {\nif (context.eof) {\nreturn;\n}\nif (inAvail < 0) {\ncontext.eof = true;\n}\nfor (int i = 0; i < inAvail; i++) {\nfinal byte[] buffer = ensureBufferSize(decodeSize, context);\nfinal byte b = in[inPos++];\nif (b == PAD) {\ncontext.eof = true;\nbreak;\n} else {\nif (b >= 0 && b < DECODE_TABLE.length) {\nfinal int result = DECODE_TABLE[b];\nif (result >= 0) {\ncontext.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\ncontext.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;\nif (context.modulus == 0) {\nbuffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);\n}\n}\n}\n}\n}\n// Two forms of EOF as far as base64 decoder is concerned: actual\nif (context.eof && context.modulus != 0) {\nfinal byte[] buffer = ensureBufferSize(decodeSize, context);\nswitch(context.modulus) {\ncase 2:\ncontext.ibitWorkArea = context.ibitWorkArea >> 4;\nbuffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\nbreak;\ncase 3:\ncontext.ibitWorkArea = context.ibitWorkArea >> 2;\nbuffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);\nbreak;\n}\n}\n}"
}