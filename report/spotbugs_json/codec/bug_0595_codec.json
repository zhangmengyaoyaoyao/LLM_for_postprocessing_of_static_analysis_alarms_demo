{
    "category": "PERFORMANCE",
    "vtype": "DM_BOXED_PRIMITIVE_FOR_PARSING",
    "priority": "1",
    "rank": "16",
    "project": "codec",
    "warning_line": "rounds = Integer.valueOf(m.group(3));\n",
    "warning_method": "private static String sha2Crypt(byte[] keyBytes, String salt, String saltPrefix, int blocksize, String algorithm) throws Exception {\nint keyLen = keyBytes.length;\nint rounds = ROUNDS_DEFAULT;\nboolean roundsCustom = false;\nif (salt == null) {\nthrow new IllegalArgumentException(\"Invalid salt value: null\");\n}\nPattern p = Pattern.compile(\"^\\\\$([56])\\\\$(rounds=(\\\\d+)\\\\$)?([\\\\.\\\\/a-zA-Z0-9]{1,16}).*\");\nMatcher m = p.matcher(salt);\nif (m == null || !m.find()) {\nthrow new IllegalArgumentException(\"Invalid salt value: \" + salt);\n}\nif (m.group(3) != null) {\nrounds = Integer.valueOf(m.group(3));\nrounds = Math.max(ROUNDS_MIN, Math.min(ROUNDS_MAX, rounds));\nroundsCustom = true;\n}\nString saltString = m.group(4);\nbyte[] saltBytes = saltString.getBytes(\"UTF-8\");\nint saltLen = saltBytes.length;\nMessageDigest ctx = MessageDigest.getInstance(algorithm);\nctx.update(keyBytes);\n// NB: the MD5 algorithm did add the $1$ salt_prefix. This is not deemed\nctx.update(saltBytes);\nMessageDigest altCtx = MessageDigest.getInstance(algorithm);\naltCtx.update(keyBytes);\naltCtx.update(saltBytes);\naltCtx.update(keyBytes);\nbyte[] altResult = altCtx.digest();\nint cnt = keyBytes.length;\nwhile (cnt > blocksize) {\nctx.update(altResult, 0, blocksize);\ncnt -= blocksize;\n}\nctx.update(altResult, 0, cnt);\n// NB: this step differs significantly from the MD5 algorithm. It\ncnt = keyBytes.length;\nwhile (cnt > 0) {\nif ((cnt & 1) != 0) {\nctx.update(altResult, 0, blocksize);\n} else {\nctx.update(keyBytes);\n}\ncnt >>= 1;\n}\naltResult = ctx.digest();\naltCtx = MessageDigest.getInstance(algorithm);\nfor (int i = 1; i <= keyLen; i++) {\naltCtx.update(keyBytes);\n}\nbyte[] tempResult = altCtx.digest();\nbyte[] pBytes = new byte[keyLen];\nint cp = 0;\nwhile (cp < keyLen - blocksize) {\nSystem.arraycopy(tempResult, 0, pBytes, cp, blocksize);\ncp += blocksize;\n}\nSystem.arraycopy(tempResult, 0, pBytes, cp, keyLen - cp);\naltCtx = MessageDigest.getInstance(algorithm);\nfor (int i = 1; i <= 16 + (altResult[0] & 0xff); i++) {\naltCtx.update(saltBytes);\n}\ntempResult = altCtx.digest();\n// Remark: The salt is limited to 16 chars, how does this make sense?\nbyte[] sBytes = new byte[saltLen];\ncp = 0;\nwhile (cp < saltLen - blocksize) {\nSystem.arraycopy(tempResult, 0, sBytes, cp, blocksize);\ncp += blocksize;\n}\nSystem.arraycopy(tempResult, 0, sBytes, cp, saltLen - cp);\nfor (int i = 0; i <= rounds - 1; i++) {\nctx = MessageDigest.getInstance(algorithm);\nif ((i & 1) != 0) {\nctx.update(pBytes, 0, keyLen);\n} else {\nctx.update(altResult, 0, blocksize);\n}\nif (i % 3 != 0) {\nctx.update(sBytes, 0, saltLen);\n}\nif (i % 7 != 0) {\nctx.update(pBytes, 0, keyLen);\n}\nif ((i & 1) != 0) {\nctx.update(altResult, 0, blocksize);\n} else {\nctx.update(pBytes, 0, keyLen);\n}\naltResult = ctx.digest();\n}\n// size specified above, consisting of multiple pieces:\nStringBuilder buffer = new StringBuilder(saltPrefix + (roundsCustom ? ROUNDS_PREFIX + rounds + \"$\" : \"\") + saltString + \"$\");\n// follows:\n// characters as output:\n// 1. character: the six low bits of the first byte\n// 2. character: the two high bits of the first byte and the\n// 3. character: the four high bytes from the second byte and\n// 4. character: the six high bits from the third byte\n// This was just a safeguard in the C implementation:\nif (blocksize == 32) {\nB64.b64from24bit(altResult[0], altResult[10], altResult[20], 4, buffer);\nB64.b64from24bit(altResult[21], altResult[1], altResult[11], 4, buffer);\nB64.b64from24bit(altResult[12], altResult[22], altResult[2], 4, buffer);\nB64.b64from24bit(altResult[3], altResult[13], altResult[23], 4, buffer);\nB64.b64from24bit(altResult[24], altResult[4], altResult[14], 4, buffer);\nB64.b64from24bit(altResult[15], altResult[25], altResult[5], 4, buffer);\nB64.b64from24bit(altResult[6], altResult[16], altResult[26], 4, buffer);\nB64.b64from24bit(altResult[27], altResult[7], altResult[17], 4, buffer);\nB64.b64from24bit(altResult[18], altResult[28], altResult[8], 4, buffer);\nB64.b64from24bit(altResult[9], altResult[19], altResult[29], 4, buffer);\nB64.b64from24bit((byte) 0, altResult[31], altResult[30], 3, buffer);\n} else {\nB64.b64from24bit(altResult[0], altResult[21], altResult[42], 4, buffer);\nB64.b64from24bit(altResult[22], altResult[43], altResult[1], 4, buffer);\nB64.b64from24bit(altResult[44], altResult[2], altResult[23], 4, buffer);\nB64.b64from24bit(altResult[3], altResult[24], altResult[45], 4, buffer);\nB64.b64from24bit(altResult[25], altResult[46], altResult[4], 4, buffer);\nB64.b64from24bit(altResult[47], altResult[5], altResult[26], 4, buffer);\nB64.b64from24bit(altResult[6], altResult[27], altResult[48], 4, buffer);\nB64.b64from24bit(altResult[28], altResult[49], altResult[7], 4, buffer);\nB64.b64from24bit(altResult[50], altResult[8], altResult[29], 4, buffer);\nB64.b64from24bit(altResult[9], altResult[30], altResult[51], 4, buffer);\nB64.b64from24bit(altResult[31], altResult[52], altResult[10], 4, buffer);\nB64.b64from24bit(altResult[53], altResult[11], altResult[32], 4, buffer);\nB64.b64from24bit(altResult[12], altResult[33], altResult[54], 4, buffer);\nB64.b64from24bit(altResult[34], altResult[55], altResult[13], 4, buffer);\nB64.b64from24bit(altResult[56], altResult[14], altResult[35], 4, buffer);\nB64.b64from24bit(altResult[15], altResult[36], altResult[57], 4, buffer);\nB64.b64from24bit(altResult[37], altResult[58], altResult[16], 4, buffer);\nB64.b64from24bit(altResult[59], altResult[17], altResult[38], 4, buffer);\nB64.b64from24bit(altResult[18], altResult[39], altResult[60], 4, buffer);\nB64.b64from24bit(altResult[40], altResult[61], altResult[19], 4, buffer);\nB64.b64from24bit(altResult[62], altResult[20], altResult[41], 4, buffer);\nB64.b64from24bit((byte) 0, (byte) 0, altResult[63], 2, buffer);\n}\nArrays.fill(tempResult, (byte) 0);\nArrays.fill(pBytes, (byte) 0);\nArrays.fill(sBytes, (byte) 0);\nctx.reset();\naltCtx.reset();\nArrays.fill(keyBytes, (byte) 0);\nArrays.fill(saltBytes, (byte) 0);\nreturn buffer.toString();\n}"
}