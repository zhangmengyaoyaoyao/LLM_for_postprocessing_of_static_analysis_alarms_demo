{
    "category": "Multithreaded correctness",
    "vtype": "NN_NAKED_NOTIFY",
    "priority": "2",
    "rank": "14",
    "project": "pool",
    "warning_line": "latch.notify();\n",
    "warning_method": "private void allocate() {\nboolean clearOldest = false;\nsynchronized (this) {\nif (isClosed())\nreturn;\nfor (; ; ) {\nif (!_allocationQueue.isEmpty()) {\nLatch latch = (Latch) _allocationQueue.getFirst();\nObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(latch.getkey(), pool);\n_poolList.add(latch.getkey());\n}\nlatch.setPool(pool);\nif (!pool.queue.isEmpty()) {\n_allocationQueue.removeFirst();\nlatch.setPair((ObjectTimestampPair) pool.queue.removeFirst());\npool.incrementInternalProcessingCount();\n_totalIdle--;\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {\nclearOldest = true;\nbreak;\n}\nif ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {\n_allocationQueue.removeFirst();\nlatch.setMayCreate(true);\npool.incrementInternalProcessingCount();\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\n}\nbreak;\n}\n}\nif (clearOldest) {\nclearOldest();\n}\n}"
}