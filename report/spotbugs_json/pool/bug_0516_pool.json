{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "pool",
    "warning_line": "public class GenericObjectPool<T> extends BaseObjectPool<T> implements ObjectPool<T> {\npublic static final byte WHEN_EXHAUSTED_FAIL   = 0;\npublic static final byte WHEN_EXHAUSTED_BLOCK  = 1;\npublic static final byte WHEN_EXHAUSTED_GROW   = 2;\npublic static final int DEFAULT_MAX_IDLE  = 8;\npublic static final int DEFAULT_MIN_IDLE = 0;\npublic static final int DEFAULT_MAX_ACTIVE  = 8;\npublic static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;\npublic static final boolean DEFAULT_LIFO = true;\npublic static final long DEFAULT_MAX_WAIT = -1L;\npublic static final boolean DEFAULT_TEST_ON_BORROW = false;\npublic static final boolean DEFAULT_TEST_ON_RETURN = false;\npublic static final boolean DEFAULT_TEST_WHILE_IDLE = false;\npublic static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;\npublic static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;\npublic static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;\npublic static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;\npublic GenericObjectPool() {\nthis(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,\nDEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,\nDEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory) {\nthis(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,\nDEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,\nDEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, GenericObjectPool.Config config) {\nthis(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,\nconfig.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,\nconfig.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,\nconfig.softMinEvictableIdleTimeMillis, config.lifo);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive) {\nthis(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,\nDEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,\nDEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,\nDEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,\nboolean testOnBorrow, boolean testOnReturn) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,\ntestOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,\nDEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,\nint maxIdle, boolean testOnBorrow, boolean testOnReturn) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,\nDEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,\nint maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,\nint numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,\ntimeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,\nint maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,\nint numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,\ntimeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,\nDEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,\nint maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,\nint numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,\nlong softMinEvictableIdleTimeMillis) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,\ntimeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,\nsoftMinEvictableIdleTimeMillis, DEFAULT_LIFO);\n}\npublic GenericObjectPool(PoolableObjectFactory<T> factory, int maxActive, byte whenExhaustedAction, long maxWait,\nint maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,\nint numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,\nlong softMinEvictableIdleTimeMillis, boolean lifo) {\n_factory = factory;\n_maxActive = maxActive;\n_lifo = lifo;\nswitch(whenExhaustedAction) {\ncase WHEN_EXHAUSTED_BLOCK:\ncase WHEN_EXHAUSTED_FAIL:\ncase WHEN_EXHAUSTED_GROW:\n_whenExhaustedAction = whenExhaustedAction;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"whenExhaustedAction \" + whenExhaustedAction + \" not recognized.\");\n}\n_maxWait = maxWait;\n_maxIdle = maxIdle;\n_minIdle = minIdle;\n_testOnBorrow = testOnBorrow;\n_testOnReturn = testOnReturn;\n_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;\n_numTestsPerEvictionRun = numTestsPerEvictionRun;\n_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;\n_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;\n_testWhileIdle = testWhileIdle;\n_pool = new CursorableLinkedList<ObjectTimestampPair<T>>();\nstartEvictor(_timeBetweenEvictionRunsMillis);\n}\npublic synchronized int getMaxActive() {\nreturn _maxActive;\n}\npublic void setMaxActive(int maxActive) {\nsynchronized(this) {\n_maxActive = maxActive;\n}\nallocate();\n}\npublic synchronized byte getWhenExhaustedAction() {\nreturn _whenExhaustedAction;\n}\npublic void setWhenExhaustedAction(byte whenExhaustedAction) {\nsynchronized(this) {\nswitch(whenExhaustedAction) {\ncase WHEN_EXHAUSTED_BLOCK:\ncase WHEN_EXHAUSTED_FAIL:\ncase WHEN_EXHAUSTED_GROW:\n_whenExhaustedAction = whenExhaustedAction;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"whenExhaustedAction \" + whenExhaustedAction + \" not recognized.\");\n}\n}\nallocate();\n}\npublic synchronized long getMaxWait() {\nreturn _maxWait;\n}\npublic void setMaxWait(long maxWait) {\nsynchronized(this) {\n_maxWait = maxWait;\n}\nallocate();\n}\npublic synchronized int getMaxIdle() {\nreturn _maxIdle;\n}\npublic void setMaxIdle(int maxIdle) {\nsynchronized(this) {\n_maxIdle = maxIdle;\n}\nallocate();\n}\npublic void setMinIdle(int minIdle) {\nsynchronized(this) {\n_minIdle = minIdle;\n}\nallocate();\n}\npublic synchronized int getMinIdle() {\nreturn _minIdle;\n}\npublic boolean getTestOnBorrow() {\nreturn _testOnBorrow;\n}\npublic void setTestOnBorrow(boolean testOnBorrow) {\n_testOnBorrow = testOnBorrow;\n}\npublic boolean getTestOnReturn() {\nreturn _testOnReturn;\n}\npublic void setTestOnReturn(boolean testOnReturn) {\n_testOnReturn = testOnReturn;\n}\npublic synchronized long getTimeBetweenEvictionRunsMillis() {\nreturn _timeBetweenEvictionRunsMillis;\n}\npublic synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {\n_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;\nstartEvictor(_timeBetweenEvictionRunsMillis);\n}\npublic synchronized int getNumTestsPerEvictionRun() {\nreturn _numTestsPerEvictionRun;\n}\npublic synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {\n_numTestsPerEvictionRun = numTestsPerEvictionRun;\n}\npublic synchronized long getMinEvictableIdleTimeMillis() {\nreturn _minEvictableIdleTimeMillis;\n}\npublic synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {\n_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;\n}\npublic synchronized long getSoftMinEvictableIdleTimeMillis() {\nreturn _softMinEvictableIdleTimeMillis;\n}\npublic synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {\n_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;\n}\npublic synchronized boolean getTestWhileIdle() {\nreturn _testWhileIdle;\n}\npublic synchronized void setTestWhileIdle(boolean testWhileIdle) {\n_testWhileIdle = testWhileIdle;\n}\npublic synchronized boolean getLifo() {\nreturn _lifo;\n}\npublic synchronized void setLifo(boolean lifo) {\nthis._lifo = lifo;\n}\npublic void setConfig(GenericObjectPool.Config conf) {\nsynchronized (this) {\nsetMaxIdle(conf.maxIdle);\nsetMinIdle(conf.minIdle);\nsetMaxActive(conf.maxActive);\nsetMaxWait(conf.maxWait);\nsetWhenExhaustedAction(conf.whenExhaustedAction);\nsetTestOnBorrow(conf.testOnBorrow);\nsetTestOnReturn(conf.testOnReturn);\nsetTestWhileIdle(conf.testWhileIdle);\nsetNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);\nsetMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);\nsetTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);\nsetSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);\nsetLifo(conf.lifo);\n}\nallocate();\n}\n@Override\npublic T borrowObject() throws Exception {\nlong starttime = System.currentTimeMillis();\nLatch<T> latch = new Latch<T>();\nbyte whenExhaustedAction;\nlong maxWait;\nsynchronized (this) {\nwhenExhaustedAction = _whenExhaustedAction;\nmaxWait = _maxWait;\n_allocationQueue.add(latch);\n}\nallocate();\nfor(;;) {\nsynchronized (this) {\nassertOpen();\n}\nif(latch.getPair() == null) {\nif(latch.mayCreate()) {\n} else {\nswitch(whenExhaustedAction) {\ncase WHEN_EXHAUSTED_GROW:\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n_numInternalProcessing++;\n}\n}\nbreak;\ncase WHEN_EXHAUSTED_FAIL:\nsynchronized (this) {\nif (latch.getPair() != null || latch.mayCreate()) {\nbreak;\n}\n_allocationQueue.remove(latch);\n}\nthrow new NoSuchElementException(\"Pool exhausted\");\ncase WHEN_EXHAUSTED_BLOCK:\ntry {\nsynchronized (latch) {\nif (latch.getPair() == null && !latch.mayCreate()) {\nif(maxWait <= 0) {\nlatch.wait();\n} else {\nfinal long elapsed = (System.currentTimeMillis() - starttime);\nfinal long waitTime = maxWait - elapsed;\nif (waitTime > 0)\n{\nlatch.wait(waitTime);\n}\n}\n} else {\nbreak;\n}\n}\nif(isClosed() == true) {\nthrow new IllegalStateException(\"Pool closed\");\n}\n} catch(InterruptedException e) {\nboolean doAllocate = false;\nsynchronized(this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n} else if (latch.getPair() == null && latch.mayCreate()) {\n_numInternalProcessing--;\ndoAllocate = true;\n} else {\n_numInternalProcessing--;\n_numActive++;\nreturnObject(latch.getPair().getValue());\n}\n}\nif (doAllocate) {\nallocate();\n}\nThread.currentThread().interrupt();\nthrow e;\n}\nif(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {\nsynchronized(this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n} else {\nbreak;\n}\n}\nthrow new NoSuchElementException(\"Timeout waiting for idle object\");\n} else {\ncontinue; \n}\ndefault:\nthrow new IllegalArgumentException(\"WhenExhaustedAction property \" + whenExhaustedAction +\n\" not recognized.\");\n}\n}\n}\nboolean newlyCreated = false;\nif(null == latch.getPair()) {\ntry {\nT obj = _factory.makeObject();\nlatch.setPair(new ObjectTimestampPair<T>(obj));\nnewlyCreated = true;\n} finally {\nif (!newlyCreated) {\nsynchronized (this) {\n_numInternalProcessing--;\n}\nallocate();\n}\n}\n}\ntry {\n_factory.activateObject(latch.getPair().value);\nif(_testOnBorrow &&\n!_factory.validateObject(latch.getPair().value)) {\nthrow new Exception(\"ValidateObject failed\");\n}\nsynchronized(this) {\n_numInternalProcessing--;\n_numActive++;\n}\nreturn latch.getPair().value;\n}\ncatch (Throwable e) {\nPoolUtils.checkRethrow(e);\ntry {\n_factory.destroyObject(latch.getPair().value);\n} catch (Throwable e2) {\nPoolUtils.checkRethrow(e2);\n}\nsynchronized (this) {\n_numInternalProcessing--;\nif (!newlyCreated) {\nlatch.reset();\n_allocationQueue.add(0, latch);\n}\n}\nallocate();\nif(newlyCreated) {\nthrow new NoSuchElementException(\"Could not create a validated object, cause: \" + e.getMessage());\n}\nelse {\ncontinue; \n}\n}\n}\n}\nprivate synchronized void allocate() {\nif (isClosed()) return;\nfor (;;) {\nif (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {\nLatch<T> latch = _allocationQueue.removeFirst();\nlatch.setPair( _pool.removeFirst());\n_numInternalProcessing++;\nsynchronized (latch) {\nlatch.notify();\n}\n} else {\nbreak;\n}\n}\nfor(;;) {\nif((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {\nLatch<T> latch = _allocationQueue.removeFirst();\nlatch.setMayCreate(true);\n_numInternalProcessing++;\nsynchronized (latch) {\nlatch.notify();\n}\n} else {\nbreak;\n}\n}\n}\n@Override\npublic void invalidateObject(T obj) throws Exception {\ntry {\nif (_factory != null) {\n_factory.destroyObject(obj);\n}\n} finally {\nsynchronized (this) {\n_numActive--;\n}\nallocate();\n}\n}\n@Override\npublic void clear() {\nList<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();\nsynchronized(this) {\ntoDestroy.addAll(_pool);\n_numInternalProcessing = _numInternalProcessing + _pool._size;\n_pool.clear();\n}\ndestroy(toDestroy, _factory);\n}\nprivate void destroy(Collection<ObjectTimestampPair<T>> c, PoolableObjectFactory<T> factory) {\nfor (Iterator<ObjectTimestampPair<T>> it = c.iterator(); it.hasNext();) {\ntry {\nfactory.destroyObject(it.next().value);\n} catch(Exception e) {\n} finally {\nsynchronized(this) {\n_numInternalProcessing--;\n}\nallocate();\n}\n}\n}\n@Override\npublic synchronized int getNumActive() {\nreturn _numActive;\n}\n@Override\npublic synchronized int getNumIdle() {\nreturn _pool.size();\n}\n@Override\npublic void returnObject(T obj) throws Exception {\ntry {\naddObjectToPool(obj, true);\n} catch (Exception e) {\nif (_factory != null) {\ntry {\n_factory.destroyObject(obj);\n} catch (Exception e2) {\n}\n// TODO: Correctness here depends on control in addObjectToPool.\nsynchronized(this) {\n_numActive--;\n}\nallocate();\n}\n}\n}\nprivate void addObjectToPool(T obj, boolean decrementNumActive) throws Exception {\nboolean success = true;\nif(_testOnReturn && !(_factory.validateObject(obj))) {\nsuccess = false;\n} else {\n_factory.passivateObject(obj);\n}\nboolean shouldDestroy = !success;\nboolean doAllocate = false;\nsynchronized (this) {\nif (isClosed()) {\nshouldDestroy = true;\n} else {\nif((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {\nshouldDestroy = true;\n} else if(success) {\nif (_lifo) {\n_pool.addFirst(new ObjectTimestampPair<T>(obj));\n} else {\n_pool.addLast(new ObjectTimestampPair<T>(obj));\n}\nif (decrementNumActive) {\n_numActive--;\n}\ndoAllocate = true;\n}\n}\n}\nif (doAllocate) {\nallocate();\n}\nif(shouldDestroy) {\ntry {\n_factory.destroyObject(obj);\n} catch(Exception e) {\n}\nif (decrementNumActive) {\nsynchronized(this) {\n_numActive--;\n}\nallocate();\n}\n}\n}\n@Override\npublic void close() throws Exception {\nsuper.close();\nsynchronized (this) {\nclear();\nstartEvictor(-1L);\nwhile(_allocationQueue.size() > 0) {\nLatch<T> l = _allocationQueue.removeFirst();\nsynchronized (l) {\nl.notify();\n}\n}\n}\n}\n@Deprecated\n@Override\npublic void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {\nList<ObjectTimestampPair<T>> toDestroy = new ArrayList<ObjectTimestampPair<T>>();\nfinal PoolableObjectFactory<T> oldFactory = _factory;\nsynchronized (this) {\nassertOpen();\nif(0 < getNumActive()) {\nthrow new IllegalStateException(\"Objects are already active\");\n} else {\ntoDestroy.addAll(_pool);\n_numInternalProcessing = _numInternalProcessing + _pool._size;\n_pool.clear();\n}\n_factory = factory;\n}\ndestroy(toDestroy, oldFactory);\n}\npublic void evict() throws Exception {\nassertOpen();\nsynchronized (this) {\nif(_pool.isEmpty()) {\nreturn;\n}\nif (null == _evictionCursor) {\n_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);\n}\n}\nfor (int i=0,m=getNumTests();i<m;i++) {\nfinal ObjectTimestampPair<T> pair;\nsynchronized (this) {\nif ((_lifo && !_evictionCursor.hasPrevious()) ||\n!_lifo && !_evictionCursor.hasNext()) {\n_evictionCursor.close();\n_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);\n}\npair = _lifo ?\n_evictionCursor.previous() :\n_evictionCursor.next();\n_evictionCursor.remove();\n_numInternalProcessing++;\n}\nboolean removeObject = false;\nfinal long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;\nif ((getMinEvictableIdleTimeMillis() > 0) &&\n(idleTimeMilis > getMinEvictableIdleTimeMillis())) {\nremoveObject = true;\n} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&\n(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&\n((getNumIdle() + 1)> getMinIdle())) { \nremoveObject = true;\n}\nif(getTestWhileIdle() && !removeObject) {\nboolean active = false;\ntry {\n_factory.activateObject(pair.value);\nactive = true;\n} catch(Exception e) {\nremoveObject=true;\n}\nif(active) {\nif(!_factory.validateObject(pair.value)) {\nremoveObject=true;\n} else {\ntry {\n_factory.passivateObject(pair.value);\n} catch(Exception e) {\nremoveObject=true;\n}\n}\n}\n}\nif (removeObject) {\ntry {\n_factory.destroyObject(pair.value);\n} catch(Exception e) {\n}\n}\nsynchronized (this) {\nif(!removeObject) {\n_evictionCursor.add(pair);\nif (_lifo) {\n_evictionCursor.previous();\n}\n}\n_numInternalProcessing--;\n}\n}\nallocate();\n}\nprivate void ensureMinIdle() throws Exception {\nint objectDeficit = calculateDeficit(false);\nfor ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {\ntry {\naddObject();\n} finally {\nsynchronized (this) {\n_numInternalProcessing--;\n}\nallocate();\n}\n}\n}\nprivate synchronized int calculateDeficit(boolean incrementInternal) {\nint objectDeficit = getMinIdle() - getNumIdle();\nif (_maxActive > 0) {\nint growLimit = Math.max(0,\ngetMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);\nobjectDeficit = Math.min(objectDeficit, growLimit);\n}\nif (incrementInternal && objectDeficit >0) {\n_numInternalProcessing++;\n}\nreturn objectDeficit;\n}\n@Override\npublic void addObject() throws Exception {\nassertOpen();\nif (_factory == null) {\nthrow new IllegalStateException(\"Cannot add objects without a factory.\");\n}\nT obj = _factory.makeObject();\ntry {\nassertOpen();\naddObjectToPool(obj, false);\n} catch (IllegalStateException ex) { \ntry {\n_factory.destroyObject(obj);\n} catch (Exception ex2) {\n}\nthrow ex;\n}\n}\nprotected synchronized void startEvictor(long delay) {\nif(null != _evictor) {\nEvictionTimer.cancel(_evictor);\n_evictor = null;\n}\nif(delay > 0) {\n_evictor = new Evictor();\nEvictionTimer.schedule(_evictor, delay, delay);\n}\n}\nsynchronized String debugInfo() {\nStringBuffer buf = new StringBuffer();\nbuf.append(\"Active: \").append(getNumActive()).append(\"\\n\");\nbuf.append(\"Idle: \").append(getNumIdle()).append(\"\\n\");\nbuf.append(\"Idle Objects:\\n\");\nIterator<ObjectTimestampPair<T>> it = _pool.iterator();\nlong time = System.currentTimeMillis();\nwhile(it.hasNext()) {\nObjectTimestampPair<T> pair = it.next();\nbuf.append(\"\\t\").append(pair.value).append(\"\\t\").append(time - pair.tstamp).append(\"\\n\");\n}\nreturn buf.toString();\n}\nprivate int getNumTests() {\nif(_numTestsPerEvictionRun >= 0) {\nreturn Math.min(_numTestsPerEvictionRun, _pool.size());\n} else {\nreturn(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));\n}\n}\nprivate class Evictor extends TimerTask {\n@Override\npublic void run() {\ntry {\nevict();\n} catch(Exception e) {\n} catch(OutOfMemoryError oome) {\noome.printStackTrace(System.err);\n}\ntry {\nensureMinIdle();\n} catch(Exception e) {\n}\n}\n}\npublic static class Config {\n//CHECKSTYLE: stop VisibilityModifier\npublic int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;\npublic int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;\npublic int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;\npublic long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;\npublic byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;\npublic boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;\npublic boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;\npublic boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;\npublic long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;\npublic int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;\npublic long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;\npublic long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;\npublic boolean lifo = GenericObjectPool.DEFAULT_LIFO;\n//CHECKSTYLE: resume VisibilityModifier\n}\nprivate static final class Latch<T> {\nprivate ObjectTimestampPair<T> _pair;\nprivate boolean _mayCreate = false;\nprivate synchronized ObjectTimestampPair<T> getPair() {\nreturn _pair;\n}\nprivate synchronized void setPair(ObjectTimestampPair<T> pair) {\n_pair = pair;\n}\nprivate synchronized boolean mayCreate() {\nreturn _mayCreate;\n}\nprivate synchronized void setMayCreate(boolean mayCreate) {\n_mayCreate = mayCreate;\n}\nprivate synchronized void reset() {\n_pair = null;\n_mayCreate = false;\n}\n}\nprivate int _maxIdle = DEFAULT_MAX_IDLE;\nprivate int _minIdle = DEFAULT_MIN_IDLE;\nprivate int _maxActive = DEFAULT_MAX_ACTIVE;\nprivate long _maxWait = DEFAULT_MAX_WAIT;\nprivate byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;\nprivate volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;\nprivate volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;\nprivate boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;\nprivate long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;\nprivate int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;\nprivate long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;\nprivate long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;\nprivate boolean _lifo = DEFAULT_LIFO;\nprivate CursorableLinkedList<ObjectTimestampPair<T>> _pool = null;\nprivate CursorableLinkedList<ObjectTimestampPair<T>>.Cursor _evictionCursor = null;\nprivate PoolableObjectFactory<T> _factory = null;\nprivate int _numActive = 0;\nprivate Evictor _evictor = null;\nprivate int _numInternalProcessing = 0;\nprivate final LinkedList<Latch<T>> _allocationQueue = new LinkedList<Latch<T>>();\n",
    "warning_method": "@Override\npublic void addObject() throws Exception {\nassertOpen();\nif (_factory == null) {\nthrow new IllegalStateException(\"Cannot add objects without a factory.\");\n}\nT obj = _factory.makeObject();\ntry {\nassertOpen();\naddObjectToPool(obj, false);\n} catch (IllegalStateException ex) {\ntry {\n_factory.destroyObject(obj);\n} catch (Exception ex2) {\n}\nthrow ex;\n}\n}"
}