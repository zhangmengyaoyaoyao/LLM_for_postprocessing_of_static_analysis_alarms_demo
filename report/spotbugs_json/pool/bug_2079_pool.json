{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "pool",
    "warning_line": "this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);\n}\npublic StackKeyedObjectPool(int max) {\nthis((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);\n}\npublic StackKeyedObjectPool(int max, int init) {\nthis((KeyedPoolableObjectFactory)null,max,init);\n}\npublic StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {\nthis(factory,DEFAULT_MAX_SLEEPING);\n}\npublic StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {\nthis(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);\n}\npublic StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {\n_factory = factory;\n_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);\n_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);\n_pools = new HashMap();\n_activeCount = new HashMap();\n}\npublic synchronized Object borrowObject(Object key) throws Exception {\nassertOpen();\nStack stack = (Stack)(_pools.get(key));\nif(null == stack) {\nstack = new Stack();\nstack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);\n_pools.put(key,stack);\n}\nObject obj = null;\ndo {\nboolean newlyMade = false;\nif (!stack.empty()) {\nobj = stack.pop();\n_totIdle--;\n} else {\nif(null == _factory) {\nthrow new NoSuchElementException(\"pools without a factory cannot create new objects as needed.\");\n} else {\nobj = _factory.makeObject(key);\nnewlyMade = true;\n}\n}\nif (null != _factory && null != obj) {\ntry {\n_factory.activateObject(key, obj);\nif (!_factory.validateObject(key, obj)) {\nthrow new Exception(\"ValidateObject failed\");\n}\n} catch (Throwable t) {\ntry {\n_factory.destroyObject(key,obj);\n} catch (Throwable t2) {\n} finally {\nobj = null;\n}\nif (newlyMade) {\nthrow new NoSuchElementException(\n\"Could not create a validated object, cause: \" +\nt.getMessage());\n}\n}\n}\n} while (obj == null);\nincrementActiveCount(key);\nreturn obj;\n}\npublic synchronized void returnObject(Object key, Object obj) throws Exception {\ndecrementActiveCount(key);\nif (null != _factory) {\nif (_factory.validateObject(key, obj)) {\ntry {\n_factory.passivateObject(key, obj);\n} catch (Exception ex) {\n_factory.destroyObject(key, obj);\nreturn;\n}\n} else {\nreturn;\n}\n}\nif (isClosed()) {\nif (null != _factory) {\ntry {\n_factory.destroyObject(key, obj);\n} catch (Exception e) {\n}\n}\nreturn;\n}\nStack stack = (Stack)_pools.get(key);\nif(null == stack) {\nstack = new Stack();\nstack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);\n_pools.put(key,stack);\n}\nfinal int stackSize = stack.size();\nif (stackSize >= _maxSleeping) {\nfinal Object staleObj;\nif (stackSize > 0) {\nstaleObj = stack.remove(0);\n_totIdle--;\n} else {\nstaleObj = obj;\n}\nif(null != _factory) {\ntry {\n_factory.destroyObject(key, staleObj);\n} catch (Exception e) {\n}\n}\n}\nstack.push(obj);\n_totIdle++;\n}\npublic synchronized void invalidateObject(Object key, Object obj) throws Exception {\ndecrementActiveCount(key);\nif(null != _factory) {\n_factory.destroyObject(key,obj);\n}\nnotifyAll(); \n}\npublic synchronized void addObject(Object key) throws Exception {\nassertOpen();\nif (_factory == null) {\nthrow new IllegalStateException(\"Cannot add objects without a factory.\");\n}\nObject obj = _factory.makeObject(key);\ntry {\nif (!_factory.validateObject(key, obj)) {\nreturn;\n}\n} catch (Exception e) {\ntry {\n_factory.destroyObject(key, obj);\n} catch (Exception e2) {\n}\nreturn;\n}\n_factory.passivateObject(key, obj);\nStack stack = (Stack)_pools.get(key);\nif(null == stack) {\nstack = new Stack();\nstack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);\n_pools.put(key,stack);\n}\nfinal int stackSize = stack.size();\nif (stackSize >= _maxSleeping) {\nfinal Object staleObj;\nif (stackSize > 0) {\nstaleObj = stack.remove(0);\n_totIdle--;\n} else {\nstaleObj = obj;\n}\ntry {\n_factory.destroyObject(key, staleObj);\n} catch (Exception e) {\nif (obj == staleObj) {\nthrow e;\n}\n}\n} else {\nstack.push(obj);\n_totIdle++;\n}\n}\npublic synchronized int getNumIdle() {\nreturn _totIdle;\n}\npublic synchronized int getNumActive() {\nreturn _totActive;\n}\npublic synchronized int getNumActive(Object key) {\nreturn getActiveCount(key);\n}\npublic synchronized int getNumIdle(Object key) {\ntry {\nreturn((Stack)(_pools.get(key))).size();\n} catch(Exception e) {\nreturn 0;\n}\n}\npublic synchronized void clear() {\nIterator it = _pools.keySet().iterator();\nwhile(it.hasNext()) {\nObject key = it.next();\nStack stack = (Stack)(_pools.get(key));\ndestroyStack(key,stack);\n}\n_totIdle = 0;\n_pools.clear();\n_activeCount.clear();\n}\npublic synchronized void clear(Object key) {\nStack stack = (Stack)(_pools.remove(key));\ndestroyStack(key,stack);\n}\nprivate synchronized void destroyStack(Object key, Stack stack) {\nif(null == stack) {\nreturn;\n} else {\nif(null != _factory) {\nIterator it = stack.iterator();\nwhile(it.hasNext()) {\ntry {\n_factory.destroyObject(key,it.next());\n} catch(Exception e) {\n}\n}\n}\n_totIdle -= stack.size();\n_activeCount.remove(key);\nstack.clear();\n}\n}\npublic synchronized String toString() {\nStringBuffer buf = new StringBuffer();\nbuf.append(getClass().getName());\nbuf.append(\" contains \").append(_pools.size()).append(\" distinct pools: \");\nIterator it = _pools.keySet().iterator();\nwhile(it.hasNext()) {\nObject key = it.next();\nbuf.append(\" |\").append(key).append(\"|=\");\nStack s = (Stack)(_pools.get(key));\nbuf.append(s.size());\n}\nreturn buf.toString();\n}\npublic void close() throws Exception {\nsuper.close();\nclear();\n}\npublic synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {\nif(0 < getNumActive()) {\nthrow new IllegalStateException(\"Objects are already active\");\n} else {\nclear();\n_factory = factory;\n}\n}\nprivate int getActiveCount(Object key) {\ntry {\nreturn ((Integer)_activeCount.get(key)).intValue();\n} catch(NoSuchElementException e) {\nreturn 0;\n} catch(NullPointerException e) {\nreturn 0;\n}\n}\nprivate void incrementActiveCount(Object key) {\n_totActive++;\nInteger old = (Integer)(_activeCount.get(key));\nif(null == old) {\n_activeCount.put(key,new Integer(1));\n} else {\n_activeCount.put(key,new Integer(old.intValue() + 1));\n}\n}\nprivate void decrementActiveCount(Object key) {\n_totActive--;\nInteger active = (Integer)(_activeCount.get(key));\nif(null == active) {\n} else if(active.intValue() <= 1) {\n_activeCount.remove(key);\n} else {\n_activeCount.put(key, new Integer(active.intValue() - 1));\n}\n}\nprotected static final int DEFAULT_MAX_SLEEPING  = 8;\nprotected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;\nprotected HashMap _pools = null;\nprotected KeyedPoolableObjectFactory _factory = null;\nprotected int _maxSleeping = DEFAULT_MAX_SLEEPING;\nprotected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;\nprotected int _totActive = 0;\nprotected int _totIdle = 0;\nprotected HashMap _activeCount = null;\n",
    "warning_method": "public synchronized void clear() {\nIterator it = _pools.keySet().iterator();\nwhile (it.hasNext()) {\nObject key = it.next();\nStack stack = (Stack) (_pools.get(key));\ndestroyStack(key, stack);\n}\n_totIdle = 0;\n_pools.clear();\n_activeCount.clear();\n}"
}