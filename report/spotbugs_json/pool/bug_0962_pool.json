{
    "category": "Multithreaded correctness",
    "vtype": "NO_NOTIFY_NOT_NOTIFYALL",
    "priority": "3",
    "rank": "17",
    "project": "pool",
    "warning_line": "latch.notify();\n",
    "warning_method": "private synchronized void allocate() {\nif (isClosed()) {\nreturn;\n}\nfor (; ; ) {\nif (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {\nLatch<T> latch = _allocationQueue.removeFirst();\nlatch.setPair(_pool.removeFirst());\n_numInternalProcessing++;\nsynchronized (latch) {\nlatch.notify();\n}\n} else {\nbreak;\n}\n}\nfor (; ; ) {\nif ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {\nLatch<T> latch = _allocationQueue.removeFirst();\nlatch.setMayCreate(true);\n_numInternalProcessing++;\nsynchronized (latch) {\nlatch.notify();\n}\n} else {\nbreak;\n}\n}\n}"
}