{
    "category": "Multithreaded correctness",
    "vtype": "NN_NAKED_NOTIFY",
    "priority": "2",
    "rank": "14",
    "project": "pool",
    "warning_line": "latch.notify();\n",
    "warning_method": "private void allocate() {\nboolean clearOldest = false;\nsynchronized (this) {\nif (isClosed()) {\nreturn;\n}\nIterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();\nwhile (allocationQueueIter.hasNext()) {\nLatch<K, V> latch = allocationQueueIter.next();\nObjectQueue pool = (_poolMap.get(latch.getkey()));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(latch.getkey(), pool);\n_poolList.add(latch.getkey());\n}\nlatch.setPool(pool);\nif (!pool.queue.isEmpty()) {\nallocationQueueIter.remove();\nlatch.setPair(pool.queue.removeFirst());\npool.incrementInternalProcessingCount();\n_totalIdle--;\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {\nclearOldest = true;\nbreak;\n}\nif ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {\nallocationQueueIter.remove();\nlatch.setMayCreate(true);\npool.incrementInternalProcessingCount();\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif (_maxActive < 0) {\nbreak;\n}\n}\n}\nif (clearOldest) {\nclearOldest();\n}\n}"
}