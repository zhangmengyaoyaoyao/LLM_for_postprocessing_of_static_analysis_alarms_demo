{
    "category": "DODGY_CODE",
    "vtype": "UCF_USELESS_CONTROL_FLOW",
    "priority": "3",
    "rank": "20",
    "project": "pool",
    "warning_line": "if (!underTest.endEvictionTest(idleObjects)) {\n",
    "warning_method": "@Override\npublic void evict() throws E {\nassertOpen();\nif (getNumIdle() > 0) {\nPooledObject<T> underTest = null;\nfinal EvictionPolicy<T> evictionPolicy = getEvictionPolicy();\nsynchronized (evictionLock) {\nfinal EvictionConfig evictionConfig = new EvictionConfig(getMinEvictableIdleDuration(), getSoftMinEvictableIdleDuration(), getMinIdlePerKey());\nfinal boolean testWhileIdle = getTestWhileIdle();\nfor (int i = 0, m = getNumTests(); i < m; i++) {\nif (evictionIterator == null || !evictionIterator.hasNext()) {\nif (evictionKeyIterator == null || !evictionKeyIterator.hasNext()) {\nfinal List<K> keyCopy = new ArrayList<>();\nfinal Lock readLock = keyLock.readLock();\nreadLock.lock();\ntry {\nkeyCopy.addAll(poolKeyList);\n} finally {\nreadLock.unlock();\n}\nevictionKeyIterator = keyCopy.iterator();\n}\nwhile (evictionKeyIterator.hasNext()) {\nevictionKey = evictionKeyIterator.next();\nfinal ObjectDeque<T> objectDeque = poolMap.get(evictionKey);\nif (objectDeque == null) {\ncontinue;\n}\nfinal Deque<PooledObject<T>> idleObjects = objectDeque.getIdleObjects();\nevictionIterator = new EvictionIterator(idleObjects);\nif (evictionIterator.hasNext()) {\nbreak;\n}\nevictionIterator = null;\n}\n}\nif (evictionIterator == null) {\nreturn;\n}\nfinal Deque<PooledObject<T>> idleObjects;\ntry {\nunderTest = evictionIterator.next();\nidleObjects = evictionIterator.getIdleObjects();\n} catch (final NoSuchElementException nsee) {\ni--;\nevictionIterator = null;\ncontinue;\n}\nif (!underTest.startEvictionTest()) {\ni--;\ncontinue;\n}\nboolean evict;\ntry {\nevict = evictionPolicy.evict(evictionConfig, underTest, poolMap.get(evictionKey).getIdleObjects().size());\n} catch (final Throwable t) {\nPoolUtils.checkRethrow(t);\nswallowException(new Exception(t));\nevict = false;\n}\nif (evict) {\ndestroy(evictionKey, underTest, true, DestroyMode.NORMAL);\ndestroyedByEvictorCount.incrementAndGet();\n} else {\nif (testWhileIdle) {\nboolean active = false;\ntry {\nfactory.activateObject(evictionKey, underTest);\nactive = true;\n} catch (final Exception e) {\ndestroy(evictionKey, underTest, true, DestroyMode.NORMAL);\ndestroyedByEvictorCount.incrementAndGet();\n}\nif (active) {\nboolean validate = false;\nThrowable validationThrowable = null;\ntry {\nvalidate = factory.validateObject(evictionKey, underTest);\n} catch (final Throwable t) {\nPoolUtils.checkRethrow(t);\nvalidationThrowable = t;\n}\nif (!validate) {\ndestroy(evictionKey, underTest, true, DestroyMode.NORMAL);\ndestroyedByEvictorCount.incrementAndGet();\nif (validationThrowable != null) {\nif (validationThrowable instanceof RuntimeException) {\nthrow (RuntimeException) validationThrowable;\n}\nthrow (Error) validationThrowable;\n}\n} else {\ntry {\nfactory.passivateObject(evictionKey, underTest);\n} catch (final Exception e) {\ndestroy(evictionKey, underTest, true, DestroyMode.NORMAL);\ndestroyedByEvictorCount.incrementAndGet();\n}\n}\n}\n}\nif (!underTest.endEvictionTest(idleObjects)) {\n}\n}\n}\n}\n}\nfinal AbandonedConfig ac = this.abandonedConfig;\nif (ac != null && ac.getRemoveAbandonedOnMaintenance()) {\nremoveAbandoned(ac);\n}\n}"
}