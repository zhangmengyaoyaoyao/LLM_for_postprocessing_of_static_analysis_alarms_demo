{
    "category": "BAD_PRACTICE",
    "vtype": "DE_MIGHT_IGNORE",
    "priority": "3",
    "rank": "19",
    "project": "pool",
    "warning_line": "} catch(Exception e) {\n",
    "warning_method": "public void evict() throws Exception {\nK key = null;\nboolean testWhileIdle;\nlong minEvictableIdleTimeMillis;\nsynchronized (this) {\ntestWhileIdle = this.testWhileIdle;\nminEvictableIdleTimeMillis = this.minEvictableIdleTimeMillis;\nif (_evictionKeyCursor != null && _evictionKeyCursor._lastReturned != null) {\nkey = _evictionKeyCursor._lastReturned.value();\n}\n}\nfor (int i = 0, m = getNumTests(); i < m; i++) {\nfinal ObjectTimestampPair<V> pair;\nsynchronized (this) {\nif (_poolMap == null || _poolMap.size() == 0) {\ncontinue;\n}\nif (null == _evictionKeyCursor) {\nresetEvictionKeyCursor();\nkey = null;\n}\nif (null == _evictionCursor) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n} else {\nresetEvictionKeyCursor();\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n}\n}\n}\n}\nif (_evictionCursor == null) {\ncontinue;\n}\nif ((this.lifo && !_evictionCursor.hasPrevious()) || (!this.lifo && !_evictionCursor.hasNext())) {\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n} else {\nresetEvictionKeyCursor();\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n}\n}\n}\n}\n}\nif ((this.lifo && !_evictionCursor.hasPrevious()) || (!this.lifo && !_evictionCursor.hasNext())) {\ncontinue;\n}\npair = this.lifo ? _evictionCursor.previous() : _evictionCursor.next();\n_evictionCursor.remove();\nObjectQueue objectQueue = _poolMap.get(key);\nobjectQueue.incrementInternalProcessingCount();\n_totalIdle--;\n}\nboolean removeObject = false;\nif ((minEvictableIdleTimeMillis > 0) && (System.currentTimeMillis() - pair.getTstamp() > minEvictableIdleTimeMillis)) {\nremoveObject = true;\n}\nif (testWhileIdle && removeObject == false) {\nboolean active = false;\ntry {\n_factory.activateObject(key, pair.getValue());\nactive = true;\n} catch (Exception e) {\nremoveObject = true;\n}\nif (active) {\nif (!_factory.validateObject(key, pair.getValue())) {\nremoveObject = true;\n} else {\ntry {\n_factory.passivateObject(key, pair.getValue());\n} catch (Exception e) {\nremoveObject = true;\n}\n}\n}\n}\nif (removeObject) {\ntry {\n_factory.destroyObject(key, pair.getValue());\n} catch (Exception e) {\n}\n}\nsynchronized (this) {\nObjectQueue objectQueue = _poolMap.get(key);\nobjectQueue.decrementInternalProcessingCount();\nif (removeObject) {\nif (objectQueue.queue.isEmpty() && objectQueue.activeCount == 0 && objectQueue.internalProcessingCount == 0) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n} else {\n_evictionCursor.add(pair);\n_totalIdle++;\nif (this.lifo) {\n_evictionCursor.previous();\n}\n}\n}\n}\nallocate();\n}"
}