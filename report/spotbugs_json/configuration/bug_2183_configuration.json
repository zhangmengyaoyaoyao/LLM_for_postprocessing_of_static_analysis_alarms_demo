{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "configuration",
    "warning_line": "public class BaseHierarchicalConfiguration extends AbstractHierarchicalConfiguration<ImmutableNode>\nimplements Cloneable, InMemoryNodeModelSupport\n{\nprivate final EventListener<ConfigurationEvent> changeListener;\npublic BaseHierarchicalConfiguration()\n{\nthis((HierarchicalConfiguration<ImmutableNode>) null);\n}\npublic BaseHierarchicalConfiguration(HierarchicalConfiguration<ImmutableNode> c)\n{\nthis(createNodeModel(c));\n}\nprotected BaseHierarchicalConfiguration(NodeModel<ImmutableNode> model)\n{\nsuper(model);\nchangeListener = createChangeListener();\n}\n@Override\npublic InMemoryNodeModel getNodeModel()\n{\nreturn (InMemoryNodeModel) super.getNodeModel();\n}\n@Override\npublic Configuration subset(String prefix)\n{\nbeginRead(false);\ntry\n{\nList<QueryResult<ImmutableNode>> results = fetchNodeList(prefix);\nif (results.isEmpty())\n{\nreturn new BaseHierarchicalConfiguration();\n}\nfinal BaseHierarchicalConfiguration parent = this;\nBaseHierarchicalConfiguration result =\nnew BaseHierarchicalConfiguration()\n{\n@Override\nprotected Object interpolate(Object value)\n{\nreturn parent.interpolate(value);\n}\n@Override\npublic ConfigurationInterpolator getInterpolator()\n{\nreturn parent.getInterpolator();\n}\n};\nresult.getModel().setRootNode(createSubsetRootNode(results));\nif (result.isEmpty())\n{\nreturn new BaseHierarchicalConfiguration();\n}\nelse\n{\nresult.setSynchronizer(getSynchronizer());\nreturn result;\n}\n}\nfinally\n{\nendRead();\n}\n}\nprivate ImmutableNode createSubsetRootNode(\nCollection<QueryResult<ImmutableNode>> results)\n{\nImmutableNode.Builder builder = new ImmutableNode.Builder();\nObject value = null;\nint valueCount = 0;\nfor (QueryResult<ImmutableNode> result : results)\n{\nif (result.isAttributeResult())\n{\nbuilder.addAttribute(result.getAttributeName(),\nresult.getAttributeValue(getModel().getNodeHandler()));\n}\nelse\n{\nif (result.getNode().getValue() != null)\n{\nvalue = result.getNode().getValue();\nvalueCount++;\n}\nbuilder.addChildren(result.getNode().getChildren());\nbuilder.addAttributes(result.getNode().getAttributes());\n}\n}\nif (valueCount == 1)\n{\nbuilder.value(value);\n}\nreturn builder.create();\n}\npublic HierarchicalConfiguration<ImmutableNode> configurationAt(String key,\nboolean supportUpdates)\n{\nbeginRead(false);\ntry\n{\nreturn supportUpdates ? createConnectedSubConfiguration(key)\n: createIndependentSubConfiguration(key);\n}\nfinally\n{\nendRead();\n}\n}\nprotected InMemoryNodeModel getSubConfigurationParentModel()\n{\nreturn (InMemoryNodeModel) getModel();\n}\nprotected NodeSelector getSubConfigurationNodeSelector(String key)\n{\nreturn new NodeSelector(key);\n}\nprotected SubnodeConfiguration createSubConfigurationForTrackedNode(\nNodeSelector selector, InMemoryNodeModelSupport parentModelSupport)\n{\nSubnodeConfiguration subConfig =\nnew SubnodeConfiguration(this, new TrackedNodeModel(\nparentModelSupport, selector, true));\ninitSubConfigurationForThisParent(subConfig);\nreturn subConfig;\n}\nprotected void initSubConfigurationForThisParent(SubnodeConfiguration subConfig)\n{\ninitSubConfiguration(subConfig);\nsubConfig.addEventListener(ConfigurationEvent.ANY, changeListener);\n}\nprivate BaseHierarchicalConfiguration createConnectedSubConfiguration(\nString key)\n{\nNodeSelector selector = getSubConfigurationNodeSelector(key);\ngetSubConfigurationParentModel().trackNode(selector, this);\nreturn createSubConfigurationForTrackedNode(selector, this);\n}\nprivate List<HierarchicalConfiguration<ImmutableNode>> createConnectedSubConfigurations(\nInMemoryNodeModelSupport parentModelSupport,\nCollection<NodeSelector> selectors)\n{\nList<HierarchicalConfiguration<ImmutableNode>> configs =\nnew ArrayList<HierarchicalConfiguration<ImmutableNode>>(\nselectors.size());\nfor (NodeSelector selector : selectors)\n{\nconfigs.add(createSubConfigurationForTrackedNode(selector,\nparentModelSupport));\n}\nreturn configs;\n}\nprivate BaseHierarchicalConfiguration createIndependentSubConfiguration(\nString key)\n{\nList<ImmutableNode> targetNodes = fetchFilteredNodeResults(key);\nif (targetNodes.size() != 1)\n{\nthrow new ConfigurationRuntimeException(\n\"Passed in key must select exactly one node: \" + key);\n}\nBaseHierarchicalConfiguration sub =\nnew BaseHierarchicalConfiguration(new InMemoryNodeModel(\ntargetNodes.get(0)));\ninitSubConfiguration(sub);\nreturn sub;\n}\nprivate BaseHierarchicalConfiguration createIndependentSubConfigurationForNode(\nImmutableNode node)\n{\nBaseHierarchicalConfiguration sub =\nnew BaseHierarchicalConfiguration(new InMemoryNodeModel(node));\ninitSubConfiguration(sub);\nreturn sub;\n}\nprivate List<ImmutableNode> fetchFilteredNodeResults(String key)\n{\nNodeHandler<ImmutableNode> handler = getModel().getNodeHandler();\nreturn resolveNodeKey(handler.getRootNode(), key, handler);\n}\npublic ImmutableHierarchicalConfiguration immutableConfigurationAt(\nString key, boolean supportUpdates)\n{\nreturn ConfigurationUtils.unmodifiableConfiguration(configurationAt(\nkey, supportUpdates));\n}\npublic HierarchicalConfiguration<ImmutableNode> configurationAt(String key)\n{\nreturn configurationAt(key, false);\n}\npublic ImmutableHierarchicalConfiguration immutableConfigurationAt(\nString key)\n{\nreturn ConfigurationUtils.unmodifiableConfiguration(configurationAt(\nkey));\n}\npublic List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(\nString key)\n{\nList<ImmutableNode> nodes;\nbeginRead(false);\ntry\n{\nnodes = fetchFilteredNodeResults(key);\n}\nfinally\n{\nendRead();\n}\nList<HierarchicalConfiguration<ImmutableNode>> results =\nnew ArrayList<HierarchicalConfiguration<ImmutableNode>>(\nnodes.size());\nfor (ImmutableNode node : nodes)\n{\nBaseHierarchicalConfiguration sub =\ncreateIndependentSubConfigurationForNode(node);\nresults.add(sub);\n}\nreturn results;\n}\npublic List<HierarchicalConfiguration<ImmutableNode>> configurationsAt(\nString key, boolean supportUpdates)\n{\nif (!supportUpdates)\n{\nreturn configurationsAt(key);\n}\nInMemoryNodeModel parentModel;\nbeginRead(false);\ntry\n{\nparentModel = getSubConfigurationParentModel();\n}\nfinally\n{\nendRead();\n}\nCollection<NodeSelector> selectors =\nparentModel.selectAndTrackNodes(key, this);\nreturn createConnectedSubConfigurations(this, selectors);\n}\npublic List<ImmutableHierarchicalConfiguration> immutableConfigurationsAt(\nString key)\n{\nreturn toImmutable(configurationsAt(key));\n}\npublic List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(\nString key)\n{\nList<ImmutableNode> nodes;\nbeginRead(false);\ntry\n{\nnodes = fetchFilteredNodeResults(key);\n}\nfinally\n{\nendRead();\n}\nif (nodes.size() != 1)\n{\nreturn Collections.emptyList();\n}\nImmutableNode parent = nodes.get(0);\nList<HierarchicalConfiguration<ImmutableNode>> subs =\nnew ArrayList<HierarchicalConfiguration<ImmutableNode>>(parent\n.getChildren().size());\nfor (ImmutableNode node : parent.getChildren())\n{\nsubs.add(createIndependentSubConfigurationForNode(node));\n}\nreturn subs;\n}\npublic List<HierarchicalConfiguration<ImmutableNode>> childConfigurationsAt(\nString key, boolean supportUpdates)\n{\nif (!supportUpdates)\n{\nreturn childConfigurationsAt(key);\n}\nInMemoryNodeModel parentModel = getSubConfigurationParentModel();\nreturn createConnectedSubConfigurations(this,\nparentModel.trackChildNodes(key, this));\n}\npublic List<ImmutableHierarchicalConfiguration> immutableChildConfigurationsAt(\nString key)\n{\nreturn toImmutable(childConfigurationsAt(key));\n}\nprotected void subnodeConfigurationChanged(ConfigurationEvent event)\n{\nfireEvent(ConfigurationEvent.SUBNODE_CHANGED, null, event, event.isBeforeUpdate());\n}\nprivate void initSubConfiguration(BaseHierarchicalConfiguration sub)\n{\nsub.setSynchronizer(getSynchronizer());\nsub.setExpressionEngine(getExpressionEngine());\nsub.setListDelimiterHandler(getListDelimiterHandler());\nsub.setThrowExceptionOnMissing(isThrowExceptionOnMissing());\nsub.getInterpolator().setParentInterpolator(getInterpolator());\n}\nprivate EventListener<ConfigurationEvent> createChangeListener()\n{\nreturn new EventListener<ConfigurationEvent>()\n{\n@Override\npublic void onEvent(ConfigurationEvent event)\n{\nsubnodeConfigurationChanged(event);\n}\n};\n}\n@Override\npublic Configuration interpolatedConfiguration()\n{\nInterpolatedVisitor visitor = new InterpolatedVisitor();\nNodeHandler<ImmutableNode> handler = getModel().getNodeHandler();\nNodeTreeWalker.INSTANCE\n.walkDFS(handler.getRootNode(), visitor, handler);\nBaseHierarchicalConfiguration c =\n(BaseHierarchicalConfiguration) clone();\nc.getNodeModel().setRootNode(visitor.getInterpolatedRoot());\nreturn c;\n}\n@Override\nprotected NodeModel<ImmutableNode> cloneNodeModel()\n{\nreturn new InMemoryNodeModel(getModel().getNodeHandler().getRootNode());\n}\nprivate static List<ImmutableHierarchicalConfiguration> toImmutable(\nList<? extends HierarchicalConfiguration<?>> subs)\n{\nList<ImmutableHierarchicalConfiguration> res =\nnew ArrayList<ImmutableHierarchicalConfiguration>(subs.size());\nfor (HierarchicalConfiguration<?> sub : subs)\n{\nres.add(ConfigurationUtils.unmodifiableConfiguration(sub));\n}\nreturn res;\n}\nprivate static NodeModel<ImmutableNode> createNodeModel(\nHierarchicalConfiguration<ImmutableNode> c)\n{\nImmutableNode root = (c != null) ? obtainRootNode(c) : null;\nreturn new InMemoryNodeModel(root);\n}\nprivate static ImmutableNode obtainRootNode(\nHierarchicalConfiguration<ImmutableNode> c)\n{\nreturn c.getNodeModel().getNodeHandler().getRootNode();\n",
    "warning_method": "@Override\npublic void visitBeforeChildren(ImmutableNode node, NodeHandler<ImmutableNode> handler) {\nReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;\nupdateNode(node, refHandler);\ninsertNewChildNodes(node, refHandler);\n}"
}