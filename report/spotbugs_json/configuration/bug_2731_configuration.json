{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "configuration",
    "warning_line": "public class CombinedConfiguration extends\nAbstractHierarchicalConfiguration<Object> implements\nConfigurationListener, Cloneable\n{\npublic static final int EVENT_COMBINED_INVALIDATE = 40;\nprivate static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();\nprivate static final CombinedNodeHandler COMBINED_NODE_HANDLER = new CombinedNodeHandler();\nprivate static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();\nprivate static final String PROP_RELOAD_CHECK = \"CombinedConfigurationReloadCheck\";\nprivate NodeCombiner nodeCombiner;\nprivate CombinedNode combinedRoot;\nprivate List<ConfigData> configurations;\nprivate Map<String, Configuration> namedConfigurations;\nprivate ExpressionEngine conversionExpressionEngine;\nprivate boolean forceReloadCheck;\nprivate boolean ignoreReloadExceptions = true;\npublic CombinedConfiguration(NodeCombiner comb)\n{\nsuper(new CombinedConfigurationNodeHandler());\nsetNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);\nclear();\n}\npublic CombinedConfiguration()\n{\nthis(null);\n}\npublic NodeCombiner getNodeCombiner()\n{\nreturn nodeCombiner;\n}\npublic void setNodeCombiner(NodeCombiner nodeCombiner)\n{\nif (nodeCombiner == null)\n{\nthrow new IllegalArgumentException(\n\"Node combiner must not be null!\");\n}\nthis.nodeCombiner = nodeCombiner;\ninvalidate();\n}\npublic boolean isForceReloadCheck()\n{\nreturn forceReloadCheck;\n}\npublic void setForceReloadCheck(boolean forceReloadCheck)\n{\nthis.forceReloadCheck = forceReloadCheck;\n}\npublic boolean isIgnoreReloadExceptions()\n{\nreturn ignoreReloadExceptions;\n}\npublic void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)\n{\nthis.ignoreReloadExceptions = ignoreReloadExceptions;\n}\npublic ExpressionEngine getConversionExpressionEngine()\n{\nreturn conversionExpressionEngine;\n}\npublic void setConversionExpressionEngine(\nExpressionEngine conversionExpressionEngine)\n{\nthis.conversionExpressionEngine = conversionExpressionEngine;\n}\npublic void addConfiguration(AbstractHierarchicalConfiguration<?> config,\nString name, String at)\n{\nif (config == null)\n{\nthrow new IllegalArgumentException(\n\"Added configuration must not be null!\");\n}\nif (name != null && namedConfigurations.containsKey(name))\n{\nthrow new ConfigurationRuntimeException(\n\"A configuration with the name '\"\n+ name\n+ \"' already exists in this combined configuration!\");\n}\nConfigData cd = new ConfigData(config, name, at);\nconfigurations.add(cd);\nif (name != null)\n{\nnamedConfigurations.put(name, config);\n}\nconfig.getNodeHandler().initNodeHandlerRegistry(getCombinedNodeHandler());\nconfig.addConfigurationListener(this);\ninvalidate();\n}\npublic void addConfiguration(AbstractHierarchicalConfiguration<?> config,\nString name)\n{\naddConfiguration(config, name, null);\n}\npublic void addConfiguration(AbstractHierarchicalConfiguration<?> config)\n{\naddConfiguration(config, null, null);\n}\npublic int getNumberOfConfigurations()\n{\nreturn configurations.size();\n}\npublic Configuration getConfiguration(int index)\n{\nConfigData cd = configurations.get(index);\nreturn cd.getConfiguration();\n}\npublic Configuration getConfiguration(String name)\n{\nreturn namedConfigurations.get(name);\n}\npublic List<AbstractHierarchicalConfiguration<?>> getConfigurations()\n{\nList<AbstractHierarchicalConfiguration<?>> list = new ArrayList<AbstractHierarchicalConfiguration<?>>();\nfor (ConfigData configuration : configurations)\n{\nlist.add(configuration.getConfiguration());\n}\nreturn list;\n}\npublic List<String> getConfigurationNameList()\n{\nList<String> list = new ArrayList<String>();\nfor (ConfigData configuration : configurations)\n{\nlist.add((configuration).getName());\n}\nreturn list;\n}\npublic boolean removeConfiguration(Configuration config)\n{\nfor (int index = 0; index < getNumberOfConfigurations(); index++)\n{\nif (configurations.get(index).getConfiguration() == config)\n{\nremoveConfigurationAt(index);\nreturn true;\n}\n}\nreturn false;\n}\npublic Configuration removeConfigurationAt(int index)\n{\nConfigData cd = configurations.remove(index);\nif (cd.getName() != null)\n{\nnamedConfigurations.remove(cd.getName());\n}\ncd.getConfiguration().removeConfigurationListener(this);\ninvalidate();\nreturn cd.getConfiguration();\n}\npublic Configuration removeConfiguration(String name)\n{\nConfiguration conf = getConfiguration(name);\nif (conf != null)\n{\nremoveConfiguration(conf);\n}\nreturn conf;\n}\npublic Set<String> getConfigurationNames()\n{\nreturn namedConfigurations.keySet();\n}\npublic void invalidate()\n{\nsynchronized (getNodeCombiner()) \n{\ncombinedRoot = null;\n}\nfireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);\n}\npublic void configurationChanged(ConfigurationEvent event)\n{\nif (!event.isBeforeUpdate())\n{\ninvalidate();\n}\n}\n@Override\npublic Object getRootNode()\n{\nsynchronized (getNodeCombiner())\n{\nif (combinedRoot == null)\n{\ngetCombinedNodeHandler().setHandlers(createSubHandlers());\ncombinedRoot = constructCombinedNode();\n}\nreturn combinedRoot;\n}\n}\n@Override\npublic void clear()\n{\nfireEvent(EVENT_CLEAR, null, null, true);\nconfigurations = new ArrayList<ConfigData>();\nnamedConfigurations = new HashMap<String, Configuration>();\nfireEvent(EVENT_CLEAR, null, null, false);\ninvalidate();\n}\n@Override\npublic Object clone()\n{\ntry\n{\nCombinedConfiguration copy = (CombinedConfiguration) super.clone();\ncopy.clear();\nfor (ConfigData cd : configurations)\n{\ncopy\n.addConfiguration(\n(AbstractHierarchicalConfiguration<?>) ConfigurationUtils\n.cloneConfiguration(cd\n.getConfiguration()), cd\n.getName(), cd.getAt());\n}\nreturn copy;\n}\ncatch (CloneNotSupportedException cnsex)\n{\nthrow new ConfigurationRuntimeException(cnsex);\n}\n}\n@Override\npublic Object getProperty(String key)\n{\nif (isForceReloadCheck())\n{\nfor (ConfigData cd : configurations)\n{\ntry\n{\ncd.getConfiguration().getProperty(PROP_RELOAD_CHECK);\n}\ncatch (Exception ex)\n{\nif (!ignoreReloadExceptions)\n{\nthrow new ConfigurationRuntimeException(ex);\n}\n}\n}\n}\nreturn super.getProperty(key);\n}\npublic Configuration getSource(String key)\n{\nif (key == null)\n{\nthrow new IllegalArgumentException(\"Key must not be null!\");\n}\nNodeList<Object> nodes = fetchNodeList(key);\nif (nodes.size() == 0)\n{\nreturn null;\n}\nConfiguration source = findSourceConfiguration(nodes, 0);\nfor (int idx = 1; idx < nodes.size(); idx++)\n{\nConfiguration src = findSourceConfiguration(nodes, idx);\nif (src != source)\n{\nthrow new IllegalArgumentException(\"The key \" + key\n+ \" is defined by multiple sources!\");\n}\n}\nreturn source;\n}\nprotected Map<Class<?>, NodeHandler<?>> createSubHandlers()\n{\nMap<Class<?>, NodeHandler<?>> result = new HashMap<Class<?>, NodeHandler<?>>();\nfor (ConfigData cd : configurations)\n{\nresult.put(cd.getConfiguration().getRootNode().getClass(), cd\n.getConfiguration().getNodeHandler());\n}\nreturn result;\n}\n@Override\nprotected NodeList<Object> fetchNodeList(String key)\n{\nif (isForceReloadCheck())\n{\nperformReloadCheck();\n}\nreturn super.fetchNodeList(key);\n}\nprotected void performReloadCheck()\n{\nfor (ConfigData cd : configurations)\n{\ntry\n{\ncd.getConfiguration().getProperty(PROP_RELOAD_CHECK);\n}\ncatch (Exception ex)\n{\n;\n}\n}\n}\nprivate CombinedNode constructCombinedNode()\n{\ninitSubHandlers();\nif (getNumberOfConfigurations() < 1)\n{\nreturn new CombinedNode();\n}\nelse\n{\nIterator<ConfigData> it = configurations.iterator();\nCombinedNode node = it.next().getTransformedRoot();\nwhile (it.hasNext())\n{\nnode = getNodeCombiner().combine(node, getNodeHandler(),\nit.next().getTransformedRoot(), getNodeHandler());\n}\nif (getLogger().isDebugEnabled())\n{\nByteArrayOutputStream os = new ByteArrayOutputStream();\nPrintStream stream = new PrintStream(os);\nTreeUtils.printTree(stream, node, getNodeHandler());\ngetLogger().debug(os.toString());\n}\nreturn node;\n}\n}\nprivate void initSubHandlers()\n{\nMap<Class<?>, NodeHandler<?>> handlers = new HashMap<Class<?>, NodeHandler<?>>(\ncreateSubHandlers());\nhandlers.put(CombinedNode.class, COMBINED_NODE_HANDLER);\ngetCombinedNodeHandler().setHandlers(handlers);\n}\nprivate Configuration findSourceConfiguration(Object node)\n{\nObject root = null;\nObject current = node;\nwhile (current != null)\n{\nroot = current;\ncurrent = getNodeHandler().getParent(current);\n}\nfor (ConfigData cd : configurations)\n{\nif (root == cd.getRootNode())\n{\nreturn cd.getConfiguration();\n}\n}\nreturn this;\n}\nprivate Configuration findSourceConfiguration(NodeList<Object> nl, int idx)\n{\nreturn nl.isNode(idx) ? findSourceConfiguration(nl.getNode(idx))\n: findSourceConfiguration(nl.getAttributeParent(idx));\n}\nprivate CombinedConfigurationNodeHandler getCombinedNodeHandler()\n{\nreturn (CombinedConfigurationNodeHandler) getNodeHandler();\n",
    "warning_method": "private CombinedNode constructCombinedNode() {\ninitSubHandlers();\nif (getNumberOfConfigurations() < 1) {\nreturn new CombinedNode();\n} else {\nIterator<ConfigData> it = configurations.iterator();\nCombinedNode node = it.next().getTransformedRoot();\nwhile (it.hasNext()) {\nnode = getNodeCombiner().combine(node, getNodeHandler(), it.next().getTransformedRoot(), getNodeHandler());\n}\nif (getLogger().isDebugEnabled()) {\nByteArrayOutputStream os = new ByteArrayOutputStream();\nPrintStream stream = new PrintStream(os);\nTreeUtils.printTree(stream, node, getNodeHandler());\ngetLogger().debug(os.toString());\n}\nreturn node;\n}\n}"
}