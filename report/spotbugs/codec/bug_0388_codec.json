{
    "category": "DODGY_CODE",
    "vtype": "SF_SWITCH_FALLTHROUGH",
    "priority": "2",
    "rank": "17",
    "project": "codec",
    "warning_line": "validateTrailingCharacters();\ncase 2 : \nvalidateCharacter(MASK_2BITS, context);\n",
    "warning_method": "@Override\nvoid decode(final byte[] input, int inPos, final int inAvail, final Context context) {\nif (context.eof) {\nreturn;\n}\nif (inAvail < 0) {\ncontext.eof = true;\n}\nfor (int i = 0; i < inAvail; i++) {\nfinal byte b = input[inPos++];\nif (b == pad) {\ncontext.eof = true;\nbreak;\n}\nfinal byte[] buffer = ensureBufferSize(decodeSize, context);\nif (b >= 0 && b < this.decodeTable.length) {\nfinal int result = this.decodeTable[b];\nif (result >= 0) {\ncontext.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;\ncontext.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result;\nif (context.modulus == 0) {\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);\n}\n}\n}\n}\n// Two forms of EOF as far as Base32 decoder is concerned: actual\nif (context.eof && context.modulus > 0) {\nfinal byte[] buffer = ensureBufferSize(decodeSize, context);\nswitch(context.modulus) {\ncase 1:\nvalidateTrailingCharacters();\ncase 2:\nvalidateCharacter(MASK_2BITS, context);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);\nbreak;\ncase 3:\nvalidateTrailingCharacters();\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);\nbreak;\ncase 4:\nvalidateCharacter(MASK_4BITS, context);\ncontext.lbitWorkArea = context.lbitWorkArea >> 4;\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\nbreak;\ncase 5:\nvalidateCharacter(MASK_1BITS, context);\ncontext.lbitWorkArea = context.lbitWorkArea >> 1;\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\nbreak;\ncase 6:\nvalidateTrailingCharacters();\ncontext.lbitWorkArea = context.lbitWorkArea >> 6;\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\nbreak;\ncase 7:\nvalidateCharacter(MASK_3BITS, context);\ncontext.lbitWorkArea = context.lbitWorkArea >> 3;\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);\nbuffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);\nbreak;\ndefault:\nthrow new IllegalStateException(\"Impossible modulus \" + context.modulus);\n}\n}\n}"
}