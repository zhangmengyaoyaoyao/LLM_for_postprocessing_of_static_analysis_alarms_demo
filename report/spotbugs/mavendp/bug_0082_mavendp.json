{
    "category": "BAD_PRACTICE",
    "vtype": "SE_COMPARATOR_SHOULD_BE_SERIALIZABLE",
    "priority": "3",
    "rank": "20",
    "project": "mavendp",
    "warning_line": "public class BuildClasspathMojo\nextends AbstractDependencyFilterMojo\nimplements Comparator<Artifact>\n{\nprivate boolean stripVersion = false;\nprivate String prefix;\nprivate File cpFile;\nprivate File outputFile;\nprivate boolean regenerateFile;\nprivate String fileSeparator;\nprivate String pathSeparator;\nprivate String localRepoProperty;\nboolean attach;\nboolean outputFilterFile;\nprivate MavenProjectHelper projectHelper;\nboolean isFileSepSet = true;\nboolean isPathSepSet = true;\npublic void execute()\nthrows MojoExecutionException\n{\nif ( cpFile != null )\n{\ngetLog().warn( \"The parameter cpFile is deprecated. Use outputFile instead.\" );\nthis.outputFile = cpFile;\n}\nisFileSepSet = StringUtils.isNotEmpty( fileSeparator );\nisPathSepSet = StringUtils.isNotEmpty( pathSeparator );\nif ( attach && StringUtils.isEmpty( localRepoProperty ) )\n{\nlocalRepoProperty = \"${M2_REPO}\";\n}\nSet<Artifact> artifacts = getResolvedDependencies( true );\nif ( artifacts == null || artifacts.isEmpty() )\n{\ngetLog().info( \"No dependencies found.\" );\n}\nList<Artifact> artList = new ArrayList<Artifact>( artifacts );\nStringBuffer sb = new StringBuffer();\nIterator<Artifact> i = artList.iterator();\nif ( i.hasNext() )\n{\nappendArtifactPath( i.next(), sb );\nwhile ( i.hasNext() )\n{\nsb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );\nappendArtifactPath( (Artifact) i.next(), sb );\n}\n}\nString cpString = sb.toString();\nif ( isFileSepSet )\n{\nfinal String pattern = Pattern.quote( File.separator );\nfinal String replacement = Matcher.quoteReplacement( fileSeparator );\ncpString = cpString.replaceAll( pattern, replacement );\n}\nif ( outputFilterFile )\n{\ncpString = \"classpath=\" + cpString;\n}\nif ( outputFile == null )\n{\ngetLog().info( \"Dependencies classpath:\\n\" + cpString );\n}\nelse\n{\nif ( regenerateFile || !isUpdToDate( cpString ) )\n{\nstoreClasspathFile( cpString, outputFile );\n}\nelse\n{\nthis.getLog().info( \"Skipped writing classpath file '\" + outputFile + \"'.  No changes found.\" );\n}\n}\nif ( attach )\n{\nattachFile( cpString );\n}\n}\nprotected void attachFile( String cpString )\nthrows MojoExecutionException\n{\nFile attachedFile = new File( project.getBuild().getDirectory(), \"classpath\" );\nstoreClasspathFile( cpString, attachedFile );\nprojectHelper.attachArtifact( project, attachedFile, \"classpath\" );\n}\nprotected void appendArtifactPath( Artifact art, StringBuffer sb )\n{\nif ( prefix == null )\n{\nString file = art.getFile().getPath();\nif ( StringUtils.isNotEmpty( localRepoProperty ) )\n{\nfile = StringUtils.replace( file, getLocal().getBasedir(), localRepoProperty );\n}\nsb.append( file );\n}\nelse\n{\n// TODO: add param for prepending groupId and version.\nsb.append( prefix );\nsb.append( File.separator );\nsb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId) );\n}\n}\nprivate boolean isUpdToDate( String cpString )\n{\ntry\n{\nString oldCp = readClasspathFile();\nreturn ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );\n}\ncatch ( Exception ex )\n{\nthis.getLog().warn( \"Error while reading old classpath file '\" + outputFile + \"' for up-to-date check: \" + ex );\nreturn false;\n}\n}\nprivate void storeClasspathFile( String cpString, File out )\nthrows MojoExecutionException\n{\nout.getParentFile().mkdirs();\nWriter w = null;\ntry\n{\nw = new BufferedWriter( new FileWriter( out ) );\nw.write( cpString );\ngetLog().info( \"Wrote classpath file '\" + out + \"'.\" );\n}\ncatch ( IOException ex )\n{\nthrow new MojoExecutionException( \"Error while writting to classpath file '\" + out + \"': \"\n+ ex.toString(), ex );\n}\nfinally\n{\nIOUtil.close( w );\n}\n}\nprotected String readClasspathFile()\nthrows IOException\n{\nif ( outputFile == null )\n{\nthrow new IllegalArgumentException(\n\"The outputFile parameter cannot be null if the file is intended to be read.\" );\n}\nif ( !outputFile.isFile() )\n{\nreturn null;\n}\nStringBuffer sb = new StringBuffer();\nBufferedReader r = null;\ntry\n{\nr = new BufferedReader( new FileReader( outputFile ) );\nString l;\nwhile ( ( l = r.readLine() ) != null )\n{\nsb.append( l );\n}\nreturn sb.toString();\n}\nfinally\n{\nIOUtil.close( r );\n}\n}\npublic int compare( Artifact art1, Artifact art2 )\n{\nif ( art1 == art2 )\n{\nreturn 0;\n}\nelse if ( art1 == null )\n{\nreturn -1;\n}\nelse if ( art2 == null )\n{\nreturn +1;\n}\nString s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();\nString s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();\nreturn s1.compareTo( s2 );\n}\nprotected ArtifactsFilter getMarkedArtifactFilter()\n{\nreturn null;\n}\npublic File getCpFile()\n{\nreturn this.outputFile;\n}\npublic void setCpFile( File theCpFile )\n{\nthis.outputFile = theCpFile;\n}\npublic String getFileSeparator()\n{\nreturn this.fileSeparator;\n}\npublic void setFileSeparator( String theFileSeparator )\n{\nthis.fileSeparator = theFileSeparator;\n}\npublic String getPathSeparator()\n{\nreturn this.pathSeparator;\n}\npublic void setPathSeparator( String thePathSeparator )\n{\nthis.pathSeparator = thePathSeparator;\n}\npublic String getPrefix()\n{\nreturn this.prefix;\n}\npublic void setPrefix( String thePrefix )\n{\nthis.prefix = thePrefix;\n}\npublic boolean isRegenerateFile()\n{\nreturn this.regenerateFile;\n}\npublic void setRegenerateFile( boolean theRegenerateFile )\n{\nthis.regenerateFile = theRegenerateFile;\n}\npublic boolean isStripVersion()\n{\nreturn this.stripVersion;\n}\npublic void setStripVersion( boolean theStripVersion )\n{\nthis.stripVersion = theStripVersion;\n}\npublic String getLocalRepoProperty()\n{\nreturn localRepoProperty;\n}\npublic void setLocalRepoProperty( String localRepoProperty )\n{\nthis.localRepoProperty = localRepoProperty;\n}\npublic boolean isFileSepSet()\n{\nreturn isFileSepSet;\n}\npublic void setFileSepSet( boolean isFileSepSet )\n{\nthis.isFileSepSet = isFileSepSet;\n}\npublic boolean isPathSepSet()\n{\nreturn isPathSepSet;\n}\npublic void setPathSepSet( boolean isPathSepSet )\n{\nthis.isPathSepSet = isPathSepSet;\n}\n",
    "warning_method": "protected void attachFile(String cpString) throws MojoExecutionException {\nFile attachedFile = new File(project.getBuild().getDirectory(), \"classpath\");\nstoreClasspathFile(cpString, attachedFile);\nprojectHelper.attachArtifact(project, attachedFile, \"classpath\");\n}"
}