{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "pool",
    "warning_line": "public class GenericKeyedObjectPool<K,V> extends BaseKeyedObjectPool<K,V> implements KeyedObjectPool<K,V>, GenericKeyedObjectPoolMBean<K> {\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory<K,V> factory) {\nthis(factory, new GenericKeyedObjectPoolConfig.Builder().createConfig());\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory<K,V> factory, GenericKeyedObjectPoolConfig config) {\nif (factory == null) {\nthrow new IllegalArgumentException(\"factory must not be null\");\n}\nif (config == null) {\nthrow new IllegalArgumentException(\"config must not be null\");\n}\n_factory = factory;\nthis.maxIdlePerKey = config.getMaxIdlePerKey();\nthis.minIdlePerKey = config.getMinIdlePerKey();\nthis.maxTotalPerKey = config.getMaxTotalPerKey();\nthis.maxTotal = config.getMaxTotal();\nthis.maxWait = config.getMaxWait();\nthis.whenExhaustedAction = config.getWhenExhaustedAction();\nthis.testOnBorrow = config.getTestOnBorrow();\nthis.testOnReturn = config.getTestOnReturn();\nthis.testWhileIdle = config.getTestWhileIdle();\nthis.timeBetweenEvictionRunsMillis = config.getTimeBetweenEvictionRunsMillis();\nthis.numTestsPerEvictionRun = config.getNumTestsPerEvictionRun();\nthis.minEvictableIdleTimeMillis = config.getMinEvictableIdleTimeMillis();\nthis.lifo = config.getLifo();\n_poolMap = new HashMap<K,ObjectQueue>();\n_poolList = new CursorableLinkedList<K>();\nstartEvictor(this.timeBetweenEvictionRunsMillis);\n}\npublic synchronized int getMaxTotalPerKey() {\nreturn this.maxTotalPerKey;\n}\npublic synchronized void setMaxTotalPerKey(int maxTotalPerKey) {\nthis.maxTotalPerKey = maxTotalPerKey;\nallocate();\n}\npublic synchronized int getMaxTotal() {\nreturn this.maxTotal;\n}\npublic synchronized void setMaxTotal(int maxTotal) {\nthis.maxTotal = maxTotal;\nallocate();\n}\npublic synchronized WhenExhaustedAction getWhenExhaustedAction() {\nreturn this.whenExhaustedAction;\n}\npublic synchronized void setWhenExhaustedAction(WhenExhaustedAction whenExhaustedAction) {\nthis.whenExhaustedAction = whenExhaustedAction;\nallocate();\n}\npublic synchronized long getMaxWait() {\nreturn this.maxWait;\n}\npublic synchronized void setMaxWait(long maxWait) {\nthis.maxWait = maxWait;\n}\npublic synchronized int getMaxIdlePerKey() {\nreturn this.maxIdlePerKey;\n}\npublic synchronized void setMaxIdlePerKey(int maxIdlePerKey) {\nthis.maxIdlePerKey = maxIdlePerKey;\nallocate();\n}\npublic synchronized void setMinIdle(int minIdlePerKey) {\nthis.minIdlePerKey = minIdlePerKey;\n}\npublic synchronized int getMinIdlePerKey() {\nreturn this.minIdlePerKey;\n}\npublic synchronized boolean getTestOnBorrow() {\nreturn this.testOnBorrow;\n}\npublic synchronized void setTestOnBorrow(boolean testOnBorrow) {\nthis.testOnBorrow = testOnBorrow;\n}\npublic synchronized boolean getTestOnReturn() {\nreturn this.testOnReturn;\n}\npublic synchronized void setTestOnReturn(boolean testOnReturn) {\nthis.testOnReturn = testOnReturn;\n}\npublic synchronized long getTimeBetweenEvictionRunsMillis() {\nreturn this.timeBetweenEvictionRunsMillis;\n}\npublic synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {\nthis.timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;\nstartEvictor(this.timeBetweenEvictionRunsMillis);\n}\npublic synchronized int getNumTestsPerEvictionRun() {\nreturn this.numTestsPerEvictionRun;\n}\npublic synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {\nthis.numTestsPerEvictionRun = numTestsPerEvictionRun;\n}\npublic synchronized long getMinEvictableIdleTimeMillis() {\nreturn this.minEvictableIdleTimeMillis;\n}\npublic synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {\nthis.minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;\n}\npublic synchronized boolean getTestWhileIdle() {\nreturn this.testWhileIdle;\n}\npublic synchronized void setTestWhileIdle(boolean testWhileIdle) {\nthis.testWhileIdle = testWhileIdle;\n}\npublic synchronized boolean getLifo() {\nreturn this.lifo;\n}\npublic synchronized void setLifo(boolean lifo) {\nthis.lifo = lifo;\n}\n@Override\npublic V borrowObject(K key) throws Exception {\nlong starttime = System.currentTimeMillis();\nLatch latch = new Latch(key);\nWhenExhaustedAction whenExhaustedAction;\nlong maxWait;\nsynchronized (this) {\nwhenExhaustedAction = this.whenExhaustedAction;\nmaxWait = this.maxWait;\n_allocationQueue.add(latch);\nallocate();\n}\nfor(;;) {\nsynchronized (this) {\nassertOpen();\n}\nif (null == latch.getPair()) {\nif (latch.mayCreate()) {\n} else {\nswitch(whenExhaustedAction) {\ncase GROW:\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\nlatch.getPool().incrementInternalProcessingCount();\n}\n}\nbreak;\ncase FAIL:\nsynchronized (this) {\nif (latch.getPair() != null || latch.mayCreate()) {\nbreak;\n}\n_allocationQueue.remove(latch);\n}\nthrow new NoSuchElementException(\"Pool exhausted\");\ncase BLOCK:\ntry {\nsynchronized (latch) {\nif (latch.getPair() == null && !latch.mayCreate()) {\nif (maxWait <= 0) {\nlatch.wait();\n} else {\nfinal long elapsed = (System.currentTimeMillis() - starttime);\nfinal long waitTime = maxWait - elapsed;\nif (waitTime > 0)\n{\nlatch.wait(waitTime);\n}\n}\n} else {\nbreak;\n}\n}\n} catch(InterruptedException e) {\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n} else {\nbreak;\n}\n}\nThread.currentThread().interrupt();\nthrow e;\n}\nif (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n} else {\nbreak;\n}\n}\nthrow new NoSuchElementException(\"Timeout waiting for idle object\");\n} else {\ncontinue; \n}\ndefault:\nthrow new IllegalArgumentException(\"whenExhaustedAction \" + whenExhaustedAction +\n\" not recognized.\");\n}\n}\n}\nboolean newlyCreated = false;\nif (null == latch.getPair()) {\ntry {\nV obj = _factory.makeObject(key);\nlatch.setPair(new ObjectTimestampPair<V>(obj));\nnewlyCreated = true;\n} finally {\nif (!newlyCreated) {\nsynchronized (this) {\nlatch.getPool().decrementInternalProcessingCount();\nallocate();\n}\n}\n}\n}\ntry {\n_factory.activateObject(key, latch.getPair().getValue());\nif (this.testOnBorrow && !_factory.validateObject(key, latch.getPair().getValue())) {\nthrow new Exception(\"ValidateObject failed\");\n}\nsynchronized (this) {\nlatch.getPool().decrementInternalProcessingCount();\nlatch.getPool().incrementActiveCount();\n}\nreturn latch.getPair().getValue();\n} catch (Throwable e) {\nPoolUtils.checkRethrow(e);\ntry {\n_factory.destroyObject(key, latch.getPair().getValue());\n} catch (Throwable e2) {\nPoolUtils.checkRethrow(e2);\n}\nsynchronized (this) {\nlatch.getPool().decrementInternalProcessingCount();\nif (!newlyCreated) {\nlatch.reset();\n_allocationQueue.add(0, latch);\n}\nallocate();\n}\nif (newlyCreated) {\nthrow new NoSuchElementException(\n\"Could not create a validated object, cause: \" +\ne.getMessage());\n}\nelse {\ncontinue; \n}\n}\n}\n}\nprivate void allocate() {\nboolean clearOldest = false;\nsynchronized (this) {\nif (isClosed()) return;\nIterator<Latch> allocationQueueIter = _allocationQueue.iterator();\nwhile (allocationQueueIter.hasNext()) {\nLatch latch = allocationQueueIter.next();\nObjectQueue pool = _poolMap.get(latch.getkey());\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(latch.getkey(), pool);\n_poolList.add(latch.getkey());\n}\nlatch.setPool(pool);\nif (!pool.queue.isEmpty()) {\nallocationQueueIter.remove();\nlatch.setPair(pool.queue.removeFirst());\npool.incrementInternalProcessingCount();\n_totalIdle--;\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif ((this.maxTotal > 0) &&\n(_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {\nclearOldest = true;\nbreak;\n}\nif ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) &&\n(this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {\nallocationQueueIter.remove();\nlatch.setMayCreate(true);\npool.incrementInternalProcessingCount();\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif (this.maxTotalPerKey < 0) {\nbreak;\n}\n}\n}\nif (clearOldest) {\nclearOldest();\n}\n}\n@Override\npublic void clear() {\nMap<K,List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K,List<ObjectTimestampPair<V>>>();\nsynchronized (this) {\nfor (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {\nK key = it.next();\nObjectQueue pool = _poolMap.get(key);\nList<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();\nobjects.addAll(pool.queue);\ntoDestroy.put(key, objects);\nit.remove();\n_poolList.remove(key);\n_totalIdle = _totalIdle - pool.queue.size();\n_totalInternalProcessing =\n_totalInternalProcessing + pool.queue.size();\npool.queue.clear();\n}\n}\ndestroy(toDestroy, _factory);\n}\npublic void clearOldest() {\nfinal Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();\nfinal Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();\nsynchronized (this) {\nfor (K key : _poolMap.keySet()) {\nfinal CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;\nfor (ObjectTimestampPair<V> pair : list) {\nmap.put(pair, key);\n}\n}\nSet<Map.Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();\nint itemsToRemove = ((int) (map.size() * 0.15)) + 1;\nIterator<Map.Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();\nwhile (iter.hasNext() && itemsToRemove > 0) {\nMap.Entry<ObjectTimestampPair<V>, K> entry = iter.next();\nK key = entry.getValue();\nObjectTimestampPair<V> pairTimeStamp = entry.getKey();\nfinal CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;\nlist.remove(pairTimeStamp);\nif (toDestroy.containsKey(key)) {\ntoDestroy.get(key).add(pairTimeStamp);\n} else {\nList<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();\nlistForKey.add(pairTimeStamp);\ntoDestroy.put(key, listForKey);\n}\nif (list.isEmpty()) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n_totalIdle--;\n_totalInternalProcessing++;\nitemsToRemove--;\n}\n}\ndestroy(toDestroy, _factory);\n}\n@Override\npublic void clear(K key) {\nMap<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();\nfinal ObjectQueue pool;\nsynchronized (this) {\npool = _poolMap.remove(key);\nif (pool == null) {\nreturn;\n} else {\n_poolList.remove(key);\n}\nList<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();\nobjects.addAll(pool.queue);\ntoDestroy.put(key, objects);\n_totalIdle = _totalIdle - pool.queue.size();\n_totalInternalProcessing =\n_totalInternalProcessing + pool.queue.size();\npool.queue.clear();\n}\ndestroy(toDestroy, _factory);\n}\nprivate void destroy(Map<K, List<ObjectTimestampPair<V>>> m, KeyedPoolableObjectFactory<K, V> factory) {\nfor (Map.Entry<K, List<ObjectTimestampPair<V>>> entry : m.entrySet()) {\nK key = entry.getKey();\nCollection<ObjectTimestampPair<V>> c = entry.getValue();\nfor (ObjectTimestampPair<V> pair : c) {\ntry {\nfactory.destroyObject(key, pair.getValue());\n} catch (Exception e) {\n} finally {\nsynchronized (this) {\n_totalInternalProcessing--;\nallocate();\n}\n}\n}\n}\n}\n@Override\npublic synchronized int getNumActive() {\nreturn _totalActive;\n}\n@Override\npublic synchronized int getNumIdle() {\nreturn _totalIdle;\n}\n@Override\npublic synchronized int getNumActive(K key) {\nfinal ObjectQueue pool = (_poolMap.get(key));\nreturn pool != null ? pool.activeCount : 0;\n}\n@Override\npublic synchronized int getNumIdle(K key) {\nfinal ObjectQueue pool = (_poolMap.get(key));\nreturn pool != null ? pool.queue.size() : 0;\n}\n@Override\npublic void returnObject(K key, V obj) throws Exception {\ntry {\naddObjectToPool(key, obj, true);\n} catch (Exception e) {\ntry {\n_factory.destroyObject(key, obj);\n} catch (Exception e2) {\n}\n// TODO: Correctness here depends on control in addObjectToPool.\nObjectQueue pool = (_poolMap.get(key));\nif (pool != null) {\nsynchronized(this) {\npool.decrementActiveCount();\nallocate();\n}\n}\n}\n}\nprivate void addObjectToPool(K key, V obj,\nboolean decrementNumActive) throws Exception {\nboolean success = true; \nif (this.testOnReturn && !_factory.validateObject(key, obj)) {\nsuccess = false;\n} else {\n_factory.passivateObject(key, obj);\n}\nboolean shouldDestroy = !success;\nObjectQueue pool;\nsynchronized (this) {\npool = (_poolMap.get(key));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(key, pool);\n_poolList.add(key);\n}\nif (isClosed()) {\nshouldDestroy = true;\n} else {\nif (this.maxIdlePerKey >= 0 && (pool.queue.size() >= this.maxIdlePerKey)) {\nshouldDestroy = true;\n} else if (success) {\nif (this.lifo) {\npool.queue.addFirst(new ObjectTimestampPair<V>(obj));\n} else {\npool.queue.addLast(new ObjectTimestampPair<V>(obj));\n}\n_totalIdle++;\nif (decrementNumActive) {\npool.decrementActiveCount();\n}\nallocate();\n}\n}\n}\nif (shouldDestroy) {\ntry {\n_factory.destroyObject(key, obj);\n} catch(Exception e) {\n}\nif (decrementNumActive) {\nsynchronized(this) {\npool.decrementActiveCount();\nallocate();\n}\n}\n}\n}\n@Override\npublic void invalidateObject(K key, V obj) throws Exception {\ntry {\n_factory.destroyObject(key, obj);\n} finally {\nsynchronized (this) {\nObjectQueue pool = (_poolMap.get(key));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(key, pool);\n_poolList.add(key);\n}\npool.decrementActiveCount();\nallocate(); \n}\n}\n}\n@Override\npublic void addObject(K key) throws Exception {\nassertOpen();\nV obj = _factory.makeObject(key);\ntry {\nassertOpen();\naddObjectToPool(key, obj, false);\n} catch (IllegalStateException ex) { \ntry {\n_factory.destroyObject(key, obj);\n} catch (Exception ex2) {\n}\nthrow ex;\n}\n}\npublic synchronized void preparePool(K key, boolean populateImmediately) {\nObjectQueue pool = (_poolMap.get(key));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(key,pool);\n_poolList.add(key);\n}\nif (populateImmediately) {\ntry {\nensureMinIdle(key);\n}\ncatch (Exception e) {\n}\n}\n}\n@Override\npublic void close() throws Exception {\nsuper.close();\nsynchronized (this) {\nclear();\nif (null != _evictionCursor) {\n_evictionCursor.close();\n_evictionCursor = null;\n}\nif (null != _evictionKeyCursor) {\n_evictionKeyCursor.close();\n_evictionKeyCursor = null;\n}\nstartEvictor(-1L);\n}\n}\npublic void evict() throws Exception {\nK key = null;\nboolean testWhileIdle;\nlong minEvictableIdleTimeMillis;\nsynchronized (this) {\ntestWhileIdle = this.testWhileIdle;\nminEvictableIdleTimeMillis = this.minEvictableIdleTimeMillis;\nif (_evictionKeyCursor != null &&\n_evictionKeyCursor._lastReturned != null) {\nkey = _evictionKeyCursor._lastReturned.value();\n}\n}\nfor (int i=0, m=getNumTests(); i<m; i++) {\nfinal ObjectTimestampPair<V> pair;\nsynchronized (this) {\nif (_poolMap == null || _poolMap.size() == 0) {\ncontinue;\n}\nif (null == _evictionKeyCursor) {\nresetEvictionKeyCursor();\nkey = null;\n}\nif (null == _evictionCursor) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n} else {\nresetEvictionKeyCursor();\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n}\n}\n}\n}\nif (_evictionCursor == null) {\ncontinue; \n}\nif ((this.lifo && !_evictionCursor.hasPrevious()) ||\n(!this.lifo && !_evictionCursor.hasNext())) {\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n} else { \nresetEvictionKeyCursor();\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n}\n}\n}\n}\n}\nif ((this.lifo && !_evictionCursor.hasPrevious()) ||\n(!this.lifo && !_evictionCursor.hasNext())) {\ncontinue; \n}\npair = this.lifo ?\n_evictionCursor.previous() :\n_evictionCursor.next();\n_evictionCursor.remove();\n_totalIdle--;\n_totalInternalProcessing++;\n}\nboolean removeObject=false;\nif ((minEvictableIdleTimeMillis > 0) &&\n(System.currentTimeMillis() - pair.getTstamp() >\nminEvictableIdleTimeMillis)) {\nremoveObject=true;\n}\nif (testWhileIdle && removeObject == false) {\nboolean active = false;\ntry {\n_factory.activateObject(key,pair.getValue());\nactive = true;\n} catch(Exception e) {\nremoveObject=true;\n}\nif (active) {\nif (!_factory.validateObject(key,pair.getValue())) {\nremoveObject=true;\n} else {\ntry {\n_factory.passivateObject(key,pair.getValue());\n} catch(Exception e) {\nremoveObject=true;\n}\n}\n}\n}\nif (removeObject) {\ntry {\n_factory.destroyObject(key, pair.getValue());\n} catch(Exception e) {\n} finally {\nif (this.minIdlePerKey == 0) {\nsynchronized (this) {\nObjectQueue objectQueue =\n_poolMap.get(key);\nif (objectQueue != null &&\nobjectQueue.queue.isEmpty()) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n}\n}\n}\n}\nsynchronized (this) {\nif (!removeObject) {\n_evictionCursor.add(pair);\n_totalIdle++;\nif (this.lifo) {\n_evictionCursor.previous();\n}\n}\n_totalInternalProcessing--;\n}\n}\n}\nprivate void resetEvictionKeyCursor() {\nif (_evictionKeyCursor != null) {\n_evictionKeyCursor.close();\n}\n_evictionKeyCursor = _poolList.cursor();\nif (null != _evictionCursor) {\n_evictionCursor.close();\n_evictionCursor = null;\n}\n}\nprivate void resetEvictionObjectCursor(K key) {\nif (_evictionCursor != null) {\n_evictionCursor.close();\n}\nif (_poolMap == null) {\nreturn;\n}\nObjectQueue pool = _poolMap.get(key);\nif (pool != null) {\nCursorableLinkedList<ObjectTimestampPair<V>> queue = pool.queue;\n_evictionCursor = queue.cursor(this.lifo ? queue.size() : 0);\n}\n}\n@SuppressWarnings(\"unchecked\") \nprivate void ensureMinIdle() throws Exception {\nif (this.minIdlePerKey > 0) {\nK[] keysCopy;\nsynchronized(this) {\nkeysCopy = (K[]) _poolMap.keySet().toArray(); \n}\nfor (int i=0; i < keysCopy.length; i++) {\nensureMinIdle(keysCopy[i]);\n}\n}\n}\nprivate void ensureMinIdle(K key) throws Exception {\nObjectQueue pool;\nsynchronized(this) {\npool = (_poolMap.get(key));\n}\nif (pool == null) {\nreturn;\n}\nint objectDeficit = calculateDeficit(pool, false);\nfor (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {\ntry {\naddObject(key);\n} finally {\nsynchronized (this) {\npool.decrementInternalProcessingCount();\nallocate();\n}\n}\n}\n}\nprotected synchronized void startEvictor(long delay) {\nif (null != _evictor) {\nEvictionTimer.cancel(_evictor);\n_evictor = null;\n}\nif (delay > 0) {\n_evictor = new Evictor();\nEvictionTimer.schedule(_evictor, delay, delay);\n}\n}\nsynchronized String debugInfo() {\nStringBuffer buf = new StringBuffer();\nbuf.append(\"Active: \").append(getNumActive()).append(\"\\n\");\nbuf.append(\"Idle: \").append(getNumIdle()).append(\"\\n\");\nfor (K key : _poolMap.keySet()) {\nbuf.append(\"\\t\").append(key).append(\" \").append(_poolMap.get(key)).append(\"\\n\");\n}\nreturn buf.toString();\n}\nprivate synchronized int getNumTests() {\nif (this.numTestsPerEvictionRun >= 0) {\nreturn Math.min(this.numTestsPerEvictionRun, _totalIdle);\n} else {\nreturn(int)(Math.ceil(_totalIdle/Math.abs((double)this.numTestsPerEvictionRun)));\n}\n}\nprivate synchronized int calculateDeficit(ObjectQueue pool,\nboolean incrementInternal) {\nint objectDefecit = 0;\nobjectDefecit = this.minIdlePerKey - pool.queue.size();\nif (this.maxTotalPerKey > 0) {\nint growLimit = Math.max(0, this.maxTotalPerKey - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);\nobjectDefecit = Math.min(objectDefecit, growLimit);\n}\nif (this.maxTotal > 0) {\nint growLimit = Math.max(0, this.maxTotal - getNumActive() - getNumIdle() - _totalInternalProcessing);\nobjectDefecit = Math.min(objectDefecit, growLimit);\n}\nif (incrementInternal && objectDefecit > 0) {\npool.incrementInternalProcessingCount();\n}\nreturn objectDefecit;\n}\nprivate class ObjectQueue {\nprivate int activeCount = 0;\nprivate final CursorableLinkedList<ObjectTimestampPair<V>> queue = new CursorableLinkedList<ObjectTimestampPair<V>>();\nprivate int internalProcessingCount = 0;\nvoid incrementActiveCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalActive++;\n}\nactiveCount++;\n}\nvoid decrementActiveCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalActive--;\n}\nif (activeCount > 0) {\nactiveCount--;\n}\n}\nvoid incrementInternalProcessingCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalInternalProcessing++;\n}\ninternalProcessingCount++;\n}\nvoid decrementInternalProcessingCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalInternalProcessing--;\n}\ninternalProcessingCount--;\n}\n}\nstatic class ObjectTimestampPair<V> implements Comparable<ObjectTimestampPair<V>> {\n//CHECKSTYLE: stop VisibilityModifier\nprivate final V value;\nprivate final long tstamp;\n//CHECKSTYLE: resume VisibilityModifier\nObjectTimestampPair(V val) {\nthis(val, System.currentTimeMillis());\n}\nObjectTimestampPair(V val, long time) {\nvalue = val;\ntstamp = time;\n}\n@Override\npublic String toString() {\nreturn value + \";\" + tstamp;\n}\npublic int compareTo(ObjectTimestampPair<V> other) {\nfinal long tstampdiff = this.tstamp - other.tstamp;\nif (tstampdiff == 0) {\nreturn System.identityHashCode(this) - System.identityHashCode(other);\n} else {\nreturn (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);\n}\n}\npublic V getValue() {\nreturn value;\n}\npublic long getTstamp() {\nreturn tstamp;\n}\n}\nprivate class Evictor extends TimerTask {\n@Override\npublic void run() {\ntry {\nevict();\n} catch(Exception e) {\n} catch(OutOfMemoryError oome) {\noome.printStackTrace(System.err);\n}\ntry {\nensureMinIdle();\n} catch (Exception e) {\n}\n}\n}\nprivate final class Latch {\nprivate final K _key;\nprivate ObjectQueue _pool;\nprivate ObjectTimestampPair<V> _pair;\nprivate boolean _mayCreate = false;\nprivate Latch(K key) {\n_key = key;\n}\nprivate synchronized K getkey() {\nreturn _key;\n}\nprivate synchronized ObjectQueue getPool() {\nreturn _pool;\n}\nprivate synchronized void setPool(ObjectQueue pool) {\n_pool = pool;\n}\nprivate synchronized ObjectTimestampPair<V> getPair() {\nreturn _pair;\n}\nprivate synchronized void setPair(ObjectTimestampPair<V> pair) {\n_pair = pair;\n}\nprivate synchronized boolean mayCreate() {\nreturn _mayCreate;\n}\nprivate synchronized void setMayCreate(boolean mayCreate) {\n_mayCreate = mayCreate;\n}\nprivate synchronized void reset() {\n_pair = null;\n_mayCreate = false;\n}\n}\nprivate int maxIdlePerKey; \nprivate int minIdlePerKey; \nprivate int maxTotalPerKey; \nprivate int maxTotal; \nprivate long maxWait; \nprivate WhenExhaustedAction whenExhaustedAction; \nprivate boolean testOnBorrow; \nprivate boolean testOnReturn; \nprivate boolean testWhileIdle; \nprivate long timeBetweenEvictionRunsMillis; \nprivate int numTestsPerEvictionRun; \nprivate long minEvictableIdleTimeMillis; \nprivate boolean lifo; \nprivate final Map<K,ObjectQueue> _poolMap;\nprivate int _totalActive = 0;\nprivate int _totalIdle = 0;\nprivate int _totalInternalProcessing = 0;\nprivate final KeyedPoolableObjectFactory<K,V> _factory;\nprivate Evictor _evictor = null;\nprivate final CursorableLinkedList<K> _poolList;\nprivate CursorableLinkedList<ObjectTimestampPair<V>>.Cursor _evictionCursor = null;\nprivate CursorableLinkedList<K>.Cursor _evictionKeyCursor = null;\nprivate final LinkedList<Latch> _allocationQueue = new LinkedList<Latch>();\n",
    "warning_method": "private void allocate() {\nboolean clearOldest = false;\nsynchronized (this) {\nif (isClosed())\nreturn;\nIterator<Latch> allocationQueueIter = _allocationQueue.iterator();\nwhile (allocationQueueIter.hasNext()) {\nLatch latch = allocationQueueIter.next();\nObjectQueue pool = _poolMap.get(latch.getkey());\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(latch.getkey(), pool);\n_poolList.add(latch.getkey());\n}\nlatch.setPool(pool);\nif (!pool.queue.isEmpty()) {\nallocationQueueIter.remove();\nlatch.setPair(pool.queue.removeFirst());\npool.incrementInternalProcessingCount();\n_totalIdle--;\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif ((this.maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= this.maxTotal)) {\nclearOldest = true;\nbreak;\n}\nif ((this.maxTotalPerKey < 0 || pool.activeCount + pool.internalProcessingCount < this.maxTotalPerKey) && (this.maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < this.maxTotal)) {\nallocationQueueIter.remove();\nlatch.setMayCreate(true);\npool.incrementInternalProcessingCount();\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif (this.maxTotalPerKey < 0) {\nbreak;\n}\n}\n}\nif (clearOldest) {\nclearOldest();\n}\n}"
}