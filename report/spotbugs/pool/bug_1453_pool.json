{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "pool",
    "warning_line": "public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {\npublic static final byte WHEN_EXHAUSTED_FAIL   = 0;\npublic static final byte WHEN_EXHAUSTED_BLOCK  = 1;\npublic static final byte WHEN_EXHAUSTED_GROW   = 2;\npublic static final int DEFAULT_MAX_IDLE  = 8;\npublic static final int DEFAULT_MAX_ACTIVE  = 8;\npublic static final int DEFAULT_MAX_TOTAL  = -1;\npublic static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;\npublic static final long DEFAULT_MAX_WAIT = -1L;\npublic static final boolean DEFAULT_TEST_ON_BORROW = false;\npublic static final boolean DEFAULT_TEST_ON_RETURN = false;\npublic static final boolean DEFAULT_TEST_WHILE_IDLE = false;\npublic static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;\npublic static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;\npublic static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;\npublic static final int DEFAULT_MIN_IDLE = 0;\npublic static final boolean DEFAULT_LIFO = true;\npublic GenericKeyedObjectPool() {\nthis(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,\nDEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,\nDEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {\nthis(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,\nDEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,\nDEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {\nthis(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,\nconfig.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,\nconfig.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {\nthis(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,\nDEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,\nDEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,\nDEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, boolean testOnBorrow, boolean testOnReturn) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,\nDEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, int maxIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,\nDEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,\nDEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,\nDEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,\nint numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,\ntestOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,\nminEvictableIdleTimeMillis, testWhileIdle);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,\nlong timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,\nboolean testWhileIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,\nGenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,\nnumTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,\nlong timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,\nboolean testWhileIdle) {\nthis(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,\ntimeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,\nDEFAULT_LIFO);\n}\npublic GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,\nlong maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,\nlong timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,\nboolean testWhileIdle, boolean lifo) {\n_factory = factory;\n_factoryClassLoader = Thread.currentThread().getContextClassLoader();\n_maxActive = maxActive;\n_lifo = lifo;\nswitch (whenExhaustedAction) {\ncase WHEN_EXHAUSTED_BLOCK:\ncase WHEN_EXHAUSTED_FAIL:\ncase WHEN_EXHAUSTED_GROW:\n_whenExhaustedAction = whenExhaustedAction;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"whenExhaustedAction \" + whenExhaustedAction + \" not recognized.\");\n}\n_maxWait = maxWait;\n_maxIdle = maxIdle;\n_maxTotal = maxTotal;\n_minIdle = minIdle;\n_testOnBorrow = testOnBorrow;\n_testOnReturn = testOnReturn;\n_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;\n_numTestsPerEvictionRun = numTestsPerEvictionRun;\n_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;\n_testWhileIdle = testWhileIdle;\n_poolMap = new HashMap();\n_poolList = new CursorableLinkedList();\nstartEvictor(_timeBetweenEvictionRunsMillis);\n}\npublic synchronized int getMaxActive() {\nreturn _maxActive;\n}\npublic void setMaxActive(int maxActive) {\nsynchronized(this) {\n_maxActive = maxActive;\n}\nallocate();\n}\npublic synchronized int getMaxTotal() {\nreturn _maxTotal;\n}\npublic void setMaxTotal(int maxTotal) {\nsynchronized(this) {\n_maxTotal = maxTotal;\n}\nallocate();\n}\npublic synchronized byte getWhenExhaustedAction() {\nreturn _whenExhaustedAction;\n}\npublic void setWhenExhaustedAction(byte whenExhaustedAction) {\nsynchronized(this) {\nswitch(whenExhaustedAction) {\ncase WHEN_EXHAUSTED_BLOCK:\ncase WHEN_EXHAUSTED_FAIL:\ncase WHEN_EXHAUSTED_GROW:\n_whenExhaustedAction = whenExhaustedAction;\nbreak;\ndefault:\nthrow new IllegalArgumentException(\"whenExhaustedAction \" + whenExhaustedAction + \" not recognized.\");\n}\n}\nallocate();\n}\npublic synchronized long getMaxWait() {\nreturn _maxWait;\n}\npublic void setMaxWait(long maxWait) {\nsynchronized(this) {\n_maxWait = maxWait;\n}\nallocate();\n}\npublic synchronized int getMaxIdle() {\nreturn _maxIdle;\n}\npublic void setMaxIdle(int maxIdle) {\nsynchronized(this) {\n_maxIdle = maxIdle;\n}\nallocate();\n}\npublic void setMinIdle(int poolSize) {\n_minIdle = poolSize;\n}\npublic int getMinIdle() {\nint maxIdle = getMaxIdle();\nif (_minIdle > maxIdle) {\nreturn maxIdle;\n} else {\nreturn _minIdle;\n}\n}\npublic boolean getTestOnBorrow() {\nreturn _testOnBorrow;\n}\npublic void setTestOnBorrow(boolean testOnBorrow) {\n_testOnBorrow = testOnBorrow;\n}\npublic boolean getTestOnReturn() {\nreturn _testOnReturn;\n}\npublic void setTestOnReturn(boolean testOnReturn) {\n_testOnReturn = testOnReturn;\n}\npublic synchronized long getTimeBetweenEvictionRunsMillis() {\nreturn _timeBetweenEvictionRunsMillis;\n}\npublic synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {\n_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;\nstartEvictor(_timeBetweenEvictionRunsMillis);\n}\npublic synchronized int getNumTestsPerEvictionRun() {\nreturn _numTestsPerEvictionRun;\n}\npublic synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {\n_numTestsPerEvictionRun = numTestsPerEvictionRun;\n}\npublic synchronized long getMinEvictableIdleTimeMillis() {\nreturn _minEvictableIdleTimeMillis;\n}\npublic synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {\n_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;\n}\npublic synchronized boolean getTestWhileIdle() {\nreturn _testWhileIdle;\n}\npublic synchronized void setTestWhileIdle(boolean testWhileIdle) {\n_testWhileIdle = testWhileIdle;\n}\npublic synchronized void setConfig(GenericKeyedObjectPool.Config conf) {\nsetMaxIdle(conf.maxIdle);\nsetMaxActive(conf.maxActive);\nsetMaxTotal(conf.maxTotal);\nsetMinIdle(conf.minIdle);\nsetMaxWait(conf.maxWait);\nsetWhenExhaustedAction(conf.whenExhaustedAction);\nsetTestOnBorrow(conf.testOnBorrow);\nsetTestOnReturn(conf.testOnReturn);\nsetTestWhileIdle(conf.testWhileIdle);\nsetNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);\nsetMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);\nsetTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);\n}\npublic synchronized boolean getLifo() {\nreturn _lifo;\n}\npublic synchronized void setLifo(boolean lifo) {\nthis._lifo = lifo;\n}\npublic Object borrowObject(Object key) throws Exception {\nlong starttime = System.currentTimeMillis();\nLatch latch = new Latch(key);\nbyte whenExhaustedAction;\nlong maxWait;\nsynchronized (this) {\nwhenExhaustedAction = _whenExhaustedAction;\nmaxWait = _maxWait;\n_allocationQueue.add(latch);\n}\nallocate();\nfor(;;) {\nsynchronized (this) {\nassertOpen();\n}\nif (null == latch.getPair()) {\nif (latch.mayCreate()) {\n} else {\nswitch(whenExhaustedAction) {\ncase WHEN_EXHAUSTED_GROW:\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\nlatch.getPool().incrementInternalProcessingCount();\n}\n}\nbreak;\ncase WHEN_EXHAUSTED_FAIL:\nsynchronized (this) {\nif (latch.getPair() != null || latch.mayCreate()) {\nbreak;\n}\n_allocationQueue.remove(latch);\n}\nthrow new NoSuchElementException(\"Pool exhausted\");\ncase WHEN_EXHAUSTED_BLOCK:\ntry {\nsynchronized (latch) {\nif (latch.getPair() == null && !latch.mayCreate()) {\nif (maxWait <= 0) {\nlatch.wait();\n} else {\nfinal long elapsed = (System.currentTimeMillis() - starttime);\nfinal long waitTime = maxWait - elapsed;\nif (waitTime > 0)\n{\nlatch.wait(waitTime);\n}\n}\n} else {\nbreak;\n}\n}\nif(isClosed() == true) {\nthrow new IllegalStateException(\"Pool closed\");\n}\n} catch(InterruptedException e) {\nboolean doAllocate = false;\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n} else if (latch.getPair() == null && latch.mayCreate()) {\nlatch.getPool().decrementInternalProcessingCount();\ndoAllocate = true;\n} else {\nlatch.getPool().decrementInternalProcessingCount();\nlatch.getPool().incrementActiveCount();\nreturnObject(latch.getkey(), latch.getPair().getValue());\n}\n}\nif (doAllocate) {\nallocate();\n}\nThread.currentThread().interrupt();\nthrow e;\n}\nif (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {\nsynchronized (this) {\nif (latch.getPair() == null && !latch.mayCreate()) {\n_allocationQueue.remove(latch);\n} else {\nbreak;\n}\n}\nthrow new NoSuchElementException(\"Timeout waiting for idle object\");\n} else {\ncontinue; \n}\ndefault:\nthrow new IllegalArgumentException(\"whenExhaustedAction \" + whenExhaustedAction +\n\" not recognized.\");\n}\n}\n}\nboolean newlyCreated = false;\nif (null == latch.getPair()) {\ntry {\nObject obj = _factory.makeObject(key);\nlatch.setPair(new ObjectTimestampPair(obj));\nnewlyCreated = true;\n} finally {\nif (!newlyCreated) {\nsynchronized (this) {\nlatch.getPool().decrementInternalProcessingCount();\n}\nallocate();\n}\n}\n}\ntry {\n_factory.activateObject(key, latch.getPair().value);\nif (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {\nthrow new Exception(\"ValidateObject failed\");\n}\nsynchronized (this) {\nlatch.getPool().decrementInternalProcessingCount();\nlatch.getPool().incrementActiveCount();\n}\nreturn latch.getPair().value;\n} catch (Throwable e) {\nPoolUtils.checkRethrow(e);\ntry {\n_factory.destroyObject(key, latch.getPair().value);\n} catch (Throwable e2) {\nPoolUtils.checkRethrow(e2);\n}\nsynchronized (this) {\nlatch.getPool().decrementInternalProcessingCount();\nif (!newlyCreated) {\nlatch.reset();\n_allocationQueue.add(0, latch);\n}\n}\nallocate();\nif (newlyCreated) {\nNoSuchElementException nsee = new NoSuchElementException(\n\"Unable to validate object\");\nnsee.initCause(e);\nthrow nsee;\n}\nelse {\ncontinue; \n}\n}\n}\n}\nprivate void allocate() {\nboolean clearOldest = false;\nsynchronized (this) {\nif (isClosed()) return;\nIterator allocationQueueIter = _allocationQueue.iterator();\nwhile (allocationQueueIter.hasNext()) {\nLatch latch = (Latch) allocationQueueIter.next();\nObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(latch.getkey(), pool);\n_poolList.add(latch.getkey());\n}\nlatch.setPool(pool);\nif (!pool.queue.isEmpty()) {\nallocationQueueIter.remove();\nlatch.setPair(\n(ObjectTimestampPair) pool.queue.removeFirst());\npool.incrementInternalProcessingCount();\n_totalIdle--;\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif ((_maxTotal > 0) &&\n(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {\nclearOldest = true;\nbreak;\n}\nif ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&\n(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {\nallocationQueueIter.remove();\nlatch.setMayCreate(true);\npool.incrementInternalProcessingCount();\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif (_maxActive < 0) {\nbreak;\n}\n}\n}\nif (clearOldest) {\nclearOldest();\n}\n}\npublic void clear() {\nMap toDestroy = new HashMap();\nsynchronized (this) {\nfor (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {\nObject key = it.next();\nObjectQueue pool = (ObjectQueue)_poolMap.get(key);\nList objects = new ArrayList();\nobjects.addAll(pool.queue);\ntoDestroy.put(key, objects);\nit.remove();\n_poolList.remove(key);\n_totalIdle = _totalIdle - pool.queue.size();\n_totalInternalProcessing =\n_totalInternalProcessing + pool.queue.size();\npool.queue.clear();\n}\n}\ndestroy(toDestroy, _factory);\n}\npublic void clearOldest() {\nfinal Map toDestroy = new HashMap();\nfinal Map map = new TreeMap();\nsynchronized (this) {\nfor (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {\nfinal Object key = keyiter.next();\nfinal CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;\nfor (Iterator it = list.iterator(); it.hasNext();) {\nmap.put(it.next(), key);\n}\n}\nSet setPairKeys = map.entrySet();\nint itemsToRemove = ((int) (map.size() * 0.15)) + 1;\nIterator iter = setPairKeys.iterator();\nwhile (iter.hasNext() && itemsToRemove > 0) {\nMap.Entry entry = (Map.Entry) iter.next();\nObject key = entry.getValue();\nObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();\nObjectQueue objectQueue = (ObjectQueue)_poolMap.get(key);\nfinal CursorableLinkedList list = objectQueue.queue;\nlist.remove(pairTimeStamp);\nif (toDestroy.containsKey(key)) {\n((List)toDestroy.get(key)).add(pairTimeStamp);\n} else {\nList listForKey = new ArrayList();\nlistForKey.add(pairTimeStamp);\ntoDestroy.put(key, listForKey);\n}\nobjectQueue.incrementInternalProcessingCount();\n_totalIdle--;\nitemsToRemove--;\n}\n}\ndestroy(toDestroy, _factory);\n}\npublic void clear(Object key) {\nMap toDestroy = new HashMap();\nfinal ObjectQueue pool;\nsynchronized (this) {\npool = (ObjectQueue)(_poolMap.remove(key));\nif (pool == null) {\nreturn;\n} else {\n_poolList.remove(key);\n}\nList objects = new ArrayList();\nobjects.addAll(pool.queue);\ntoDestroy.put(key, objects);\n_totalIdle = _totalIdle - pool.queue.size();\n_totalInternalProcessing =\n_totalInternalProcessing + pool.queue.size();\npool.queue.clear();\n}\ndestroy(toDestroy, _factory);\n}\nprivate void destroy(Map m, KeyedPoolableObjectFactory factory) {\nfor (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {\nMap.Entry entry = (Entry) entries.next();\nObject key = entry.getKey();\nCollection c = (Collection) entry.getValue();\nfor (Iterator it = c.iterator(); it.hasNext();) {\ntry {\nfactory.destroyObject(\nkey,((ObjectTimestampPair)(it.next())).value);\n} catch(Exception e) {\n} finally {\nsynchronized(this) {\nObjectQueue objectQueue =\n(ObjectQueue) _poolMap.get(key);\nif (objectQueue != null) {\nobjectQueue.decrementInternalProcessingCount();\nif (objectQueue.internalProcessingCount == 0 &&\nobjectQueue.activeCount == 0 &&\nobjectQueue.queue.isEmpty()) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n} else {\n_totalInternalProcessing--;\n}\n}\nallocate();\n}\n}\n}\n}\npublic synchronized int getNumActive() {\nreturn _totalActive;\n}\npublic synchronized int getNumIdle() {\nreturn _totalIdle;\n}\npublic synchronized int getNumActive(Object key) {\nfinal ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));\nreturn pool != null ? pool.activeCount : 0;\n}\npublic synchronized int getNumIdle(Object key) {\nfinal ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));\nreturn pool != null ? pool.queue.size() : 0;\n}\npublic void returnObject(Object key, Object obj) throws Exception {\ntry {\naddObjectToPool(key, obj, true);\n} catch (Exception e) {\nif (_factory != null) {\ntry {\n_factory.destroyObject(key, obj);\n} catch (Exception e2) {\n}\n// TODO: Correctness here depends on control in addObjectToPool.\nObjectQueue pool = (ObjectQueue) (_poolMap.get(key));\nif (pool != null) {\nsynchronized(this) {\npool.decrementActiveCount();\nif (pool.queue.isEmpty() &&\npool.activeCount == 0 &&\npool.internalProcessingCount == 0) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n}\nallocate();\n}\n}\n}\n}\nprivate void addObjectToPool(Object key, Object obj,\nboolean decrementNumActive) throws Exception {\nboolean success = true; \nif (_testOnReturn && !_factory.validateObject(key, obj)) {\nsuccess = false;\n} else {\n_factory.passivateObject(key, obj);\n}\nboolean shouldDestroy = !success;\nObjectQueue pool;\nboolean doAllocate = false;\nsynchronized (this) {\npool = (ObjectQueue) (_poolMap.get(key));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(key, pool);\n_poolList.add(key);\n}\nif (isClosed()) {\nshouldDestroy = true;\n} else {\nif (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {\nshouldDestroy = true;\n} else if (success) {\nif (_lifo) {\npool.queue.addFirst(new ObjectTimestampPair(obj));\n} else {\npool.queue.addLast(new ObjectTimestampPair(obj));\n}\n_totalIdle++;\nif (decrementNumActive) {\npool.decrementActiveCount();\n}\ndoAllocate = true;\n}\n}\n}\nif (doAllocate) {\nallocate();\n}\nif (shouldDestroy) {\ntry {\n_factory.destroyObject(key, obj);\n} catch(Exception e) {\n}\nif (decrementNumActive) {\nsynchronized(this) {\npool.decrementActiveCount();\nif (pool.queue.isEmpty() &&\npool.activeCount == 0 &&\npool.internalProcessingCount == 0) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n}\nallocate();\n}\n}\n}\npublic void invalidateObject(Object key, Object obj) throws Exception {\ntry {\n_factory.destroyObject(key, obj);\n} finally {\nsynchronized (this) {\nObjectQueue pool = (ObjectQueue) (_poolMap.get(key));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(key, pool);\n_poolList.add(key);\n}\npool.decrementActiveCount();\n}\nallocate(); \n}\n}\npublic void addObject(Object key) throws Exception {\nassertOpen();\nif (_factory == null) {\nthrow new IllegalStateException(\"Cannot add objects without a factory.\");\n}\nObject obj = _factory.makeObject(key);\ntry {\nassertOpen();\naddObjectToPool(key, obj, false);\n} catch (IllegalStateException ex) { \ntry {\n_factory.destroyObject(key, obj);\n} catch (Exception ex2) {\n}\nthrow ex;\n}\n}\npublic synchronized void preparePool(Object key, boolean populateImmediately) {\nObjectQueue pool = (ObjectQueue)(_poolMap.get(key));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(key,pool);\n_poolList.add(key);\n}\nif (populateImmediately) {\ntry {\nensureMinIdle(key);\n}\ncatch (Exception e) {\n}\n}\n}\npublic void close() throws Exception {\nsuper.close();\nsynchronized (this) {\nclear();\nif (null != _evictionCursor) {\n_evictionCursor.close();\n_evictionCursor = null;\n}\nif (null != _evictionKeyCursor) {\n_evictionKeyCursor.close();\n_evictionKeyCursor = null;\n}\nstartEvictor(-1L);\nwhile(_allocationQueue.size() > 0) {\nLatch l = (Latch) _allocationQueue.removeFirst();\nsynchronized (l) {\nl.notify();\n}\n}\n}\n}\npublic void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {\nMap toDestroy = new HashMap();\nfinal KeyedPoolableObjectFactory oldFactory = _factory;\nsynchronized (this) {\nassertOpen();\nif (0 < getNumActive()) {\nthrow new IllegalStateException(\"Objects are already active\");\n} else {\nfor (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {\nObject key = it.next();\nObjectQueue pool = (ObjectQueue)_poolMap.get(key);\nif (pool != null) {\nList objects = new ArrayList();\nobjects.addAll(pool.queue);\ntoDestroy.put(key, objects);\nit.remove();\n_poolList.remove(key);\n_totalIdle = _totalIdle - pool.queue.size();\n_totalInternalProcessing =\n_totalInternalProcessing + pool.queue.size();\npool.queue.clear();\n}\n}\n_factory = factory;\n_factoryClassLoader = Thread.currentThread().getContextClassLoader();\n}\n}\ndestroy(toDestroy, oldFactory);\n}\npublic void evict() throws Exception {\nObject key = null;\nboolean testWhileIdle;\nlong minEvictableIdleTimeMillis;\nsynchronized (this) {\ntestWhileIdle = _testWhileIdle;\nminEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;\nif (_evictionKeyCursor != null &&\n_evictionKeyCursor._lastReturned != null) {\nkey = _evictionKeyCursor._lastReturned.value();\n}\n}\nfor (int i=0, m=getNumTests(); i<m; i++) {\nfinal ObjectTimestampPair pair;\nsynchronized (this) {\nif (_poolMap == null || _poolMap.size() == 0) {\ncontinue;\n}\nif (null == _evictionKeyCursor) {\nresetEvictionKeyCursor();\nkey = null;\n}\nif (null == _evictionCursor) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n} else {\nresetEvictionKeyCursor();\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n}\n}\n}\n}\nif (_evictionCursor == null) {\ncontinue; \n}\nif ((_lifo && !_evictionCursor.hasPrevious()) ||\n(!_lifo && !_evictionCursor.hasNext())) {\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n} else { \nresetEvictionKeyCursor();\nif (_evictionKeyCursor != null) {\nif (_evictionKeyCursor.hasNext()) {\nkey = _evictionKeyCursor.next();\nresetEvictionObjectCursor(key);\n}\n}\n}\n}\n}\nif ((_lifo && !_evictionCursor.hasPrevious()) ||\n(!_lifo && !_evictionCursor.hasNext())) {\ncontinue; \n}\npair = _lifo ?\n(ObjectTimestampPair) _evictionCursor.previous() :\n(ObjectTimestampPair) _evictionCursor.next();\n_evictionCursor.remove();\nObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);\nobjectQueue.incrementInternalProcessingCount();\n_totalIdle--;\n}\nboolean removeObject=false;\nif ((minEvictableIdleTimeMillis > 0) &&\n(System.currentTimeMillis() - pair.tstamp >\nminEvictableIdleTimeMillis)) {\nremoveObject=true;\n}\nif (testWhileIdle && removeObject == false) {\nboolean active = false;\ntry {\n_factory.activateObject(key,pair.value);\nactive = true;\n} catch(Exception e) {\nremoveObject=true;\n}\nif (active) {\nif (!_factory.validateObject(key,pair.value)) {\nremoveObject=true;\n} else {\ntry {\n_factory.passivateObject(key,pair.value);\n} catch(Exception e) {\nremoveObject=true;\n}\n}\n}\n}\nif (removeObject) {\ntry {\n_factory.destroyObject(key, pair.value);\n} catch(Exception e) {\n}\n}\nsynchronized (this) {\nObjectQueue objectQueue =\n(ObjectQueue)_poolMap.get(key);\nobjectQueue.decrementInternalProcessingCount();\nif (removeObject) {\nif (objectQueue.queue.isEmpty() &&\nobjectQueue.activeCount == 0 &&\nobjectQueue.internalProcessingCount == 0) {\n_poolMap.remove(key);\n_poolList.remove(key);\n}\n} else {\n_evictionCursor.add(pair);\n_totalIdle++;\nif (_lifo) {\n_evictionCursor.previous();\n}\n}\n}\n}\nallocate();\n}\nprivate void resetEvictionKeyCursor() {\nif (_evictionKeyCursor != null) {\n_evictionKeyCursor.close();\n}\n_evictionKeyCursor = _poolList.cursor();\nif (null != _evictionCursor) {\n_evictionCursor.close();\n_evictionCursor = null;\n}\n}\nprivate void resetEvictionObjectCursor(Object key) {\nif (_evictionCursor != null) {\n_evictionCursor.close();\n}\nif (_poolMap == null) {\nreturn;\n}\nObjectQueue pool = (ObjectQueue) (_poolMap.get(key));\nif (pool != null) {\nCursorableLinkedList queue = pool.queue;\n_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);\n}\n}\nprivate void ensureMinIdle() throws Exception {\nif (getMinIdle() > 0) {\nObject[] keysCopy;\nsynchronized(this) {\nkeysCopy = _poolMap.keySet().toArray();\n}\nfor (int i=0; i < keysCopy.length; i++) {\nensureMinIdle(keysCopy[i]);\n}\n}\n}\nprivate void ensureMinIdle(Object key) throws Exception {\nObjectQueue pool;\nsynchronized(this) {\npool = (ObjectQueue)(_poolMap.get(key));\n}\nif (pool == null) {\nreturn;\n}\nint objectDeficit = calculateDeficit(pool, false);\nfor (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {\ntry {\naddObject(key);\n} finally {\nsynchronized (this) {\npool.decrementInternalProcessingCount();\n}\nallocate();\n}\n}\n}\nprotected synchronized void startEvictor(long delay) {\nif (null != _evictor) {\nEvictionTimer.cancel(_evictor);\n_evictor = null;\n}\nif (delay > 0) {\n_evictor = new Evictor();\nEvictionTimer.schedule(_evictor, delay, delay);\n}\n}\nsynchronized String debugInfo() {\nStringBuffer buf = new StringBuffer();\nbuf.append(\"Active: \").append(getNumActive()).append(\"\\n\");\nbuf.append(\"Idle: \").append(getNumIdle()).append(\"\\n\");\nIterator it = _poolMap.keySet().iterator();\nwhile (it.hasNext()) {\nObject key = it.next();\nbuf.append(\"\\t\").append(key).append(\" \").append(_poolMap.get(key)).append(\"\\n\");\n}\nreturn buf.toString();\n}\nprivate synchronized int getNumTests() {\nif (_numTestsPerEvictionRun >= 0) {\nreturn Math.min(_numTestsPerEvictionRun, _totalIdle);\n} else {\nreturn(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));\n}\n}\nprivate synchronized int calculateDeficit(ObjectQueue pool,\nboolean incrementInternal) {\nint objectDefecit = 0;\nobjectDefecit = getMinIdle() - pool.queue.size();\nif (getMaxActive() > 0) {\nint growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);\nobjectDefecit = Math.min(objectDefecit, growLimit);\n}\nif (getMaxTotal() > 0) {\nint growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);\nobjectDefecit = Math.min(objectDefecit, growLimit);\n}\nif (incrementInternal && objectDefecit > 0) {\npool.incrementInternalProcessingCount();\n}\nreturn objectDefecit;\n}\nprivate class ObjectQueue {\nprivate int activeCount = 0;\nprivate final CursorableLinkedList queue = new CursorableLinkedList();\nprivate int internalProcessingCount = 0;\nvoid incrementActiveCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalActive++;\n}\nactiveCount++;\n}\nvoid decrementActiveCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalActive--;\n}\nif (activeCount > 0) {\nactiveCount--;\n}\n}\nvoid incrementInternalProcessingCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalInternalProcessing++;\n}\ninternalProcessingCount++;\n}\nvoid decrementInternalProcessingCount() {\nsynchronized (GenericKeyedObjectPool.this) {\n_totalInternalProcessing--;\n}\ninternalProcessingCount--;\n}\n}\nstatic class ObjectTimestampPair implements Comparable {\n//CHECKSTYLE: stop VisibilityModifier\nObject value;\nlong tstamp;\n//CHECKSTYLE: resume VisibilityModifier\nObjectTimestampPair(Object val) {\nthis(val, System.currentTimeMillis());\n}\nObjectTimestampPair(Object val, long time) {\nvalue = val;\ntstamp = time;\n}\npublic String toString() {\nreturn value + \";\" + tstamp;\n}\npublic int compareTo(Object obj) {\nreturn compareTo((ObjectTimestampPair) obj);\n}\npublic int compareTo(ObjectTimestampPair other) {\nfinal long tstampdiff = this.tstamp - other.tstamp;\nif (tstampdiff == 0) {\nreturn System.identityHashCode(this) - System.identityHashCode(other);\n} else {\nreturn (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);\n}\n}\npublic Object getValue() {\nreturn value;\n}\npublic long getTstamp() {\nreturn tstamp;\n}\n}\nprivate class Evictor extends TimerTask {\npublic void run() {\nClassLoader savedClassLoader =\nThread.currentThread().getContextClassLoader();\ntry {\nThread.currentThread().setContextClassLoader(\n_factoryClassLoader);\ntry {\nevict();\n} catch(Exception e) {\n} catch(OutOfMemoryError oome) {\noome.printStackTrace(System.err);\n}\ntry {\nensureMinIdle();\n} catch (Exception e) {\n}\n} finally {\nThread.currentThread().setContextClassLoader(savedClassLoader);\n}\n}\n}\npublic static class Config {\n//CHECKSTYLE: stop VisibilityModifier\npublic int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;\npublic int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;\npublic int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;\npublic int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;\npublic long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;\npublic byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;\npublic boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;\npublic boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;\npublic boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;\npublic long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;\npublic int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;\npublic long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;\npublic boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;\n//CHECKSTYLE: resume VisibilityModifier\n}\nprivate static final class Latch {\nprivate final Object _key;\nprivate ObjectQueue _pool;\nprivate ObjectTimestampPair _pair;\nprivate boolean _mayCreate = false;\nprivate Latch(Object key) {\n_key = key;\n}\nprivate synchronized Object getkey() {\nreturn _key;\n}\nprivate synchronized ObjectQueue getPool() {\nreturn _pool;\n}\nprivate synchronized void setPool(ObjectQueue pool) {\n_pool = pool;\n}\nprivate synchronized ObjectTimestampPair getPair() {\nreturn _pair;\n}\nprivate synchronized void setPair(ObjectTimestampPair pair) {\n_pair = pair;\n}\nprivate synchronized boolean mayCreate() {\nreturn _mayCreate;\n}\nprivate synchronized void setMayCreate(boolean mayCreate) {\n_mayCreate = mayCreate;\n}\nprivate synchronized void reset() {\n_pair = null;\n_mayCreate = false;\n}\n}\nprivate int _maxIdle = DEFAULT_MAX_IDLE;\nprivate volatile int _minIdle = DEFAULT_MIN_IDLE;\nprivate int _maxActive = DEFAULT_MAX_ACTIVE;\nprivate int _maxTotal = DEFAULT_MAX_TOTAL;\nprivate long _maxWait = DEFAULT_MAX_WAIT;\nprivate byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;\nprivate volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;\nprivate volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;\nprivate boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;\nprivate long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;\nprivate int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;\nprivate long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;\nprivate Map _poolMap = null;\nprivate int _totalActive = 0;\nprivate int _totalIdle = 0;\nprivate int _totalInternalProcessing = 0;\nprivate KeyedPoolableObjectFactory _factory = null;\nprivate ClassLoader _factoryClassLoader = null;\nprivate Evictor _evictor = null;\nprivate CursorableLinkedList _poolList = null;\nprivate CursorableLinkedList.Cursor _evictionCursor = null;\nprivate CursorableLinkedList.Cursor _evictionKeyCursor = null;\nprivate boolean _lifo = DEFAULT_LIFO;\nprivate LinkedList _allocationQueue = new LinkedList();\n",
    "warning_method": "public void run() {\nClassLoader savedClassLoader = Thread.currentThread().getContextClassLoader();\ntry {\n// set the classloader for the factory\nThread.currentThread().setContextClassLoader(_factoryClassLoader);\n// Evict from the pool\ntry {\nevict();\n} catch (Exception e) {\n} catch (OutOfMemoryError oome) {\noome.printStackTrace(System.err);\n}\n// Re-create idle instances.\ntry {\nensureMinIdle();\n} catch (Exception e) {\n}\n} finally {\n// restore the previous CCL\nThread.currentThread().setContextClassLoader(savedClassLoader);\n}\n}"
}