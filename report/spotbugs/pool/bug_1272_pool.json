{
    "category": "Multithreaded correctness",
    "vtype": "NO_NOTIFY_NOT_NOTIFYALL",
    "priority": "3",
    "rank": "17",
    "project": "pool",
    "warning_line": "latch.notify();\n",
    "warning_method": "private synchronized void allocate() {\nif (isClosed())\nreturn;\nfor (; ; ) {\nif (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {\nLatch latch = (Latch) _allocationQueue.removeFirst();\nlatch.setPair((ObjectTimestampPair) _pool.removeFirst());\n_numInternalProcessing++;\nsynchronized (latch) {\nlatch.notify();\n}\n} else {\nbreak;\n}\n}\nfor (; ; ) {\nif ((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {\nLatch latch = (Latch) _allocationQueue.removeFirst();\nlatch.setMayCreate(true);\n_numInternalProcessing++;\nsynchronized (latch) {\nlatch.notify();\n}\n} else {\nbreak;\n}\n}\n}"
}