{
    "category": "Multithreaded correctness",
    "vtype": "NO_NOTIFY_NOT_NOTIFYALL",
    "priority": "3",
    "rank": "17",
    "project": "pool",
    "warning_line": "latch.notify();\n",
    "warning_method": "private void allocate() {\nboolean clearOldest = false;\nsynchronized (this) {\nif (isClosed())\nreturn;\nIterator allocationQueueIter = _allocationQueue.iterator();\nwhile (allocationQueueIter.hasNext()) {\nLatch latch = (Latch) allocationQueueIter.next();\nObjectQueue pool = (ObjectQueue) (_poolMap.get(latch.getkey()));\nif (null == pool) {\npool = new ObjectQueue();\n_poolMap.put(latch.getkey(), pool);\n_poolList.add(latch.getkey());\n}\nlatch.setPool(pool);\nif (!pool.queue.isEmpty()) {\nallocationQueueIter.remove();\nlatch.setPair((ObjectTimestampPair) pool.queue.removeFirst());\npool.incrementInternalProcessingCount();\n_totalIdle--;\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif ((_maxTotal > 0) && (_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {\nclearOldest = true;\nbreak;\n}\nif ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) && (_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {\nallocationQueueIter.remove();\nlatch.setMayCreate(true);\npool.incrementInternalProcessingCount();\nsynchronized (latch) {\nlatch.notify();\n}\ncontinue;\n}\nif (_maxActive < 0) {\nbreak;\n}\n}\n}\nif (clearOldest) {\nclearOldest();\n}\n}"
}