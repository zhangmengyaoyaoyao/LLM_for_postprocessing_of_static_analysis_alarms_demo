{
    "category": "PERFORMANCE",
    "vtype": "WMI_WRONG_MAP_ITERATOR",
    "priority": "2",
    "rank": "18",
    "project": "pool",
    "warning_line": "final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;\n",
    "warning_method": "public void clearOldest() {\nfinal Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();\nfinal Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();\nsynchronized (this) {\nfor (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext(); ) {\nfinal K key = keyiter.next();\nfinal List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;\nfor (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext(); ) {\nmap.put(it.next(), key);\n}\n}\nSet<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();\nint itemsToRemove = ((int) (map.size() * 0.15)) + 1;\nIterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();\nwhile (iter.hasNext() && itemsToRemove > 0) {\nEntry<ObjectTimestampPair<V>, K> entry = iter.next();\nK key = entry.getValue();\nObjectTimestampPair<V> pairTimeStamp = entry.getKey();\nObjectQueue objectQueue = _poolMap.get(key);\nfinal List<ObjectTimestampPair<V>> list = objectQueue.queue;\nlist.remove(pairTimeStamp);\nif (toDestroy.containsKey(key)) {\ntoDestroy.get(key).add(pairTimeStamp);\n} else {\nList<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();\nlistForKey.add(pairTimeStamp);\ntoDestroy.put(key, listForKey);\n}\nobjectQueue.incrementInternalProcessingCount();\n_totalIdle--;\nitemsToRemove--;\n}\n}\ndestroy(toDestroy, _factory);\n}"
}