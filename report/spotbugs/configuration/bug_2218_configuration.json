{
    "category": "DODGY_CODE",
    "vtype": "RI_REDUNDANT_INTERFACES",
    "priority": "3",
    "rank": "20",
    "project": "configuration",
    "warning_line": "public class CombinedConfiguration extends BaseHierarchicalConfiguration implements\nEventListener<ConfigurationEvent>, Cloneable\n{\npublic static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =\nnew EventType<ConfigurationEvent>(ConfigurationEvent.ANY,\n\"COMBINED_INVALIDATE\");\nprivate static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;\nprivate static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();\nprivate static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()\n.create();\nprivate NodeCombiner nodeCombiner;\nprivate List<ConfigData> configurations;\nprivate Map<String, Configuration> namedConfigurations;\nprivate ExpressionEngine conversionExpressionEngine;\nprivate boolean upToDate;\npublic CombinedConfiguration(NodeCombiner comb)\n{\nnodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;\ninitChildCollections();\n}\npublic CombinedConfiguration()\n{\nthis(null);\n}\npublic NodeCombiner getNodeCombiner()\n{\nbeginRead(true);\ntry\n{\nreturn nodeCombiner;\n}\nfinally\n{\nendRead();\n}\n}\npublic void setNodeCombiner(NodeCombiner nodeCombiner)\n{\nif (nodeCombiner == null)\n{\nthrow new IllegalArgumentException(\n\"Node combiner must not be null!\");\n}\nbeginWrite(true);\ntry\n{\nthis.nodeCombiner = nodeCombiner;\ninvalidateInternal();\n}\nfinally\n{\nendWrite();\n}\n}\npublic ExpressionEngine getConversionExpressionEngine()\n{\nbeginRead(true);\ntry\n{\nreturn conversionExpressionEngine;\n}\nfinally\n{\nendRead();\n}\n}\npublic void setConversionExpressionEngine(\nExpressionEngine conversionExpressionEngine)\n{\nbeginWrite(true);\ntry\n{\nthis.conversionExpressionEngine = conversionExpressionEngine;\n}\nfinally\n{\nendWrite();\n}\n}\npublic void addConfiguration(Configuration config, String name,\nString at)\n{\nif (config == null)\n{\nthrow new IllegalArgumentException(\n\"Added configuration must not be null!\");\n}\nbeginWrite(true);\ntry\n{\nif (name != null && namedConfigurations.containsKey(name))\n{\nthrow new ConfigurationRuntimeException(\n\"A configuration with the name '\"\n+ name\n+ \"' already exists in this combined configuration!\");\n}\nConfigData cd = new ConfigData(config, name, at);\nif (getLogger().isDebugEnabled())\n{\ngetLogger()\n.debug(\"Adding configuration \" + config + \" with name \"\n+ name);\n}\nconfigurations.add(cd);\nif (name != null)\n{\nnamedConfigurations.put(name, config);\n}\ninvalidateInternal();\n}\nfinally\n{\nendWrite();\n}\nregisterListenerAt(config);\n}\npublic void addConfiguration(Configuration config, String name)\n{\naddConfiguration(config, name, null);\n}\npublic void addConfiguration(Configuration config)\n{\naddConfiguration(config, null, null);\n}\npublic int getNumberOfConfigurations()\n{\nbeginRead(true);\ntry\n{\nreturn getNumberOfConfigurationsInternal();\n}\nfinally\n{\nendRead();\n}\n}\npublic Configuration getConfiguration(int index)\n{\nbeginRead(true);\ntry\n{\nConfigData cd = configurations.get(index);\nreturn cd.getConfiguration();\n}\nfinally\n{\nendRead();\n}\n}\npublic Configuration getConfiguration(String name)\n{\nbeginRead(true);\ntry\n{\nreturn namedConfigurations.get(name);\n}\nfinally\n{\nendRead();\n}\n}\npublic List<Configuration> getConfigurations()\n{\nbeginRead(true);\ntry\n{\nList<Configuration> list =\nnew ArrayList<Configuration>(getNumberOfConfigurationsInternal());\nfor (ConfigData cd : configurations)\n{\nlist.add(cd.getConfiguration());\n}\nreturn list;\n}\nfinally\n{\nendRead();\n}\n}\npublic List<String> getConfigurationNameList()\n{\nbeginRead(true);\ntry\n{\nList<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());\nfor (ConfigData cd : configurations)\n{\nlist.add(cd.getName());\n}\nreturn list;\n}\nfinally\n{\nendRead();\n}\n}\npublic boolean removeConfiguration(Configuration config)\n{\nfor (int index = 0; index < getNumberOfConfigurations(); index++)\n{\nif (configurations.get(index).getConfiguration() == config)\n{\nremoveConfigurationAt(index);\nreturn true;\n}\n}\nreturn false;\n}\npublic Configuration removeConfigurationAt(int index)\n{\nConfigData cd = configurations.remove(index);\nif (cd.getName() != null)\n{\nnamedConfigurations.remove(cd.getName());\n}\nunregisterListenerAt(cd.getConfiguration());\ninvalidateInternal();\nreturn cd.getConfiguration();\n}\npublic Configuration removeConfiguration(String name)\n{\nConfiguration conf = getConfiguration(name);\nif (conf != null)\n{\nremoveConfiguration(conf);\n}\nreturn conf;\n}\npublic Set<String> getConfigurationNames()\n{\nbeginRead(true);\ntry\n{\nreturn namedConfigurations.keySet();\n}\nfinally\n{\nendRead();\n}\n}\npublic void invalidate()\n{\nbeginWrite(true);\ntry\n{\ninvalidateInternal();\n}\nfinally\n{\nendWrite();\n}\n}\n@Override\npublic void onEvent(ConfigurationEvent event)\n{\nif (event.isBeforeUpdate())\n{\ninvalidate();\n}\n}\n@Override\nprotected void clearInternal()\n{\nunregisterListenerAtChildren();\ninitChildCollections();\ninvalidateInternal();\n}\n@Override\npublic Object clone()\n{\nbeginRead(false);\ntry\n{\nCombinedConfiguration copy = (CombinedConfiguration) super.clone();\ncopy.initChildCollections();\nfor (ConfigData cd : configurations)\n{\ncopy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd\n.getConfiguration()), cd.getName(), cd.getAt());\n}\nreturn copy;\n}\nfinally\n{\nendRead();\n}\n}\npublic Configuration getSource(String key)\n{\nif (key == null)\n{\nthrow new IllegalArgumentException(\"Key must not be null!\");\n}\nSet<Configuration> sources = getSources(key);\nif (sources.isEmpty())\n{\nreturn null;\n}\nIterator<Configuration> iterator = sources.iterator();\nConfiguration source = iterator.next();\nif (iterator.hasNext())\n{\nthrow new IllegalArgumentException(\"The key \" + key\n+ \" is defined by multiple sources!\");\n}\nreturn source;\n}\npublic Set<Configuration> getSources(String key)\n{\nbeginRead(false);\ntry\n{\nList<QueryResult<ImmutableNode>> results = fetchNodeList(key);\nSet<Configuration> sources = new HashSet<Configuration>();\nfor (QueryResult<ImmutableNode> result : results)\n{\nSet<Configuration> resultSources =\nfindSourceConfigurations(result.getNode());\nif (resultSources.isEmpty())\n{\nsources.add(this);\n}\nelse\n{\nsources.addAll(resultSources);\n}\n}\nreturn sources;\n}\nfinally\n{\nendRead();\n}\n}\n@Override\nprotected void beginRead(boolean optimize)\n{\nif (optimize)\n{\nsuper.beginRead(true);\nreturn;\n}\nboolean lockObtained = false;\ndo\n{\nsuper.beginRead(false);\nif (isUpToDate())\n{\nlockObtained = true;\n}\nelse\n{\nendRead();\nbeginWrite(false); \nendWrite();\n}\n} while (!lockObtained);\n}\n@Override\nprotected void beginWrite(boolean optimize)\n{\nsuper.beginWrite(true);\nif(optimize)\n{\nreturn;\n}\ntry\n{\nif (!isUpToDate())\n{\ngetSubConfigurationParentModel().replaceRoot(\nconstructCombinedNode(), this);\nupToDate = true;\n}\n}\ncatch (RuntimeException rex)\n{\nendWrite();\nthrow rex;\n}\n}\nprivate boolean isUpToDate()\n{\nreturn upToDate;\n}\nprivate void invalidateInternal()\n{\nupToDate = false;\nfireEvent(COMBINED_INVALIDATE, null, null, false);\n}\nprivate void initChildCollections()\n{\nconfigurations = new ArrayList<ConfigData>();\nnamedConfigurations = new HashMap<String, Configuration>();\n}\nprivate ImmutableNode constructCombinedNode()\n{\nif (getNumberOfConfigurationsInternal() < 1)\n{\nif (getLogger().isDebugEnabled())\n{\ngetLogger().debug(\"No configurations defined for \" + this);\n}\nreturn EMPTY_ROOT;\n}\nelse\n{\nIterator<ConfigData> it = configurations.iterator();\nImmutableNode node = it.next().getTransformedRoot();\nwhile (it.hasNext())\n{\nnode = nodeCombiner.combine(node,\nit.next().getTransformedRoot());\n}\nif (getLogger().isDebugEnabled())\n{\nByteArrayOutputStream os = new ByteArrayOutputStream();\nPrintStream stream = new PrintStream(os);\nTreeUtils.printTree(stream, node);\ngetLogger().debug(os.toString());\n}\nreturn node;\n}\n}\nprivate Set<Configuration> findSourceConfigurations(ImmutableNode node)\n{\nSet<Configuration> result = new HashSet<Configuration>();\nFindNodeVisitor<ImmutableNode> visitor =\nnew FindNodeVisitor<ImmutableNode>(node);\nfor (ConfigData cd : configurations)\n{\nNodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,\ngetModel().getNodeHandler());\nif (visitor.isFound())\n{\nresult.add(cd.getConfiguration());\nvisitor.reset();\n}\n}\nreturn result;\n}\nprivate void registerListenerAt(Configuration configuration)\n{\nif (configuration instanceof EventSource)\n{\n((EventSource) configuration).addEventListener(\nConfigurationEvent.ANY, this);\n}\n}\nprivate void unregisterListenerAt(Configuration configuration)\n{\nif (configuration instanceof EventSource)\n{\n((EventSource) configuration).removeEventListener(\nConfigurationEvent.ANY, this);\n}\n}\nprivate void unregisterListenerAtChildren()\n{\nif (configurations != null)\n{\nfor (ConfigData child : configurations)\n{\nunregisterListenerAt(child.getConfiguration());\n}\n}\n}\nprivate int getNumberOfConfigurationsInternal()\n{\nreturn configurations.size();\n",
    "warning_method": "private ImmutableNode constructCombinedNode() {\nif (getNumberOfConfigurationsInternal() < 1) {\nif (getLogger().isDebugEnabled()) {\ngetLogger().debug(\"No configurations defined for \" + this);\n}\nreturn EMPTY_ROOT;\n} else {\nIterator<ConfigData> it = configurations.iterator();\nImmutableNode node = it.next().getTransformedRoot();\nwhile (it.hasNext()) {\nnode = nodeCombiner.combine(node, it.next().getTransformedRoot());\n}\nif (getLogger().isDebugEnabled()) {\nByteArrayOutputStream os = new ByteArrayOutputStream();\nPrintStream stream = new PrintStream(os);\nTreeUtils.printTree(stream, node);\ngetLogger().debug(os.toString());\n}\nreturn node;\n}\n}"
}